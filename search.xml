<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>讀後感｜我們就是火星人：尋找宇宙中的地外生命</title>
    <url>/bignami-we-are-the-martians/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>生命和宇宙的聯繫是《我們就是火星人》的主旋律。大霹靂後的原初核合成（Big Bang nucleosynthesis）雖然僅持續短暫時間，卻製造了宇宙含量最豐富的元素氫、氦。然而隨著空間持續膨脹，溫度下降到無法維持核融合反應，導致原初核合成中止。</p>
<p>直到第一批恆星誕生，最初的元素才在恆星核融合過程中轉變成組成身體的碳、呼吸所需的氧以及胺基酸裡的硫和氮。不過比鐵更重的銅、鉬等微量元素，得仰賴超新星的爆炸核合成。它提供足夠能量形成這些元素，填補了元素週期表其他空白。另外因超新星爆發而四逸的元素聚集為星際氣體，它們的組成成分隨著每次爆發變得越來越多元，成為孕育複雜分子和行星系統的搖籃。</p>
<span id="more"></span>

<h2 id="生命起源的隨機性與決定性"><a href="#生命起源的隨機性與決定性" class="headerlink" title="生命起源的隨機性與決定性"></a>生命起源的隨機性與決定性</h2><p>若形成最初生命的分子證實來自外太空，那麼宇宙物質的種類與數量分布可能影響了生命的型態，了解它們的源頭與生成機制，就有依據推測為何生物僅採用特定分子而不用另一群分子的謎題（例如手性不對稱）。然而目前為止，這些現象是隨機事件導致的巧合（生命原料源於外太空），還是分子差異演化所致結果（生命原料在地球生成）仍未有定論。</p>
<p>不過最重要的是明白「隨機」和「決定」的含意，如果形成生命的樞紐是可遇不可求的事件，那麼就意味著即便備齊良好條件，沒有機運仍然不會產生生命；反之，如果生命是反應的必然結果，那我們就更有可能從其他條件良好的星球發現生命跡象。</p>
<p>除了體內元素和宇宙的歷史連結，作者還說明了怎麼透過光、隕石和火箭聯繫我們、天體和遙遠的過去。第三章聚焦在搜索行星的觀測天文學，討論觀測結果對行星理論的衝擊。由於行星是生存的根據地，所以適居行星的形成機率也是攸關生命是否普及在宇宙中的關鍵。</p>
<h2 id="接觸天文學與泛種論的關聯"><a href="#接觸天文學與泛種論的關聯" class="headerlink" title="接觸天文學與泛種論的關聯"></a>接觸天文學與泛種論的關聯</h2><p>而在第四、五、六章介紹的接觸天文學，則是從墜落地球的隕石或是從其他天體採集的岩石中直接獲取資訊，由於沒有被瘋狂的地質活動風化，它們仍保留歷史的痕跡，研究者可以藉此得知岩石以至地球的過去。其中較有趣的是默奇森隕石和ALH84001，前者含有豐富有機物質，後者則有疑似微生物的化石，它們暗示著生命源於外太空的泛種論（Panspermia）。</p>
<p>泛種論可以追溯到希臘哲學家Anaxagoras，繼而由提出解離說的阿瑞尼斯發展，解釋胞子受輻射推動從一個星球飄到另一星球（Radiopanspermia），發現DNA雙螺旋結構的克立克亦曾參與，但他認為是外星智慧刻意安排生命在星際中遷移。此書則採用岩石泛種論（Lithopanspermia）試著估算微生物附著在拋向太空的岩石上，散播到其他天體的機會。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>我已經陳述了此書的知識概要，雖然大半篇幅是看似無關的天文學細節上，但這是因為作者一再強調的事——生命和宇宙的過往緊緊聯繫著。探索生命起源之謎可以從既有生命回推古早生命，但追尋古早生命的無機物源頭也是個途徑，沒理由不從天文學找線索，或許能從中找到生命之所以如此的終極原因。</p>
<h2 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h2><p>查詢天文生物學相關書籍時往往會碰上名、實不符的狀況。有些書意不在探討形成生命的機制，但內容卻涉及機制的關鍵環節，得了解這領域的研究方向才會注意到。</p>
<p>另外，生命起源和地外生物也是宗教人士愛好的話題，所以有些書雖然叫作「揭開生命起源的奧祕」，實則在提倡智慧設計和玄學理論。還有一些像此書一樣，書名看起來像科幻童書，卻正正經經地介紹組成生物體的物質源頭。</p>
<p>因此，為了挑到合宜的文本，除瀏覽作者背景和內容概要外，還可以透過圖書館分類號確認，其中與天文生物學密切相關的有361.9（天文生物學）和361.12（生命起源）。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>寫論文的糟糕和美好經驗</title>
    <url>/good-and-bad-experiences-in-journal-article-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我對論文寫作的第一印象是「寫論文很難，要花很長的時間才能完成，而且從準備到發表過程中會受到大量的批判，一路過關斬將才有機會嶄露頭角」。</p>
<p>所以每當開啟 word 檔開始打字的時候，都有起步的焦慮感：覺得自己還沒準備好，想要把文獻回顧完全，研究結果做到滴水不漏才有辦法動筆。</p>
<p>這種印象部分奠基於碩士論文寫作經驗，當時往往盯著螢幕許久沒有任何想法，最後歸因於自己文獻回顧不夠完整或是研究做得不夠完善。</p>
<p>我意識到阻礙我進展的是對於完美論文的期待，我期待論文能夠達到讓我感到愉悅和成就感的標準。</p>
<p>然而，人們總是無法在初稿時達到滿意的程度吧？而且論文需要於修改中逐漸精緻，沒辦法一蹴可幾，我的期待反過來成為我的壓力。</p>
<p>為了舒緩這種壓力和焦慮，我轉而把精力投注在文獻回顧或改進研究內容。雖然多做準備能暫時減緩我的焦慮和踏實感，但這只是將自己的壓力和負擔延後，之後將面對更多的時間、資源和要求的壓力。</p>
<span id="more"></span>

<h2 id="「發表論文的初衷是感謝」"><a href="#「發表論文的初衷是感謝」" class="headerlink" title="「發表論文的初衷是感謝」"></a>「發表論文的初衷是感謝」</h2><p>而我對論文的美好經驗則來自研究所的老師。我的指導教授從前曾問我：「你認為我們為什麼要投稿論文？」</p>
<p>從功利的角度講，Publish or Perish。發表論文是在學術界生存的根本，也是一個人能力的證據，舉凡畢業、獎學金、申請學校、公司求職、學校教職等皆可能需要論文作為能力的佐證。</p>
<p>然而，我的指導教授認為這些都只是其次，發表論文的初衷是感謝。</p>
<p>為什麼感謝？做研究總是關注著某些議題，為了解決問題，我們參考了這麼多文獻，我們正是對於前人的文獻表達感謝。</p>
<p>表達感謝的途徑有二，首先是引用這些文獻，彰明他們的貢獻；其次是基於這些文獻發展出我們的想法，促進對議題的理解，讓這些想法得以演化和繁衍下去。</p>
<p>科學是尋求解釋的活動，而我們對世界的認知並非一日造就而成的。無論是科學革命還是漸進式的科學史觀，當今的知識體系都是多人長年活動累積的結果，一項研究的鑄成往往有其思想根基和參考依據，無論是要贊同、反駁還是引發想法，都會踏過前人的足跡。</p>
<p>經過長期演變，論文已是紀錄和傳播科學活動成果的最有效和公認的媒介，研究和發表其實就是：我們感到疑惑，我們開始研究，我們參考了誰的想法和觀念，我們想到了一些點子和把持一些觀點。</p>
<p>我們想要提供一些新的解釋，我們感謝前人對於我們思想和研究的幫助，我們回饋學界這些觀念，用一種經過長期演變且公認最有效率的媒介，論文。</p>
<p>以感謝的角度來看待論文發表很大程度地舒緩了寫論文的恐懼和壓力，即使論文有那些功利價值，但我的指導教授還是提醒了我研究和發表理想和溫暖的一面。</p>
<h2 id="「一則文獻既不是最重要的也不是最不重要的」"><a href="#「一則文獻既不是最重要的也不是最不重要的」" class="headerlink" title="「一則文獻既不是最重要的也不是最不重要的」"></a>「一則文獻既不是最重要的也不是最不重要的」</h2><p>而對論文另一部份美好經驗則來自論文寫作課的老師。</p>
<p>有別於我的指導教授，寫作課老師從實用角度分析論文的寫作與發表，將論文寫作描述得很像 youtube 上頭 8 分鐘的 DIY 影片，好像我們在某個閒暇無事的下午，點開影片照著做就可以完成，不是什麼無法做到的事。</p>
<p>總結他的課程，他強調論文寫作縱使有那些功利價值，也不需要感到壓力，論文發表會被 reject 沒錯，但再換家推銷就好。</p>
<p>換句話說，寫作課老師讓我感受到，即使沒有達到最完美的狀況，論文還是有價值；即使還沒有準備好，也能開始動筆；即使能力還不夠，進展中就會有所成長；即使被批判，那也是很自然，因為這都是科學過程的一部分。</p>
<p>一則文獻既不是最重要的也不是最不重要的，科學重視的是合理而非真理，文獻呈現的是探索的過程，我們沒辦法在一則文獻中完全佐證我們的主張或對世界的看法。</p>
<p>錯誤與正確都是研究累積後，後世對我們的評價而已，所以不用太擔心文獻被批判等等，這本來就是科學新陳代謝的一環。</p>
<h2 id="正向寫作經驗的關鍵"><a href="#正向寫作經驗的關鍵" class="headerlink" title="正向寫作經驗的關鍵"></a>正向寫作經驗的關鍵</h2><ul>
<li><strong>寫作是 routine</strong>：寫作跟運動很像，寫作的愉悅需要一點投資，最重要的投資就是起步的意願，隨後是堅持的決心。寫作是 routine，而非儀式行為。是以，治療寫作不快或抑鬱的方法跟控制慢性病一樣，每天吃藥（寫作）。</li>
<li><strong>參與感</strong>：讓寫作交流可以提升寫作的回饋感，因為寫作終究是科學交流的一部份。透過研討會、一對一討論、編修等途徑，可以從中得到寫作靈感而疏通寫作瓶頸，也可以從交流中獲得參與感和社群歸屬，最終得到「意義」</li>
<li><strong>正面看待評論</strong>：看待拒稿和批評的認知轉換有助於降低寫作的恐懼，投稿寫作就跟賣東西一樣，一定有人買，只是看誰會買和賣什麼價碼而已。論文跟基因不一樣，別人罵你先天特徵是沒機會改變，但別人批評論文內容有改善的機會。</li>
<li><strong>分享的心</strong>：如果真心喜歡自己的研究，那寫作就是分享自己熱情和喜好的管道。若有類似的經驗便能體會為什麼用分享看待寫作可以增加正向寫作經驗。</li>
</ul>
<h2 id="當然還是有糟糕的經驗"><a href="#當然還是有糟糕的經驗" class="headerlink" title="當然還是有糟糕的經驗"></a>當然還是有糟糕的經驗</h2><p>儘管羅列了一堆美好經驗和建立正面想法的「要點」，寫論文還是有坐困愁城和自我質疑的時候，像是指示牴觸價值觀、結果不明又不想自欺欺人、截止日到但品質不滿意等等。</p>
<p>舉我的例子來說，我不太習慣被 Paul Nurse 稱之為「修正主義 (revisionist)」的科學敘事 (Nurse. (2016). Cell, 165(6), 1301-1306.)。就我理解，這是指論文敘事隱藏了科研的意外與不可控，調整文章內容以說個毫無破綻的好故事，而不是說個貼近事實的發現歷程。</p>
<p>最容易接觸這類修正主義的途徑可能是台灣的理科教科書。從歐幾里得、牛頓、孟德爾、波爾、拉瓦節，課本呈現的是生硬且不直觀，但和諧線性的科學史觀。理論的發展與邏輯的推演高度相符，彷彿有了前提、假設和足夠的測量，理論即順水推舟浮現，科學史跟課本都能一併翻向的新頁。</p>
<p>我想，為了溝通的效率，精簡內容和梳理邏輯是撰寫論文的必要過程。然而，當論文呈現與事實迥異的發現軌跡，後人要追溯某項理論的沿革時，只能走在一條虛構的途徑上，而這條途徑很可能只在想像中行得通。</p>
<p>等到開始寫論文，我也希望自己能夠避免這種狀況，想盡可能讓論文的敘事貼近發現的過程，保留激發研究點子的關鍵因素，討論理論與結果衝突的理由與和解方式，而不是為了結果而調整敘述過程的方向。</p>
<p>雖然只是一點點，但我也想要為自己認同的理念和未來做點事。不過，我後來才體會到，論文寫作還是有協商的因素存在，與合作者的協調、與計畫主持人的溝通、與編輯和審閱者的答辯等等。</p>
<p>我想這些合作與協商是必要的，只是折磨之處在於，若討論不是基於事實與道理，而是訴諸權威或群眾等無關論文內容的事情，那麼我有點難克服下筆時的抗拒感。</p>
<h2 id="但我還是想記住好的"><a href="#但我還是想記住好的" class="headerlink" title="但我還是想記住好的"></a>但我還是想記住好的</h2><p>儘管如此，我其實是喜好寫作表達想法的，我覺得將自己的主張和論證陳述清楚，嘗試去說服別人的過程仍值得投入。</p>
<p>畢竟寫論文也是一種發聲管道，若渴望能依照這途徑去實踐或改變什麼，那是否要做下去也非取決於經驗的好壞，而是渴望的程度。</p>
<p>既然如此，傾聽內心裡較良善的聲音讓自己有動力做下去，我覺得會比被糟糕回憶困住半途而廢還來得有機會幫助自己達到目標。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜再創世紀</title>
    <url>/church-2014-regenesis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《再創世紀》的作者將合成生物學的各項里程碑比擬為生物演化和產業革命的重要階段，簡介晚近的基因工程技術並討論其引發的倫理爭議。雖然主題不是講解天文生物學，但是此書前三章關於合成生命的討論對釐清生命的定義有許多啟發。</p>
<span id="more"></span>

<p>人造生命可分為三種：由現有物種重組新物種、以生物原料製造生命和電腦模擬的虛擬生命。</p>
<p>2010年克雷格凡特團隊的人工基因組細菌即是重組生物的一個案例，研究者合成出維持生命所需的最短基因，再轉殖到細菌中取代原本的基因，這種極簡生命體不只排除了影響生產效率或實驗結果的未知干擾，製作過程中也有助於辨別何為生命的必須要素。至於從無到有建立生命的嘗試則能在找不到地外生物的情況下，拓展或是挑戰我們對生命的定義。</p>
<p>目前這問題仍莫衷一是，除了國中生物課本採用的條列式定義（生命具有繁殖、生長、代謝、運動等性質），還有NASA的定義：生命是能自我增值並遵循達爾文演化的化學系統。</p>
<p>作者則主張生命並非涇渭分明的概念，而是一種連續的屬性，可以透過再現複雜度（replicated complexity）度量。然而作者沒有明講其定義，只能從他舉的例子推測再現複雜度是指「重現近似複雜結構的能力」和「複雜結構間的關聯性」。這觀念可以解釋條列式定義的反例，例如：</p>
<ul>
<li><strong>病毒</strong>：得仰賴宿主的酵素系統複製基因組，因此只有有限重現能力，是再現複雜度較低的生命形式。</li>
<li><strong>騾子</strong>：雖然不能繁殖，但是體內細胞仍有自我複製能力，而且個體的複雜度源頭可連結自親代，仍有相對高的再現複雜度。</li>
<li><strong>火焰</strong>：火焰也是能夠成長和自我複製的系統，但是延燒火焰的性質和燃燒物有關，和原本的火焰關聯較低，因此再現複雜度不高。</li>
</ul>
<p>不同的定義反映著不同的哲學觀。好比說NASA把生命限制為化學系統是基於太空搜索的實用目的；但是作者作為創造生命的鼓吹者，自然不滿足於這種限制，因此他的定義能涵蓋自我複製並演化的機械人。我覺得重要的不是比較這些定義的優劣，而是了解定義的理論背景和適用範圍。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Church &amp; Regis. (2014). Regenesis: how synthetic biology will reinvent nature and ourselves. 中國由電子工業出版社翻譯並出版，《再創世紀：合成生物學將如何重新創造自然和我們人類》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜樹之歌</title>
    <url>/haskell-2017-the-songs-of-trees/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>歌，是有序的聲音；聲音，則是波動的一種形式。若沒有變動與交互作用，也就不會產生聲音。因此，聲音也是網路的一項性質。</p>
<p>Haskell 以樹木為觀察對象，描述樹木與雨水、風、動植物、微生物等事物互動發出的聲響，揭示了看似孤立的樹，實則串聯萬物的生命史，形成龐雜的生命網路。</p>
<span id="more"></span>

<p>除了科普生態與植物學知識，Haskell 亦借題簡介有關的生態議題，探討人類應抱持何種倫理觀點，看待因開發造成的生態破壞。究竟要把人類視為自然的一部份，而連帶將汙染與滅絕視為無須干預的現象？還是劃清人類與自然的界線，強調人類維護自然的責任？</p>
<p>Haskell 認為，前者會陷入虛無主義，後者則忽略了人的自然性。因此，真正的答案，或許得回歸生物網路之中，我們需要把自己放在自然網路的脈絡思考，而不是單用人類這物種的觀念看待自己。</p>
<p>畢竟，塑造我們的不只是這副軀體，還有環境、共棲微生物、作物和獵物等。所有的生命過程，都是網路中的一個節點和其他節點形成持續變動的關係。透過這是腳，我們能漸漸體會何者為美，何者為值得保護的東西，什麼又代表好，從而找出人類在全球變遷中該負起何種道義責任。</p>
<p>這本書讀起來，像帶有自然書寫風格的抒情文，用字遣詞華麗而浪漫。在此紀錄書中一些有趣的概念。</p>
<ul>
<li><strong>雨的語言</strong>：由於各地的空氣粒子組成不同，黏附著不同懸浮粒子的雨水也就蘊含著各自的語彙和文法。</li>
<li><strong>植物的記憶</strong>：植物雖然不像動物以電流傳遞訊號，但也會用化學留住事件的傷痕。我想，如果延伸「疤痕是種記憶」的想法，那麼因為河流侵蝕而留下的河谷，是不是也算得上大地的記憶了？</li>
<li><strong>歌的來源</strong>：書中提到克丘亞族相信，樹木與河流都是會唱歌的生命，族裡傳頌的歌曲都是從它們學來的。這點與《複眼人》的瓦憂瓦憂族一致！<br>瓦奧拉尼人：瓦奧拉尼人注重群體而輕視個體，個人的自主性和能力是建立於社群中。他們認為名字是關係的產物，若脫離既有社群，就得捨棄舊有的名稱。例如他們會以植物的用途或是植物與其他生物的關係來為植物命名。因此，同一種植物可能會有不同的名稱和描述，來表示植物與不同事物的關係。</li>
<li><strong>細胞特化</strong>：細胞特化除了增進效率，也避免了細胞擁有過多發展性而癌化。</li>
<li><strong>海洋微粒</strong>：海洋微粒會增加微生物可依附的表面積，從而改變海洋微生物群落組成。</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">David George Haskell. (2017) The songs of trees: stories from nature's great connectors. 台灣由商周翻譯並出版，《樹之歌：生物學家對宇宙萬物的哲學思索》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>「天文」生物學：數量的緣故</title>
    <url>/history-of-astrobiology-naked-eyes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>國中時，剛看完《星艦迷航記VIII：戰鬥巡航》的我向學校裡最接近外星生物專家的生物老師詢問是否真有外星人，他告訴我地球外還有許多星球，如果沒有其他生命也太奇怪了。</p>
<p>如同我的生物老師所述，對於地外生命的信心有很大一部分是建立在數量上，既然宇宙已經誕生百餘億年，當中又充滿無數星系，很難想像當中不會有其他生命存在。</p>
<p>然而宇宙的尺度也是經學界漫長掙扎才逐漸變得清晰，早在人類只能以肉眼觀察世界的時候，滿天繁星已不計其數，甚至至今我們對於宇宙中有多少顆適居行星仍沒有精確的估計。</p>
<p>天文生物學的發展不只是事實的累積，也是世代人觀念轉變的結果。</p>
<span id="more"></span>

<h2 id="肉眼"><a href="#肉眼" class="headerlink" title="肉眼"></a>肉眼</h2><p>最初人類只能以肉眼觀察這個世界，其他的天體在天空化為一個小亮點，這些亮點的意義在不同人眼裡衍伸出不同的樣貌，這些推論與想像便成為天文生物學興起前，人們對地外生命的想像基礎。</p>
<p>對於無法觸及的天空，德膜克利特(Democritus, 410 - 380 BC) 等原子學派 (Atomists) 哲人認為，既然原子的隨機運動組成了世間萬物，天與地應遵循相同法則，形成地球的過程沒理由不能在天外形成其他世界，是以其後繼者伊比鳩魯在給希羅多德的信 (<a href="http://www.attalus.org/old/diogenes10b.html">Letter to Herodotus</a>) 中提到，</p>
<blockquote>
<p>We must not believe that all worlds necessarily have one identical form.  Let us also beware of thinking that animals are derived from the infinite; for there is no one who can prove that the seeds from which animals are born, and plants, and all the other objects which we contemplate, have been brought from the exterior in such a world, and that this same world would not have been able to produce them of itself. （我們絕對不能假設各個世界有一致的樣貌，……，因為沒有人能證明形成動物、植物和我們眼前一切的種子無法在這樣的世界萌生。）</p>
</blockquote>
<p>伊比鳩魯的門徒 Metrodorus（400 BC） 也對地外生命的可能留下更明確的評述。</p>
<blockquote>
<p>It is unnatural in a large field to have only one stalk of wheat, and in the infinite universe only one living world.（無垠宇宙僅有一個育有生命的世界和沃野千里卻只長出一束麥子一樣不尋常。）</p>
</blockquote>
<p>相較於原子學派，亞里斯多德學派哲人認為地球是唯一的世界，所以沒有為地外生命留下空間。</p>
<p>亞里斯多德以朝向&#x2F;背離中心的本性解釋火、水、土和空氣四種基本元素的運動現象，所以如果世界不只一個，那麼物質便喪失了明確的運動目標，維繫世界運作的基本原理將不復存在。透過這個規謬過程，四元素說結合地心說共同否定了多重世界的觀點。</p>
<p>此外，天與地也在亞里斯多德體系中割裂。有別於四元素，天空是由以太組成。太陽、月亮還有其他五顆行星就在層層嵌套的天球上緩緩繞著地球旋轉，而原子學派眼裡可能存在繽紛世界的星斗只是鑲在最外層恆星天上閃爍的光點。</p>
<p>同片天空不同的想像與推論，形成了不同的結論。</p>
<p>如今我們知道，原子學派哲人的想像比較接近當今學界對世界的認知，然而這不代表他們是天文生物學還是任何現代科學的根源。囿於當時的觀察手段，無論哪派哲人的思想都沒有嚴謹事實支持，即使有許多詞彙為後世研究者共用，其中的內涵也已發生很大的變化。</p>
<p>但另一方面，儘管只能取得有限的線索，希臘人仍試圖靠著理性與智力解釋世界，而不是將問題簡化為鬼、神、UFO 或我不知道。</p>
<p>亞里斯多德的學說在中世紀時期被阿奎納 (St. Thomas Aquinas, 1225-1274) 納入神學體系，此後單一世界的想法持續主宰著歐洲人的世界觀。然而關於「數量」的爭議並沒有就此定論，亞里斯多德體系在哥白尼掀起科學革命後逐漸衰落，現代科學興起後更多的科技與觀察手段逐漸揭示宇宙的樣貌。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
  </entry>
  <entry>
    <title>從碩班第一次專題課說起......</title>
    <url>/how-i-learn-from-seminars/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>讀碩班前，我其實不知道 seminar 到底要幹嘛，也不知道和我有什麼關係。所以如同曖昧、戀愛等陌生概念，所有關於 seminar 的知識都是PTT教我的。</p>
<p>然而在完成人生中第一次正式報告後，我發現生資所碩一的專題課跟想像中有些差距：老師在有限的檢討時間內傾向於引導同學發現邏輯錯誤，或是補充報告中值得大家學習的觀念，不曾直接指正學習態度、格式錯誤或邏輯謬誤。這點和以往聽聞前輩提到的「 seminar 被老師痛電」很不一樣，上一周報告結束後沒有被批評到一文不值，所以心裡有些不踏實。</p>
<p>不過我內心期望的只是被電的體驗嗎？不對。我渴望的是成長，批判不是成長的唯一途徑。我要從 seminar 中學習的不是接受批評或是習於挨罵，因為這種本領已在服役期間漸漸培養起來，我想從 seminar 獲得學者的素養。</p>
<span id="more"></span>

<h2 id="seminar-是什麼？"><a href="#seminar-是什麼？" class="headerlink" title="seminar 是什麼？"></a>seminar 是什麼？</h2><p>seminar 源於拉丁文的「seminar ium」（苗床），從字根可以看出教育者的期許是讓 seminar 成為新概念的苗床，希望學生在檢視新近研究成果之外，也能互相討論激盪出新的想法。另外，對學生而言，準備報告和參與討論的過程考驗彙整資料、傳達觀念及構思問題的能力，這樣的演練有助於奠立從事學術的基礎。</p>
<p>但是了解  seminar  的起源和目的有什麼幫助呢？</p>
<p>我認為如果可以辨識出課程用意，便能聚焦在學習的成效上，而非「有沒有被電？」、「什麼時候輪到我報告？」、「報告完了是否該吃一頓大餐？」、「同學幹嘛問機掰問題」等無關緊要的指標。</p>
<p>因此，為了學習到更多有價值的事物，我彙整了網路上蒐集到的資料，列舉應當要從課程中培養的能力，並提出可行的練習方式，以在往後的專題課中實踐。</p>
<ul>
<li>學會閱讀研究論文及其內涵</li>
<li>在有限時間內清晰地表達科學概念</li>
<li>能即時答覆聽眾的提問</li>
<li>學會「聽講」這種學習或交流方式</li>
<li>能於聽講過程中組織問題，並清楚地向講者提問</li>
</ul>
<p>雖然要培養的能力還可以找到一大堆，但要專題課的目標可以歸納為「學習扮演研究者、策畫者、講者和聽眾」。儘管還沒有實際投入研究，但學生可以鑽研論文來學習研究者怎麼從觀察中形成問題意識，找出疑點提出假說，最後設計實驗驗證之。</p>
<p>除了實驗結果，科學交流也是科研的一環，有效的溝通能讓他人接受你的主張，所以研讀論文後也要試著報告給其他人聽，學會結合腹稿、逐字稿、簡報呈現流暢的演說。</p>
<p>而且聽講是接受新穎資訊的最快方式，如果想跟上研究前沿，勢必要從研討會中有效接收想法，並累積新觀念。因此一門課不會在報告完就結束了，課程的不同時間點，都有要投注心力的事項和可以學習的地方。</p>
<h2 id="聽講筆記"><a href="#聽講筆記" class="headerlink" title="聽講筆記"></a>聽講筆記</h2><p>準備這次 seminar 的過程中，我累積了一些關於閱讀論文、製作簡報及練習演說的經驗和想法，學習怎麼當個好聽眾也是很重要的議題。</p>
<p>聽講是快速入門研究領域的方式，但成功的報告不只是講者的工作，也需要聽眾的努力。從這幾周的專題報告中我學到一個教訓，就是儘管一開始很認真想理解內容，卻可能因為一時分神或不解而和講者的節奏脫節。</p>
<p>由於時間有限，講者未必有機會頻繁停下腳步回顧內容。聽眾可以透過事先預習背景知識和研究骨幹來減少聽講當下的負擔。例如在報告前細讀書面報告或是瀏覽原始論文，再整理出簡單的筆記帶到會場。如此一來，對於報告內容就有比較明確的形象，即使自己一時分心或沒跟上講者的邏輯，也能靠著預先準備的筆記重新聚焦重點。</p>
<p>此外，由於簡報不像課本那麼詳盡，所以如果沒在演講中把握要點，回家後要複習就只能面對生硬的論文了。因此，如果能在歷次聽講中改善自己的筆記方法，便有助於演講後整理出完整的筆記，這些筆記配合講者的投影片和書面報告，就是往後複習的利器。</p>
<h2 id="練習發問"><a href="#練習發問" class="headerlink" title="練習發問"></a>練習發問</h2><p>如果只是單方面聽講，那麼聽眾與講者的念頭便沒有機會在互動中產生洞見。然而，我們的專題課討論風氣不盛，這可能源於「不敢問」及「不知道要問什麼」兩項障礙。</p>
<p>針對「不敢問」這項障礙，我覺得可以多多思考發問的好處。發問是聽眾在演講中展現主動權的行為，能釐清聽不懂的內容、反駁被曲解的觀念、探討湧起的靈感等，</p>
<p>但是問了蠢問題或有失水準的問題怎麼辦？會不會很丟臉？儘管指導老師總是說世上沒有蠢問題，有問題就要發問。然而，我一直覺得指導老師只是想是要鼓勵同學發言而非描述現況。因為，每次自己問出 google 能輕易解決、過於空泛而無明確或是邏輯不通的問題時，還是覺得自己挺低能的。這些問題對於旁人一點幫助也沒有，浪費其他人提問的寶貴時間，還展示了自己的無知與隨便，所以感到很丟臉。</p>
<p>只是，難道因為會丟臉就不問了嗎？不對啊，變強都來不及了，哪還管什麼丟臉。將相本無種，沒有跌倒幾次怎麼會有往後的好表現？ seminar 是學習與嘗試的好機會。班上有形形色色的同學，每次發問都能和不同的人交流，嘗試不同的提問方法，如此能累積經驗，更有信心面對更大的場合。</p>
<p>此外，每個人對聽講的期待或是議題的關注各不相同，他人對我們提問內容的評斷既無法控制也難以得知。若提出問題的初衷是「我」感到困惑，那麼只要發問可以解決自己的困惑，那麼我認為它就是有價值問題。</p>
<p>畢竟，seminar 都規劃了提問的環節，充分利用這個機會來解決自己的需求，我覺得其實也沒有什麼好丟臉的。如果還是很擔心緊張，也可以課前多花時間預習，聽講時寫好筆記，提問前整理好問題，這樣就不至於給自己太大的心理壓力。</p>
<p>至於「不知道要問什麼」的障礙，除了預習和寫筆記以理解內容外，可以參考平常老師或其他人發問的方式，整理出可以問的問題以及這些問題的特徵，然後依樣畫葫蘆問問題，多問、多想，遲早能問出可以獲得許多回饋的問題。</p>
<h2 id="寫回饋單"><a href="#寫回饋單" class="headerlink" title="寫回饋單"></a>寫回饋單</h2><p>有些學校的專題課會抽同學評論報告內容的優劣，提供意見讓講者更進步。不過如果沒有要求，總覺得這個工作還是交給老師吧。</p>
<p>儘管如此，還是能整理一份鑑賞筆記，用來提示自己或同學徵詢時給他當參考。獨立於報告內容的筆記，鑑賞筆記用於評斷報告的科學結構、內容品質、視覺設計和口語表達的優劣，解釋這場報告優秀或低劣的原因，找出可以學習的優點，紀錄要避免的錯誤。</p>
<p>模仿別人怎麼評論是學習鑑賞的快速方法，可以細聽老師們的回饋，這麼做一方面提醒自己，另一方面也蒐集了評論標的，成為下次聽講時觀察的重點。整理不同的評論內容後，還可以設計出一份回饋單，不僅能節省撰寫評論的時間，這份回饋單也可以作為報告練習時蒐集意見的工具。</p>
<p>在上台報告前通常需要內部演練，收集他人的意見以改進報告品質。事前提醒聽眾要留意的地方或發放回饋單有助於聽眾給出針對性的意見，也方便他們紀錄內容以免忘記，讓講者更有機會獲得明確且豐富的建議。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章是我第一次參加專題課後的心得，裏頭提到的心理障礙有許多仍是我現今要面對的問題。至於，過了這麼久，我對於參加研討會或 seminar 有什麼新的想法或轉變嗎？有啊，我漸漸不再把問問題當秀場了。</p>
<p>以往期待自己能像某些大神一樣，能提出讓講者與聽眾都陷入深思的犀利問題。回過頭來，我發現自己用問題的品質來衡量我的水準，才追逐著所謂「好問題」，試圖證明自己是有能力的人。</p>
<p>然而，一旦陷入這樣的心態，就會不自覺給問題貼上有價值的、沒價值的、令人訝異的、稀鬆平常的等標籤。於是，每次心中有疑惑時，便開始思考這問題有沒有價值。聽講到最後，往往因為覺得問題很平凡，而一個也沒有提。面對這種狀況，我有時還挺懊惱的，例如之前參加微生物生態學年會便有不少精彩的演講，明明有許多共鳴與想法卻不敢發言，錯失了學習的機會。</p>
<p>直到我參加了許多講座與會議，聽到了從基本、艱深到與講題毫無關聯的提問，才矯正了內心對偉大問題的期待。我意識到（或回想起）：「對啊，我就是因為不懂才問問題啊！」</p>
<p>至於能否問個犀利的問題，我蠻喜歡在 <a href="https://www.zhihu.com/question/36980830">知乎</a> 上看到的說法</p>
<blockquote>
<p>我覺得吧，聽講座也罷，看文章也好，讀教科書也算，更重要的不是去挑刺，而是一個更有建設性的問題</p>
</blockquote>
<p>簡言之，研究或開發本身就不是件易事，要從方法學或應用條件等方向去挑毛病真的太容易了。然而，除了指出漏洞並提出可能解決方式以外，另一種延伸想法的途徑是去思考，如果對方的結論是真的，那麼要如何利用這項結論，來幫助我的研究與問題？</p>
<p>透過這種方式思考問題，能延伸出許多跟自己相關的議題，也比較有動機向講者請教，還能拓展關於待解問題的深刻理解或有用猜想。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>tips &amp; tricks</category>
      </categories>
      <tags>
        <tag>communitcation</tag>
      </tags>
  </entry>
  <entry>
    <title>很久很久以前，自然用什麼盛裝生命？</title>
    <url>/how-nature-contains-life-in-early-earth/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1953年，在試管裡的雷鳴閃電與水氣蒸騰之後，米勒與尤里成功在模擬的早期地球環境中合成胺基酸，開啟了研究生命起源的先河。</p>
<p>隨著多種有機質在實驗室合成或於隕石中發現，研究人員逐漸了解生命的物質來源。然而，散落各處的有機質需要彼此接觸才有機會引發生化反應。在早期環境中，有什麼物質能夠形成容器，匯集生命形成所需的反應物？</p>
<span id="more"></span>

<p>現存生命被包覆在由磷脂組成的細胞膜內。磷脂膜的結構穩定且功能齊全，但其組成複雜，所以可能不是最早形成的容器。相較之下，脂肪酸不僅結構簡單，也能形成會膨大與分裂的囊泡。因此，脂質囊泡是構成原始細胞膜的可能選項。 </p>
<p>然而，脂質囊泡對酸鹼值與離子濃度敏感，可能難於多變的環境中穩定存在。是以，Jia等認為在磷脂膜或脂質囊泡形成前，其他容易形成的物質可能組成結構穩定的過渡容器，發揮匯集物質及促進反應的功能。 </p>
<p>為了檢驗這項假說，Jia等採取類似米勒與尤里的策略。Jia等發現，可能普遍存在早期地球的果酸可於模擬環境中形成微滴。這些微滴不僅耐受溫度、壓力和酸鹼值變動，也能吸納蛋白質和RNA等生物分子。</p>
<p>儘管目前無法確認生命是否透過果酸微滴形成，Jia等的研究成果仍支持了新的研究途徑：除了構成現存生命的大分子，存在早期地球的其他分子也可能形成過渡容器，在細胞膜出現前匯集生命形成所需的反應物。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jia et al. (2019). Membraneless polyester microdroplets as primordial compartments at the origins of life. <em>Proceedings of the National Academy of Sciences</em>, 116(32), 15830-15835.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>origins of life</category>
      </categories>
  </entry>
  <entry>
    <title>怎麼決定合併雙端序列時允許的錯配數量？</title>
    <url>/how-to-decide-max-mismatch-when-merging-paired-end-reads/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>illumina 的 Miseq 和 Hiseq 平台常用於定序 16S rRNA 基因特定變異區的增幅產物。因為這兩平台皆屬雙端定序 (paired-end sequencing)，所以每一條 DNA 都會獲得順向和逆向的序列（即定序結果）。在資料處理時，須比對這對序列的重疊區域，再基於重疊區域合併雙方，才能重建出代表該 DNA 的完整序列。</p>
<p>不管使用的軟體為 FLASH 、PEAR 還是 Usearch，合併雙端序列時都有許多參數可以設定。其中一個參數是合併時允許的錯配數量。這參數的必要性在於，即使順向和逆向序列都源於同一條 DNA，兩者的重疊區域仍會因為定序錯誤而略有差異。合併時允許少量的錯配數量能避免捨棄掉這些正確的序列。</p>
<p>然而，我們要怎麼知道洽當的錯配數量上限？使用預設值、反覆試誤、調查文獻都是常見的方法，不過我更想要知道能依照資料選定適用參數的策略。畢竟，如果能先推算出理論值，那麼測試時便有參考的基準，除了能縮減試誤時間，在寫論文或向他人解釋方法時也比較有依據。</p>
<p>因此，雖然在資料處理流程已成熟的今日，糾結參數設定可能被視為無關宏旨，我還是想以本文紀錄，自己思考這個問題的方向與看法。</p>
<span id="more"></span>

<p>首先，順逆向序列的重疊區只要有任一列發生定序錯誤便會發生錯配。由於 illumina 定序平台的逆向序列品質往往較順向序列品質低，假設不計兩序列同時出錯的狀況，重疊區的錯配數量可由逆向序列的預期鹼基錯誤數量估計。</p>
<p>由於 illumina 定序平台的逆向序列品質往往較順向序列低，而且重疊區任何一條序列發生定序錯誤便會造成錯配。假設不計兩序列於相同位點同時出錯的狀況，那麼重疊區的錯配數量上限，可以由逆向序列的預期鹼基錯誤數量估計：錯配數量 &lt; 逆向序列重疊區的預期鹼基錯誤數 * 2</p>
<p>舉例來說，若增幅和定序 16S rRNA 基因 V4 區域之後，獲得一對長度為 250 bp 的序列。由於 V4 區域大約只有 253 bp 長，所以這對序列的重疊區長達 247 bp，幾乎覆蓋了整個 V4 區域。</p>
<p>假設考慮最極端的狀況，即要在順向和逆向序列的每個鹼基都完全對應時，我們才肯相信合併後的序列源於同一條 DNA。那麼，在逆向序列平均品質分數為 20 的狀況下，重疊區的預期錯誤數量為 $0.99 * 247 &#x3D; 2.47$。</p>
<p>這意味著，即使是這對序列得自於同一條 DNA，平均而言也會出現 $2.47 * 2 &#x3D; 4.94$ 個錯配。因此至少要允許 5 個錯配，才能確保這些源於同一條 DNA 的正確序列能順利合併。</p>
<p>推廣來說，錯配數量上限取決於重疊區的長度與品質。隨著對重疊區長度的要求放寬，預期的鹼基錯誤數會跟著下降，允許的錯配數量也得調低，才能確保合併雙端序列的特異性和靈敏度平衡。</p>
<p>依照這個推論，在取得資料時，可以先思考「若這對序列沒有定序錯誤，要有多長的重疊序列，才肯相信它們得自於同一條DNA」。</p>
<p>接著，找到平均品質最差的那個樣本的逆向序列，計算其 3’ 端重疊區域的預期鹼基錯誤數（該段區域的定序錯誤率之和），得出數值的兩倍，應該可以當作測試雙端序列合併的參數的起始值。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
        <category>metagenomics</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下載和安裝 RDP classifier</title>
    <url>/how-to-download-and-install-rdp-classifier/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RDP classifier 是基於 Naive Bayes 的物種分類器，常用於註解 16S rRNA 基因序列的分類資訊。除了使用內建的 RDP 資料庫以外，RDP classifier 也允許使用自訂資料庫來訓練分類器。除了內建的 RDP database，也支援以其他資料庫來訓練分類器。</p>
<p>目前，RDP classifier 的核心演算法已被整合到 Mothur 和 DADA2 等流程的副程式庫，所以只要有安裝這些流程軟體，即使沒有安裝 RDP classifier，也能以相同的演算法註解物種資訊。然而，若想要依據自訂或最新的資料庫註解序列，或是使用 copy number 校正等功能，仍有獨立使用 RDP classifier 的必要。</p>
<p>本文將介紹三種下載和安裝 RDP classifier 的方式。</p>
<span id="more"></span>

<h2 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h2><p>透過 conda 安裝的方式可參考 <a href="https://anaconda.org/bioconda/rdp_classifier">Anaconda 的教學</a>。目前，conda 與 RDP 官網提供的 classifier 皆為最新的 2.13 版。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c bioconda rdp_classifier</span><br><span class="line">conda install -c bioconda/label/cf201901 rdp_classifier</span><br></pre></td></tr></table></figure>

<h2 id="官方網站"><a href="#官方網站" class="headerlink" title="官方網站"></a>官方網站</h2><p>若不想要裝一堆附加的軟體或剛好 conda 沒有需要的版本，也可以直接到官網提供的<a href="https://sourceforge.net/projects/rdp-classifier/">連結</a>下載可執行檔。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/rdp-classifier/rdp-class</span><br><span class="line">ifier/rdp_classifier_2.13.zip</span><br><span class="line">unzip rdp_classifier_2.13.zip</span><br><span class="line"><span class="built_in">chmod</span> u+x path/to/rdp_classifier_2.13/dist/classifier.jar</span><br></pre></td></tr></table></figure>

<p>由於 RDP classifier 是依賴 JAVA 的軟體，所以執行時要輸入 .jar 的絕對路徑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar &lt;<span class="built_in">command</span>&gt;  </span><br><span class="line">&lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<p>為了簡化指令，可以創造名為 rdp_classifier 的腳本，並將腳本所在的目錄加入環境變數。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch rdp_classifier</span><br><span class="line">chmod u+x rdp_classifier</span><br><span class="line">vim rdp_classifier</span><br></pre></td></tr></table></figure>
<p>接著把落落長的指令放到腳本中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar $*</span><br></pre></td></tr></table></figure>
<p>如此一來，往後執行時就只需要輸入 rdp_classifier即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdp_classifier &lt;<span class="built_in">command</span>&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>若是 Ubuntu，則可以從套件庫安裝。只是相較於 conda，ubuntu 套件庫內的 RDP classifier 還<a href="https://packages.ubuntu.com/impish/rdp-classifier">停在 2.10 版</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install rdp-classifier</span><br></pre></td></tr></table></figure>
<p>除了前述方法，也能夠安裝集合了 RDP 團隊包含了 classifier 在內各種開發工具的 <a href="https://github.com/rdpstaff/RDPTools">RDPTools</a>。只是 RDPTools 是透過 make 和 makefile 來編譯與安裝。由於依賴的軟體和環境設定等問題，我到現在還沒成功過，暫時無法整理出相關的筆記。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
        <category>metagenomics</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜太空生物學</title>
    <url>/lee-2017-astrobiology/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>李炎的太空生物學是台灣少見的天文生物學專著，不過內容卻虛實參半。前半段摘錄新聞網或部落格報導的奇聞軼事，補充維基百科的條目說明，加上一些感想湊成討論生命起源和地外生命的篇章。然而，參考資料似乎不限於期刊論文，好比「墨西哥人發現外星人寶寶」之類的農場新聞也直接收錄，並沒有加以解釋或編輯。</p>
<span id="more"></span>
<p>中段改編自美國國家太空生物研究中心發表的《人類在太空的生理學》(Human Physiology in Space)，這是太空生物學(Space biology)的一環，雖然和字面上的涵義和天文生物學(Astrobiology)相似，但是前者研究太空環境對既有生物的影響，後者探討生命是怎麼來的。</p>
<p>太空生物學有許多實用價值，例如若能了解動物的生理變化將有助於設計太空人的健康維護措施，而掌握植物的太空生理學知識也能應用在太空農業上。至於微生物生長繁殖的狀況，則與天文生物學息息相關。由於各行星可能因隕石衝擊而把表土拋向太空，假如土中的微生物能捱過最初的撞擊，並在微重力、高輻射的極端環境存活，便有機會把生命播種到其他星球。</p>
<p>此書各章節較為零碎，例如第一部分看起來像鄉野奇談、第二部分讀起來像人體生理學課本，較難看出與主題的關聯。此書末以幾篇應用藍菌淨化代謝廢物的實驗報告作結。查詢了作者與其研究生的論文，發現原文僅提到可處理畜牧業或廚餘廢水，沒說明是否能應用在太空船的維生系統，因此這部分內容可能是作者自行延伸而來。</p>
<p>這部分有點可惜的是，作者用很大的篇幅（幾乎把整份論文貼了上來）來強調藍菌具有生物淨化的潛力。可是，閱讀以太空生物學為題的作品時，會期待能了解太空與畜牧環境差異，以及應用時會碰上的困難，但是作者較少著墨這些問題。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李炎 (2017)《太空生物學》，漢珍數位圖書股份有限公司。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1. Two Sum</title>
    <url>/leetcode-1-two-sum/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
</blockquote>
<p>求數列內，和為目標值的兩數之座標</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,2,4], target &#x3D; 6<br>Output: [1,2]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code>：數列長度介於 2 至 104 之間</li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code>：數列各項可能有負值</li>
<li><code>-109 &lt;= target &lt;= 109</code>：目標值可能為負值</li>
<li>Only one valid answer exists.：僅有一組解</li>
</ul>
<span id="more"></span>

<p><strong>知識點</strong><br>hash table</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題最直觀的解法是將數列各項兩兩相加，最遲到比對所有組合後才找到題解。然而，目標值在這算法裡僅作為判斷結果的依據，沒有充分利用其提供的資訊。</p>
<p>為了充分利用目標值，可以各項與目標值之差為 keys，各項座標為 values，建立 hash table 存儲讀過的數字。</p>
<p>若現在的數字為先前出現過的數字與目標值之差，則回傳這兩數字的座標即為題解；若否，則新增現在的數字與目標值之差到 hash table 內。由於題目設計保證有唯一解，所以最遲遍歷整個數列即可找到題解。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = &#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record.keys() :</span><br><span class="line">                <span class="keyword">return</span>([record[nums[i]], i])</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                record[diff] = i</span><br></pre></td></tr></table></figure>
<ul>
<li>此以 python dict 實踐 hash table 的功能。</li>
<li><code>record.keys()</code> 可寫成 <code>record</code>，但標出來比較清楚</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜戲說統計</title>
    <url>/lee-2017-introduction-to-statistics-and-quantitative-analysis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知乎上有段軼聞可以很好地形容我讀《戲說統計》的心境：</p>
<blockquote>
<p>以前上新東方時候聽老師講的，說以前老俞還講課的時候，特別陶醉，做完題對答案，就問“有沒有人哪道題不懂啊？”要是有人提問題的話，老俞總是深情地看一眼題目，然後放下手中的教案，說：“同學們啊，這道題讓我想起了當初創業時候的的一件事，balabalabala”短短幾分鐘的就能把全班人講的如痴如醉，然後來一句“好的，大家還有哪道題不懂嗎？（阿冰，知乎）</p>
</blockquote>
<span id="more"></span>

<p>讀《戲說統計》是因為我很喜歡李連江老師的另一本書。教讀者怎麼走入和走好學術這條路的書有很多，例如讀《別鬧了，費曼先生》可以立志，讀《你和你的研究》讓人不忘摘星，讀《研究生完全求生手冊》則能學習踏實做事。</p>
<p>然而李老師的《在學術界謀生存》卻教讀者在了解自己是個平凡人後，怎麼面對期望落差，怎麼處理生涯焦慮，怎麼不負自己的使命與期待。因此，得知他還有一本既講統計也談學術生涯的著作時，便到圖書館借來看。</p>
<p>在經驗分享方面，《戲說統計》的立論與《在學術界謀生存》一致，皆勸勉讀者在看清事實後仍保持積極，追求自我的價值與肯定，例如：</p>
<blockquote>
<p>人生的智慧在於準確判斷自己，欣然接納自己。(144)</p>
</blockquote>
<blockquote>
<p>設立現實的目標，才能建立自信。(287)</p>
</blockquote>
<blockquote>
<p>看過，看不懂，很好！好在哪裡？好在創造了機會。看不懂，讓人不快，不憤不啟。(292)</p>
</blockquote>
<p>這些原則跟我讀了一些書、問了一些人而且親自碰一次壁後體會的想法一樣：多做事，少幹話；爭取機會，別找藉口；把握現在，不要懊悔過去；用指標衡量進展，但不要用指標定義自我價值。</p>
<p>至於描述統計的內容，對學過統計學的讀者而言可能較淺。作者用了許多篇幅討論詞彙的含意，也試圖澄清專有名詞的命名邏輯。例如 variable 應譯為變量還是變項？而 variable 的三層意義，即事實與反事實之別（因果推論）、個體屬性的日新月異（縱向研究）、屬性的因人而異（橫斷研究），為什麼攸關研究設計？</p>
<p>這些立論初學者讀來可能恍然大悟，但要應用於實務難題時恐怕無從發揮；而有經驗者讀來或許覺得有趣，但可能會發出「早點知道這種理解方法」的喟嘆，畢竟自己已度過瓶頸，如今不需要這樣的輔助才能理解抽象概念。</p>
<p>此外，書中多以比喻取代公式推導來解釋統計觀念，但能否理解作者的比喻與推理則見仁見智。例如作者雖然很用心講解樣本分布、抽樣分布和誤差分布的關係，但對這些觀念已經有定見的人來說，比喻與借代反而有可能阻礙讀者理解作者想傳達的意義。</p>
<p>總結對《戲說統計》的看法，我會說這本書是很私人的著作，是作者盡到傳承與坦率之義務的著作。</p>
<p>李老師（即作者）曾寫道：「最有效的誤導方法就是培養學術明星，製造學術天才，甚至奇才」，也在這本書提到「學者要盡到承傳的天職，對學生坦誠自己求學的辛苦是本分 (012)」。《戲說統計》記錄了李老師學習統計時遭遇的難點和克服這些困難的方式，未經歷這些困難的讀者可能覺得行文囉嗦，但有共鳴的讀者或會感到助益匪淺。</p>
<p>畢竟讀者很多元，一本著作有這樣兩極的評價也不是什麼問題。我覺得教育講究感同身受，即使是再簡單的問題，若有一位搞不懂的學生，便需要一位能讓學生搞懂的老師。假設不存在這樣的老師，那位學生自己搞懂以後能指導曾跟他一樣迷惘的學生，不也是一樁美事嗎？</p>
<p>書中還有一些有意思的句子摘錄如下：</p>
<blockquote>
<p>我認為教師的功勞不是教知識，而是鼓舞學生。知識可以教，但要靠學生自己刻苦研究才能學到；能力不能教，只能靠學生自己鍛鍊提高。學生學知識，長本領，出成就，都靠學生自己。教師起什麼作用呢？教師的責任主要是影響學生。用什麼影響？就是以書本上的知識為手段，幫助學生樹立自己的學習目標，激發學生的創造精神，鼓勵學生艱苦努力，幫助學生認識自己的潛力，促使學生把自己的潛力發揮出來。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師的主要功勞就是給學生偉大的刺激，偉大的鼓舞。教師要在課堂上把學生的學習精神、奮鬥精神鼓舞起來，教師的作用就是刺激和鼓舞，用敲鑼打鼓的方法振奮學生，讓學生努力。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>… 學生造就老師。老師的成就有學生的貢獻，不是教師自己本來就那麼優秀。必須有優秀的學生，教師才能進步，這是我堅信不疑的。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師刺激學生，學生就會跟教師研討，有研討，就能出成就。老師的智慧是學生敲出來的，學生很優秀，總是敲打教師，教師就進步了。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>在方法論中，術語歸根結蒂是「約定」。約定俗成，遊戲能玩下去，溝通有效，誤會不深，就沒有必要更改術語。(008)</p>
</blockquote>
<blockquote>
<p>不怕了，就是學會了；敢用了，就是學通了；用對了，就是學精了。(011)</p>
</blockquote>
<blockquote>
<p>琢磨怎樣化繁為簡，化平淡為有趣，化有趣為智慧，也是教書的樂趣。(012)</p>
</blockquote>
<blockquote>
<p>英國哲學家奧斯丁說，通常情況下，我們需要的不是被告知，而是被提醒。方法論的主要作用就是提醒我們注意思維的漏洞與陷阱，(027)</p>
</blockquote>
<blockquote>
<p>常是相對的，變是絕對的。常是異常，無常是常。常往往是希望的目標，不是研究對象。希望常，是因為害怕變；提倡常，是因為現實中有不可阻擋的變。所以，「天不變，道亦不變」是個訴諸虛幻奢望的討好建議，不是基於事實研究的明智建言。話說回來，因為變是常態，也因為變很難把握，所以保守是明智，求變是進取。(027)</p>
</blockquote>
<blockquote>
<p>對人生來說，日新月異之變是唯一能直接觀察的變。人生之所以難，之所以有趣，歸根結蒂是因為人能意識到這兩種變化，試圖打通這兩種變化。我們看到種種因人而異之變，自然會想到自己日新月異之變。問題在於，這兩者之間，只在很有限的程度上相通，而且我們很難準確知道到底在什麼程度上、在哪個方面相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的智慧與藝術，關鍵就是在正確的時候採納適當的價值觀。人生不能沒有希望，希望來自相信因人而異之變與日新月異之變相通；然而有希望必然有失望，失望來自二者經常並不相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的關鍵是發現和發揚正態分布對自己有利的屬性，躲避和弭補正態分布對自己不利的屬性。 (139)</p>
</blockquote>
<blockquote>
<p>… 最難判斷的就是我們的相對位置，而平均值和標準差可以幫我們確定自己的相對位置。在這個意義上，我們關注平均值和標準差，就是希望知道自己在這個世界上的位置，也是希望改變我們的地位。人生的苦悶在於，無論我們做什麼，都既糾結於平均值，也糾結於標準差。(141)</p>
</blockquote>
<blockquote>
<p>年輕時要努力奮鬥，因為自己的位置是不確定的，自己的潛力是未知的。但是一定要注意，人生的舞台有很多，人的能力有多面，千萬不要覺得人生只有一條路。你在這一條路上可能平平，在另一條路上卻可能優秀。一方面要堅韌不拔，另一方面要靈活機動，才能找到你最擅長做的事。(145)</p>
</blockquote>
<blockquote>
<p>研究生是學者最畏懼的讀者，他們會跟老師說，你把數據庫給我，我重複做一遍，跟你學。(185)</p>
</blockquote>
<blockquote>
<p>無論學什麼，都分兩個功夫：一個是投入時間學，另一個是用心琢磨怎麼學。又投入時間學，又用心想，就會慢慢找出一個適合自己的方法。哪一天你找到適合自己的方法了，你就學會了。(262)</p>
</blockquote>
<p>[^*] 李連江 (2017)《戲說統計：文科生的量化方法》，中國政法大學出版社。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1480. Running Sum of 1d Array</title>
    <url>/leetcode-1480-running-sum-of-1d-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>計算數列逐項的累積和 (runningSum)</p>
<span id="more"></span>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array nums. We define a running sum of an array as runningSum[i] &#x3D; sum(nums[0]…nums[i]).<br>Return the running sum of nums.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,4]<br>Output: [1,3,6,10]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array  </p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題應該算是 for loop 練習，我覺得要留意 (1) indices out of range 以及 (2) len(nums) &#x3D;&#x3D; 1 的狀況。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[n] = nums[n - <span class="number">1</span>] + nums[n]</span><br><span class="line">        <span class="keyword">return</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜153. Find Minimum in Rotated Sorted Array</title>
    <url>/leetcode-153-find-minimum-in-rotated-sorted-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given the sorted rotated<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]">1</span></a></sup> array <code>nums</code> of unique elements, return the <em>minimum element of this array</em>.</p>
</blockquote>
<p>平移一嚴格遞增數列各項 n 單位後，求此數列的最小值</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,4,5,1,2]<br>Output: 1</p>
</blockquote>
<p><em>須留意幾個樣例：數列只含一項、數列只含兩項、平移後與原數列相同、最小值位於數列尾部</em></p>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li><code>n == nums.length</code>：數列長度為 n</li>
<li><code>1 &lt;= n &lt;= 5000</code>：數列長度介於 1 至 5000 項</li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code>：數列各項介於 -5000 至 5000，因此兩項相加不至於超出整數大小的上下界</li>
<li>All the integers of <code>nums</code> are <strong>unique</strong>：數列各項唯一</li>
<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times：數列已排序，且至多平移 n 次，最少平移 1 次</li>
<li>You must write an algorithm that runs in <code>O(log n)</code> time：此題有時間複雜度限制</li>
</ul>
<p><strong>知識點</strong><br>binary search</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題的關鍵在於判斷最小值，並使用二分搜尋法簡化找尋最小值的步驟。</p>
<p>由於數列已由小到大排序，所以如果某項數值在平移後小於前一項，該項即為數列的最小值。依照這項原則，可以先定義 <code>left</code>、<code>mid</code>、<code>right</code> 三個指標，其中 <code>mid</code> 是 <code>left</code> 與 <code>right</code> 的中間值。</p>
<p>若 <code>nums[mid]</code> 小於其前一項，則 <code>nums[mid]</code> 為最小值，即可中斷迴圈並回傳題解。若尚未找到最小值，則可比較 <code>nums[mid]</code> 與 <code>nums[right]</code>，選定下一個搜索標的。</p>
<p>假設 <code>nums[right]</code> &gt; <code>nums[mid]</code>，表示數列於 <code>mid</code> 至 <code>right</code> 之間嚴格遞增，表示原數列的首尾交接處不在此區間，所以可以縮小搜索範圍到 <code>left</code> 至 <code>mid - 1</code> 之間。反之，則表示數列於 <code>left</code> 至 <code>mid</code> 之間嚴格遞增，則可縮小搜索範圍至 <code>mid + 1</code> 至 <code>right</code> 之間。</p>
<p>由於嚴格遞增數列一定有唯一的最小值，所以最遲在 <code>left</code> 與 <code>right</code> 指向同一座標時，會找到數列最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = right - (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>(nums[mid])</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="mid-的定義方式"><a href="#mid-的定義方式" class="headerlink" title="mid 的定義方式"></a><code>mid</code> 的定義方式</h3><p><code>mid</code> 亦可定義為 <code>(left + right)//2</code>，但聽同事討論，若兩數的數值極大，則有數值超出整數範圍的風險。以相減的方式撰寫則一定不會超出範圍。</p>
<h3 id="判斷首尾交界處的方式"><a href="#判斷首尾交界處的方式" class="headerlink" title="判斷首尾交界處的方式"></a>判斷首尾交界處的方式</h3><p>有看過同事在比較時，不比對 <code>nums[right]</code>，而是比對 <code>nums[-1]</code>，有一樣的效果。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜217. Contains Duplicate</title>
    <url>/leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p>
</blockquote>
<p>(給定一整數陣列，判斷其中是否含重複的數字。)</p>
<p>Example:</p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,1]<br>Output: true</p>
</blockquote>
<span id="more"></span>

<h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>若 array 含重複數字，則有以下特性：</p>
<ul>
<li>數字重複出現</li>
<li>array 長度大於其中數字種類數</li>
<li>若將 array 排序，則重複的數字比鄰出現</li>
</ul>
<p>根據第一種特性，可用 hash table 存儲讀過的數字，再判斷讀入的數字是否已存在 hash table 中。此處，我以 python 的 <code>dict</code> 充作 hash table 來實踐這個想法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        occur = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> occur.keys():</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                occur[n] = n</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">由於計算時間和空間需求都隨陣列大小線性增長，所以時間與空間複雜度都是 $O(n)$</span><br><span class="line"></span><br><span class="line">除了 `<span class="built_in">dict</span>`，python 的 `<span class="built_in">set</span>` 也能體現 <span class="built_in">hash</span> table 的特性。`<span class="built_in">set</span>` 可想像為僅有 key 的 `<span class="built_in">dict</span>`，由於 `<span class="built_in">set</span>` 的元素皆獨一無二，故可將 array 轉為 `<span class="built_in">set</span>`，再比較兩者的長度。若 `<span class="built_in">set</span>` 長度小於 array，則表示 array 含重複值。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>至於先排序，再比較數值兩側是否有重複值的做法，可參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a></p>
<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><ul>
<li><p>使用 list, dict, set 存讀過的數字有什麼差異？（參考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448">廖雪峰的官方網站：使用dict和set</a>）</p>
</li>
<li><p>python 是怎麼體現 <code>set</code> 的概念？（參考：<a href="https://stackoverflow.com/questions/3949310/how-is-set-implemented">How is set() implemented?</a>）</p>
</li>
<li><p>排序算法跟 hash table 算法相比有什麼優點？（參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a>）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜53. Maximum Subarray</title>
    <url>/leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an integer array nums, find the subarray which has the largest sum and return its sum.</p>
</blockquote>
<p>給一整數數列，求其子數列級數的最大值。</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6</p>
</blockquote>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li>$1$$\leq$ nums.length $\leq$$10^5$：數列長度介於 $1$ 至 $10^5$ 間</li>
<li>$-10^4$$\leq$ nums[i] $\leq$$10^4$：數值介於 $-10^4$ 至 $10^4$ 間</li>
</ul>
<p><strong>知識點</strong></p>
<ul>
<li>dynamic programming</li>
<li>Kadane’s Algorithm</li>
</ul>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>這題常見的作法是 Kadane’s algorithm，我在解題時並不知道這套演算法，所以一開始是用極端情形勾勒 function 的輪廓，再透過更多樣例「擬合」出可能的解法，最後才整合為提交的答案。</p>
<ul>
<li><strong>數列僅包含一個數字</strong>：解為該項數字，表示即使只有一個數字也能回傳</li>
<li><strong>數列全為正值</strong>：解為數列各項之和，所以程式碼內含有累加操作</li>
<li><strong>數列全為負值</strong>：解為數列最大的一項數字，所以程式碼內含有暫存最大值的變項與比較數值的判斷式</li>
</ul>
<p>由此分析可知問題癥結在於，累加的級數在碰到負數時要如何處置？</p>
<ul>
<li>若級數於累加後增加，則將這些數字納入計算。例如 [2, -1, -3, 5]，由於 5 &gt; -1 + -3，所以仍有涵蓋這兩個負數的價值。</li>
<li>若級數於累加後減少，則跳過這些數字，從新的位置開始計算。例如 [2, -1, -4, 1]，累加新的數字無法抵銷兩個負數值，所以不如跳過。</li>
</ul>
<p>至此，我雖然對計算方式有個概念，但還是經過了一連串測試，才歸納出以下算法。依序累加數列各項，每次累加後 (1) 若累加後級數沒增加，則從當前項重新計算級數；(2) 更新當前級數的最大值。</p>
<p>遍歷整條數列後，當前級數的最大值即為題解。只須走一趟循環，空間用量也固定，所以時間複雜度和空間複雜度分別為 $O(n)$ 與 $O(1)$。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        maxVal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sums += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &lt; nums[i]:</span><br><span class="line">                sums = nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; maxVal:</span><br><span class="line">                maxVal = sums</span><br><span class="line">        <span class="keyword">return</span>(maxVal)</span><br></pre></td></tr></table></figure>
<p><em>當初以為要回傳子數列的位置，所以才使用 index 取值</em></p>
<ul>
<li><code>sums</code>：紀錄當前累加值</li>
<li><code>maxVal</code>：紀錄當前累加的最大值</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>MiTalk 2022：在講台上</title>
    <url>/mitalk-6-thu-2022/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>兩年前，我曾以聽眾的身分報名 MiTalk，如今總算有點結果可以參加口頭報告。趁著記憶猶新，我想紀錄此次工作坊的所見所得，並且借題敘述一些尚未獨立成篇的想法。</p>
<p>其中一個感悟是，以報告者的身分參加會議能增加聽講的敏感度和觀察面向。當聽眾時，關注的項目往往是相關研究或新奇題材。而經歷了準備報告的過程後，即使對講題不感興趣，也會留意講者的投影片設計、敘事結構、肢體語言和危機處理。</p>
<p>這些是準備報告的共同課題，所以每次聽講也能從多樣的示範中學習適合自己的解決辦法。</p>
<span id="more"></span>

<h2 id="談談口頭報告的緊張感"><a href="#談談口頭報告的緊張感" class="headerlink" title="談談口頭報告的緊張感"></a>談談口頭報告的緊張感</h2><p>坦白講，因為緊張和焦慮，我幾乎無法專心在其他人的報告內容。不過，雖然這次聽講人數較多，可是我覺得報告的緊張感比以前輕微，所以想花點篇幅來整理自己做了什麼來緩解緊張情緒。</p>
<h3 id="剖析緊張的根源"><a href="#剖析緊張的根源" class="headerlink" title="剖析緊張的根源"></a>剖析緊張的根源</h3><p>「講得不好怎麼辦？」、「被發現不是個咖怎麼辦？」、「講錯怎麼辦？」，我覺得，這些焦慮和維護個人價值的渴望有關。當我們把行為、評價與個人價值掛勾，便會擔憂行為失當是否影響個人價值，開始想像一些可怕的圖景，讓自己在事情發生前變得緊張不安。這種擔憂會因注意到自己無法控制他人想法而加劇，導致自己的決策受他人的想法擺布，也為了滿足全數人的期待而疲憊不堪。</p>
<h3 id="嘗試認知轉換"><a href="#嘗試認知轉換" class="headerlink" title="嘗試認知轉換"></a>嘗試認知轉換</h3><p>既然很多心理掙扎源於認知與行動的不協調，所以改變認知的模式是有機會緩解報告的不安感。首先，可以嘗試讓口頭報告與他人評價脫鉤。我的老師常提醒我，口頭報告（或是發表期刊論文）固然有宣傳和證明自己等作用，但除了功利價值，「發表」既是對前人的感謝也是對來者的祝福。</p>
<p>畢竟，無論我們基於什麼目的從事科學，都需要閱讀大量文獻。當我們從前人的心血獲得發現與見解，從而滿足研究的動機以後，將結果發表出來就是最好的回饋，表達我們從過去得到什麼靈感，並發展出可以給未來的東西。因此，再微不足道的發現與努力，再笨拙的傳達方式，都無損一個人表達感謝的誠意與熱情。</p>
<p>其次，也可以學著讓他人評價與個人價值脫鉤。由於評價是建立在對價值的判斷，兩者的關係也因人而異。每次報告，聽眾的背景和期待都不一樣，即使是同樣的內容也可能激起不同迴響。若透過他人評價來穩固個人價值，等於把定義自我的自由讓給這些無法控制的變項。</p>
<p>那要如何爭取定義自我的自由呢？可行的策略是在準備報告時，先為自己設立幾個目標，避免被他人評價牽著走。這些目標反映了個人最在乎的事情，所以達成目標的過程也是自我實踐與定義的過程。例如這次我給自己設定的目標有，</p>
<ul>
<li><strong>健康</strong>：不管準備得怎麼樣都不熬夜</li>
<li><strong>情緒</strong>：即使當下緊張或焦慮，也要專注於當下，不要為了未來而恐慌或為過去懊悔</li>
<li><strong>科學</strong>：用「如果往後有更完整的資料，我也能把握機會」的心態去分析資料</li>
<li><strong>報告</strong>：嘗試用新的簡報版型、敘事結構和陳述方式</li>
</ul>
<p>列了目標以後，我會提醒自己，不管別人怎麼想，只要達成預先設定的目標就是我的勝利。另外，在報告前，我也透過和朋友聊天、在附近走走、穿上不同風格的衣服或與民宿老闆閒聊等策略，提醒自己具有多元面貌，不只是一個在台上報告的人。</p>
<p>至於犯錯、出糗或聽到批評等，我則將之聯想為 bug 和 warning。寫程式的時候，警告訊息往往用紅色字體呈現，但要注意的是字裡行間的訊息，而不是色彩給我們的原始感受。對於生活中碰到的 bug 和 warning，我試著用這樣的聯想，讓自己能跟寫程式的時候一樣勇敢按下 Run，從錯誤訊息提供的線索，找到克服困難的途徑。</p>
<h3 id="緩解即刻的感受"><a href="#緩解即刻的感受" class="headerlink" title="緩解即刻的感受"></a>緩解即刻的感受</h3><p>認知轉換需要時間練習，上台前即時湧起的感受仍需要一些精神勝利法或不理性的敘事結構來克服。以下列幾個我用過的手段，這些方法通常能穩定心情一段時間，讓我能更專注在準備報告。</p>
<ul>
<li><strong>「呼~」</strong>：呼吸，然後什麼都不要想，專注體會當下所有情緒感受，不做任何評價。這方式的假設是，儘管每個人擁有的時間有限，但我們能提升對生活的意識來增加經驗的厚度。由於每次情緒波動都是別於平常的經驗。因此，不管接下來發生什麼事，透過調整呼吸來品味當下的感受，都能為我們賺來生活的體驗。</li>
<li><strong>「反正我們都會死」</strong>：反正我們都會死，現場所有人的掙扎與聲嘶力竭都會風化在歷史，隨太陽燃盡，最後在宇宙熱寂裡靜默。所以目光放遠一點，我們在台上不是對著觀眾還是南瓜什麼的呢喃，而是面對一座座顫抖的墓碑自白。現在發生什麼事也無所謂，反正再過$10^{150}$年，我們都會分解成孤單的光子，平均散佈在宇宙中，再沒機會碰到彼此。</li>
<li><strong>「就這十分鐘而已」</strong>：這招從國小用到大，伴我對抗打手心、罰站、訓斥等麻煩。簡言之，就是不斷提醒自己任何感受都會消退，也提醒自己要發生的事情根本很快就過了。像報告只有十分鐘，就算支支吾吾了十分鐘也會過去，而十分鐘有多短？短到課堂間睡個覺都不夠呢。（不過應用此方法時，盡量別想像棒式之類的經驗。）</li>
<li><strong>「宇宙某處正在發生生死存亡的戰爭」</strong>：這是一種珍惜的心態。想像宇宙某處正在發生星系間的戰爭，下一秒銀河系可能要被當作質量兵器砸毀在其他星系群了，這或許是最後一次報告，不管怎樣都要好好地享受。即使幸免於難，對於自己能在地球上安穩穩地站著，活在重力常數為 $6.67 \times 10^{-11}m^{3}kg^{-1}s^{-2}$ 的宇宙中也是感激不盡。</li>
<li><strong>「輪我了」</strong>：求學過程有碰過多堂枯燥的課程，每次聽課都覺得折磨，又不能不出席。被荼毒多年，如今終於輪到我上台報仇，難得有老師待在台下機會，應該要大方講，以洩先前當學生之恨。</li>
<li>最後再補充一個比較積極的方法，這也是我覺得最有效的方式：想像想傾訴的對象坐在台下，然後把這場演講獻給他們。當自己總算做出點什麼時，往往忍不住想對著某些人說「你看！」吧？</li>
</ul>
<p>如果曾支持自己的人坐在台下，我會想讓他們知道，多虧了他們的關懷與支持，我才有辦法做出東西來。我覺得，這種想像讓我更能以分享與交流的心態去演講，而不會總擔憂自己做得不好而裹足不前。</p>
<h2 id="如何回答自己不熟悉的問題？"><a href="#如何回答自己不熟悉的問題？" class="headerlink" title="如何回答自己不熟悉的問題？"></a>如何回答自己不熟悉的問題？</h2><p>回答問題時，除了能簡要答覆自己熟悉的部分，若對問題不熟悉，也要盡可能回饋對方自己的見解，才能彼此互惠。這次 MiTalk ，我對自己回答問題的方式不太滿意，所以留意了各講者答覆不熟悉議題的策略（就是講者會停頓一下、發出「摁～」聲音或眼睛朝右上方看的那種問題），期待自己往後能預先準備，不會因為緊張而妨礙與聽眾交流的機會。</p>
<h3 id="Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉"><a href="#Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉" class="headerlink" title="Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉"></a>Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉</h3><ol>
<li>承認對 A 不熟悉</li>
<li>承諾可從 B 方面解釋</li>
<li>提出 B 方面的見解</li>
</ol>
<h3 id="Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"><a href="#Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法" class="headerlink" title="Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"></a>Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法</h3><ol>
<li>解釋數據的統計與數理意義</li>
<li>坦白目前仍在思考生物解釋</li>
<li>表示此問題值得探討，說明可能的探討方向</li>
</ol>
<h3 id="Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性"><a href="#Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性" class="headerlink" title="Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性"></a>Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性</h3><ol>
<li>坦白該部分並非專長</li>
<li>說明已知的資訊</li>
<li>承認目前專注的部分</li>
<li>承諾往後可能怎麼做</li>
</ol>
<h3 id="Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"><a href="#Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制" class="headerlink" title="Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"></a>Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制</h3><ol>
<li>承認該限制暫時無法克服</li>
<li>提出即使存在限制，在部分資料或條件下仍表現關注的現象</li>
<li>承諾未來可能怎麼解決之</li>
</ol>
<h3 id="Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"><a href="#Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節" class="headerlink" title="Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"></a>Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節</h3><ol>
<li>概略回答問題</li>
<li>承認沒有詳記所有資訊</li>
<li>提供參考資料給聽眾</li>
</ol>
<h3 id="Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"><a href="#Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現" class="headerlink" title="Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"></a>Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現</h3><ol>
<li>承認自己僅探討了感興趣的項目</li>
<li>依照自己理解推論該細節可能跟研究現象有何關係</li>
<li>感謝對方提出這方面的見解</li>
<li>承諾會回到實驗室思考對方的問題</li>
</ol>
<h3 id="Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"><a href="#Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究" class="headerlink" title="Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"></a>Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究</h3><p>若只回答：「自己沒有細究」會很可惜。畢竟，如果聽眾對研究題材沒興趣的話，也不會浪費時間提問了。既然講者是在場對主題最熟悉的人，即使沒做過相關研究，聽眾也會期待講者的閱歷和經驗能對延伸問題給出什麼新奇想法。因此，可以大膽依照自己的知識做有理據的猜測。</p>
<h2 id="After-phD-PI-or-Boss"><a href="#After-phD-PI-or-Boss" class="headerlink" title="After phD: PI or Boss?"></a>After phD: PI or Boss?</h2><p>這節主辦單位邀情王永福博士、張瑞仁博士、曾景鴻博士介紹他們的公司以及分享在博士後踏入創業之路的動機。</p>
<p>如果重來，會選擇創業還是當PI？<br>別人不會端著錢要你做沒意義的事情。</p>
<p>我覺得這個問題相當於比較產業與學術的職業特質。 先前讀過 Vincent Vanhoucke 的分析，他指出，當工程師和當研究員需要不一樣的心態。相較於工程師，研究員要面對未知是否有解的難題。很多時候，研究結果無法指向解答，只生出更多疑問。這意味著，科研的進展不代表應用的進展，投注整個生涯若能促成概念轉換已相當傑出，更多的研究只在概念上延伸微小的範圍，甚至沒有一絲漣漪地沉澱在歷史長河。</p>
<p>面對意義的喪失，有些人離開學界。例如，王博士即認為他仍會選擇創業，因為學術研究的回饋感較低，很常在實驗室沒日沒夜，卻對自己究竟解決了什麼重要問題感到困惑。相較之下，業界處理的是具體而且迫切的問題，每次都有明確的目標和衡量標準。此外，王博士也認為創業能獲得資金自由，從而保障研究自由，可以自己決定研究方向，不必靠計畫維繫實驗室運作。而張博士則認為只有產業才能與實務問題接軌，因為學術發現局限於文獻，規模、可行性與市場潛能都未經檢驗，若要實踐理想，仍得踏入產業界。</p>
<p>然而，也有些人選擇留在學界，嘗試增加與產業的連結來賦予職涯意義。例如陸永祥老師在擔任助理教授時意識到，自己雖然有許多期刊發表，但這些研究僅圍繞在自己創造出來的問題，並沒有解決這世界面臨的任何難題。因此，陸老師決定踏入產業界，在各大商業發表會中擷取靈感，了解當前社會的需求，藉此引導研究計畫開展，從而結合了研究志業與實務意義。</p>
<p>這幾個例子也呼應曾博士所述，創業與學術的抉擇跟個性有關，你的個性會決定你怎麼選擇職業，怎麼在職涯中追尋意義、成就與滿足。</p>
<h3 id="phD-的訓練對創業有幫助嗎？"><a href="#phD-的訓練對創業有幫助嗎？" class="headerlink" title="phD 的訓練對創業有幫助嗎？"></a>phD 的訓練對創業有幫助嗎？</h3><p>三位講者的共識是，phD 對專業技術與抽象思考有幫助，但對經營面的幫助有限。創業要管理的財務和人事問題比經營實驗室更為複雜，這些都不是就讀博士班容易接觸的事情。因此，張博士認為，創業與否的關鍵在商機，商機比起主題、決心和學位更重要。如果時機對了，對商機感興趣便能主動出擊。畢竟，培育 phD 和培育老闆要注重的素養有別，花費大量時間攻讀學位後，仍需要從頭累積經營經驗，此時無論商機或是能力都可能過時了。</p>
<p>所以三位講者建議，若有良好的機會（例如家庭背景、產業需求、新穎技術、貴人等），要抓住時機創業；若境況太差（資金不足、對產業陌生、能力不足等），需要累積點什麼，這時就讀 phD 或進入欲創業的領域，才對往後創業有幫助。換句話說，為了創業而就讀博士班不是好理由。因此，王博士也希望大家思考繼續進修的動機是什麼，並期許大家不要為了趕上別人而莽撞地決定讀博士班。</p>
<h3 id="為什麼選擇創業這條辛苦的路？"><a href="#為什麼選擇創業這條辛苦的路？" class="headerlink" title="為什麼選擇創業這條辛苦的路？"></a>為什麼選擇創業這條辛苦的路？</h3><p>我覺得張博士的答覆很有趣：「找不到方向或沒機會創業的人更辛苦吧？」</p>
<h3 id="業界研究人力和業務人力的比例為何"><a href="#業界研究人力和業務人力的比例為何" class="headerlink" title="業界研究人力和業務人力的比例為何"></a>業界研究人力和業務人力的比例為何</h3><p>曾博士提供了一個經驗法則，公司最高齡員工的年紀與業務人員的比例正相關。</p>
<h2 id="小型工作坊"><a href="#小型工作坊" class="headerlink" title="小型工作坊"></a>小型工作坊</h2><h3 id="Networking-and-Ecosystem"><a href="#Networking-and-Ecosystem" class="headerlink" title="Networking and Ecosystem"></a>Networking and Ecosystem</h3><p>講者：謝志豪老師 &amp; 吳育瑋老師</p>
<p>共現網路不等於交互作用網路，而交互關係也會隨著規律事件或突發事件而變動。謝老師的工作是利用時間序列資料，推論交互作用隨時間變化的網路。</p>
<p>然而，時間序列分析對採樣頻率有一定要求，一項研究至少數十到數百個樣本才夠。然而受限於經費，往往沒有辦法獲得那麼龐大的資料，所以主持人便詢問是否有克服採樣量不足的方法，而謝老師的答覆則是：「沒有，你還是得去採樣。」</p>
<p>這答覆挺實際的，理論強如克卜勒和牛頓也需要第谷和佛蘭斯蒂德。雖然現在分析工具很多，但沒資料仍是寸步難行。若想解決科學問題卻受經費限制，那只能拉長時間，例如謝老師創建浮游生物資料庫的期許是在「30年後」能為人所用，而不是現在就生出大量樣本，或用少數樣本配合數據模型獲得驚人結果。</p>
<p>因為先前摸過時間序列資料，所以我想了解不同的時間尺度怎麼影響網路推論，也想了解採樣時間不一的問題要怎麼克服。謝老師回覆，時間尺度跟關切的問題有關，不同尺度得出的交互作用網路也有別，無法彼此推論。</p>
<p>至於採樣時間不一的問題是目前時間序列分析的限制，常見的手段是利用內插法來推論特定時間的測量值，但不是每個狀況都適合使用內插法。因此，如果時間差異很大，採用較大的時間尺度還有可能應用此演算法。</p>
<p>而吳老師則簡介他在應用網路分析的心得，例如網路指標的用途不止是簡化數據，也是為了不讓分析者被資料視覺化的形式欺瞞。另外，他也推薦我們讀 Faust. (2021). Open challenges for microbial network construction and analysis. The ISME Journal, 1-8. 了解目前生物網路分析面臨的挑戰（不過謝老師補充，其實有數則問題已經被他解決了）。</p>
<h3 id="Probiotics"><a href="#Probiotics" class="headerlink" title="Probiotics"></a>Probiotics</h3><p>講者：徐瑋萱老師、李保宏老師、陳彥伯老師 </p>
<p>人體益生菌的進展分為消化、免疫、代謝與神經益生菌等世代。目前，台灣業界著重消化與免疫益生菌，但國外正積極發展第三、四代益生菌的市場。不過，益生菌的應用場合也不只人體，還可應用於寵物皮膚炎治療、牲畜疾病防治、土壤改良與環境工程（carbon sink，改善二氧化碳濃度飆升的問題）。此外，益生菌的形式亦未必要為活菌，死菌不僅較容易保存，也能避免他人竊取菌株私自培養。</p>
<p>在益生菌發展中，徐老師有個有趣發現：益生菌可能透過胞泌體影響其他微生物的生理過程，從而降低病原菌的毒性或生長能力。這現象的潛力在於，針對發炎性腸炎的疾病，也許不需透過菌群移植或單菌接種來改善群落結構，只要改變群落的功能就可以達到治療疾病的效果。</p>
<p>此外，益生菌的胞泌體還可能透過神經或其他組織運輸到其他部位，影響遠端部位的生理機能，例如遷移到腦部可能改善精神狀況或記憶相關疾病等。不過關於這些胞泌體的專一性和作用機制都仍不明朗，還需要許多研究確認之。</p>
<p>不過，目前益生菌的研究手段和方向受限於法規，例如基因改造技術便不得用於食品級的益生菌。而透過誘導突變再篩選菌株等菌種改良方式雖可用於食品，但無法獲取有機認證。</p>
<h2 id="邀請演講"><a href="#邀請演講" class="headerlink" title="邀請演講"></a>邀請演講</h2><h3 id="陳可萱老師與林宛柔老師：植物共棲真菌"><a href="#陳可萱老師與林宛柔老師：植物共棲真菌" class="headerlink" title="陳可萱老師與林宛柔老師：植物共棲真菌"></a>陳可萱老師與林宛柔老師：植物共棲真菌</h3><p>陳老師的研究主題是苔類真菌相。苔類受注目的理由除了能於極端環境生存以外，也跟苔類欠缺其他植物常見的菌根菌有關。儘管欠缺近似菌根菌的結構，苔類仍有許多共棲真菌。這些共棲真菌與苔類的關係是陳老師的研究焦點，例如判斷共棲真菌是長在死掉的植物（腐生）還是長在活的植物（共生、內生、寄生），或是了解真菌與苔類共棲於組織內或組織周圍等。</p>
<p>由於苔類從新生到死亡等不同生長階段的組織會出現在同一株當中（Senescence gradient，衰老梯度），所以可以做為探討真菌不同食性的研究題材。其中一種研究食性的方式是，透過C&#x2F;N穩定同位素技術，判斷真菌和植物間是否有營養交換。假如兩者有互換碳與氮，那可能兩者為共生關係；若真菌單方面擷取碳，但植物沒有獲得氮，則可能真菌寄生在植物上。</p>
<p>除了演化與生態應用，由於苔類與共棲生物密切相關，既然苔類能耐受極端環境，其上的生物應該也有相當的耐受性，所以苔類可能作為搜索極端環境生物的標的。其次，苔類可容納各種生物生存，所以或許可以利用這種特性，將苔類作為媒介，把生物接種到不同環境中。</p>
<p>相較於自營性植物共棲真菌，林老師的研究題材是水晶蘭和阿里山水晶蘭等異營性植物的共棲真菌。完全異營性植物只仰賴共棲真菌提供的營養，所以植物與真菌的關係更為密切。這種營養的依賴性可能反映在異營植物與其共棲真菌的演化歷史上。</p>
<p>由於水晶蘭和阿里山水晶蘭型態相近，生存環境也類似，所以林老師想探討兩植物的親緣關係，並了解共棲真菌是否跟兩種植物的分野有關。而研究結果發現，相較於水晶蘭，阿里山水晶蘭與錫杖花的親緣關係較密切。即使生存於相同環境，水晶蘭和阿里山水晶蘭的共棲真菌組成在屬的分類階層仍大不相同，暗示著水晶蘭與阿里山水晶蘭的分野可能跟共棲真菌有關。</p>
<h3 id="張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性"><a href="#張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性" class="headerlink" title="張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性"></a>張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性</h3><p>張博士的研究探討多樣性與群落功能性的關聯。群落的功能性是指各族群的代謝與生理功能之集合，可用生物量、呼吸率和物質消耗率等方式估計。目前已知，α diversity 和 γ diversity 與功能性正相關，但 β diversity 與功能性的關係則尚未明朗。</p>
<p>此研究的假說是分化生態棲位的決定性篩選會增加 β diversity，使得群落的功能多樣性隨分類組成分化而增加。相較於低功能多樣性的群落，高功能多樣性的群落更能應用環境中的不同資源，代謝共通產物也會越多。根據此假說，分化棲位的決定性群落構建過程會加強 β diversity 與功能性的正相關性。 （推理方式：deterministic heterogenize selection→niche diversification→β diversity↑→functional diversity↑→exploit resources→function effects ↑→function indices ↑）</p>
<p>為了探討此假說，張博士使用 Bray-Curtis dissimilarity 度量 β diversity，用 β mean pairwise taxa index (bea-MPTI) 評估決定性分化過程，以 biomass 評估功能性，來檢驗 β diversity、deterministic processes 和 functioning 三者的關聯。</p>
<p>我對此研究很感興趣，也有一些猜想。首先，我會想了解正相關性是否只出現在某種尺度內，例如：(1) 資源有限的情況下，群落多樣性增加應該也不會增加functioning，(2) 功能多樣性隨群落多樣性增加的幅度飽和，應該也會讓functioning 增長的趨勢停滯。其次，如果假設 niche diversification 導致功能性上升，也許使用採計親緣關係的 UniFrac 也能獲得類似的結果。</p>
<p>最後，在 α 和 γ diversity 和 functioning 正相關的情況下，β diversity 還能跟 functioning 呈負相關嗎？依照我的理解，α diversity 、β diversity 和 γ diversity 三者有關，當metacommunities 間 β diversity 為零，那 γ diversity 就等於 α diversity；若 metacommunities 間的 β diversity 為一，那 γ diveristy 應該是 α diversity 之和。按照這層關係，在 α diversity 固定的情況下，γ diversity 上升會伴隨 β diversity 上升，所以當 γ diversity 跟功能性正相關時，β diversity 也會跟功能性正相關。</p>
<p>我在想 β diversity 和 functioning 呈負相關的一個可能是，α diversity 和 β diversity 呈負相關。換句話說，若某種生態過程會使得群落間組成逐漸相似，但最大化單一棲地的多樣性，那麼就可能觀察到 β diversity 和 functioning 呈負相關。例如說在 local dispersal limitation 微弱的初級演替環境，頻繁的遷移雖然會讓各族群的組成逐漸相似 (β diversity↓)，也會增加各群落的族群數 (α diversity↑)，提升 metacommunity 的 functioning。</p>
<p>按照這想法推測，隨著各群落的規模觸及環境負荷極限，可能出現heterogeneous selection，例如發生 lottery competition，各群落的優勢族群取決於隨機事件，增加了 β diversity。又或發生 homogeneous selection，例如先前遷入的族群造成 priority effects，限制了後續能於各區域生存的族群多樣性，使得 β diversity 下降。在沒有更多遷入族群的情況下，這兩種情況都使得 α diversity 下降，但後者降低 γ diversity，降低 metacommunity 的 functioning，於是 β diversity 又和 functioning 正相關了。</p>
<h3 id="其他印象深刻的內容"><a href="#其他印象深刻的內容" class="headerlink" title="其他印象深刻的內容"></a>其他印象深刻的內容</h3><ul>
<li><strong>何攖寧老師</strong>：雖然獨立於培養的方法可以普查環境微生物，但為了驗證假說、生產應用和探索功能等需求，仍有培養細菌的需求。而冰河溶解、大地震、工業汙染等突發事件造成的菌群變化，更強調現地即時指引樣本微生物培養的重要性，畢竟突發事件相當罕見，時間過了就沒辦法研究了。</li>
<li><strong>邱名鍾博士</strong>：邱博士提到隨寄生蟲感染而上&#x2F;下調的宿主基因非常多，這些基因不僅反映了宿主受影響的生理功能和途徑，也反映了寄生蟲和宿主軍備競賽的過程。</li>
<li><strong>林玉儒老師</strong>：林老師講了「鬼花飄香」的故事，研究人員從已滅絕的魏氏岳槿之植物標本取得核酸，再找出產生香味的關鍵基因，將這段基因插入酵母菌生產香味分子以重現魏氏岳槿的氣味（完整故事可見科學人報導）。</li>
<li><strong>陳彥伯老師</strong>：「這項研究很感謝在行政院農委會任職的學妹協助，本來跟學妹約好要在台上 cue 她的，但今天學妹卻沒來。」</li>
<li><strong>陳立賢老師</strong>：「我們以蔥根製作的面膜並不會有蔥油餅敷在臉上的油膩感。」</li>
<li><strong>汪碧涵老師</strong>：「我們每次 reject，都往點數更高的期刊投。」</li>
<li><strong>謝志豪老師</strong>：「這裡不解釋，若對network感興趣，可以去讀書。」</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>兩年前參加 MiTalk 時，碩班研究正好碰到瓶頸。當時聽了許多老師討論他們的求學經歷，卻仍然困惑自己是否適合做研究。於是，我期許自己能透過研討會增廣見聞，在跟人討論的過程中激勵自己。如今帶著一點結果再次參加 MiTalk，算是朝當時立下的目標稍稍前進一步了。</p>
<p>我現在覺得不具備做好某件事的特質，不是放棄的理由。我很喜歡《原子習慣》提倡的概念，要成為怎樣的人取決於動機和行動，這實在是很 existentialism。確實，研究了未必有明確結果，報告後的回饋也不一定如預期，考到什麼學校也不保證能讀到畢業，當到計畫主持人或工廠老闆還是可能有多種麻煩要應對。</p>
<p>然而，這些行動無論成敗都是定義自己的過程。當你為了瞭解 metagenomics，在 compiler 輸入 print(“Hello world”) 那刻，就成了生物資訊學家；當你為了解釋群落演替，在紙上畫了數個方格模擬動物遷徙的時候，就成了理論生態學家；當你開始反思自己的研究，為了某個癥結輾轉難眠，你也已經是個學者了。</p>
<p>至於能在生物資訊、理論生態或是學者的路走去哪、走多遠或走出什麼道路，端看每次行動的抉擇。但我想在這個過程需要時間琢磨。因此，我現在對自己的期許是要有耐心，漸漸不再擔憂自己欠缺什麼條件，而是想辦法做到當下能做到的事情，剩下交給時間。</p>
]]></content>
      <categories>
        <category>microbial ecology</category>
        <category>microbiota</category>
      </categories>
      <tags>
        <tag>career</tag>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜724. Find Pivot Index</title>
    <url>/leetcode-724-find-pivot-index/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>若數列某項兩側各數字的總和相同，則該項為數列的樞紐 (pivot)。給定一整數數列，判斷其是否含樞紐項。若有，求樞紐之索引值；若無，則回傳 <code>-1</code>。</p>
<span id="more"></span>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers <code>nums</code>, calculate the pivot index of this array.<br>The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right.<br><strong>If the index is on the left edge of the array, then the left sum is <code>0</code></strong> because there are no elements to the left. This also applies to the right edge of the array.<br>Return the leftmost pivot index. If no such index exists, return <code>-1</code>.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,7,3,6,5,6]<br>Output: 3</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,-1,-1,0]<br>Output: 2</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,0,1,1]<br>Output: 0</p>
</blockquote>
<p><em>留意負數項、樞紐位於數列首尾、數列只含一項或兩項的案例</em></p>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code>：留意負數項</li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此處借鑑<a href="https://leetcode.com/problems/find-pivot-index/solutions/127676/find-pivot-index/">官方解法</a>。首先計算數列的級數 (<code>S</code>)，接著依序讀過數列，並計算讀過數字之和 (<code>leftSum</code>，即當前項左側的子數列總和)。</p>
<p>由於已算過 <code>S</code>，所以當前項右側的子數列總和可透過 <code>S - nums[i] - leftSum</code> 得知。</p>
<p>若當前項左右兩側的子數列總和一致，表示當前項為樞紐，其索引值便為題解；若總和不一致，則累計 <code>leftSum</code> 的值。若遍歷數列仍未求得樞紐，即可確認此數列無樞紐，依題目要求回傳 <code>-1</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        S = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> leftSum == S - nums[i] - leftSum:</span><br><span class="line">                <span class="keyword">return</span>(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                leftSum += nums[i]</span><br><span class="line">        <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="曾嘗試但失敗的解法"><a href="#曾嘗試但失敗的解法" class="headerlink" title="曾嘗試但失敗的解法"></a>曾嘗試但失敗的解法</h3><p>我原先的想法是定義兩個指標，在一次迴圈中從數列兩側夾擠，同時計算 <code>leftSum</code> 和 <code>rightSum</code>。當兩指標重合，且左右數列總和一致時，指標的位置即為樞紐的索引值；反之，則表示此數列沒有樞紐。</p>
<p>這種方法的關鍵在於判斷何時要調動兩側的指標，所以在程式碼中間我寫了不少判斷式。然而，當數列正負數穿插的時候，判斷式便會很難寫。</p>
<p>舉下方的程式碼為例，碰到 <code>[-1,-1,-1,0,1,1]</code> 和 <code>[-1,-1,-1,0,1,1,0]</code> 這兩個案例時，右側指標會在循環中不斷往左側移動，直接錯過樞紐的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        leftSum = nums[l]</span><br><span class="line">        rightSum = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span>  <span class="built_in">abs</span>(leftSum) &lt; <span class="built_in">abs</span>(rightSum):</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                leftSum += nums[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                rightSum += nums[r]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftSum == rightSum:</span><br><span class="line">            <span class="keyword">return</span>(l)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="練習題目時，適合使用程式語言定義好的-function-嗎？"><a href="#練習題目時，適合使用程式語言定義好的-function-嗎？" class="headerlink" title="練習題目時，適合使用程式語言定義好的 function 嗎？"></a>練習題目時，適合使用程式語言定義好的 function 嗎？</h3><p>我覺得這算是我其中一種心態糾結，即「為了打好基礎，必須手刻所有功能」。不過追根究柢，做題的目的是透過題目學習該題相關知識。</p>
<p>以這題為例，<code>sum</code>並非解題的關鍵，也不是這題的核心知識，如果使用這個 function 能改善程式碼的可讀性和簡潔性，那麼我覺得使用程式語言定義好的 function 也不錯。</p>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>網際牛仔與無障礙空間（上）：如何以鍵盤瀏覽網頁？</title>
    <url>/navigate-websites-with-keyboard/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為什麼想以鍵盤瀏覽網頁？滑鼠是為簡化繁瑣的鍵入指令而生，也與圖形介面的發展相輔相成。因此，當代網頁本來就適合以滑鼠瀏覽，純靠瀏覽器有限的快捷鍵反倒綁手綁腳。</p>
<p>然而，有時擁有自己的風格比起事情做的有效率還重要。本文就是我對於「用鍵盤瀏覽網頁」這項風格的探索與總結。</p>
<blockquote>
<p>Style over Substance. It doesn’t matter how well you do something, as long as you look good doing it. （格調重於成效，只要你作風有形，事情幹得怎麼樣並不要緊。） </p>
<p style="text-align:right" > The core rulebook for Cyberpunk 2020 </p>
</blockquote>
<span id="more"></span>

<h1 id="「覺得酷」的學習成本有多高？"><a href="#「覺得酷」的學習成本有多高？" class="headerlink" title="「覺得酷」的學習成本有多高？"></a>「覺得酷」的學習成本有多高？</h1><p>就我的使用經驗，是否要用鍵盤瀏覽網頁是風格問題而不是效率問題。因為瀏覽網頁不像編輯文件一樣要頻繁移動游標，點擊和拖曳等行為的頻率也較低，所以沒那麼講究要降低手部位移的幅度。畢竟，有時網頁看一半，漱杯飲料或嗑片餅乾的移動幅度，都比單手改持滑鼠的移動幅度還要大。</p>
<p>儘管如此，我認為除了營造風格以外，善用快捷鍵能減少滑鼠在精密操作時的磨耗感，例如開啟狹窄的右鍵選單、滾動長頁面或點擊尺寸很小的按鈕，這些瑣碎操作不見得會影響瀏覽網頁的效率，但會大幅降低查找資料的心情（對，就是 kimochi 問題）。</p>
<p>更重要的是，體驗鍵盤瀏覽網頁的成本極低，只要學會以下三組快捷鍵，就能流暢地逛平常習慣的網頁了。本文也將以這三組快捷鍵為主軸，簡介如何利用 Windows 系統、Chrome 瀏覽器與 Vimium 套件的快捷鍵，以鍵盤瀏覽網頁。</p>
<ol>
<li>設定開啟瀏覽器的快捷鍵</li>
<li>學會開分頁(<code>Ctrl</code> + <code>T</code>)、關分頁 (<code>Ctrl</code> + <code>W</code>)、切換分頁 (<code>Ctrl</code> + <code>Tab</code>)</li>
<li>安裝 Vimium 或其他 Vim-like 瀏覽器套件</li>
<li>學會用 Vim-like 套件的功能點擊連結 (<code>f</code> + <code>&lt;index&gt;</code>)</li>
</ol>
<p>既然要用鍵盤瀏覽網頁，那首要的目標自然是透過鍵盤開啟瀏覽器。然而，Chrome 與 Windows 雖然有不少快捷鍵，卻似乎沒有能開啟瀏覽器的快捷鍵。幸好，Windows 支援用戶為檔案或程式建立捷徑 (Shortcut) 和設定快捷鍵 (Shortcut key)，所以能在需要時快速開啟檔案或程式，不必再移動到它們（或其捷徑）的所在目錄。</p>
<p>瀏覽器的捷徑可從執行檔自行建立（<strong>chrome.exe - Shortcut</strong>），或是使用安裝時自動建立的捷徑（ <strong>Google Chrome</strong>）。建立瀏覽器的捷徑之後，便能為其設定快捷鍵。</p>
<ol>
<li>右鍵點擊「捷徑」</li>
<li>點選「內容 (Properties)」</li>
<li>點選「快捷鍵」</li>
<li>按下自訂快捷鍵，例如 <code>Ctrl</code> + <code>Alt</code> + <code>C</code></li>
<li>點選「確定」套用設定</li>
</ol>
<h1 id="暢遊-Google-search"><a href="#暢遊-Google-search" class="headerlink" title="暢遊 Google search"></a>暢遊 Google search</h1><p>Chrome 完整的快捷鍵列表可參考<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hant&co=GENIE.Platform=Desktop">google 說明</a>。以下我嘗試從用戶角度，說明有哪些常用快捷鍵值得留意，而這些快捷鍵又有哪些使用的情境。</p>
<h2 id="如何透過搜尋引擎查找關鍵字？"><a href="#如何透過搜尋引擎查找關鍵字？" class="headerlink" title="如何透過搜尋引擎查找關鍵字？"></a>如何透過搜尋引擎查找關鍵字？</h2><p>假設今天想查詢某項資訊，可考慮以下三種方式來輸入關鍵字，再點擊 <code>Enter</code> 執行搜索：</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>開啟新分頁並移至新分頁的網址列</strong></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>移至網址列</td>
<td><code>Alt</code> + <code>D</code> or <code>Ctrl</code> + <code>L</code> or <code>F6</code></td>
</tr>
<tr>
<td>於網址列搜尋 Google</td>
<td><code>Ctrl</code> + <code>E</code> or <code>Ctrl</code> + <code>K</code></td>
</tr>
</tbody></table>
<p>由於以上方法皆透過網址列搜尋關鍵字，一旦網頁跳轉到搜索結果，該列便會轉變為網址。此時若想修正錯字或更改關鍵字，可以使用 <code>/</code> 切換到 Google search box，在該位置編輯關鍵字，就不用重新輸入一遍或編輯藏在長串網址當中的關鍵字。</p>
<p>跳轉到搜索結果後，便能使用以下快捷鍵滑動或跳動網頁，尋找自己需要的資訊。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>連續滑動網頁</td>
<td><code>↑</code> and <code>↓</code></td>
</tr>
<tr>
<td>向下跳數列</td>
<td><code>Space</code> or <code>PageDown</code></td>
</tr>
<tr>
<td>向上跳數列</td>
<td><code>Shift</code> + <code>Space</code> or <code>PageUp</code></td>
</tr>
<tr>
<td>移動至網頁最上端</td>
<td><code>Home</code></td>
</tr>
<tr>
<td>移動至網頁最底端</td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="如何開啟特定連結？"><a href="#如何開啟特定連結？" class="headerlink" title="如何開啟特定連結？"></a>如何開啟特定連結？</h2><p>假如你已找到感興趣的結果，接下來得移動游標到連結位置才能開啟。Chrome 預設以 <code>Tab</code> 和　<code>Shift + Tab</code> 在連結間切換。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移動至下一個連結</td>
<td><code>Tab</code></td>
</tr>
<tr>
<td>移動至上一個連結</td>
<td><code>Shift</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<p>另一種方式是啟用無障礙設定裡的「使用文字游標瀏覽頁面」。在這模式裡，用戶能以 <code>←</code>、<code>↑</code>、<code>↓</code>、<code>→</code> 操作文字游標，讓網頁能像文檔一樣瀏覽。</p>
<ol>
<li><code>Alt</code> + <code>E</code> ，開啟瀏覽器設定選單</li>
<li><code>S</code>，選取「設定」</li>
<li><code>/</code>，進入搜索框</li>
<li>查詢「無障礙設定」</li>
<li>使用 <code>Tab</code> 移動到游標瀏覽功能開關</li>
<li><code>Enter</code>，開啟或關閉功能</li>
</ol>
<p><em>(或是以 <code>F7</code>快速切換文字游標瀏覽模式。記得關掉提醒通知，往後啟用模式才不用一再確認。）</em></p>
<p>當游標移動到連結位置，即可使用以下快捷鍵，決定要於哪個分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟連結</td>
<td><code>Enter</code></td>
</tr>
<tr>
<td><strong>於新分頁開啟連結</strong></td>
<td><code>Ctrl</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新分頁開啟連結並移至新分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新視窗開啟連結並移至新視窗</td>
<td><code>Shift</code> + <code>Enter</code></td>
</tr>
</tbody></table>
<h2 id="如果我還沒找到滿意的結果，要怎麼前往下一頁？"><a href="#如果我還沒找到滿意的結果，要怎麼前往下一頁？" class="headerlink" title="如果我還沒找到滿意的結果，要怎麼前往下一頁？"></a>如果我還沒找到滿意的結果，要怎麼前往下一頁？</h2><p>很遺憾的，目前 Chrome 或 Google Search <strong>沒有直達下一頁的快捷鍵</strong>，只能持續押著 <code>Tab</code> 直到頁面底部。那使用 <code>Shift</code> + <code>Tab</code> 從頁面底部開始找起呢？可行，但不見得比較快，因為頁面底部除了「下一頁」與「上一頁」按鈕外，還有隱私權、服務條款、活動紀錄與地理位置等連結要通過。</p>
<p>開啟連結是使用鍵盤瀏覽網頁的最大障礙，因為用戶必須先滑動視窗找到對應的連結，再移動游標通過一樣內容到該連結的位置。換句話說，用戶至少要跑兩次迴圈才能找到並打開連結。</p>
<p>既然如此，那為什麼不一開始就使用 <code>Tab</code> 來逛網頁呢？其實可以，但非常惱人。</p>
<p>首先，游標移動不若視窗滑動迅速。其次，連結在網頁上的順序未必與游標移動的順序一致，使得用戶無法預期瀏覽的方向。以 Google search 為例，一則搜尋條目在視覺上的結構為頁庫存檔選項、翻譯選項與連結文字。然而，游標移動的順序卻是連結文字、頁庫存檔選項、翻譯選項，導致需要連續按三次 <code>Tab</code> 才能移動到下一個連結。</p>
<blockquote>
<p><a href="https://5uperb0y.com/">https://5uperb0y.com</a> ▼ 翻譯這個網頁<br>5uperb0y’s blog</p>
</blockquote>
<p>第三，不是每個網頁都會醒目標示游標的位置，以至於用戶不僅無法確認游標移動的順序，還可能找不到游標的位置。就拿我這個網站為例，可以試試使用 <code>Tab</code> 來找到任一文章的連結，我相信按了十幾下可能都還沒辦法確認游標位置，所以也很難開啟特定連結。</p>
<p>在本文其他節，我會介紹能迴避這些問題的取巧手段和擴充套件。但在此處，我們先假設所有搜索都能在第一頁找到答案，並繼續了解如何透過快捷鍵管理分頁與視窗。</p>
<h2 id="如何管理瀏覽器分頁？"><a href="#如何管理瀏覽器分頁？" class="headerlink" title="如何管理瀏覽器分頁？"></a>如何管理瀏覽器分頁？</h2><p>如今我們已經會使用快捷鍵搜尋和瀏覽網頁，然而隨著點擊而累積的分頁又該如何管理呢？雖然列出了許多選項，但我常用的僅有粗體標示者。</p>
<h3 id="開啟與關閉分頁"><a href="#開啟與關閉分頁" class="headerlink" title="開啟與關閉分頁"></a>開啟與關閉分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>shortcut</th>
</tr>
</thead>
<tbody><tr>
<td>開啟新分頁並移至新分頁</td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td><strong>關閉當前分頁</strong></td>
<td><code>Ctrl</code> + <code>W</code> or <code>Ctrl</code> + <code>F4</code></td>
</tr>
<tr>
<td>依關閉順序，重新開啟已關閉之分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td>
</tr>
</tbody></table>
<h3 id="切換與移動分頁"><a href="#切換與移動分頁" class="headerlink" title="切換與移動分頁"></a>切換與移動分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至指定分頁</td>
<td><code>Ctrl</code> + <code>[1-8]</code></td>
</tr>
<tr>
<td>移至最後分頁</td>
<td><code>Ctrl</code> + <code>9</code></td>
</tr>
<tr>
<td><strong>移至下一分頁</strong></td>
<td><code>Ctrl</code> + <code>PageDown</code> or <code>Ctrl</code> + <code>Tab</code></td>
</tr>
<tr>
<td>移至上一分頁</td>
<td><code>Ctrl</code> + <code>PageUp</code> or <code>Ctrl</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>後挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageDown</code></td>
</tr>
<tr>
<td>前挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageUp</code></td>
</tr>
<tr>
<td>挪動分頁為獨立視窗</td>
<td><code>Shift</code> + <code>W</code></td>
</tr>
</tbody></table>
<h3 id="搜索或開啟曾瀏覽的網頁"><a href="#搜索或開啟曾瀏覽的網頁" class="headerlink" title="搜索或開啟曾瀏覽的網頁"></a>搜索或開啟曾瀏覽的網頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>上一頁</strong></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>開啟搜尋歷史</td>
<td><code>Ctrl</code> + <code>H</code></td>
</tr>
</tbody></table>
<h2 id="如何管理瀏覽器視窗？"><a href="#如何管理瀏覽器視窗？" class="headerlink" title="如何管理瀏覽器視窗？"></a>如何管理瀏覽器視窗？</h2><p>除了分頁，Chrome 亦支援以快捷鍵開啟視窗或調整視窗大小。不過這些快捷鍵我也不常用到，頂多會用無痕視窗查詢特殊關鍵字或測試 SEO 和網頁有沒有問題。值得留意的是，<code>ALT</code> + <code>Space</code> 是開啟視窗右鍵選單的快捷鍵，所以縮小或放大都有提示，不須記憶。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>開新視窗</td>
<td><code>Ctrl</code> + <code>N</code></td>
<td>寫作時參照文件</td>
</tr>
<tr>
<td>開新無痕視窗</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td>
<td>查詢關鍵字、測試網頁</td>
</tr>
<tr>
<td>將當前視窗縮至最小</td>
<td><code>ALT</code> + <code>Space</code>, then <code>N</code></td>
<td>操作桌面的檔案或軟體</td>
</tr>
<tr>
<td>將當前視窗開至最大</td>
<td><code>ALT</code> + <code>Space</code>, then <code>X</code></td>
<td>很少用</td>
</tr>
</tbody></table>
<p>相較於 Chrome，Windows 提供了更多調整視窗尺寸的途徑。因此有助於在寫程式或編輯文件時，雙開文件並分配視窗在螢幕上的位置，以便邊參閱資料邊修改文件。下圖是視窗間的關係，點擊 <code>Win</code> 與下圖的方向鍵，即可在不同形式的視窗間切換。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           上半視窗（點選 ↓ 會回到原始視窗）</span><br><span class="line">              ↑</span><br><span class="line">左半視窗 ←  最大視窗 → 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">左半視窗 ⇆ 原始視窗 ⇆ 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">           最小視窗          </span><br></pre></td></tr></table></figure>

<p>至於要在視窗間切換或取回縮小的視窗，可以使用 <code>Alt</code> + <code>Tab</code> 進入選單，再配合方向鍵選取。</p>
<h1 id="快捷鍵組合技"><a href="#快捷鍵組合技" class="headerlink" title="快捷鍵組合技"></a>快捷鍵組合技</h1><p>前一節介紹了 Chrome 內建的快捷鍵，但諸如好手氣、右鍵搜索、於無痕視窗開啟等功能都沒有對應的快捷鍵。因此，這一節要介紹如何組合基本的快捷鍵，實踐這些方便功能。</p>
<h2 id="「透過-Google-搜尋」"><a href="#「透過-Google-搜尋」" class="headerlink" title="「透過 Google 搜尋」"></a>「透過 Google 搜尋」</h2><p><strong>方法一：透過「開新分頁」</strong></p>
<ol>
<li>標示 (highlight) 欲搜索的字串</li>
<li><code>Ctrl</code> + <code>C</code>，複製字串</li>
<li><code>Ctrl</code> + <code>T</code>，開啟並移動游標至新分頁的網址列</li>
<li><code>Ctrl</code> + <code>V</code>，貼上字串至網址列</li>
<li><code>Enter</code>，執行搜尋</li>
</ol>
<p>若要在同一分頁搜尋，可以使用 <code>Ctrl</code> + <code>E</code>&#x2F;<code>K</code>&#x2F;<code>L</code> 取代 <code>Ctrl</code> + <code>T</code>。</p>
<p><strong>方法二：透過「右鍵選單」</strong><br>若使用 windows 電腦，可使用選單鍵開啟右鍵選單，執行相關功能。</p>
<ol>
<li>標示欲搜索的字串</li>
<li><code>☰</code>，透過選單鍵(menu key)開啟選單</li>
<li><code>S</code>，執行「透過 Google 搜尋」</li>
</ol>
<h2 id="「好手氣」"><a href="#「好手氣」" class="headerlink" title="「好手氣」"></a>「好手氣」</h2><p>Google search 首頁有個好手氣的按鈕，能直接進入第一個搜尋的網頁。我們可以使用 Google search 的無障礙連結來達到類似目的。</p>
<ol>
<li>輸入搜尋內容</li>
<li><code>Tab</code>，開啟無障礙輔助提示，此時應該會停在「跳至主內容」</li>
<li><code>Enter</code>，確認跳至「主內容」，通常會直接將游標移動到第一個連結</li>
<li><code>Enter</code>，進入第一個連結</li>
</ol>
<p>由於 Google 有時會在第一則搜尋條目前安插精選摘要、廣告或是錯字提醒的窗格，所以這招並非總是見效。儘管如此，仍比遍歷 Google search 的功能窗格更為便捷。</p>
<h2 id="「在無痕視窗中開啟連結」"><a href="#「在無痕視窗中開啟連結」" class="headerlink" title="「在無痕視窗中開啟連結」"></a>「在無痕視窗中開啟連結」</h2><p>Chrome 介紹了各種開啟連結的方式，唯獨不支援在無痕視窗開啟連結的方式，所以此處同樣要利用選單鍵的來開啟右鍵選單。</p>
<ol>
<li>移動游標至連結</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>G</code>，執行「在無痕視窗中開啟連結」</li>
</ol>
<h2 id="「另存為圖片」"><a href="#「另存為圖片」" class="headerlink" title="「另存為圖片」"></a>「另存為圖片」</h2><p><strong>方法一：透過「另存網頁」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code>，開啟圖片於新分頁並切換至新分頁</li>
<li><code>Ctrl</code> + <code>S</code>，另存新檔</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<p><strong>方法二：透過「右鍵選單」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>V</code>，執行「另存為圖片」</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<h2 id="拖曳當前分頁為獨立視窗"><a href="#拖曳當前分頁為獨立視窗" class="headerlink" title="拖曳當前分頁為獨立視窗"></a>拖曳當前分頁為獨立視窗</h2><p>Chrome 沒有相關的快捷鍵，不過我們可以透過「於新視窗開啟分頁」的快捷鍵來模擬。然而與滑鼠拖曳最大的差別在於，重啟後不會保留已填入的資料，也不會刪除舊的分頁。</p>
<ol>
<li><code>Ctrl</code> + <code>L</code> (or <code>Alt</code> + <code>D</code>)，移至網址列</li>
<li><code>Shift</code> + <code>Enter</code>，於新視窗開啟連結</li>
</ol>
<h1 id="以取巧的方式迴避點擊連結的障礙？"><a href="#以取巧的方式迴避點擊連結的障礙？" class="headerlink" title="以取巧的方式迴避點擊連結的障礙？"></a>以取巧的方式迴避點擊連結的障礙？</h1><p>本文前半部曾提到，點擊連結是用鍵盤瀏覽網頁最大的困難。在這一節，我嘗試用瀏覽器搜尋功能（<code>Ctrl</code>+<code>F</code>）可以迅速跳轉位置的特性，解決游標移動效率不彰的問題。</p>
<h2 id="如何直達特定連結？"><a href="#如何直達特定連結？" class="headerlink" title="如何直達特定連結？"></a>如何直達特定連結？</h2><p>直達特定連結有以下五個步驟：</p>
<ol>
<li>辨識：目視想要開啟的連結</li>
<li>編碼：觀察連結文字或網址，從中挑選獨一無二的子字串作為頁內搜尋的關鍵字。</li>
<li>搜尋：<code>Ctrl</code>+<code>F</code>，搜尋關鍵字以找到連結位置</li>
<li>跳轉：若選對關鍵字，游標會直接移動到連結。若否，則使用 <code>Enter</code> 和 <code>Shift</code> + <code>Enter</code>前後查詢連結</li>
<li>開啟：<code>Enter</code>，開啟連結（若想要在新分頁開啟連結，可以先　<code>Esc</code> 退出，再執行開分頁搜索的行為）</li>
</ol>
<p>為連結編碼（或說選用關鍵字）時，可挑選網域的子字串。由於網域通常會採用較獨特的名稱，所以較不容易與其它連結衝突，能避免查詢時無法一步到位。此外，Google search 會將來自相同網站的相似內容以巢狀結構編排，不會讓單一網站的內容佔滿搜尋結果。這項特性讓頁內搜索時不會一次出現很多結果，同樣提升了搜尋的精準度。</p>
<h2 id="如何前往下一頁？"><a href="#如何前往下一頁？" class="headerlink" title="如何前往下一頁？"></a>如何前往下一頁？</h2><p>頁內搜索的訣竅同樣能運用於前往下一頁。Google search 最下方的結果分頁有兩個潛在標的，第一個是「下一頁」本身，這個詞彙相當獨特，所以搜尋時不容易被結果條目干擾。然而它的長度較長（若以注音輸入法要按九個按鈕），所以可能要先複製字串或是用<a href="https://key.chtouch.com/cv.aspx?p=3120">window使用者造詞</a>將這些代表「下一頁」的關鍵字存為快捷鍵，減少輸入時間。（使用者造詞可以降低到只要按四個按鈕）</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋 <code>下一頁</code></li>
<li><code>Ctrl</code> + <code>Enter</code></li>
</ol>
<p>第二個搜索標的則是表示頁數的數字，原則上這些數字會是整個頁面最後一個數字，所以我們可以從頁面底部反向搜索這些數字來直達連結。只是 Chrome 的最後一列可能顯示用戶地址資訊，其中郵遞區號會影響查詢。目前，我還沒找到關閉這些訊息顯示的方法。</p>
<ol>
<li><code>Ctrl</code>+ <code>F</code>，搜尋任意數字</li>
<li><code>Shift</code> + <code>Enter</code>，往回找到最後一個搜尋結果，最差要往回查兩次才能越過郵遞區號到達頁面數字</li>
<li><code>Ctrl</code> + <code>Enter</code>，開啟下一頁</li>
</ol>
<p>由於不是每個網頁都有前往下一頁的對應按鈕，所以 Chrome 沒有下一頁的關鍵字也蠻合理的。不過我猜這項特性也跟搜尋引擎的理念有關。假設在關鍵字正確的情況下，Google Search 總是能推薦最佳的內容。那麼，只要用戶下對關鍵字，就能從第一個連結取得想要的結果。</p>
<p>若第一頁沒出現想要的結果，表示下錯關鍵字或議題太冷門，再怎麼瀏覽都很難找到想要的資訊。因此，基於對搜尋演算法的信任，下一頁的需求其實不高，這項缺陷算是變相鼓勵用戶改善搜索的效率而非瀏覽的效率。</p>
<h2 id="如何複製文字？"><a href="#如何複製文字？" class="headerlink" title="如何複製文字？"></a>如何複製文字？</h2><p>較費時的做法是啟用文字游標瀏覽模式，再移動游標至目標文句，再使用 <code>Shift</code> + 方向鍵選取並複製。搜尋快捷鍵則能節省游標移動的時間，</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋目標文句</li>
<li><code>Esc</code>，脫離頁內搜尋窗格</li>
<li><code>Shift</code> + 方向鍵，選取要複製的文句</li>
<li><code>Ctrl</code> + <code>V</code>，複製</li>
</ol>
<p>如果要複製的文字篇幅較長，這方法甚至會比滑鼠來得有效且可靠，因為使用滑鼠選取時，要同時壓著鼠鍵並滑過狹長的文字區域，這過程有如遊玩電流急急棒一樣。相較之下，使用上下鍵卻可以一次複製一整列，還不用擔心手滑取消掉選取的區域。但如果目標文句較短的話，輸入搜尋關鍵字的時間都足以重新打字一遍了，這方法便顯得沒什麼效率。</p>
<h1 id="使用-Vimium-解放鍵盤的潛能"><a href="#使用-Vimium-解放鍵盤的潛能" class="headerlink" title="使用 Vimium 解放鍵盤的潛能"></a>使用 Vimium 解放鍵盤的潛能</h1><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的擴充套件，借鑒了 Vim 編輯器的操作邏輯與鍵位設置，大幅改善了在 Chrome 的鍵盤瀏覽體驗。</p>
<h2 id="為什麼-Vim-的功能改善鍵盤瀏覽體驗？"><a href="#為什麼-Vim-的功能改善鍵盤瀏覽體驗？" class="headerlink" title="為什麼 Vim 的功能改善鍵盤瀏覽體驗？"></a>為什麼 Vim 的功能改善鍵盤瀏覽體驗？</h2><p>從鍵盤輸入電腦的訊號不外乎指令（例如開分頁、複製、下一頁)和文字（例如中文、英文與符號），由於指令數量遠大於按鈕的數量，若要確保鍵盤尺寸在雙手便於敲擊的範圍，勢必得存在兼具兩種定位的按鈕。而專為鍵盤設計的 Vim 與 Windows 與 Chrome 等仰賴鍵鼠相輔者的差異正體現在讓電腦區分鍵入訊號的方式。</p>
<p>鍵鼠相輔的圖形介面保留了文字鍵的獨立性，讓滑鼠與功能選單取代部分指令（例如游標移動），而且只有在一併輸入 <code>Ctrl</code>、<code>Alt</code>、<code>Home</code> 等特殊控制鍵時，這些文字鍵才會發揮指令的功能。然而，這些特殊控制鍵分布於鍵盤兩側，編輯複雜文件時，雙手往往要在滑鼠、文字鍵區與控制鍵等區域間來回移動。</p>
<p>與之相對，Vim 則透過切換模式來區分鍵入訊號。文字鍵在 Insert 模式用於輸入內容，在 Normal 模式則用於下達指令，所以無論要鍵入指令還是文字，所有操作都圍繞在 f 與 j 那列按鍵 (home row)，降低了操作時雙手位移的幅度。</p>
<p>但是，Vim 的這些特性為什麼可以改善用鍵盤瀏覽網頁的體驗？</p>
<p>Vim 的 Normal 模式有許多便於移動與跳轉指標的指令，這些有用的指令在鍵鼠系統裡多被滑鼠取代，導致鍵盤不足以支持瀏覽網頁的需求。然而，除了輸入關鍵字外，瀏覽網頁時其實少有編輯文字的需求，也就沒有下達指令與輸入文字的衝突。這種情況可以類比為 Vim 的 Normal 模式，如果能透過 vimium 之類的套件，移植 Vim 好用的指令到這些閒置的文字鍵，便能充分發會鍵盤的潛能。</p>
<h2 id="Vimium-解決了鍵盤開啟連結的麻煩"><a href="#Vimium-解決了鍵盤開啟連結的麻煩" class="headerlink" title="Vimium 解決了鍵盤開啟連結的麻煩"></a>Vimium 解決了鍵盤開啟連結的麻煩</h2><p>雖然 Vimium 還有許多功能（這些功能可透過輸入 <code>?</code> 查詢），但我覺得在改善瀏覽網頁方面，快速開啟連結是最方便也最重要的功能。</p>
<p>若使用 Chrome 內建的快捷鍵，必須透過遍歷或是搜尋來找到連結。當網站連結編排不友善時，遍歷的時間會延長非常多。相較之下，Vimium 引進了 Vim Easymotion 功能，用戶只要鍵入 <code>f</code>，Vimium 便會自動為連結標記關鍵字，只要輸入關鍵字就能直接開啟標註的連結。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="按下 `f` 即可自動標註連結，再按下標註的字母即可開啟連結。由於每個連結至多標註兩個字母，所以視窗內的連結都可以在輸入三個鍵以內開啟。"></p>
<p>學會以 Vimium 開啟連結，再配合 Windows 與 Chrome 內建直觀的快捷鍵，其實就足以查資料、逛論壇或是到社群平台串門子了。若對於效率有要求，還可以再讀 Vimium 的說明，學習以 home row 為核心的鍵盤操作。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>網頁瀏覽是少量文字編輯，加上大量查詢、瀏覽、點擊與切換等指令的循環。鍵鼠系統已能流暢地瀏覽網頁，所以是否要單用鍵盤瀏覽網頁是風格問題，我對此議題的總結如下，</p>
<ul>
<li><strong>格調重於成效</strong>：「社會組織是一部大型機器，每個人都是維繫機器運作必要的鏍絲釘。」雖然必要，但無可避免被取代。有時小小的不一樣，可以讓自己多少脫離被束縛與異化的感受。</li>
<li><strong>搜索取代遍歷</strong>：鍵盤操作較不直覺，但很精準，行為可以直接反映想法，不用經過滑鼠拖曳或是<code>Tab</code>切換的過程。</li>
<li><strong>自訂創造風格</strong>：按鍵數量有限，但可透過模式切換、特殊控制鍵、輸入順序、指令組合等方式來擴充可容納的指令。儘管擁有選項，卻不存在預設值，若想使用鍵盤就得思考和選擇，決定什麼才適合現今的自己。</li>
</ul>
<p>在實務上，只要學習 Vimium 的快搜鍵 <code>f</code> 加上瀏覽器內建按鍵（例如方向鍵），就可以應對網頁瀏覽的多數需求了。</p>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tips and tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜程式碼區塊的跳脫符號 (escape characters)</title>
    <url>/nextflow-escape-characters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹程式碼定義變項的符號與 nextflow 內建語法衝突時，有哪些選項可以解決之。</p>
<span id="more"></span>
<h2 id="Nextflow-管理程式的單位"><a href="#Nextflow-管理程式的單位" class="headerlink" title="Nextflow 管理程式的單位"></a>Nextflow 管理程式的單位</h2><p>Process 是 Nextflow 管理程式的單位，其中必然包含 script 區塊來定義想執行的程式。除了 script 區塊，還有 directives（環境設置）、inputs（輸入資料）、outputs（輸出資料）等非必要但有助流程控管的區塊。</p>
<p>在執行程式前，Nextflow 會解讀 script 區塊帶有 <code>$</code> 前綴的變項，代入 inputs、parameters 或 config files 的對應內容。<br>以 process fastQC 為例，nextflow 將 <code>fq</code> (input) 的內容代入 <code>$&#123;fq&#125;</code> (script) 後才執行程式，再將輸出結果透過 <code>fqc</code>(output) 傳遞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process fastQC &#123;</span><br><span class="line">    publishDir &quot;$&#123;params.outdir&#125;/qc&quot;, mode: &#x27;copy&#x27;, overwrite: true</span><br><span class="line">    input:</span><br><span class="line">        path fq</span><br><span class="line">    output:</span><br><span class="line">        path &quot;*_fastqc.&#123;zip,html&#125;&quot; into fqc</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fastqc --nogroup -q $&#123;fq&#125;</span><br><span class="line">    &quot;&quot;&quot;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程式碼與nextflow-語法衝突"><a href="#程式碼與nextflow-語法衝突" class="headerlink" title="程式碼與nextflow 語法衝突"></a>程式碼與nextflow 語法衝突</h2><p>值得留意的是，perl 或 bash 等語言也使用 <code>$</code> 標記變項（例如：<code>$i</code>、<code>$path</code>）。Nextflow 無法區分以 <code>$</code> 為前綴的變項是定義在 script 內（script 變項），還是得自於 inputs, parameters 或 config files（nextflow 變項）。</p>
<p>因此，如果程式碼出現以 <code>$</code> 定義或呼叫的 script 變項 ，nextflow 便有可能因為無法在 inputs、parameters 或 config files 找到對應內容而報錯。</p>
<p>舉以下案例來說，<code>title</code>&#x2F;<code>$title</code> 是使用 bash 定義的 script 變項。然而，nextflow 卻誤判該變項的來源，以至於找不到其內容（<code>No such variable</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># printPath.nf</span><br><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title=&quot;The current directory is,&quot;</span><br><span class="line">    echo &quot;$title \n $PWD&quot;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    printDir().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run printPath.nf</span><br><span class="line">Error executing process &gt; &#x27;printDir&#x27;</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">    No such variable: title -- Check script &#x27;printDir.nf&#x27; at line: 4</span><br></pre></td></tr></table></figure>

<p>對於這個問題，主要的解法是透過更換標記符號來區分 script 變項和 nextflow 變項。</p>
<h2 id="更換-nextflow-變項的標記符號"><a href="#更換-nextflow-變項的標記符號" class="headerlink" title="更換 nextflow 變項的標記符號"></a>更換 nextflow 變項的標記符號</h2><p>第一種方法是改以三個單引號夾註程式碼，提示 nextflow 改以 <code>！&#123;&#125;</code> 標記 nextflow 變項。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更換-跳脫-script-變項的標記符號"><a href="#更換-跳脫-script-變項的標記符號" class="headerlink" title="更換 (跳脫) script 變項的標記符號"></a>更換 (跳脫) script 變項的標記符號</h2><p>若 script 變項不多，也可以在 <code>＄</code> 前面加上反斜線(<code>\$</code>)，提示 nextflow 忽略 <code>$</code> 符號。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;\$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更動跳脫字元"><a href="#更動跳脫字元" class="headerlink" title="更動跳脫字元"></a>更動跳脫字元</h2><p>由於 nextflow 的底層是 groovy，所以除了 script 與 nextflow 的語法衝突，也可能碰到 script 與 groovy 語法衝突的狀況。</p>
<p>以下兩個案例都在 script 區塊使用反斜線來編輯文字。由於反斜線是 groovy 預設的跳脫符號，所以執行這些 processes 時也可能發生編譯錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sepReplace.nf</span><br><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    sepReplace().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run sepReplace.nf</span><br><span class="line">(skip)</span><br><span class="line">Command error:</span><br><span class="line">    .command.sh line3: unexpected EOF while looking for matching `&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>或是<a href="https://github.com/nextflow-io/nextflow/issues/67">這個案例</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># strRemove.nf</span><br><span class="line">process strRemove &#123;</span><br><span class="line">    outpur:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    echo &quot;Hello lg:en&quot; | sed &quot;s/.*lg:\(.*\).*/\1/&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    strRemove().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run strRemove.nf</span><br><span class="line">Script compilation error</span><br><span class="line">- file : /path/to/workdir/strRemove.nf</span><br><span class="line">- cause: Unexpected character: &#x27;\&#x27;&#x27; @ line 4, column 7.</span><br><span class="line">       &#x27;&#x27;&#x27;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure>

<p>碰到這種情形，首先要使用 <code>$/</code> 和 <code>/$</code> 夾註程式碼，提示 groovy 改以 <code>$</code> 作為跳脫符號，以區分 script 和 groovy 語法。</p>
<p>接著，在 script 變項的 <code>$</code> 前面再加一個 <code>$</code> (<code>$$</code>)，提示 nextflow 忽略 <code>$</code> 符號，以區分 script 和 nextflow 語法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    $/</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    /$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封裝為腳本"><a href="#封裝為腳本" class="headerlink" title="封裝為腳本"></a>封裝為腳本</h2><p>不過，如果程式碼用到大量變項，前述方法會讓程式碼顯得囉嗦又不易讀。此時，可以考慮將程式碼封裝為腳本，再從 script 區塊呼叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># sepReplace.sh</span><br><span class="line">str=&quot;A,B,C&quot;</span><br><span class="line">echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    $baseDir/sepReplace.sh</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為 nextflow、bash、perl 都以 <code>$</code> 標記變項，所以執行 process 時可能會無法正確辨識 script 區塊內的變項來源而報錯。可能的解決途徑如下，</p>
<ul>
<li><strong>nextflow 變項少</strong>：以三個單引號夾註程式碼，再以 <code>！&#123;&#125;</code> 標記 nextflow 變項</li>
<li><strong>script 變項少</strong>：以 <code>\</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>出現反斜線</strong>：以 <code>$/</code> 和 <code>/$</code> 夾註程式碼，再以 <code>$</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>程式碼龐雜</strong>：將程式碼封裝為腳本，再從 process 呼叫腳本</li>
</ul>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜輸入 empty channel 會發生什麼事？</title>
    <url>/nextflow-input-with-an-empty-channel/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上週碰到一個離奇的 bug，有支 nextflow 腳本可以順利執行，但會無聲無息地略過其中一個 process。該腳本執行後於終端吐出的訊息類似以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf</span><br><span class="line">[3c/9ab742] process &gt; a1 [100%] 1 of 1 ✔</span><br><span class="line">[8e/4eg429] process &gt; a2 [100%] 1 of 1 ✔</span><br><span class="line">[-        ] process &gt; b1</span><br><span class="line">[2f/0c0b71] process &gt; c1 [100%] 1 of 1 ✔</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><code>a1</code> 與 <code>a2</code> 輸出的 channel 經 <code>join</code> 之後輸入 <code>b1</code>，而 <code>c1</code> 則獨立於其他三個 process。</li>
<li>nextflow 沒有任何錯誤訊息（即終端看不到紅色的字）</li>
<li>nextflow 沒有為 <code>b1</code> 開啟工作目錄，所以也無從查看 <code>.command.log/err/out</code> 等與腳本執行相關的資訊</li>
<li>查看 <code>.nextflow.log</code> 只能找到啟動 <code>b1</code> 的訊息：<code>[main] DEBUG nextflow.processor.TaskProcessor - Starting process &gt; b1</code>，但沒有其他執行細節。</li>
</ul>
<h1 id="解決策略"><a href="#解決策略" class="headerlink" title="解決策略"></a>解決策略</h1><p>由於 nextflow 幾乎沒有給出任何提示，所以只能自己想辦法在腳本內安排中斷點印出 channel 的內容。當時的策略是先不用 <code>join</code>，而是單獨輸入 <code>a1</code> 與 <code>a2</code> 的輸出，以便用 <code>stdout</code> 和 <code>view()</code>檢查各個 channel 是否與我們預期相同。</p>
<p>結果問題還真的出在 channel 的合併，原來 <code>a1</code> 與 <code>a2</code> 的輸出結果沒有共同的 key，所以執行 <code>join</code> 操作後會生成一個 empty channel。</p>
<h1 id="Empty-channel"><a href="#Empty-channel" class="headerlink" title="Empty channel"></a>Empty channel</h1><p>在 Nextflow 裏頭，可使用 <code>channel.empty()</code>建立 empty channel，其作用相當於對 process 傳遞終止訊號（參考 <a href="https://javadoc.io/static/io.nextflow/nextflow/0.28.2/nextflow/Channel.html">Nextflow Channel Class 的說明</a>）。</p>
<p>舉例來說，以下這支 nextflow 腳本會依序印出同一時間輸入的數對。雖然 <code>a_ch</code> 含有四項數字，但因為 <code>b_ch</code> 其中一項為 empty channel 的終止訊號，所以這個 process 只遞交並執行了三次<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="執行腳本時，nextflow 會先以 `nextflow.processor.TaskProcessor` 啟動 process，透過 `nextflow.executor.LocalHandler` 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 `.nextflow.log`。">1</span></a></sup>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demoEmptyChannel.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($&#123;a&#125;, $&#123;b&#125;)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>, <span class="string">&quot;a4&quot;</span>)</span><br><span class="line">    b_ch = channel.of(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>).concat(channel.empty()).concat(channel.of(<span class="string">&quot;b4&quot;</span>)) <span class="comment">// append items with concat() and channel.of()</span></span><br><span class="line">    p(a_ch, b_ch).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoEmptyChannel.nf</span><br><span class="line">[a8/4b2c55] process &gt; p (3) [100%] 3 of 3 ✔</span><br><span class="line">(a3, b4)</span><br><span class="line">(a2, b2)</span><br><span class="line">(a1, b1)</span><br></pre></td></tr></table></figure>

<h1 id="使用-ifEmpty-為輸入-channel-設定預設值"><a href="#使用-ifEmpty-為輸入-channel-設定預設值" class="headerlink" title="使用 ifEmpty 為輸入 channel 設定預設值"></a>使用 <code>ifEmpty</code> 為輸入 channel 設定預設值</h1><p>為了避免 process 被跳過或是沒有執行的狀況，<a href="https://www.nextflow.io/docs/latest/operator.html#operator-ifempty">nextflow 官方文件</a>建議以 <code>ifEmpty</code> 為 channel 設定預設值。如以下案例，由於 <code>b_ch</code> 為 empty channel，經 <code>ifEmpty</code> operator 賦予預設值，使得 process 能順利運行。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demoIfEmpty.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($a, $b)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>&#125;</span><br><span class="line">workflow &#123;   </span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>)</span><br><span class="line">    <span class="comment">// &lt;defalut value&gt; if ch.isempty() else ch</span></span><br><span class="line">    b_ch = channel.empty()</span><br><span class="line">    p(a_ch, b_ch.ifEmpty(<span class="string">&quot;b_default&quot;</span>)).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoIfEmpty.nf</span><br><span class="line">[47/459729] process &gt; p (1) [100%] 1 of 1 ✔</span><br><span class="line">(a1, b_default)</span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 的 process 會跳過含有 empty channel 的任務，若想避免這種狀況在非預期的情形發生（例如 <code>join</code> 失敗），可使用 <code>ifEmpty</code> 為 process 的輸入 channel 設定預設值。</p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href="https://stackoverflow.com/questions/70888844/nextflow-how-to-fail-if-channel-is-empty-ifempty">NextFlow: How to fail if channel is empty ( .ifEmpty() )</a></li>
<li><a href="https://stackoverflow.com/questions/64042860/check-if-nextflow-channel-is-empty">check if nextflow channel is empty</a>)</li>
<li><a href="https://github.com/nextflow-io/nf-hack18/blob/master/asciidocs/07_processes.adoc">Nextflow Workshop Hackaton 2018: 07_processes</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">執行腳本時，nextflow 會先以 <code>nextflow.processor.TaskProcessor</code> 啟動 process，透過 <code>nextflow.executor.LocalHandler</code> 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 <code>.nextflow.log</code>。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜怎麼從運行中的腳本取回參數？</title>
    <url>/nextflow-retrieve-configuration-when-workflow-runs/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在執行腳本前，Nextflow 會讀取設置檔 (configuration files) 中的參數，將之代入腳本的對應位置後再執行程式。這項特性有助於使用者管理複雜流程的輸入值與環境設定，也將具體數值從流程邏輯抽離，讓開發者專注於流程的梳理與串接。</p>
<p>然而，隨著流程腳本改版，設置檔的內容也可能跟著改變，是否有方法能記錄執行流程時使用的設置檔，以利往後重現分析或追蹤歷次設定？</p>
<p>在這篇文中，我首先介紹了 nextflow 導入參數的方式，再陳述取回參數的可行策略，並附上這些策略的最簡範例供參考。</p>
<span id="more"></span>

<h2 id="Nextflow-導入參數的方式"><a href="#Nextflow-導入參數的方式" class="headerlink" title="Nextflow 導入參數的方式"></a>Nextflow 導入參數的方式</h2><p>以下是 nextflow 導入參數的常見方式，若一參數被多種方式定義，則會以順位較小者為準。</p>
<table>
<thead>
<tr>
<th>順位</th>
<th>方式</th>
<th>範例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>於命令列輸入</td>
<td><code>nextflow run workflow.nf --something value</code></td>
</tr>
<tr>
<td>2</td>
<td>以 <code>-params-file</code> 導入</td>
<td><code>nextflow run workflow.nf -params-file params.json</code></td>
</tr>
<tr>
<td>3</td>
<td>以 <code>-c</code> 導入</td>
<td><code>nextflow run workflow.nf -c params.config</code></td>
</tr>
<tr>
<td>4</td>
<td>於 nextflow 腳本內宣告</td>
<td><code>params.something = value</code></td>
</tr>
</tbody></table>
<h2 id="使用-params-取回參數"><a href="#使用-params-取回參數" class="headerlink" title="使用 params 取回參數"></a>使用 <code>params</code> 取回參數</h2><p>其中一個方法是讀取 <code>params</code> 的內容，<code>params</code>是 nextflow 的<a href="https://www.nextflow.io/docs/latest/script.html?highlight=implicit#implicit-variables">隱變項</a>，採用 <code>[key1:value1, key2:value2,...]</code>格式存儲以不同方式導入的參數。</p>
<h3 id="params-json"><a href="#params-json" class="headerlink" title="params.json"></a>params.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;paramsDerivedConfig&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;provided using the -params-file option&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="params-config"><a href="#params-config" class="headerlink" title="params.config"></a>params.config</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">params &#123;</span><br><span class="line">    configDerivedConfig = <span class="string">&quot;specified using the -c option&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getConfig-nf"><a href="#getConfig-nf" class="headerlink" title="getConfig.nf"></a>getConfig.nf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">params.inScriptConfig = <span class="string">&quot;defined within the script itself&quot;</span></span><br><span class="line">process retrieveConfigFromParams &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$params&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf --commandSpecifiedConfig <span class="string">&quot;specified on the command line&quot;</span> -params-file params.json -c params.config</span><br><span class="line">[configDerivedConfig:specified using the -c option, config-derived-config:specified using the -c option, paramsDerivedConfig:provided using the -params-file option, params-derived-config:provided using the -params-file option, commandSpecifiedConfig:specified on the <span class="built_in">command</span> line, command-specified-config:specified on the <span class="built_in">command</span> line, inScriptConfig:defined within the script itself, in-script-config:defined within the script itself]</span><br></pre></td></tr></table></figure>

<h2 id="從輸入路徑取回參數"><a href="#從輸入路徑取回參數" class="headerlink" title="從輸入路徑取回參數"></a>從輸入路徑取回參數</h2><p>然而，前述方法只能取回以 <code>params</code> 存儲的參數，若想取得 <code>process</code>, <code>docker</code>, <code>report</code> 等<a href="https://www.nextflow.io/docs/latest/config.html?highlight=params#config-scopes">其它設置 (configuration scope)</a>，可以讀取位於 <code>$launchDir</code> 的 <code>.nextflow.log</code>，從中獲得當初執行腳本時輸入的 <code>*.config</code> 路徑，再將設置擋複製出來。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">process getConfig &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    shell:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    str=$(grep &quot;User config file:&quot; &quot;!&#123;launchDir&#125;/.nextflow.log&quot;)</span></span><br><span class="line"><span class="string">    config=$&#123;str##*:&#125;</span></span><br><span class="line"><span class="string">    echo $&#123;config&#125;</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf -c params.config</span><br><span class="line">/home/user/workflow/params.config</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>若能從運行中的 nextflow 腳本取回輸入參數，將有助於往後重現分析或追蹤設置。目前，nextflow 有兩個隱變項能協助我們達成這項任務，</p>
<ul>
<li><code>params</code>：記錄了不同管道導入的參數，可以在 <code>*.nf</code> 檔各處呼叫以取得書入的參數和設定。</li>
<li><code>launchDir</code>：雖然本身與參數無關，但此變項記錄了腳本執行位置，其中的 <code>.nextflow.log</code> 記錄了 <code>*.config</code> 路徑。讀取該檔即可獲取輸入的參數和設定。</li>
</ul>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜背景執行 workflow 的方法</title>
    <url>/nextflow-run-in-background/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般而言，若想要背景執行 linux 指令，可在指令末端添加 <code>&amp;</code>，或是透過 <code>ctrl + z</code> 配合 <code>bg %n</code> 將執行中的指令挪到背景執行。然而，nextflow 腳本卻不適用這種做法（version &gt;&#x3D; 21.10.6），指令挪到背景後會陷入停止狀態。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf &amp;</span><br><span class="line">[1] 533</span><br><span class="line">Launching `workflow.nf` [sick_waddington] - revision: 123b1ec198</span><br><span class="line">[2]+  Stopped                 nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<p>一旦陷入停止狀態，會變得異常難清，要用 <code>kill %n &amp;&amp; fg</code> 才能一次清掉（參考<a href="https://gitter.im/nextflow-io/nextflow/archives/2020/09/16">論壇的討論</a>）。</p>
<span id="more"></span>
<h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>即使透過 <code>.sh</code> 來執行 nextflow 腳本也會遭遇相同的狀況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># run_workflow.sh</span><br><span class="line">nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./run_workflow.sh &amp;</span><br><span class="line">N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [trusting_hamilton] - revision: 936bafe285</span><br><span class="line">[1]-  Stopped                 <span class="built_in">nohup</span> nextflow run paramInput.nf</span><br><span class="line">[2]+  Stopped                 ./run_workflow.sh</span><br></pre></td></tr></table></figure>

<h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>此時，若要背景執行 nextflow 腳本，可在指令或是腳本內添加 nextflow 內建的 <code>-bg</code> 選項。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -<span class="built_in">bg</span></span><br><span class="line"> N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [furious_kowalevski] - revision: 936bafe285</span><br><span class="line">[8b/21d003] Submitted process &gt; sayHi</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure>

<p>這選項觸發的行為類似 <code>nohup</code>，能確保用戶退出 terminal 後仍能持續執行 nextflow 腳本（可參考官方<a href="https://www.nextflow.io/docs/latest/cli.html#execution-as-a-background-job">文件</a>及<a href="https://www.nextflow.io/blog/2021/5-more-tips-for-nextflow-user-on-hpc.html">部落格</a>）。</p>
<p>除此之外，添加 <code>-bg</code> 也會輸出 <code>.nextflow.pid</code> 檔，紀錄此指令的 pid，以便用戶追蹤 nextflow 腳本的執行狀況。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>若隨時將指令切到前台，並且用 <code>jobs</code> 查看執行狀態，也可以在指令末端補 <code>&amp;</code>。只是這樣退出 terminal 後，nextflow 腳本也跟著結束了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf -<span class="built_in">bg</span> &gt; log.txt &amp;</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>至於為什麼 nextflow 有這特性，我仍沒有頭緒。我試著比較添加 <code>-bg</code> 前後，<code>.nextflow.log</code> 和 <code>.command.run</code> 等檔案的內容，卻沒有發現相關差異。</p>
<p>另外，雖然官方說明 <code>-bg</code> 的行為類似 <code>nohup</code>，但卻無法用 <code>nohup</code> 達到同樣效果。可能還需要對 nextflow 和 linux 有更深的理解才能解釋吧。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜資料是怎麼在 Process 間傳遞？</title>
    <url>/nextflow-how-data-is-passed-between-processes-through-channels/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Process 是 nextflow 管理分析流程的基本單位，可包含能在 linux shell 執行的程式碼（例如 linux command, python code）、腳本（例如自訂的 hello-world.sh）與軟體（例如 GATK 或 FastQC）。 Process 之間彼此獨立，各有各的工作目錄，也可以分別設定其執行環境（例如 docker container 或 conda environment）。</p>
<p>Channel 則媒介了 process 間的資料交流，若不透過 channels 串接，process 間的檔案或變項無法共享。舉凡字串、數值、檔案路徑乃至標準輸出等，皆有對應的 qualifier 讓 nextflow 知道怎麼處理得自於 channel 的各式資料。</p>
<span id="more"></span>
<p>在以下案例，我在 process A 定義了兩條字串，並透過不同途徑傳遞給 process B。</p>
<p>首先，string 1 被寫入檔案 (<code>str.txt</code>)，再以 path qualifier 告訴 Nextflow，把檔案路徑用軟連結 (symbolic link) 掛到 process B 的工作目錄。至於 string 2 則被定義為變項 (strAsEnv, a bash variable)，再以 env qualifier 告訴 nextflow 把變項寫到 process A 工作目錄內的 <code>.command.env</code>。</p>
<p>接著，分別以 strInFile 及 strAsEnv 命名由 process A 輸出 channel，傳遞給 process B 印出。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供 process B 所需的字串</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;str.txt&quot;</span>, <span class="attr">emit:</span> strInFile</span><br><span class="line">        env strAsEnv, <span class="attr">emit:</span> strAsEnv</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;string 1&quot; &gt; &quot;str.txt&quot;</span></span><br><span class="line"><span class="string">        strAsEnv=&quot;string 2&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 印出 process A 提供的字串</span></span><br><span class="line">process B &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path strInFile</span><br><span class="line">        val strAsEnv </span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;\$(cat $&#123;strInFile&#125;) is retrieved from a file passed by a queue channel&quot;</span></span><br><span class="line"><span class="string">        echo &quot;$&#123;strAsEnv&#125; is retrieved from a environment variable passed by a value channel&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 執行 process A &amp; B</span></span><br><span class="line">workflow &#123;</span><br><span class="line">    A()</span><br><span class="line">    B(A.out.strInFile, A.out.strAsEnv).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoChannel.nf </span><br><span class="line">Launching `demoChannel.nf` [compassionate_shannon] - revision: 319cfe997a</span><br><span class="line">executor &gt;  <span class="built_in">local</span> (2)</span><br><span class="line">[f3/e5a365] process &gt; A [100%] 1 of 1 ✔</span><br><span class="line">[b0/f79f8e] process &gt; B [100%] 1 of 1 ✔</span><br><span class="line">string 1 is retrieved from a file passed by a queue channel</span><br><span class="line">string 2 is retrieved from a environment variable passed by a value channel</span><br></pre></td></tr></table></figure>
<p>各 process 的工作目錄預設建立在執行路徑下的<code>work</code>，直接觀察工作目錄內的暫存檔有助於了解 path 與 env 兩種資料傳遞方式的差異<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案">1</span></a></sup>。</p>
<p>在 process A 的工作目錄 ([f3&#x2F;e5a365]) 裡，除了輸出的 str.txt，還有 <code>.command.env</code>。Nextflow 在執行時會將所有用 env qualifier 標記的變項定義式（即　<code>var=value</code> 這種格式）寫入 <code>.command.env</code>，以利隨後可輸出到其它 process。（可查看 <code>.command.sh</code> 查看寫入變項定義式的程式碼）</p>
<p>目前，只有 bash 變項才能透過 env qualifier 輸出，其它語言的變項只能透過某些方式存成檔案輸出（例如 R 的 RDS 檔）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /work/f3/e5a365e3bb7b645cf4e13cf15eb235</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">-rw-r--r-- 1 user group   18 Jan  5 22:26 .command.env      <span class="comment"># environment variables of process A</span></span><br><span class="line">-rw-r--r-- 1 user group  146 Jan  5 22:26 .command.sh       <span class="comment"># commands to execute process A</span></span><br><span class="line">-rw-r--r-- 1 user group    9 Jan  5 22:26 str.txt           <span class="comment"># output of process A</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.env</span><br><span class="line">strAsEnv=string 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.sh　 <span class="comment"># nextflow 執行 process 的腳本，只擷取跟 `.command.env` 相關的部分</span></span><br><span class="line"><span class="comment"># capture process environment</span></span><br><span class="line"><span class="built_in">set</span> +u</span><br><span class="line"><span class="built_in">echo</span> strAsEnv=<span class="variable">$&#123;strAsEnv[@]&#125;</span> &gt; .command.env</span><br></pre></td></tr></table></figure>

<p>而在 process B 的工作目錄可留意到 str.txt 的資料型別為 <code>l</code> (link)，檔案名稱也標示了來源。值得留意的是，如果使用 <code>cat</code> 或 <code>cp</code> 等指令通常不會有什麼問題，但如果用 <code>ls</code> 顯示檔案大小時，要注意預設顯示的是軟連結的大小，而非原檔的大小。相似的狀況也可能發生在使用 <code>find</code> 搜尋時，因為限制了搜索標的為檔案而意外地排除軟連結的情形。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/work/b0/f79f8e550a4e1af11e2b03af8b4aa4$ <span class="built_in">ls</span> -al</span><br><span class="line">lrw-r--r-- 1 user group   62 Jan  5 22:26 str.txt -&gt; /work/f3/e5a365e3bb7b645cf4e13cf15eb235/str.txt</span><br></pre></td></tr></table></figure>

<p>綜上所述，要怎麼利用 channel 傳遞資料端視資料型別而異。無論想傳遞表格、文檔還是變項，都可以將其寫入檔案，再以 path qualifier 讓 nextflow 依據檔案路徑在下游 process 的工作目錄建立軟連結。若想傳遞的是 bash 變項，那還可以使用 env qualifier 將變項定義式記錄在當前 process 的工作目錄供後續取用。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>卡西尼號與行星保護</title>
    <url>/planetary-protection-rules-and-the-end-of-cassini-probe/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>歷經20年的太空旅行，美國航太總署（NASA）的卡西尼號（Cassini）太空船今天將最後的訊號傳回地球後，高速衝撞土星，以分解蒸發的壯烈方式，結束13年的土星任務。</p>
</blockquote>
<p>卡西尼號是艘軌道探測船，任務結束後沒有能量脫離行星軌道，所以不能像飛掠探測器一樣（航海家 II）飛向深空。它會留在土星系統中，最終因為故障或其他緣故減速而失控墜入土星或其他衛星。</p>
<p>然而土星的衛星中有幾個可能有生命存在（尤其是土衛六泰坦），所以主動讓卡西尼號墜入較無生命可能的土星中，以免滅菌不徹底的機體造成汙染。不過，這種壯烈的自殺已經不是第一次了，2003 年伽利略探測船也為保護木衛二歐羅巴而撞入木星濃厚的大氣層中。</p>
<p>雖然這邊只提到墜毀階段，其實所有的太空任務都有防止生物汙染其他天體的措施，不過依照天體性質和任務類別可以分為五類。此處，我把重點聚焦在分類的依據和理由，而不是防範措施（詳細作法可以在厚厚的行星保護指導手冊中找到。）</p>
<h2 id="第一類任務"><a href="#第一類任務" class="headerlink" title="第一類任務"></a>第一類任務</h2><p>第一類任務是飛掠、繞行或登陸月球、水星和多數小行星，這些天體沒有足夠的液態水維持生命，所以除了例行消毒外，探測船並不需特別處理。</p>
<h2 id="第二類任務"><a href="#第二類任務" class="headerlink" title="第二類任務"></a>第二類任務</h2><p>第二類任務則涉及那些可能沒有生物，但是對於生命起源研究有重要參考價值的天體。例如：土衛六、金星、類木行星和彗星。</p>
<p>2014年羅賽塔號登陸彗星就是第二類任務。那次任務檢測到了胺基酸、醇類等有機物，它們很可能透過彗星撞擊為早期地球帶來形成生命的必要分子。（這些有機物質可能是彗星經過星際塵埃時沾上，或是經過恆星附近起反應形成的。順道一提，首次在星際中發現胺基酸的是師大的管一政教授喔！）</p>
<p>雖然金星現在因為失控的溫室效應已經成為高溫煉獄，但是在太陽還沒今天熾熱、溫室效應也沒失控前可能存在一段宜居的時候。另外金星大氣層中有個溫度合宜，且有硫化物補給的區間，若當初有生命誕生，也許能在此續命。相關任務有 2015 年 ESA 的金星快車（繞行任務）和先前蘇聯因大氣壓扁而早夭的登陸任務。</p>
<p>土衛六和土星因為可能有液態水、有機物存在所以同屬二類，但是土衛六多了可棲息的表面以及大氣層中的有機反應，所以研究價值還好過土星。本次墜毀的卡西尼號曾在 2005 年釋放惠更斯探測器登陸土衛六，可惜登陸不久便失聯了，所幸有留下空降時和登陸當下的照片，大家可以找看看，我覺得看起像是乾涸的水庫……</p>
<h2 id="第三類任務和第四類任務"><a href="#第三類任務和第四類任務" class="headerlink" title="第三類任務和第四類任務"></a>第三類任務和第四類任務</h2><p>第三類是火星和歐羅巴（木衛二）的「繞行」、「飛掠」任務，這兩天體是太陽系內最有可能找到地外生命證據（無論死活）的地方，執行第三類任務的太空船都要經過嚴密滅菌才行。</p>
<p>火星過去可能有水流、磁場和大氣層，這些都是利於生命誕生維持的要素；即便是今日，生物也可能在岩石與冰層間的夾縫中生存。另一個誘人的證據是1984年找到的火星隕石 ALH84001，上頭有疑似細菌化石、生物代謝排遺。</p>
<p>歐羅巴冰層下可能有液態水層，這些水層不僅和岩層接觸促進物質互動（而土衛六可能是隔絕水層），也能隔絕致命輻射保護生命體。</p>
<p>由於這兩顆天體可居，即便沒有原生種，也擔心地球生物在上頭大肆繁殖影響後續監控，所以火星與歐羅巴的「登陸」升級為第四類任務。</p>
<p>雖然我們猜測火星很可能有生物，可是1976年的海盜I&#x2F;II登陸任務卻沒有發現關鍵證據。因為第四類任務的預備很麻煩，所以為了往後探測任務方便，又把它分為三個子類，滅菌等級漸增：非適居區登陸（防止地球細菌汙染火星）、生命探測任務（防止地球細菌干擾實驗）、適居區登陸（防止雙向汙染）。</p>
<h2 id="第五類任務"><a href="#第五類任務" class="headerlink" title="第五類任務"></a>第五類任務</h2><p>至於第五類則是所有回收太空船到地月系統的任務，涵蓋月球是因為它是將來重點開發區域，若受到地外生物汙染，登陸月球會升級到二三類任務，太空船多了一堆滅菌要求會讓開發變得十分不方便。前陣子 NASA 招募的行星保護官就是要專職這種任務的調查工作。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後提一提行星保護的規範。最早是寫在聯合國於 1967 年制定的《關於各國探索和利用包括月球和其他天體在內外層空間活動的原則條約》當中的第九條：<br>各締約國從事研究、探索外層空間（包括月球和其他天體）時，應避免使其遭受有害的污染，以及地球以外的物質，使地球環境發生不利的變化。<br>詳細指導方針則由國際科學理事會下轄的太空研究委員會負責負責。</p>
<p>由於當時台灣還沒退出聯合國所以也簽了這條約，想看詳細內容可以去網路上查中文的手寫文本。雖然台灣至今仍沒有進行任何登陸任務，不過得知我們也曾籌畫整個宇宙開發的小小部分，仍有莫名的參與感。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 鴿子為什麼那麼大？</title>
    <url>/schrodinger-1944-what-is-life-chapter-1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>七十九年前，薛丁格在都柏林三一學院的系列演講為鴿子尺寸提供了光學以外的解釋。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》">1</span></a></sup></p>
<span id="more"></span>

<h2 id="「鴿子為什麼那麼大？」"><a href="#「鴿子為什麼那麼大？」" class="headerlink" title="「鴿子為什麼那麼大？」"></a>「鴿子為什麼那麼大？」</h2><p>這問題乍聽之下或許令人詫異，但其實許多洞見都是從這樣怪誕或荒唐的問題萌發。</p>
<p>日常生活中，大或小的概念是建立在比較的基礎上。在這問題中，真正的目的或許不在了解鴿子的尺寸，而是想知道事物間為何存在懸殊的尺寸差異。事物尺度與其性質的關係是物理學重要的研究方向，而肉眼可見的巨觀層次和原子尺度的微觀層次則是其中的兩個極端。統計物理解釋了這兩大體系之間的關係，為巨觀現象提供微觀尺度的解釋。因此，若以此角度出發，我們可以把問題精確地重塑為：相較於原子，為什麼鴿子那麼大呢？<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」">2</span></a></sup></p>
<p>確實，相較於原子，一隻鴿子的體積非常大。成鴿的平均體重為 0.5 公斤，其組織器官則由碳、氫、氧、氮、硫、磷和其它微量元素構成。假設鴿子僅由氫原子或硫原子組成，可推知一隻成鴿含有的原子數量約在 $10^26$ 到 $10^28$ 之間，這數量遠超過當今對恆星數量的估計值($3 \times 10^{23}$)<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Dokkum & Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.">3</span></a></sup>。</p>
<p>由於鴿子與原子的懸殊比例，鴿子既無法察覺個別原子的動靜，也不受其碰撞、震盪或旋轉影響。這表示，作用於鴿子的原理和作用於原子的原理可能有很大的差異。但這樣的尺度差異對有機體究竟有什麼意義？又為什麼非得如此，才能維持鴿子的存在？</p>
<h2 id="有機體的運作仰賴精確的物理和化學定律"><a href="#有機體的運作仰賴精確的物理和化學定律" class="headerlink" title="有機體的運作仰賴精確的物理和化學定律"></a>有機體的運作仰賴精確的物理和化學定律</h2><p>有機體的運作無處不仰賴事物間精確的配合。以感知和運動為例，有機體要能靈敏接收刺激，同時不失真地傳遞訊息。這些訊息得正確抵達中樞，在歷經複雜決策後，循另一條途徑輸出，以驅動目標肌肉收縮。這個過程的順利，不只需要事件層序分明，也仰賴組織構造的規律。無論是感覺&#x2F;中樞&#x2F;運動神經的緊密連結，粗肌絲與細肌絲的間隔排列，還是細胞內訊息傳遞分子的聚攏，都是完成一項行為的要件。</p>
<p>即使是最簡單的膝跳反射，也需要器官、組織乃至細胞間的緊密配合，更遑論思考、決策與想像等複雜行為對秩序的需求。這意味著，無論生理還是結構層面，維繫有機體的各項事件皆需要相當的精確性；而外在系統對有機體的影響，也要有與之對應的精確性才會發生作用。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」">4</span></a></sup></p>
<h2 id="物理和化學定律的精確性奠基於大量原子參與"><a href="#物理和化學定律的精確性奠基於大量原子參與" class="headerlink" title="物理和化學定律的精確性奠基於大量原子參與"></a>物理和化學定律的精確性奠基於大量原子參與</h2><p>然而，少量原子無法支持有機體所需的精確性。在微觀尺度，個別原子持續進行隨機的熱運動，其移動、震盪和旋轉皆無法測量與追蹤。不過隨著系統內的原子數量增加，原子狀態（例如速度、方向、電荷等）的多樣性也隨之增加。一旦數量夠多，大量原子的平均狀態，便會呈現為巨觀層次可觀察到的方向性或規律性。</p>
<p>以順磁性為例，石英管中的氧氣雖然會因置於磁場而磁化，可是並非所有氧分子的方向皆與磁場一致。在局部，個別分子的方向其實會隨熱運動不斷轉變，所以沒有固定一致的排列方式。儘管個別分子的方向無法預期，但隨著磁場增強，石英管內順磁性分子與逆磁性分子的數量差距會逐漸增加，使得多數的氧分子與磁場方向一致，共同產生可觀測的磁化現象。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。">5</span></a></sup></p>
<p>另一項案例是布朗運動與擴散現象。在微觀尺度，單一微粒會受水分子碰撞而隨機運動，其移往各方向的機率與溶液濃度無關。不過，因為溶液中高&#x2F;低濃度區域的微粒數量有別，由高往低濃度移動的微粒自然比由低往高濃度移動的微粒多，於是微粒在巨觀層次表現出隨重力沉降或隨濃度梯度擴散等現象。</p>
<p>反之，若組成系統的原子數越小，隨機偏差的幅度就越大。這關係可以測量精確度的極限說明。扭秤是測量作用力強度重要的工具。為了偵測到更微弱的作用力，往往會替扭秤選用更輕盈的槓桿與絲線。不過，隨著扭秤尺寸縮小，原子熱運動對扭秤的影響也隨之增加，使得原子碰撞和待測作用力造成的擺幅難以區分。在這種尺度下，單次測量的意義有限，得靠多次測量來消除隨機偏差的影響。</p>
<h2 id="有機體需要足夠的原子才能受益於定律的精確性"><a href="#有機體需要足夠的原子才能受益於定律的精確性" class="headerlink" title="有機體需要足夠的原子才能受益於定律的精確性"></a>有機體需要足夠的原子才能受益於定律的精確性</h2><p>綜上所述，系統在巨觀尺度的屬性是相異狀態之原子的數量分布不均所致。系統內的原子數越多，數量不均的狀況就越容易與隨機運動區別，呈現的集體現象也就越明確。原子數量與定律精確性的關係可用 $\sqrt{n}$ 法則描述。 $\sqrt{n}$ 法則是指，對一個含有 n 個原子的系統而言，物理或化學定律的誤差範圍約在 $\sqrt{n}$ 內。式子中的平方根意味著，隨著系統含有的原子增加，作用在此系統定律的相對誤差就愈低。</p>
<p>讓我們回到文章開頭提到的問題，為何鴿子那麼大？或說，為什麼鴿子就不能像寡糖或Omega-3一樣小？這是因為，有機體的遺傳、發育和行為等生命特徵需要足夠數量的原子，才有辦法忽視個別原子的隨機運動，表現出統計物理上的宏觀秩序。</p>
<p>讓我們想像一種僅由 100 個原子組成的迷你鴿子。根據 $\sqrt{n}$ 法則，發生在迷你鴿子體內的擴散、催化、接合等反應皆有 10 個原子的不確定性，即有 10% 的相對誤差。</p>
<p>在這尺度，影響鴿子的不再是氣流、重力和光線等巨觀現象，而是電荷、碰撞、量子穿隧等微觀現象。僅僅一個離子，就可能破壞迷你鴿子的結構；即使是少量原子刺激，都會影響鴿子的感官，以致於不能辨明關鍵的環境訊號。既然無法維繫體內運作和對外互動，這樣的生命也就不會是我們定義的「鴿子」了。</p>
<h2 id="古典物理無法解釋遺傳的分子機制"><a href="#古典物理無法解釋遺傳的分子機制" class="headerlink" title="古典物理無法解釋遺傳的分子機制"></a>古典物理無法解釋遺傳的分子機制</h2><p>儘管統計物理似乎為有機體的尺存給出了圓滿的解釋，但此處的議論實為楔子：依照前述討論，有機體的秩序仰賴大量原子參與。不過就當時所知，基因很可能僅由少量原子組成，那麼基因是怎麼表現出遺傳、突變與分裂等在巨觀層次可觀測到的高度秩序？薛丁格主張，這個矛盾或許可用量子力學的概念解釋。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Dokkum &amp; Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。<a href="#fnref:5" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>R/Rstudio console 的指令長度限制</title>
    <url>/r-console-upper-limit-on-the-string-length/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>TL:DR：輸入 R&#x2F;Rstudio console 的指令之容量上限為 4095 bytes。若超出上限，console 會忽略超出的部分，顯示 + 提醒使用者補完剩餘指令。</p>
<span id="more"></span>

<p>今天測試定序前處理的 pipeline 時，發現總是無法順利讀檔。為了 debug，我把所有檔案的輸入路徑存為一個字串，並複製到 R console，重跑其中一個 function。結果 console 上印出一個 + 號，function 仍無法運作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> parse_path<span class="punctuation">(</span><span class="string">&quot;....&quot;</span><span class="punctuation">)</span> <span class="comment"># 這是長度約三千多個字符的字串</span></span><br><span class="line"><span class="operator">+</span></span><br></pre></td></tr></table></figure>
<p>我第一個反應是檢查括弧的數量和位置是否正確，接著仔細看檔案路徑中有沒有跳脫字符。然而，怎麼檢查都沒有留意到語法錯誤，於是開始丟各種長度和內容的字串測試。</p>
<p>後來，我發現只要刪除部分字串，function 又可以順利執行了，所以我猜 R 的字串可能有長度上限？循著這猜想，我在網路上找到不少面臨相似問題的人，例如：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28399710/storing-long-strings-dna-sequence-in-r">storing long strings (DNA sequence) in R</a></li>
<li><a href="https://stackoverflow.com/questions/54974996/how-to-bypass-rstudio-console-upper-limit-on-character-string-length">How to bypass RStudio console upper limit on character string length?</a></li>
</ul>
<p>最終，我才在<a href="https://community.rstudio.com/t/does-console-impose-an-upper-limit-on-the-length-of-strings/12872">這則問題</a>找到答案：輸入的字串被刪節確實是因為其大小超出限制，但並非超出 character 存儲上限，而是超出 R&#x2F;Rstudio console 的上限。</p>
<p>舉例來說，我們可以用 paste0 和 rep 建立長字串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>再使用 nchar 統計字串長度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span>seq<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure>
<p>然而，若把字串印出，再完整貼到 console 裏執行。由於字串大小超出 console 上限，所以 nchar 便無法順利運作了。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span> <span class="string">&quot;ABCDEFGABCDEFGABCDEFG......&quot;</span> <span class="punctuation">)</span></span><br><span class="line"><span class="operator">+</span> </span><br></pre></td></tr></table></figure>

<p>當然，字串也有其容量上限，這上限應該是取決於記憶體容量。這狀況，R 會直接告訴我們容量不足，而不是顯示讓人困惑的 +。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">100000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error<span class="operator">:</span> cannot allocate vector of size <span class="number">745058.1</span> Gb</span><br></pre></td></tr></table></figure>
<p>有趣的是，數字再大一點時數字會以科學記號表示，不符合 rep 的輸入規範，也會顯示錯誤。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000000000000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error <span class="keyword">in</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1e+21</span><span class="punctuation">)</span> <span class="operator">:</span> invalid <span class="string">&#x27;times&#x27;</span> argument</span><br></pre></td></tr></table></figure>
<p>這些道理我都懂，可是，我的 pipeline 是以腳本執行啊，怎麼還會碰到這問題？經過一番苦思，發現 bug 出在我的程式邏輯上，跟本文提到的限制一點關係都沒有。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/r-console-upper-limit-on-the-string-length.png?raw=true" alt="meme, it&#39;s my fault, not R&#39;s"></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 如何推論基因的尺寸？</title>
    <url>/schrodinger-1944-what-is-life-chapter-2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>依照<a href="./schrodinger-1944-what-is-life-chapter-1.md">第一章</a>的推理，生物及其生理過程有賴大量原子參與，來抵銷個別原子的隨機行為，以維持生存所需的宏觀秩序。</p>
<p>乍看之下，這項推論似乎符合當代多數的生物學觀察。畢竟個體由無數細胞組成，而細胞又由多樣的園子、分子和聚合物構築。即使是維繫生存最基本的呼吸作用，也需要大量的分子參與。這些園子的數量大小，吻合統計物理的要求，能讓物理和化學過程順利運作。</p>
<p>然而，在這章當中，我們可以看到維繫遺傳的關鍵因素，基因，相較於其穩定性，卻令人訝異地有著幾乎無法維持嚴格統計定律的數量。</p>
<span id="more"></span>

<h2 id="基因相當穩定"><a href="#基因相當穩定" class="headerlink" title="基因相當穩定"></a>基因相當穩定</h2><p>相較於紙張、磁碟片、或是塗鴉在牆上的紀錄，基因在保存事務上的能力相當穩定。基因的穩定型從色盲、鐮刀行貧血、乃至於哈布斯堡家族鮮明的戽斗等遺傳行疾病更為顯著，即使經過了上千年，這些性狀仍仍能忠實地在世代間傳遞，以致於當今的社會仍要為其奮鬥。</p>
<p>考量其穩定性，究竟需要多少原子才能讓基因維持這樣的穩定性呢？</p>
<h2 id="以染色體影像估算基因的最大尺寸"><a href="#以染色體影像估算基因的最大尺寸" class="headerlink" title="以染色體影像估算基因的最大尺寸"></a>以染色體影像估算基因的最大尺寸</h2><p>一種直觀的估算方法是透過細胞學的觀察為依據。果蠅唾腺細胞的染色體在分裂時會凝聚成顯微鏡可見的棒狀物，這些染色體上有深淺間格的調帶，假設這些條帶是基因的性向，那麼可以ˇ用染色惡體的體積，再除以調代的數量，那麼即可推論基因的尺寸。</p>
<h2 id="以遺傳圖譜估算基因的最大尺寸"><a href="#以遺傳圖譜估算基因的最大尺寸" class="headerlink" title="以遺傳圖譜估算基因的最大尺寸"></a>以遺傳圖譜估算基因的最大尺寸</h2><p>另一種迂迴但是巧妙的手法是透過遺傳方法，推論基因的數量。生物形成配子時，會先行減數分裂。減數分裂過程，同源染色體間的片段可能彼此互換，導致原先坐落相同染色體的性狀，被置換到對偶染色體上。互換會導致子代性狀的機率分布脫離孟德爾的假設，因此透過育種雜交實驗，可從子代性狀的分布推論互換的機率。</p>
<p>假設染色體各處發生互換的機率一致，若性狀間距越大，當中也有較多位點可能發生互換，也表示兩者互換的機率也越高（因為兩者之間有較多位置可能發生互換），反之則表示兩者互換機率愈高，則間距越大。基於這項假設，可以從性狀間的互換率，推論性狀在染色體上的相對位置與距離。</p>
<p>這項任務有助於在遺傳學上譜出基因的相對位置，其在推論基因尺寸的用途則在於。若我們定義基因為乘載性狀的基本單位，若一項性狀能隨互換而遷移，表示這段區域至少包含了能獨立展現性狀的基因。因此，基因的最大尺寸可由染色體的體積，除以可互換而分離的性狀數量來估計。（由於）</p>
<h2 id="基因具有令人訝異的穩定性"><a href="#基因具有令人訝異的穩定性" class="headerlink" title="基因具有令人訝異的穩定性"></a>基因具有令人訝異的穩定性</h2><p>無論透過何種方式推論，原子的最大體積約為 300 Å,而單一原子的尺寸約為 1 Å，這意味著基因所含的原子數頂多在數百萬個之間。透過前一章所推論的，這樣的尺寸顯然過少了。那麼究竟有什麼使得基因能以保有如此問訂的特性</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜Vimium，學習 Vim 的新途徑</title>
    <url>/start-learning-vim-from-vimium/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的一款擴充套件，它借鑒了 Vim 的鍵位設計與操作邏輯，讓用戶只需要鍵盤便能執行分頁管理、連結點擊與頁面瀏覽等操作。</p>
<p>由於瀏覽器終究不等同編輯器，所以 Vimium 並沒有移植 Vim 所有的功能與指令。然而，即使只納入 Vim 的部分性質，Vimium 仍顯著改善了 Chrome 的鍵盤瀏覽體驗。以點擊連結為例，Chrome 的預設作法是<a href="https://5uperb0y.com/navigate-websites-with-keyboard/">慢慢用 <code>Tab</code> 切到連結位置</a>；Vimium 則會自動標記視窗內的連結，用戶只要鍵入標記字符即可開啟連結。因為最多輸入三個字即可開啟連結，所以有時甚至比滑鼠點擊還迅速。</p>
<p>對於習慣鍵鼠操作卻有心學習 Vim 的用戶而言，一時要以 Vim 取代既有的工作流程，可能是繁瑣且費時的過程。若先從 Vimium 著手，在體驗鍵盤瀏覽網頁的流暢感之餘，也能讓 Vim 操作的抽象性質融入日常生活（例如：查資料與逛論壇）。待初探了 Vim 的設計緣由，再逐步精進其他操作模式，也不失為一種學習 Vim 的可行策略。</p>
<span id="more"></span>

<h1 id="能從-Vimium"><a href="#能從-Vimium" class="headerlink" title="能從 Vimium"></a>能從 Vimium</h1><p>借鑒了 Vim 鍵位設計與操作邏輯，無論是管理分頁、點擊連結或瀏覽頁面都能夠只憑鍵盤操作。</p>
<ul>
<li><strong>習慣在 normal 模式瀏覽文件的方式</strong>：</li>
<li><strong>理解以 home row 為核心的鍵位安排</strong>：不用為了點選控制健而不自然地伸展手指，所有操作都能集中在，相較於使用特殊控制鍵作為切換功能的方式，採用模式差異</li>
<li><strong>學習 vim 實用功能的邏輯與效果</strong>：</li>
<li><strong>了解自訂快捷鍵的意義</strong>：相較於滑鼠，快捷鍵操作有更多空間能夠因應個人的需求調整。</li>
<li></li>
<li>能夠更為習慣 normal mode 的瀏覽方式j，</li>
<li>體會以 home row 為中心的指令鍵位安排</li>
<li>習慣使用垂直移動游標，例如 <code>j</code> &amp; <code>k</code></li>
<li>了解 Vim easymotion 跳轉的邏輯與效果</li>
<li>學會使用 <code>/</code> 搜尋文字</li>
<li>體驗指令組合的效果</li>
<li>依據需求自訂快捷鍵</li>
<li>使用書籤功能</li>
</ul>
<h1 id="學會-Vimium-只要三分鐘"><a href="#學會-Vimium-只要三分鐘" class="headerlink" title="學會 Vimium 只要三分鐘"></a>學會 Vimium 只要三分鐘</h1><blockquote>
<p>Press <code>f</code> to master Vimium (and navigate internet without a mouse.)</p>
</blockquote>
<p>Vimium 最大的特色是能透過「標記與跳轉」的模式開啟連結。一旦按下 <code>f</code>，Vimium 便會為視窗內所有可互動的項目（例如連結、欄位與按鈕）標註辨識碼，接著只要輸入辨識碼即可開啟連結。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="鍵入 `f` 後, Vimium 會為視窗內的可互動物件標記辨識碼，鍵入辨識碼即可開啟連結（使用 Vimium 操作 Google search)"></p>
<ul>
<li><code>L</code>：開啟「Vimium」</li>
<li><code>SK</code>：開啟「工具」，透過 Vimium 的連結辨識碼，免除網頁設定欄位快捷鍵的負擔</li>
<li><code>SA</code>：切換至「搜尋列」，可以編輯搜尋內容</li>
</ul>
<p>雖然 Vimium 有一套基於 home row 指令，Chrome 與 Windows 內建快捷鍵已能直觀地管理分頁（例如 <code>Ctrl</code> + <code>T</code>）與滑動視窗（例如方向鍵與空白鍵），要配合瀏覽網頁的需求是綽綽有餘。例如Vimium 配合特殊控制鍵，即可在不同分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟</td>
<td><code>f</code>, then ID</td>
</tr>
<tr>
<td>於新分頁開啟</td>
<td><code>f</code>, then <code>Shift</code> + ID</td>
</tr>
<tr>
<td>於新分頁開啟並切換至新分頁</td>
<td><code>f</code>, then <code>Ctrl</code> + ID</td>
</tr>
</tbody></table>
<h1 id="以-Vim-style-瀏覽網頁"><a href="#以-Vim-style-瀏覽網頁" class="headerlink" title="以 Vim style 瀏覽網頁"></a>以 Vim style 瀏覽網頁</h1><p>鍵鼠操作以 <code>Ctrl</code>、<code>Home</code>、<code>PageUp</code> 等控制鍵，</p>
<h2 id="移動游標的方式"><a href="#移動游標的方式" class="headerlink" title="移動游標的方式"></a>移動游標的方式</h2><table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 快捷鍵</th>
<th>Vim 快捷鍵</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至頂部</td>
<td><code>gg</code></td>
<td><code>gg</code></td>
<td><code>Home</code></td>
</tr>
<tr>
<td>向上移動半個視窗</td>
<td><code>u</code></td>
<td><code>Ctrl</code> + <code>u</code></td>
<td>-</td>
</tr>
<tr>
<td>向上移動一列</td>
<td><code>k</code></td>
<td><code>k</code></td>
<td><code>↑</code></td>
</tr>
<tr>
<td>向下移動一列</td>
<td><code>j</code></td>
<td><code>j</code></td>
<td><code>↓</code></td>
</tr>
<tr>
<td>向下移動半個視窗</td>
<td><code>d</code></td>
<td><code>Ctrl</code> + <code>d</code></td>
<td>-</td>
</tr>
<tr>
<td>移至底部</td>
<td><code>G</code></td>
<td><code>G</code></td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h2><p>分頁管理是網頁瀏覽的特殊需求，所以 Vimium 就沒有照搬 Vim 的快捷鍵，而是將那些負責編輯或是功能與其他移動指令相近的按紐分配給分頁管理。<br><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_tab-operation.png?raw=true" alt="Vimium 分頁管理與頁面瀏覽的快捷鍵"><br>比對 Vimium 指令與 Chrome 快捷鍵會發現，後者需要用 <code>Ctrl</code> 和 <code>Alt</code> 等特殊控制鍵去定義。此外，觀察鍵盤位置分布可得知，Chrome 快捷鍵位置集中在兩側，似乎也是為了因應特殊控制鍵的分布以及持滑鼠的手的擺放位置。然而，瀏覽網頁時其實沒有文字輸入的需求，所以文字區塊的鍵盤等於閒置了。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 指令</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>開新分頁</td>
<td><code>t</code></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>關閉分頁</td>
<td><code>x</code></td>
<td><code>Ctrl</code> + <code>W</code></td>
</tr>
<tr>
<td>上一頁</td>
<td><code>H</code></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>L</code></td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>直達分頁</td>
<td><code>#g0</code></td>
<td><code>Ctrl</code> + <code>#</code></td>
</tr>
<tr>
<td>上一分頁</td>
<td><code>J</code></td>
<td><code>Alt</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>下一分頁</td>
<td><code>K</code></td>
<td><code>Alt</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<h2 id="數值參數"><a href="#數值參數" class="headerlink" title="數值參數"></a>數值參數</h2><p>就目前使用下來的想法，為什麼稱呼 Vimium 的行為為「指令」，而chrome的操作為「快捷鍵」，這是因為 Vimium 移植了 Vim 的機制，視每次操作為單元指令，指令可彼此疊加與重複創造出更複雜的行為。Vim 指令的行為分為 motion, replication factor, and operator。前述提及的所有指令都可算是 motion，亦即移動游標數個單位，例如一個視窗、一列、整個頁面等。這些指令都可以再前面冠上 replication factor 來增加執行次數 <replication factor> <motion>。</p>
<p>而 operator 則是對文字的編輯，這包含了 c (change)、y (yank拖)、d(delete)等，<br>Vimium 保留了 Vim 重複計數 (repeat count or replication factor) 的機制，用戶只要在命令前加上數字，便能指定命令的重複執行次數。</p>
<ul>
<li><code>4t</code>：開啟四個分頁</li>
<li><code>3x</code>：關閉前三個分頁</li>
<li><code>2d</code>：下移一個視窗(半個視窗 * 2)</li>
<li><code>3g0</code>：直達第三個分頁</li>
</ul>
<h2 id="頁面書籤"><a href="#頁面書籤" class="headerlink" title="頁面書籤"></a>頁面書籤</h2><ol>
<li><code>mc</code>，建立分頁內標記，<code>c</code> 可替換為其他小寫字母</li>
<li><code>mC</code>，建立跨分頁標記，<code>C</code> 可替換為其他大寫字母</li>
<li>&#96;&#96;c&#96;，跳轉至標記的位置</li>
</ol>
<h2 id="mode-切換"><a href="#mode-切換" class="headerlink" title="mode 切換"></a>mode 切換</h2><p>其實 Vimium 也有 insert 與 visual 模式，但相當罕用，原因如下：</p>
<ol>
<li>網頁瀏覽唯一的編輯機會是調整網址</li>
<li>若有大量編輯需求，也是在 google doc 或 Rstudio 這種瀏覽器編輯器編輯，裏頭應該有對應的 vim 套件才對</li>
<li>調整網址或更新關鍵字幾乎沒有重複操作或複雜編輯的需求</li>
<li></li>
</ol>
<h1 id="設計自己專屬的快捷鍵組合"><a href="#設計自己專屬的快捷鍵組合" class="headerlink" title="設計自己專屬的快捷鍵組合"></a>設計自己專屬的快捷鍵組合</h1><p>鼓勵用戶，Vimium 支援了自訂以下項目的功能，</p>
<p>首先鍵入 <code>?</code> 開啟 “Vimium Help”，再點選 “Options” 進入設定面板，即能看到以下設定</p>
<h2 id="“Excluded-URLs-and-keys”"><a href="#“Excluded-URLs-and-keys”" class="headerlink" title="“Excluded URLs and keys”"></a>“Excluded URLs and keys”</h2><p>這設定能限定特定網域適用的 Vimium 快捷鍵，以避免其覆蓋網頁或瀏覽器預設的快捷鍵。舉例來說，Vimium 的 <code>/</code>（搜尋頁內文字）會覆蓋 Google search 的 <code>/</code>（重返搜尋列）。</p>
<p>如果我已經很習慣使用 <code>Ctrl</code> + <code>F</code> 來查找頁內文字或是使用 <code>/</code> 來編輯搜索關鍵字，可以透過編輯 “Patterns” 和 “Keys”，讓 Vimium 的 <code>/</code> 設定不套用在 Google search 上。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_excluded-urls.png?raw=true" alt="編輯 &quot;Excluded URLs and keys&quot; 來設定 Vimium 快捷鍵的適用範圍（Keys 預設是禁用全數快捷鍵，而 Patterns 可用正則表達式編寫規則）"></p>
<h2 id="“Custom-key-mapping”"><a href="#“Custom-key-mapping”" class="headerlink" title="“Custom key mapping”"></a>“Custom key mapping”</h2><p>這設定能調整預設的快捷鍵以符合用戶的使用習慣。好比說，如果不習慣 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 的操作，可以透過以下方式改成動作遊戲常用的 <code>a</code> <code>s</code> <code>w</code> <code>d</code> (<code>map &lt;key&gt; &lt;command&gt;</code>)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改以 wasd 配置移動視窗</span></span><br><span class="line">map a scrollLeft </span><br><span class="line">map s scrollDown</span><br><span class="line">map w scrollUp</span><br><span class="line">map d scrollRight</span><br></pre></td></tr></table></figure>
<p>進階一點也能為常用網址設置快捷鍵 (<code>map &lt;key&gt; createTab &lt;url&gt;</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鍵入 @tl 以開啟 Google 翻譯</span></span><br><span class="line">map @tl createTab https://translate.google.com.tw/?hl=zh-TW</span><br></pre></td></tr></table></figure>

<h2 id="“Previous-patterns-and-Next-patterns”"><a href="#“Previous-patterns-and-Next-patterns”" class="headerlink" title="“Previous patterns and Next patterns”"></a>“Previous patterns and Next patterns”</h2><p>輸入 <code>[[</code>（上一頁）或 <code>]]</code>（下一頁）之後，Vimium 會搜尋並開啟頁面內含「上一頁」或「下一頁」的連結。這功能完全解決了 Google search 無法迅速跳轉到下一頁搜索結果的問題。然而 Vimium 預設是辨識英文和箭頭符號，所以要應用於中文網站時得自行添加搜索標的。</p>
<ol>
<li>點選 “Show Advanced Options”</li>
<li>編輯 “Previous patterns” 與 “Next patterns” </li>
<li>依照自己常用的網頁添加搜索標的（例如：Google search，上一頁&#x2F;下一頁；ptt.cc，&lt;&#x2F;&gt;；巴哈姆特，◄&#x2F;►）</li>
</ol>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_page-navigation.png?raw=true" alt="可以檢查常用網站的上一頁/下一頁來調整快捷鍵偵測的字串"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>《原子習慣》，這些訣竅也適用於學習新事物。</p>
<ol>
<li>善用 <code>f</code> 點擊連結</li>
<li>維持原本的瀏覽網頁</li>
<li>透過 <code>?</code> 查詢指令</li>
<li>學習使用 vim-like 指令瀏覽與管理分頁</li>
<li>配合習慣，自訂適合自己的快捷鍵組合</li>
</ol>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>科學溝通能力的重要性</title>
    <url>/the-importance-of-science-communication/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>科學溝通能力究竟有什麼重要性，為何值得投注心力練習？</p>
<p>溝通是學術的一環。科學的進展大抵可以分為「發現新知」和「傳播新知」兩個部分。發覺問題、建立假說，最後設計實驗證明的過程，仰賴研究能力；將新發現以具體而且可信的論證方式傳遞給他人，則仰賴表達能力。</p>
<p>越是非凡的發現，越需要清晰的語言才能充分闡明。因此，除了研究的本領，科學溝通的能力也值得重視。</p>
<span id="more"></span>

<p>在學界內最普及的溝通方式就是撰寫論文，論文不僅是傳達和保留研究成果的媒介，也是評斷個人成就的標準。在論文以外，還有研討會或學者間的非正式交流，讓研究者得以接觸學界前沿的狀況。</p>
<p>除了和他人溝通，研究者在探索問題的途中也得不斷和自己對話，例如撰寫計劃書安排研究進度，或是時時回顧實驗記錄，藉此鞏固概念及引導思考以順利完成研究。</p>
<p>最後，隨著科學的進展，研究成果的影響不會只限於學術圈，而會漸漸擴及社會。然而知識在傳播中可能被誤解，混淆的觀念恐怕扭曲大眾對科研的看法，導致恐慌及失當的決策。這些問題有賴研究者、媒體和社會間有效的溝通才能解決。</p>
<p>換句話說，社會支持著學術圈，學術圈則讓個人有立足空間，個人再反過來影響學界與社會。溝通參與了個人、學術乃至於社會三方面的發展，這也是為什麼值得投入心力在科學溝通能力養成的原因。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜VSCodeVime 常用設定</title>
    <url>/vscode-common-settings-for-vscodevim/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文紀錄一些有助於在 Vscode 使用 vim 的套件與快捷鍵設定。</p>
<span id="more"></span>
<h1 id="除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？"><a href="#除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？" class="headerlink" title="除了 Esc，還有哪些鍵適合作為模式切換快捷鍵？"></a>除了 <code>Esc</code>，還有哪些鍵適合作為模式切換快捷鍵？</h1><p>Vim 被開發出來的時候，<code>Esc</code> 位於現今當代鍵盤 <code>Tab</code> 和 <code>Caps</code> 的位置。如今，<code>Esc</code> 被移到鍵盤左上角，已不若以往方便了。既然 vim 支援充新設定快捷鍵，那麼有哪些鍵適合作為模式切換快捷鍵？</p>
<ol>
<li><code>jj</code>：位置很棒，只是打字打到 j 時，會有輕微的停頓感。缺點是編輯中文時，要頻繁切換輸入法。</li>
<li><code>jk</code>：一次按兩顆鍵，但因為可以一起按，沒有連續按鈕的卡頓感，只是同樣要解決換模式前得切換輸入法的問題。</li>
<li><code>Enter</code>*2：剛開始使用 vim 很容易忘記切回 normal 模式，既然中文輸入會頻繁輸入 enter讓文字寫入文件，enter 設定為切換模式的快捷鍵既不會干擾文字輸入也好記。只是碰到換行時會延遲等候第二次按鍵的訊號，有時還挺煩人的。</li>
<li><code>Shift</code> + <code>Enter</code>：雖然要兩個按鈕，但位置其實不錯按，而且不會輸入新列的卡頓感。唯一的缺點是設置稍嫌麻煩。</li>
</ol>
<h2 id="前述三種方法要修改-setting-json"><a href="#前述三種方法要修改-setting-json" class="headerlink" title="前述三種方法要修改 setting.json"></a>前述三種方法要修改 setting.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;CR&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CR&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;Esc&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Shift-Enter-的方法要改-keybindings-json"><a href="#Shift-Enter-的方法要改-keybindings-json" class="headerlink" title="Shift + Enter 的方法要改 keybindings.json"></a><code>Shift</code> + <code>Enter</code> 的方法要改 keybindings.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//https://github.com/VSCodeVim/Vim/issues/2584#issuecomment-385561286</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shift+Enter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.vim_escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="怎樣設定快捷鍵"><a href="#怎樣設定快捷鍵" class="headerlink" title="怎樣設定快捷鍵"></a>怎樣設定快捷鍵</h1><p>vscode 和 vim 有些彼此衝突的快捷鍵，例如常用的 <code>Ctrl</code> + <code>F</code> 或 <code>Ctrl</code> +<code>W</code> 等。依照個人習慣，可以選擇 vim 模式要啟用那些快捷鍵</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置來關掉 vim的快捷鍵 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="attr">&quot;vim.handleKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-d&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-s&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-w&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-t&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-z&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
這些是我常用的指令。</li>
</ol>
<h1 id="怎樣才不會忘記在切換模式後切為英文輸入法"><a href="#怎樣才不會忘記在切換模式後切為英文輸入法" class="headerlink" title="怎樣才不會忘記在切換模式後切為英文輸入法"></a>怎樣才不會忘記在切換模式後切為英文輸入法</h1><p>由於 Normal mode 僅能以英文輸入法下指令，假如在 Insert mode 以中文輸入法編輯文件，使用預設的 <code>Esc</code> 切換模式後，仍維持中文輸入法，還要將輸入法切回英文，才能下達指令。為了解決這問題有兩個策略：</p>
<h2 id="改變模式切換快捷鍵"><a href="#改變模式切換快捷鍵" class="headerlink" title="改變模式切換快捷鍵"></a>改變模式切換快捷鍵</h2><p>第一種策略是把切換模式的快捷鍵設定為 <code>jj</code>，雖然不見得比較快，但一定能避免中文輸入法讓指令無法執行的問題。由於改用英文字母作為切換快捷鍵，所以在切換模式前一定要更換輸入法，所以能確保切換後一定是英文輸入法</p>
<ol>
<li><code>Shift</code>, then <code>jj</code>，切為 Normal mode</li>
<li><code>i</code>，切為 Insert mode</li>
<li><code>Shift</code>，切為中文輸入法</li>
</ol>
<h2 id="自動切換輸入法"><a href="#自動切換輸入法" class="headerlink" title="自動切換輸入法"></a>自動切換輸入法</h2><p>另一種是呼叫自動切換輸入法的腳本，在切回 normal mode 時自動幫我們切換文字</p>
<ol>
<li>下載 (im.select.exe)[<a href="https://github.com/daipeihust/im-select]">https://github.com/daipeihust/im-select]</a> 放到任何你喜歡的路徑</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置以啟用輸入法自動切換 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe -s &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>透過這樣設置，在切回 normal mode 瞬間，就會變成英文輸入法。而進入 insert mode 時，就會回到當初離開時的輸入法。</p>
<h1 id="超棒的學習資源和網站"><a href="#超棒的學習資源和網站" class="headerlink" title="超棒的學習資源和網站"></a>超棒的學習資源和網站</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10291847">VsCodeVim 自動在normal mode切回英文輸入法的方法</a></li>
<li><a href="https://www.blog.lasai.com.tw/2020/07/05/vscode-vim-mode/">vscode vim mode</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜ Failed to parse remote port from server output</title>
    <url>/vscode-remote-ssh-connection-not-working-after-update/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="狀況描述"><a href="#狀況描述" class="headerlink" title="狀況描述"></a>狀況描述</h2><p>原本在 Windows 都能正常用 VSCode Remote SSH 連線伺服器，但一早卻發現連線失敗。當時，VSCode 不斷要求輸入密碼卻無法登入，”OUTPUT” 頁面提示的訊息節錄如下：</p>
<blockquote>
<p>Failed to parse remote port from server output</p>
</blockquote>
<blockquote>
<p>Acquiring lock on &#x2F;home&#x2F;username&#x2F;.vscode-server&#x2F;bin&#x2F;some-hash-code-here&#x2F;vscode-remote-lock.username.some-hash-code-here</p>
</blockquote>
<p><em>版本資訊：windows 21H2, VSCode 1.74.2</em></p>
<span id="more"></span>
<h2 id="原因與解決辦法"><a href="#原因與解決辦法" class="headerlink" title="原因與解決辦法"></a>原因與解決辦法</h2><p>參考 <a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">VSCode remote ssh connection not working</a>，簡言之，VSCode 遠端連線前，需要在伺服器端的 <code>.vscode-server/bin</code> 安裝連線相關的工具並進行一些連線設置。假設伺服器已有這些套件，”OUTPUT” 會提示 <code>Found existing installation at (.vscode-server/bin 的路徑)</code>；若沒有這些套件，則會從官方網站下載與安裝。</p>
<p>若伺服器的套件和配置沒有隨本地 Vscode 更新，便可能因為連線兩端的資訊不相符而無法順利連線，此時可刪除並重新安裝這些工具與配置檔來解決問題。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟指令視窗</li>
<li>搜尋並執行 “Remote-SSH: Kill VS Code Server on Host”，刪除 <code>vscode-server</code> 檔案與目錄</li>
<li>選取欲清除既有工具的伺服器</li>
<li>重新連線，VSCode 便會重新安裝相關軟體了</li>
</ol>
<h2 id="檢查方式"><a href="#檢查方式" class="headerlink" title="檢查方式"></a>檢查方式</h2><ol>
<li>開啟 command line 工具，以 <code>ping</code> 確認連線正常</li>
<li>使用 putty 或 mobaXtern 等工具連線伺服器，確認問題出在 VSCode </li>
<li>重新開機、重新安裝 Remote SSH、移除 <code>C:/Users/username/.ssh/Known_host</code> 的內容，確認問題不在本地端</li>
<li>按照前述步驟刪除伺服器內 <code>vscode-server</code> 的內容，重新連線</li>
</ol>
<h2 id="其他可能解法"><a href="#其他可能解法" class="headerlink" title="其他可能解法"></a>其他可能解法</h2><p>若此處提及的方式無法解決問題，可參考以下連結試試看其他人的解法。</p>
<ul>
<li><a href="https://mushding.space/2021/12/22/vscode%20remote-ssh%20%E5%95%8F%E9%A1%8C%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/">首次遠端連線且因為網路問題下載工具受阻</a> </li>
<li><a href="https://www.cnblogs.com/netsa/p/14857577.html">本地與伺服器的 SSH key 因為更新等緣故沒有同步</a></li>
<li><a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">任何可能與遠端連線配置或安裝的問題</a></li>
<li><a href="https://blog.csdn.net/myWorld001/article/details/119443079">伺服器上的 <code>vscode-server</code> 文件過時</a></li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>IDE 及其擴充套件相當方面，可以免去不少開發環境設置的功夫。畢竟我們不會等到摸熟了 IDE 所有功能及其實踐方式才開始開發，所以功能故障算是讓了解 IDE 機制或潛在設定的好機會。在本文的案例哩，可以關閉自動更新來避免這種狀況發生。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟 Settings</li>
<li>搜尋 “update: Mode”</li>
<li>設定為 “manual” 或 “none”</li>
<li>重新啟動 VScode</li>
</ol>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>卡住、沒靈感、寫不出東西怎麼辦？</title>
    <url>/what-to-do-when-you-are-stuck-in-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原本我開啟部落格編輯器是打算寫一篇文章，總結我兩周以來學習降噪演算法的經驗，但回過神來，已經盯著標題與目錄一個鐘頭了。我意識到再這樣下去不是辦法，於是把原先的標題刪除，開始思考「如果寫文章碰到瓶頸，除了躲在桌下哭訴沒有人愛我以外，還能做些什麼？」，在閱讀了網路和實體書籍資源後，我寫了這文章。因此，本文不只是各項建議的彙整，也是這些方法的實踐。  </p>
<span id="more"></span>
<h2 id="寫作瓶頸的成因為何？"><a href="#寫作瓶頸的成因為何？" class="headerlink" title="寫作瓶頸的成因為何？"></a>寫作瓶頸的成因為何？</h2><h3 id="我寫不下去了……"><a href="#我寫不下去了……" class="headerlink" title="我寫不下去了……"></a>我寫不下去了……</h3><p>儘管已經寫了十幾篇文章，每次開啟新文件的時候還是很掙扎，因為我要不是在文章的開頭感到絕望，就是在寫一半的時候覺得快不行了。我試著問論文寫作的老師，當他碰到寫作瓶頸時會怎麼克服，他說：「我在列完大綱後都能順利地寫完論文，所以沒有碰過這種障礙。」  </p>
<p>人類的悲喜和苦惱並不相通，我得靠自己找出解決辦法。  </p>
<h3 id="為什麼會碰到障礙？"><a href="#為什麼會碰到障礙？" class="headerlink" title="為什麼會碰到障礙？"></a>為什麼會碰到障礙？</h3><p>寫文章卡住多半是源於<strong>沒有東西寫（知識問題）和寫不出字來（心態問題）</strong>。在我的寫作經驗裡，大部分的情況都是碰到心態問題。畢竟無論是寫何種題目，至少都有個預設的目標，有目標表示有初步的想法，既然有想法便不至於沒內容可以寫。是以多數的情況是讀穿了參考資料，卻在文件上打兩個字刪三個字，好似永遠也寫不出文章來。  </p>
<h3 id="怎麼辨識寫作瓶頸的成因？"><a href="#怎麼辨識寫作瓶頸的成因？" class="headerlink" title="怎麼辨識寫作瓶頸的成因？"></a>怎麼辨識寫作瓶頸的成因？</h3><p>針對不同原因需要不同的解決辦法，那麼該如何辨識寫作瓶頸的成因呢？Esor Huang（電腦玩物的站長）建議大家口頭陳述想要表達的概念，由於打嘴砲不用負責，所以如果內心有點想法的話幾乎都能講出一些東西來，進而排除是知識問題。  </p>
<p>除了這個方法，我也提供一項判斷的策略：問問現在自己的感覺如何。假如<strong>真的沒東西寫了，那面對空白文件的時候，腦中浮起的應該是困惑</strong>：「什麼是微生物分析？」、「什麼是天文生物學？」、「我什麼都不知道，為什麼我會在這裡」，此時有充分好奇心的同學，應該會自動自發找資料，在資料搜索的過程中為撰寫文章準備。  </p>
<p>然而，<strong>如果是心態問題，打開文件時應該會出現恐懼、焦慮、害怕、猶豫、逃避等情緒</strong>。假如某個人笑著看著文件，卻不時點開社群網站和 Youtube 呵呵笑，即使沒有前述情緒，這個人也碰上了心態問題。  </p>
<h3 id="知識問題和心態問題需要不同的解決策略"><a href="#知識問題和心態問題需要不同的解決策略" class="headerlink" title="知識問題和心態問題需要不同的解決策略"></a>知識問題和心態問題需要不同的解決策略</h3><p>如果是知識問題，唯一的解決辦法就是充實知識，閱讀書籍也好，回顧先前的筆記也好，讓空乏的大腦裝滿寫作的素材克服無東西可寫的困難。如果是心態問題，那麼解決之道便是調整心態，想辦法擠出字來，榨乾自己直到碰上知識問題。我認為寫作一定會碰到障礙，從興起寫作的念頭，我們就開始「不知道寫什麼、閱讀和學習、寫不下去了、調整心態、榨乾自己、不知道寫什麼、……」的循環，既然決定寫文章，就拋開恐懼吧。  </p>
<h2 id="知識問題：該寫什麼？"><a href="#知識問題：該寫什麼？" class="headerlink" title="知識問題：該寫什麼？"></a>知識問題：該寫什麼？</h2><h3 id="成長是寫作與學習的循環"><a href="#成長是寫作與學習的循環" class="headerlink" title="成長是寫作與學習的循環"></a>成長是寫作與學習的循環</h3><p>關於知識問題，紀大偉老師有很棒的建議：<strong>研究所（或成長）是寫作與閱讀的循環。</strong>當寫得殫精竭慮，再也寫不出東西的時候，便該停下筆去學習或去閱讀。不必侷限於文章的主題，相關的專著或文章都可以接觸，既能補充匱乏的知識，也能促進知識間的連結，有助於寫作時有足夠且有趣的內容可以輸出。  </p>
<h3 id="學習不能作為逃避寫作的藉口"><a href="#學習不能作為逃避寫作的藉口" class="headerlink" title="學習不能作為逃避寫作的藉口"></a>學習不能作為逃避寫作的藉口</h3><p>然而<strong>吸收知識不能作為逃避寫作的藉口</strong>。之前寫多樣性分析的簡介文章時，因為總覺得不夠熟悉各項指標，所以遲遲無法下筆。我原本以為這是知識問題，但世上的知識是讀不完的，我的文章也非得涵蓋所有知識，因為對自己知識的不安而裹足不前，這是心理問題。  </p>
<p>擱置手邊的工作去閱讀是為了寫作，而不是為了享受閱讀的過程。如果真的發現要補足的知識讀不完，那麼應該重新審視文章的主題，而不是陷在學習的沼澤裡無法自拔。  </p>
<h3 id="為了寫作而學習，為了學習而寫作"><a href="#為了寫作而學習，為了學習而寫作" class="headerlink" title="為了寫作而學習，為了學習而寫作"></a>為了寫作而學習，為了學習而寫作</h3><p>因此，有效的閱讀要寫筆記。藉由寫筆記留下內容與思考的紀錄，之後撰寫文章便不需要回顧原始資料，還可以累積寫作的素材。例如這篇文章即是我讀了不同來源資料的筆記彙整出來的。  </p>
<h2 id="寫作兼具思考和表達兩種功能"><a href="#寫作兼具思考和表達兩種功能" class="headerlink" title="寫作兼具思考和表達兩種功能"></a>寫作兼具思考和表達兩種功能</h2><h3 id="寫作既是表達的媒介，也是協助思考的工具"><a href="#寫作既是表達的媒介，也是協助思考的工具" class="headerlink" title="寫作既是表達的媒介，也是協助思考的工具"></a>寫作既是表達的媒介，也是協助思考的工具</h3><p>在說明心態問題前得先釐清寫作的兩個功能。首先，寫作是傳達觀念的媒介，亦即寫作是表達的工具。但寫作有另一種身分，寫作是協助思考的方式，或著說，<strong>寫作其實是思考的一部份</strong>。  </p>
<p>因為這兩種功能的差異，所以儘管許多人曾碰到寫文章卡住的問題，仍有些編輯主張沒有寫作瓶頸這回事。因為從寫作即是思考的觀點而言，寫作之於思考有如呼吸之於跑步，跑步覺得有些吃力的時候，不該歸究於呼吸障礙而停止呼吸，應該專注於調整呼吸才對。寫作時亦然，想<strong>不到該寫什麼的時候，不應輕易中止寫作，反而要設法用寫作解決問題。</strong>  </p>
<h3 id="透過寫作思考的好處"><a href="#透過寫作思考的好處" class="headerlink" title="透過寫作思考的好處"></a>透過寫作思考的好處</h3><p>但為什麼寫作能夠協助我們思考並解決寫文章卡住的問題？首先，我們很難不依賴具體的東西把事情想清楚，例如在跟人說話的同時比劃手勢，或是利用紙筆和公式協助數學運算。因此，在寫不出東西的時候更要利用寫作呈現思考的過程，讓大腦主動思考，集中思緒在主題上，以免不同的想法在腦中衝撞，最後只剩下美食、假期和旅遊等無關事物。  </p>
<p>此外，我們的大腦無法一次處理太多事物。寫作留下的紀錄可以讓我們追溯思考的路徑，並依此延伸新想法，繼而組織文章的架構。  </p>
<h3 id="以寫作（思考性寫作）解決寫作（表達性寫作）問題"><a href="#以寫作（思考性寫作）解決寫作（表達性寫作）問題" class="headerlink" title="以寫作（思考性寫作）解決寫作（表達性寫作）問題"></a>以寫作（思考性寫作）解決寫作（表達性寫作）問題</h3><p>綜上所述，<strong>當我們寫文章卡住的時候，其實是用於表達的寫作中止了，但用於思考的寫作應持續進行</strong>，利用自由書寫等方式呈現把所想的內容保留在文字。如此一來，既推進了寫作的進度，也累積了一些文章的素材。  </p>
<p>##完美主義的心態問題</p>
<h3 id="最好是更好的敵人"><a href="#最好是更好的敵人" class="headerlink" title="最好是更好的敵人"></a>最好是更好的敵人</h3><p><strong>完成永遠比完美更重要</strong>，因為任何事都不可能完美，我自己寫作時經常犯完美主義的問題。以我部落格人氣最高的那篇文章為例，那篇就是完美主義的產物。你稍微看一眼可能會感到疑惑：「完美主義？可是那篇用字紊亂而且格式也歪掉了耶？看起來不是很完美啊！」  </p>
<p>沒錯，這就是完美主義的的下場。在撰寫開頭時便字斟句酌，隨後每寫一個字要反覆修改半天，這樣子不僅離完成遙遙無期，還會因為過分在乎細節，反而分不清文章各段的價值，忽略整體的優劣。截止日接近的時候，在匆忙之下也沒有時間充分的修改，最後不得不發布未經潤飾的最新版，而不是理想中的最佳版。  </p>
<h3 id="化解完美主義的心理暗示"><a href="#化解完美主義的心理暗示" class="headerlink" title="化解完美主義的心理暗示"></a>化解完美主義的心理暗示</h3><p>既然完美主義是心理問題，那解決問題的方式就是改變心態，以下是幾個在寫文章前可以提醒自己的事情。  </p>
<ul>
<li><p><strong>其實沒有人在乎你寫了什麼</strong>：我的網站雖然意在吸引那些潛在的同儕或貴人，但其實每天點進來的人真的很少，為了一兩個字或一句話搞些有得沒的實在不值得。</p>
</li>
<li><p><strong>其實也沒有人會好好看文章</strong>：其實我寫完文章的時候都會寄給朋友或老師看，他們未必對內容有興趣，即使有興趣也不會一個字一個字看，所以別太在乎一兩個字的差異。</p>
</li>
<li><p><strong>其實寫文章也沒什麼了不起</strong>：雖然寫了部落格記錄學習歷程，面試還是被嘴沒有實際作為實踐理想，在學校也不會因為多寫了什麼被打高分。所以與其寫得字字珠璣，還不如白話地寫出自己的見解，幫助自己才是寫作的初衷。</p>
</li>
<li><p><strong>其實在乎的事情可能是垃圾</strong>：寫文章不免來回增刪好幾次，要怎麼知道目前寫的那段是不是垃圾？只有寫完初稿才知道。所以不痛快下筆完成文章，有可能就是在垃圾堆裡面反覆撿拾垃圾，還以為自己很用心。</p>
</li>
<li><p><strong>其實沒寫完就是零</strong>：我的電腦裡還躺有好多文稿和寫作計畫，大腦裡也一直浮現新的點子和想法，但是沒寫出來誰也不知道有這些東西。你看，李嚴又帥又強，炸蝦讓人在電視前看了都想吃，結果少了收尾的醬汁還是被小當家打臉。</p>
</li>
</ul>
<p>當然寫這些不代表說寫文章是一文不值，文章累積起來還是很可觀的，只是要調整心態，畢竟寫完才有修改的空間。  </p>
<h3 id="在輕鬆的媒介寫作"><a href="#在輕鬆的媒介寫作" class="headerlink" title="在輕鬆的媒介寫作"></a>在輕鬆的媒介寫作</h3><p>除了心理暗示，也可以<strong>改變寫作的媒介降低完美主義的顧慮</strong>。大家應該有類似的經驗吧，新學期發了新課本，擔心頁面被弄髒不敢翻頁不敢做筆記，但讀二手書的時候怎麼劃記都不心疼。  </p>
<p>寫作也是一樣，當坐在高級辦公室、高級椅子、蘋果電腦、高品質文書編輯軟體前鄭重地打開文件卻寫不出字來時，不妨用隨便的態度看待寫作這件事，用廢紙、新文字文件等看起來很廉價的媒介去寫，寫爛了也不在乎，反而能擺脫完美主義的魔咒。這篇文在用電腦編輯前，即是在印壞的影印紙上擬出來的。  </p>
<p>或是找朋友聊天，即使朋友無法給出回饋，只要他能作為自己的聽眾便有助於克服完美主義的障礙。使用臉書、LINE 或 Instagram 等能記錄文字的通訊軟體聊一聊寫作主題，也順便留下草稿紀錄。我的經驗是，在對方不懂主題的情況下，自己為了裝出一副厲害的樣子便會大放厥詞，反而無意間寫出許多有價值的東西。  </p>
<p>如果沒有朋友，自己在紙上或社群網站開一則小文章自我對話也是不錯的選擇。想想平時在 PTT 或臉書發廢文的時候文思泉湧，但開 word 寫文章卻處處制肘，恐怕是社群平台本來就鼓勵大家發表沒路用的想法，在上頭可以在這種氛圍下擠出字來。  </p>
<h3 id="以截止日督促自己行動"><a href="#以截止日督促自己行動" class="headerlink" title="以截止日督促自己行動"></a>以截止日督促自己行動</h3><p>除了降低期待，設下截止日也是化解完美主義的必要方法。人都很浪漫的，如果沒有截稿日提醒現實的殘酷，也許還會以諾貝爾文學獎為目標慢吞吞地寫文章。藉由設下截稿日，讓自己意識到生存的危機，便不會浪費青春去雕琢一部大作了，從而腳踏實地展開行動。  </p>
<h2 id="工作負擔的心態問題"><a href="#工作負擔的心態問題" class="headerlink" title="工作負擔的心態問題"></a>工作負擔的心態問題</h2><h3 id="因為看不到完成的一天而拖延"><a href="#因為看不到完成的一天而拖延" class="headerlink" title="因為看不到完成的一天而拖延"></a>因為看不到完成的一天而拖延</h3><p>「完蛋，我一定完成不了」這是每個決心萬丈高樓平地起，千里始於足下的熱血男兒起步後的第一個念頭，於是整個人癱在電腦前不斷發呆，看似在網站上尋找解決問題的辦法，其實只是在逃避現實，最終在截止日當天被擊倒。  </p>
<p><strong>解決心理負擔的策略即是減少單次的工作量</strong>，例如權衡標題的廣泛性，縮減議題到可處理的範圍，列大綱和細綱將文章分為獨立的單元，利用每天的空閒時間自由書寫，再用完整的時間整合不同的片段形成段落，最後完成文章。  </p>
<h3 id="多少做一點努力"><a href="#多少做一點努力" class="headerlink" title="多少做一點努力"></a>多少做一點努力</h3><p>即使有很重的心理負擔，也不要全然放棄努力。運動、唱歌、爬山、耍廢都無助於完成文章，東摸西摸也不會加速完成的時間，只有專注於文章才有機會成功。因此在信心被擊倒的時候，得加減做些事情，例如調整大綱、加入新的圖片、改善排版、插入引用等等，在等候勇氣恢復的時候為之後寫作的過程減輕負擔。  </p>
<p>真的寫不出來，也可以先寫點其他的文章。此舉可以保持書寫的慣性和動力，讓大腦處在書寫模式，增加完成的文章的信心也順便磨筆頭。  </p>
<h3 id="安排可行的寫作計畫"><a href="#安排可行的寫作計畫" class="headerlink" title="安排可行的寫作計畫"></a>安排可行的寫作計畫</h3><p>安排寫作計畫的快感跟寫完一篇文章一樣，所以不要安於計畫。但有時仍需要可執行且可維持計畫，我自己的經驗是把文章撰寫分為蒐集資料、紀錄筆記、自由書寫、彙整想法、寫草稿、列大綱、撰寫文章、修改與校正等八個步驟，由於大家都不是專職作家，總會有俗務纏身，所以想要立下「今天要完成這篇文章」這種目標往往會失敗。  </p>
<p>因此，<strong>相較於以目標安排進度，用努力的程度來安排進度會比較適當</strong>，例如今天安排花三小時蒐集資料，如果蒐集不完就算了，用僅存的資料先走一步。如果全部流程走完，一篇文章的內容撐不起標題，那改標題即可，不需節外生枝。畢竟已經用努力來安排進度，每段時間都投注了最大的精力，如果只完成這些內容，那也沒有愧對任何人了，驕傲地把標題改小吧。  </p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>寫文章卡住的時候應釐清是源於知識問題還是源於心態問題。如果是知識問題，需要藉由閱讀和學習充實寫作的素材。如果是心態問題，則要逼自己擠出任何文字，直到腦中沒有任何想法，得重新學習為止。  </p>
<p>寫作既是思考的方式也是表達的方式，儘管寫作（表達）碰上障礙，也不要停止寫作（思考），藉由自由書寫呈現想法，保留思考的途徑和內容，將有助於規劃文章內容。  </p>
<p>完美主義和拖延的心態是完成文章的敵人，因此寫作時要降低期待，列大綱劃分文章為數個單元各個擊破。即使碰到障礙也不要輕言放棄，看書寫筆記、調整排版、繪製配圖和修正錯字等工作都有助於減輕之後的負擔。畢竟<strong>沒有克服絕望的方法，耍廢和講幹話只會讓時間流逝，面對寫作瓶頸只有硬著頭皮闖過去才有機會。</strong>  </p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p>Esor Huang (2016)：<a href="https://www.playpcesor.com/2016/04/lifehack-8.html">[LifeHack 8] 先寫再想，激發靈感潛能的心流筆記法</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2016)： <a href="https://www.playpcesor.com/2016/09/help-you-write-something.html">如何開始一場寫作風暴？編輯給任何人寫不出東西時的建議</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2018)：<a href="https://www.playpcesor.com/2018/04/write-plan.html">不要這樣列寫作計畫，幫你不拖延完成論文、書籍與部落格創作</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2019)：<a href="https://www.playpcesor.com/2019/03/write-speed.html">寫作加速法教學，解決寫報告論述文章的截稿壓力與速度瓶頸</a>。電腦玩物  </p>
</li>
<li><p>Mark Levy (2011)：《自由書寫術》。商周出版  </p>
</li>
<li><p>Steve Wallace (2018)：<a href="https://www.editing.tw/blog/progress/%E6%B2%92%E6%9C%89%E3%80%8C%E5%AF%AB%E4%BD%9C%E7%93%B6%E9%A0%B8%E3%80%8D%E9%80%99%E6%AA%94%E4%BA%8B.html">沒有「寫作瓶頸」這檔事</a>。華樂絲學術寫作部落格  </p>
</li>
<li><p>李連江 (2018)：《如何進行學術寫作．在學術界謀生存》。香港中文大學出版社  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E6%9C%9F%E6%9C%AB%E5%A0%B1%E5%91%8A%E8%87%AA%E6%95%91%E6%B3%95-%E5%AF%ABpaper-%E5%AF%AB%E8%AB%96%E6%96%87-%E5%AF%AB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E6%80%8E%E9%BA%BC%E8%BE%A6-add4ebb2c827">便秘：寫paper，寫碩論，卡住怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E5%8E%BB%E9%9A%94%E5%A3%81%E5%81%B7%E8%8F%9C-%E8%AE%80%E6%9B%B8%E5%8D%A1%E4%BD%8F-%E5%AF%AB%E5%AD%97%E5%8D%A1%E4%BD%8F-%E6%80%8E%E9%BA%BC%E8%BE%A6-1f6cf064c324">去隔壁放鬆：讀書卡住、寫字卡住，怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>英論閣學術論文編修 (2018)：<a href="https://www.enago.tw/academy/%e7%aa%81%e7%a0%b4%e5%af%ab%e4%bd%9c%e7%93%b6%e9%a0%b8%e6%9c%89%e5%85%b7%e9%ab%94%e6%96%b9%e6%b3%95%e7%9a%84%ef%bc%81/">突破寫作瓶頸有具體方法的！</a>  </p>
</li>
<li><p>畢恆達 (2005)：《論文寫作症候群：寫作心理 ．教授為什麼沒告訴我》。學富文化  </p>
</li>
<li><p>彌糧糧 (2012)：<a href="https://paste.plurk.com/show/WypPD1CYUH0MqpNAQ7b8">大家都有寫報告寫心得寫論文寫文章卡稿的經驗吧？</a>。Plurk paste 彌糧糧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>academic</category>
        <category>writing</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜常用快捷鍵與個人設置</title>
    <url>/vscode-useful-shortcuts-and-their-settings/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>VSCode 有許多快捷鍵設置，本文記錄一些我覺得挺實用的設置</p>
<span id="more"></span>

<h1 id="開啟個人快捷鍵配置"><a href="#開啟個人快捷鍵配置" class="headerlink" title="開啟個人快捷鍵配置"></a>開啟個人快捷鍵配置</h1><ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code></li>
<li>搜尋 “Preferences: Open Keyboard Shortcuts (JSON)”</li>
</ol>
<h1 id="調整當前子頁尺寸"><a href="#調整當前子頁尺寸" class="headerlink" title="調整當前子頁尺寸"></a>調整當前子頁尺寸</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"># 開啟連結</span><br><span class="line">設定條件是為了避免快捷鍵彼此衝突，點連結的行為大概只有在編輯 md 檔案時發生，所以才這樣設置。</span><br><span class="line">```JSON</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+l&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;editor.action.openLink&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus &amp;&amp; editorLangId == &#x27;markdown&#x27;&quot;</span> </span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>寫科普又不能當飯吃，為什麼還要寫？</title>
    <url>/why-do-people-write-scientific-articles/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文是 Mitalk 4 講座「科普如何當飯吃？」的聽講心得，陳俊堯老師在演講一開始先回答了這問題，再一一告訴我們，如果無法靠寫科普賺錢營生，那麼從事研究的學生、老師和學者們，到底有什麼理由勞心費神去寫科普文？</p>
<blockquote>
<p>科普如何當飯吃？做夢吧，科普怎麼可能當飯吃。</p>
</blockquote>
<span id="more"></span>

<h2 id="科普不能當飯吃，為什麼還要寫科普？"><a href="#科普不能當飯吃，為什麼還要寫科普？" class="headerlink" title="科普不能當飯吃，為什麼還要寫科普？"></a>科普不能當飯吃，為什麼還要寫科普？</h2><h3 id="即使無法靠科普吃飯，也能藉由撰寫科普成長"><a href="#即使無法靠科普吃飯，也能藉由撰寫科普成長" class="headerlink" title="即使無法靠科普吃飯，也能藉由撰寫科普成長"></a>即使無法靠科普吃飯，也能藉由撰寫科普成長</h3><p>老師提到，他的著作《細菌好朋友》雖然囊括許多獎項，但半年的銷量折算為利潤後僅得兩萬餘元。既然連成功的出版品都無法為作者帶來財富，那研究生為什麼要勞費心力撰寫更冷門的科普文章？</p>
<p>儘管老師提及科普能促進跨領域對話、增進國民素養或支援科學教育，但先不論寫科普的外部效益，書寫本身就是一種有效的學習方式。</p>
<p>很多時候我們不是懂了才開始寫作，而是從蒐集資料、提煉知識和撰寫文章的過程中，逐漸了解想要傳達的事物。具體的文字能協助我們察覺思路不嚴謹之處，而寫作瓶頸則讓我們意識到知識的空缺。因此，即使我們無法憑藉科普營生，也能從撰寫中成長。</p>
<h3 id="研究員也能為自己的愛好發聲"><a href="#研究員也能為自己的愛好發聲" class="headerlink" title="研究員也能為自己的愛好發聲"></a>研究員也能為自己的愛好發聲</h3><p>但是，當今有許多科普網站和知識型 Youtuber 向大眾導讀論文和破解迷思，那麼研究員還有必要跳進來寫科普嗎？若想要自我成長，為什麼不寫在筆記本上就好了？</p>
<p>首先，學術需要政府與社會支持，研究員不能總是期待他人為研究議題發聲。以新視野號任務為例，由於美國政府的漠視，探索冥王星始終不是太空任務的優先目標，即使獲准執行，其預算也接連被削減。</p>
<p>為此，志在研究冥王星的 Alan Stern 只得想盡辦法遊說國會，並發起請願以尋求大眾支持。最終，新視野號任務總算排進了正式的探索行程中。雖然不能把任務的成功完全歸功於科普，但這項案例告訴我們：若研究員能為了自己的好奇心而發聲，嘗試去說服他人，那麼確實有機會將個人的願望推廣為大眾的願望。</p>
<p>在說服大眾方面，科普文章是性價比很高的工具。儘管影視寓教於樂，但研究員恐無暇製作。相較之下，寫作的成本低廉還能傳遞最多資訊。內容確實且題材多樣的文字材料，可作為其他科普媒介發展的基礎，擴張文章的影響力。</p>
<h3 id="不輕易將話語權讓給不懷好意的人"><a href="#不輕易將話語權讓給不懷好意的人" class="headerlink" title="不輕易將話語權讓給不懷好意的人"></a>不輕易將話語權讓給不懷好意的人</h3><p>教育家不是唯一對科普感興趣的人，還有濾水器廠商、智慧設計學家、政客等不懷好意的人也等著扭曲科學事實以支持他們的主張。因此，即使認為教育普羅大眾沒什麼益處，研究員也是較有立場和專業去維護科學的理性客觀價值。</p>
<p>相關案例在同婚公投期間層出不窮。護家盟為了表達反同立場，除了引用爭議性研究以外，還任意曲解其他學者經過長年研究和同儕審查得出的嚴謹結果。即使是研究人員本身，也會受到政治立場影響，做出有瑕疵的研究。</p>
<p>鑒於這些情形，研究員就算不為積極的理由寫作，也有動機為消極的理由發聲，以免研究成果為人利用，最後損及大眾對科學的信任。</p>
<h3 id="科普文章是經驗交流的管道"><a href="#科普文章是經驗交流的管道" class="headerlink" title="科普文章是經驗交流的管道"></a>科普文章是經驗交流的管道</h3><p>最後，撰寫科普也能協力國內的科學教育發展。儘管推動雙語教學的風氣日盛，中文始終是最便捷的語言。但除了有限的翻譯書籍和科普網站，國高中生欠缺可靠的中文資料，架構完整而且內容正確的中文科普文章可以填補這個空缺。</p>
<p>我認為，即使是研究生也能受益於科普寫作。相較於國外林立的論壇，台灣的網路學術經驗交流很封閉，許多技術細節和科研心得埋藏在碩博士論文、實驗室內網或私密社群裡，以至於解決問題的經驗無法共享和傳承。</p>
<p>可是，國外既有成熟的討論區，為何執意要促進我們自己的交流風氣？首先，多數人的中文優於英文，故以中文撰寫文章較能準確表達觀念。再則，即使面對同樣問題，解決辦法與說明方式也因人而異，多元的內容能惠及不同程度和背景的群眾。</p>
<p>是以，撰寫科普文章不僅能彙整思路和鞏固知識，也能保留思考的成果，幫助他人解決困難。由於互助的效益會隨參與人數增加，所以即使費時耗力也值得投資。</p>
<h2 id="那麼該如何撰寫科普文章呢？"><a href="#那麼該如何撰寫科普文章呢？" class="headerlink" title="那麼該如何撰寫科普文章呢？"></a>那麼該如何撰寫科普文章呢？</h2><h3 id="科普、課本和論文的差異在於受眾"><a href="#科普、課本和論文的差異在於受眾" class="headerlink" title="科普、課本和論文的差異在於受眾"></a>科普、課本和論文的差異在於受眾</h3><p>由於科普、課本和論文的目的皆為有效傳達訊息，優良的著作皆具有趣、簡潔和明瞭等特性。然而，三種文體的受眾不一，所以各自側重不同特性。論文的讀者是學者，所以旁徵博引、言簡意賅；課本的讀者是學生，因此體系完整、內容詳盡。</p>
<p>至於科普的讀者，則是任何有興趣的大眾。是以，科普雖然像論文一樣報導新知，卻不能吝於用字；科普也跟課本一樣具有理解新知所需的背景知識，卻不應填塞無關的資訊。除了話不能省和料不能多，科普文章要能製造驚奇以取悅讀者。</p>
<h3 id="撰寫科普的第一步是選定讀者"><a href="#撰寫科普的第一步是選定讀者" class="headerlink" title="撰寫科普的第一步是選定讀者"></a>撰寫科普的第一步是選定讀者</h3><p>讀者的年齡、背景和興趣攸關選材、用字和敘事風格。因此，撰寫科普文章的第一步是選定讀者，接著推測讀者想讀的內容，尋找具有衝擊性的主題。至於該怎麼寫，可以參考老師提出的「派大星貓一拳結構」。</p>
<p>每一篇科普都是一場冒險，文章開頭要建立現實與科學之間的橋樑，吸引讀者踏入作者營造的奇妙世界。例如，想要介紹趨化性 (chemotaxis)，可以從「撲鼻而來的雞排味」寫起，利用與主題相關的生活經驗，讓讀者對內容有具體的概念，也讓他們了解自己與主題的關係。</p>
<p>好的故事需要鋪陳，重要觀念也有其前提，所以破題之後先別切入重點，要交代問題和背景知識。例如經典的回馬槍結構：提問以後，先順應大眾的常識推論，接著點出先前敘述的矛盾，讓讀者在觀念衝突之下，迫不及待想要知道答案。</p>
<p>鋪陳以後迎來故事的高潮，要把想傳達的科學概念清楚明瞭地寫出來。最後則要總結文章，再次連結主題和生活經驗，把讀者送回現實。而更多寫作結構的細節，老師推薦我們讀讀《怎樣談科學》。</p>
<h3 id="撰寫科普的訣竅"><a href="#撰寫科普的訣竅" class="headerlink" title="撰寫科普的訣竅"></a>撰寫科普的訣竅</h3><p>寫作時請留意，科普讀者只是還沒學到相關知識，而不是欠缺理解能力。因此，要簡化內容，但不要藐視讀者（例如對著國小學生用）。</p>
<p>其次，儘管寫作時要交代背景知識，並且陳述推理的過程，但用字仍要力求簡練，以免花俏或冗贅的字眼模糊焦點。老師強調「話不能省」是指邏輯不要跳躍，而不是用繁複的文字困擾讀者。</p>
<p>最後，撰寫文章是學習的過程，所以開始動筆時對主題沒有完整的理解仍可以接受。然而在交付文章之前，要再三確認自己已經搞懂，以免寫出似是而非的奇怪內容。</p>
<h2 id="該如何練習寫科普？"><a href="#該如何練習寫科普？" class="headerlink" title="該如何練習寫科普？"></a>該如何練習寫科普？</h2><h3 id="所謂寫作，就是空出時間寫作"><a href="#所謂寫作，就是空出時間寫作" class="headerlink" title="所謂寫作，就是空出時間寫作"></a>所謂寫作，就是空出時間寫作</h3><p>所謂寫作，就是空出時間寫作。他人整理的訣竅得在練習中實踐，障礙和困難也只有在實作中才能體會。而且，文章完成後才有被閱讀和被修改的機會，因此，老師在建議大家，聽完演講以後趕快找一則論文試試看。</p>
<h3 id="以改寫培養寫作能力"><a href="#以改寫培養寫作能力" class="headerlink" title="以改寫培養寫作能力"></a>以改寫培養寫作能力</h3><p>如果真的不知道怎麼寫，可以從改寫起步。首先熟讀感興趣的論文，再擷取核心觀念以中文重述（若想要省事也可以直接從摘要開始改寫）。</p>
<p>接著，思考想傳達給讀者的訊息，開始移除不必要的內容。例如在介紹飲食跟腸道微生物關係的文章裡，不需要用大半篇幅解釋 PCA ，重點是讓讀者明白吃肉的人吃素的人，腸道裡的微生物有什麼差異。</p>
<p>由於術語、抽象詞和簡稱會造成困惑，所以可以用代稱、範例和比喻等技巧減輕讀者的負擔。例如以下這段截自維基百科的句子便含有許多難解的詞彙：</p>
<blockquote>
<p><strong>枯草桿菌（學名：Bacillus subtilis）</strong>，是<strong>芽孢桿菌屬</strong>的一種細菌，為<strong>革蘭氏陽性</strong>的好氣性菌，普遍存在於土壤及植物體表，在人體亦可發現在腸道內共生的枯草桿菌。型態上的主要特徵是菌體表面生有<strong>鞭毛</strong>，體內形成的<strong>內生孢子</strong>可抵抗惡劣的外在環境而存活。</p>
</blockquote>
<p>可以改寫為：</p>
<blockquote>
<p>人的肚子裡住著一群長條狀的細菌，叫做 Bacillus subtilis ——就叫它 B 細菌吧。 B 細菌身上有條尾巴，所以可以在肚子裡游來游去。</p>
</blockquote>
<p>在改寫版本裡，用「肚子裡住著」來解釋「共生」（比喻），用 B 細菌替代 Bacillus subtilis 減輕讀者對英文的恐懼（代稱）卻不損害本意。最後以游泳為例，說明鞭毛的功能（範例）。此處用尾巴比喻鞭毛可能造成誤解，所以可以補充鞭毛的照片給讀者正確的印象。</p>
<p>改寫後，能用「因為」、「所以」、「但是」等連接詞完善文章的架構，讓讀者了解此段的用意和前後文關係。而且要顧及讀者的注意力和記憶力，適時總結內容或插入圖片以調整閱讀節奏。</p>
<p>綜上所述，透過改寫培養寫作能力的流程就是：閱讀文獻、決定要旨、篩選內容、改寫文句、理清句子關係、安插小結與圖片。接下來就能分享成品給其他人看，再從回饋中改進自己不足之處了。</p>
<h3 id="可以在哪裡寫科普？"><a href="#可以在哪裡寫科普？" class="headerlink" title="可以在哪裡寫科普？"></a>可以在哪裡寫科普？</h3><p>寫文章難，找到讀者更難，讀者願意給意見則難上加難。儘管讀者的回饋可以促使作者成長，但寫作初期不容易找到知音，此時可以投稿科學月刊、泛科學和科普寫作網路平台等媒體，在與編輯來往的過程中學習。（即使被退稿，也能了解自己與已出版著作的差異。）</p>
<p>除此之外，社群網站也是分享文章的管道。許多組織都會利用社群網站傳遞消息，所以作者也能利用臉書或推特宣傳作品。然而社群媒體適合宣傳，卻不適合保存知識。簡言之，這些網站的內部檢索不友善，對搜尋引擎的支援也不佳，所以不易取用裡頭的資訊。</p>
<p>所以，我認為在個人網頁寫作然後用社群網站推廣，是兼顧知識保存和即時交流的好方法（也可以利用 medium 這樣結合寫文和社交的平台）。而這種方式也非新鮮事，因為在軟體工程的圈子裡，透過撰寫技術文章來自我提升已是常態。</p>
<p>當然，寫作除了養成能力以外，也是建立個人知識品牌的手段。想知道在熟練科普寫作以後，要怎麼拓展自己發言的份量，老師推薦我們讀《知識內容寫作課》。</p>
<h3 id="科普不是終點"><a href="#科普不是終點" class="headerlink" title="科普不是終點"></a>科普不是終點</h3><p>演講後，有同學請教老師怎麼避免想要解釋的衝動。的確，為了達到普及的效果，科普不免要犧牲文章的精確性，所以身為作者，有時難以克制更正內容的渴望。然而，溝通的效率不在於作者說了什麼，而在於讀者接收了多少。如果詳實的說明阻礙交流，那麼科普便喪失其意義了。</p>
<p>不過即使有意掌握文章的深度，初學者該怎麼判斷什麼應該寫進文章呢？老師指出，最好的方式就是在讀者的回饋中養成品味，所以再次強調，寫作的訣竅是練習。</p>
<p>更重要的，科普不是終點，科普的目標在於承先啟後。讀者終究要放下科普，拿起課本或期刊論文，踏入嚴肅而且冷漠的科學世界。科普作者的職責是為自己的言論負責，在告訴讀者瑰麗想像的同時，也要說明當前研究的限制。因此，只要留下足夠的參考資訊，讀者就能在往後的學習中，逐漸了解當初作者想方設法要告訴他們的，是科學的哪一面。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>即使無法以科普謀生，也值得為了提升能力、宣揚理念與捍衛自己的研究寫作。科普的特性是寫實、有趣和淺顯，寫作前可鎖定讀者以安排內容深淺和用字風格。科普文章也像故事，需要破題和鋪陳，欲傳達的知識若在故事的高潮細述，有助於讓讀者在讀畢後回味無窮。</p>
<p>行文時要留意，內容簡化不代表裝可愛，用字盡可能周詳而不冗贅，抱著分享而非炫耀的心態。吸引讀者之後，若能保持他們的注意力，移除無關或令人困惑的內容，可以大幅增加文章的可讀性。完成作品後可以投稿或刊登在自己的網站上，利己也利人。</p>
<p>若擔心簡化的內容會誤導讀者，可以用註記或參考資訊補充說明。畢竟科普的目的是引領讀者踏入科學世界，只要留下足夠的延伸資訊，讀者終究能從比喻中習得事實。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>writing</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
</search>
