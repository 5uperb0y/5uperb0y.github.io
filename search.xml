<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何使用 hap.py stratification？</title>
      <link href="/using-happy-stratification-for-benchmarking-small-variants/"/>
      <url>/using-happy-stratification-for-benchmarking-small-variants/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基因體結構會影響變異分析的效度。舉例來說，在 homopolymer 或是 segmental duplicate 區域，依賴 PCR 的 Indel 分析準確性往往低於其他區域 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Olson et al. (2022). PrecisionFDA Truth Challenge V2: Calling variants from short and long reads in difficult-to-map regions. Cell genomics, 2(5).">1</span></a></sup>。因此，若能針對基因體不同區域個別評估效度，將有助於了解技術或流程的限制，進而提升效度分析的鑑別度。</p><p>為此，GIAB (Genome in a Bottle consortium) 維護了一系列 BED 檔，記錄基因體上的功能性區域、重複性區域以及高度多樣性區域等。用戶可以使用 <code>hap.py</code> 等工具，配合這些 BED 檔來評估其分析流程在各個區域的表現。</p><span id="more"></span><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>要分區呈現效度分析結果，首先得準備一份 BED 檔。這個檔案每一列都記錄一個基因體區域，四個欄位分別表示染色體名稱 (chrom)、起始位置 (start)<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="BED 檔的座標是從 0 開始計算。">3</span></a></sup>、結束位置 (end) 以及區域名稱 (name)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr1    90 110 intron</span><br><span class="line">chr1    290 310 exon</span><br></pre></td></tr></table></figure><p>在執行 <code>hap.py</code> 時，需要添加 <code>--stratification-region &lt;tag&gt;:&lt;bed&gt;</code> 選項來讀取 BED 檔。其中 <code>&lt;bed&gt;</code> 是指 BED 檔的存放路徑，<code>&lt;tag&gt;</code> 則用於標示這些區域的分類，例如我們可以用 functional_regions 來代表 intron 和 exon 兩類區域。範例的指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hap.py truth.vcf query.vcf\</span><br><span class="line">    -o output_prefix\</span><br><span class="line">    -r reference.fa\</span><br><span class="line">    --stratification-region functional_regions:input.bed</span><br></pre></td></tr></table></figure><p>分析結果會記錄在 <code>*extended.csv</code>，用戶可以依據 “Subset” 欄位來篩選想關注的區域。”Subset” 的格式為 <code>&lt;tag&gt;_&lt;name&gt;</code>，結合了分類標籤與區域名稱。</p><table><thead><tr><th>Type</th><th>Subset</th></tr></thead><tbody><tr><td>SNP</td><td>functional_regions</td></tr><tr><td>SNP</td><td>functional_regions_intron</td></tr><tr><td>SNP</td><td>functional_regions_exon</td></tr></tbody></table><p>如果提供的 BED 檔沒有標記區域名稱，那麼整份檔案會被視為相同區域，”Subset” 將只會顯示 <code>&lt;tag&gt;</code>。</p><table><thead><tr><th>Type</th><th>Subset</th></tr></thead><tbody><tr><td>SNP</td><td>functional_regions</td></tr></tbody></table><h1 id="Confident-regions-和-stratification-regions-有什麼差異？"><a href="#Confident-regions-和-stratification-regions-有什麼差異？" class="headerlink" title="Confident regions 和 stratification regions 有什麼差異？"></a>Confident regions 和 stratification regions 有什麼差異？</h1><p>Confident regions 和 stratification regions 的用途與定位不同。</p><p>Confident regions 用於界定可靠的分析範圍。由於定序與分析技術限制，即使經過嚴格品管與專家審查，仍無法確保某些區域發現的變異是否可靠。因此，GIAB 在建立 benchmark VCF 時，基於先驗知識排除了高度重複或含有結構變異的片段，定義出所謂的 high confident regions。</p><p>用戶可以透過 <code>-f/--false-positives &lt;bed&gt;</code> 指定這些區域，來限縮效度分析的範圍，唯有位在這些區域的變異會納入比較。</p><p>Stratification regions 則反映了比較的對象。用戶可以透過 <code>--stratification-region &lt;tag&gt;:&lt;bed&gt;</code> 呈現不同區域的效度分析結果。</p><p>換句話說，<code>-f/--false-positives</code> 影響資料篩選，<code>--stratification-regions</code> 則影響結果呈現。當同時指定這兩個選項時，<code>hap.py</code> 會先挑出 confident regions 內的變異來計算效度指標，再根據 stratification regions 呈現各區域的分析結果。</p><p>值得留意的是，即使 stratification regions 和 cofident regions 沒有交集，最終結果仍會完整呈現 stratification regions 所有區域的效度指標值。</p><p>舉例來說，假設我們以兩個內容相同的 VCF 檔作為 <code>truth.vcf</code> 和 <code>query.vcf</code>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr1100var1AC1000PASS.GT0/1</span><br><span class="line">chr1300var2TG1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>同時也定義了涵蓋這些變異的 Stratification regions。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr1    90 110 intron</span><br><span class="line">chr1    290 310 exon</span><br></pre></td></tr></table></figure><p>如果 confident regions 介於一號染色體第 50 到 250 個鹼基之間，那麼 var2（以及 exon）不在 confident region 範圍內，所以不會納入效度計算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr1    50 250  </span><br></pre></td></tr></table></figure><p>然而，<code>hap.py</code> 仍會完整呈現所有 stratification regions 的效度統計量。</p><table><thead><tr><th>Type</th><th>Subset</th><th>TRUTH.TOTAL</th><th>TRUTH.TP</th></tr></thead><tbody><tr><td>SNP</td><td>functional_regions</td><td>1</td><td>1</td></tr><tr><td>SNP</td><td>functional_regions_intron</td><td>1</td><td>1</td></tr><tr><td>SNP</td><td>functional_regions_exon</td><td>0</td><td>0</td></tr></tbody></table><h1 id="批次執行"><a href="#批次執行" class="headerlink" title="批次執行"></a>批次執行</h1><p><code>hap.py</code> 也支援批次分析，用戶需要準備一個 TSV 檔，在第一欄標註 <code>&lt;tag&gt;</code>，並在第二欄提供 <code>&lt;bed&gt;</code> 對應路徑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">functional_regions  functional_regions_regions.bed</span><br><span class="line">mappability mappability_regions.bed</span><br></pre></td></tr></table></figure><p>接著執行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hap.py truth.vcf query.vcf\</span><br><span class="line">    -o output_prefix\</span><br><span class="line">    -r reference.fa\</span><br><span class="line">    --stratification stratification.tsv</span><br></pre></td></tr></table></figure><p>便能獲得以下分析結果。<code>&lt;tag&gt;</code> 的用途在批次分析時更為明顯，它能幫助用戶區別基因區域的分類。</p><table><thead><tr><th>Type</th><th>Subset</th></tr></thead><tbody><tr><td>SNP</td><td>functional_regions</td></tr><tr><td>SNP</td><td>functional_regions_intron</td></tr><tr><td>SNP</td><td>functional_regions_exon</td></tr><tr><td>SNP</td><td>mappability</td></tr><tr><td>SNP</td><td>mappability_easy</td></tr><tr><td>SNP</td><td>mappability_hard</td></tr></tbody></table><p>如同單一 BED 檔的分析，如果沒有標註區域名稱，那麼整個 BED 檔案都會視為同樣區域。</p><h1 id="GIAB-genome-stratifications"><a href="#GIAB-genome-stratifications" class="headerlink" title="GIAB genome stratifications"></a>GIAB genome stratifications</h1><p>GIAB 提供多種 <a href="https://github.com/genome-in-a-bottle/genome-stratifications">BED 檔</a>，涵蓋了低複雜度、XY染色體、GC比例較高等性質不同的區域，這些都是現有技術較難準確分析的地方。</p><p>GIAB 也合併前述區域為 Union BED 檔，只分為 difficult 和 non-difficult 兩類，能較直觀地評估分析流程在具挑戰性區域的表現。</p><p>用戶能從 <a href="https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release/genome-stratifications/">GIAB 的資料庫</a> 下載對應版本與參考基因體的 BED 檔案，再從 Github 取得<a href="https://github.com/genome-in-a-bottle/genome-stratifications">批次分析的 TSV 檔</a>。</p><p>由於這些 BED 檔較大，建議挑選必要的內容下載，自己編輯批次檔來執行較為便利。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Olson et al. (2022). PrecisionFDA Truth Challenge V2: Calling variants from short and long reads in difficult-to-map regions. Cell genomics, 2(5).<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Dwarshuis et al. (2024). The GIAB genomic stratifications resource for human reference genomes. Nature Communications, 15(1), 9029.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">BED 檔的座標是從 0 開始計算。<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轉換 VCF 檔染色體命名慣例</title>
      <link href="/convert-vcf-chromosome-notation-conventions/"/>
      <url>/convert-vcf-chromosome-notation-conventions/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>VCF 檔中的 <code>##contig=&lt;ID=*,lenth=*&gt;</code> 記錄了參考基因體所有染色體的名稱和長度等資訊，而 <code>CHROM</code> 欄位則標示變異所在的染色體。目前，染色體名稱有 UCSC （<code>chr</code> + 染色體編號，例如：<code>chr1</code>和 <code>chrX</code>）和 Ensembl （沒有前綴，僅有染色體編碼，例如：<code>1</code> 和 <code>X</code>）兩種慣例。執行分析時， 如果輸入的 VCF 檔和對應的參考資料採用相異命名慣例，往往會導致分析結果失真。</p><p>舉例來說，GIAB 提供的 VCF 檔是評估變異分析常用的資料。這些 VCF 檔採用 Ensembl 慣例，如果拿 UCSC 慣例的 VCF 檔和它們比較，程式會以為沒有找到這些變異。因此，執行分析時，常常要調整染色體名稱，確保分析結果正確。</p><p>本文簡介使用 linux sed 和 bcftools 轉換 VCF 檔染色體命名慣例的方式。</p><span id="more"></span><h1 id="範例資料：分別採用-UCSC-和-Ensembl-慣例的-VCF-檔"><a href="#範例資料：分別採用-UCSC-和-Ensembl-慣例的-VCF-檔" class="headerlink" title="範例資料：分別採用 UCSC 和 Ensembl 慣例的 VCF 檔"></a>範例資料：分別採用 UCSC 和 Ensembl 慣例的 VCF 檔</h1><p><code>ucsc.vcf</code>，UCSC 慣例會在染色體名稱加上 <code>chr</code> 前綴，粒線體基因則命名為 <code>chrM</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##fileformat=VCFv4.2</span><br><span class="line">##contig=&lt;ID=chr1&gt;</span><br><span class="line">##contig=&lt;ID=chrM&gt;</span><br><span class="line">#CHROM    POS    ID    REF    ALT    QUAL    FILTER    INFO    FORMAT    test</span><br><span class="line">chr1    100    .    T    C    100    PASS    .    .    .</span><br><span class="line">chrM    100    .    T    C    100    PASS    .    .    .</span><br></pre></td></tr></table></figure><p><code>ensembl.vcf</code>，Ensembl 慣例只標記染色體名稱，粒線體基因則命名為 <code>MT</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##fileformat=VCFv4.2</span><br><span class="line">##contig=&lt;ID=1&gt;</span><br><span class="line">##contig=&lt;ID=MT&gt;</span><br><span class="line">#CHROM    POS    ID    REF    ALT    QUAL    FILTER    INFO    FORMAT    test</span><br><span class="line">1    100    .    T    C    100    PASS    .    .    .</span><br><span class="line">MT    100    .    T    C    100    PASS    .    .    .</span><br></pre></td></tr></table></figure><p>除了 <code>CHROM</code>，轉換慣例時也要一併異動 <code>##contig=&lt;ID=*</code> 的格式。許多軟體（例如 GATK）會檢查兩者是否相符，如果 <code>##contig=&lt;ID=*&gt;</code> 含有 <code>CHROM</code> 不存在的染色體（反之亦然）就會報錯。</p><h1 id="使用-sed-轉換染色體命名慣例"><a href="#使用-sed-轉換染色體命名慣例" class="headerlink" title="使用 sed 轉換染色體命名慣例"></a>使用 <code>sed</code> 轉換染色體命名慣例</h1><p>我們可以使用 <code>sed</code> 添加或是刪除 <code>chr</code> 來轉換命名慣例。使用時要注意替換字串的順序和模式。舉例來說，從 UCSC 轉換為 Ensembl 慣例時，如果先把 VCF 檔內所有的 <code>chr</code> 移除，那麼調整粒線體基因名稱時要把 <code>M</code> 改成 <code>MT</code>。然而，<code>M</code> 可能配對到太多字符，所以需要新增其它判斷的根據。</p><h2 id="UCSC-Ensembl"><a href="#UCSC-Ensembl" class="headerlink" title="UCSC -&gt; Ensembl"></a>UCSC -&gt; Ensembl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat ucsc.vcf |\</span><br><span class="line">sed &#x27;</span><br><span class="line">  s/##contig=&lt;ID=chrM/##contig=MT/;</span><br><span class="line">  s/^chrM/MT/;</span><br><span class="line">  s/^chr//;</span><br><span class="line">  s/##contig=&lt;ID=chr/##contig=&lt;ID=/&#x27;</span><br></pre></td></tr></table></figure><h2 id="Ensembl-UCSC"><a href="#Ensembl-UCSC" class="headerlink" title="Ensembl -&gt; UCSC"></a>Ensembl -&gt; UCSC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat ensembl.vcf |\</span><br><span class="line">sed &#x27;s/^\([0-9XYM]\)/chr\1/;</span><br><span class="line">  s/^chrMT/chrM/;</span><br><span class="line">  s/^##contig=&lt;ID=/##contig=&lt;ID=chr/;</span><br><span class="line">  s/^##contig=&lt;ID=chrMT/##contig=&lt;ID=chrM/&#x27; </span><br></pre></td></tr></table></figure><h1 id="使用-bcftools-轉換染色體命名慣例"><a href="#使用-bcftools-轉換染色體命名慣例" class="headerlink" title="使用 bcftools 轉換染色體命名慣例"></a>使用 <code>bcftools</code> 轉換染色體命名慣例</h1><p><code>bcftools annotate</code> 會依據用戶提供的命名格式辭典，同時更新 <code>##contig=&lt;ID=*&gt;</code> 和 <code>CHROM</code> 的紀錄。例如：</p><p><code>ucsc_to_ensembl.tsv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr1    1</span><br><span class="line">chrM    MT</span><br></pre></td></tr></table></figure><p>以及</p><p><code>ensembl_to_ucsc.tsv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1    chr1</span><br><span class="line">MT    chrM</span><br></pre></td></tr></table></figure><h2 id="UCSC-Ensembl-1"><a href="#UCSC-Ensembl-1" class="headerlink" title="UCSC -&gt; Ensembl"></a>UCSC -&gt; Ensembl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools annotate --rename-chrs ucsc_to_ensembl.tsv ucsc.vcf</span><br></pre></td></tr></table></figure><h2 id="Ensembl-UCSC-1"><a href="#Ensembl-UCSC-1" class="headerlink" title="Ensembl -&gt; UCSC"></a>Ensembl -&gt; UCSC</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools annotate --rename-chrs ensembl_to_ucsc.tsv ensembl.vcf</span><br></pre></td></tr></table></figure><h1 id="如果你拿到的是壓縮過的-VCF-檔"><a href="#如果你拿到的是壓縮過的-VCF-檔" class="headerlink" title="如果你拿到的是壓縮過的 VCF 檔"></a>如果你拿到的是壓縮過的 VCF 檔</h1><p>前述案例都是處理未壓縮的 VCF 檔，但實務上為了節省空間和時間都會事先壓縮 VCF 檔為 <code>vcf.gz</code>，並且用索引檔加速後續的資料處理。</p><p>調整 <code>vcf.gz</code> 的染色體命名慣例的步驟為解壓縮、調整格式、壓縮和索引，程式碼範例如下，記得把 <code>&lt;commands&gt;</code> 部分替換成對應的 <code>sed</code> 指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解壓縮 vcf.gz 以執行資料處理，隨後再壓縮</span></span><br><span class="line">zcat &lt;input.vcf.gz&gt; |\</span><br><span class="line">&lt;commands&gt; |\</span><br><span class="line">bcftools -o &lt;output.vcf.gz&gt; -O z</span><br><span class="line"><span class="comment"># 為更新後的 vcf.gz 建立索引檔</span></span><br><span class="line">bcftools index -t &lt;output.vcf.gz&gt;</span><br></pre></td></tr></table></figure><p><code>bcftools annotate</code> 可以直接處理並輸出壓縮的 VCF 檔，但最後還是要自行建立索引檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UCSC to Ensembl</span></span><br><span class="line">bcftools annotate --rename-chrs ucsc_to_ensembl.tsv ucsc.vcf.gz -O z -o ensembl.vcf.gz</span><br><span class="line">bcftools index -t ensembl.vcf.gz <span class="comment"># 會產出 ensembl.vcf.gz.tbi</span></span><br><span class="line"><span class="comment"># Ensembl to UCSC</span></span><br><span class="line">bcftools annotate --rename-chrs ensembl_to_ucsc.tsv ensembl.vcf.gz -O z -o ucsc.vcf.gz</span><br><span class="line">bcftools index -t ucsc.vcf.gz <span class="comment"># 會產出 ucsc.vcf.gz.tbi</span></span><br></pre></td></tr></table></figure><h1 id="延伸資訊"><a href="#延伸資訊" class="headerlink" title="延伸資訊"></a>延伸資訊</h1><ul><li><a href="https://www.biostars.org/p/98582/">VCF files: Change Chromosome Notation</a>：Biostar 上的討論了用 awk、sed、bcftools 等轉換染色體命名慣例的途徑。</li><li><a href="https://genome.ucsc.edu/FAQ/FAQgenes.html#ens">What are Ensembl and GENCODE and is there a difference?</a>：UCSC 的網站介紹了他們和 Ensembl 的染色體命名慣例差異。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Edit Distance Alignment (EDTA)</title>
      <link href="/edit-distance-alignment/"/>
      <url>/edit-distance-alignment/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>比對兩蛋白質字串，計算其最小編輯距離，並以橫槓表示間隔呈現比對結果。</p><blockquote><p>Given: Two protein strings s and t in FASTA format (with each string having length at most 1000 aa).</p><p>Return: The edit distance dE(s,t) followed by two augmented strings s′ and t′ representing an optimal alignment of s and t.</p></blockquote><p>(<a href="https://rosalind.info/problems/edta/">https://rosalind.info/problems/edta/</a>)</p><span id="more"></span><h2 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h2><p>在生物資訊學中，字串比對 (alignment) 的目的是確定兩條字串的字符間有意義的對應關係。字符的關係（例如匹配、替換、插入與刪除）反映了基因突變或定序錯誤等現象，透過比對蛋白質或核酸序列，能識別兩序列相似的片段，從而推論生物的功能、結構和演化關係。比對的結果通常以矩陣、圖示或字串形式呈現，以便研究人員比較各區域的異同。舉例來說，兩條蛋白質序列可表示為以下形式，其中 “-“ 表示間隔 (gap)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ref:  PRETT-</span><br><span class="line">read: PR-TTY</span><br></pre></td></tr></table></figure><p>BAM 檔則以更簡約的 CIGAR 格式呈現，以下文字表示輸入序列與參考序列相比，依序有「2bp 匹配、1bp 刪除、2bp 匹配、1bp 插入」。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2M1D2M1I</span><br></pre></td></tr></table></figure><p>長序列的比對則能以 Dotplot 則能呈現，例如：</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/3/33/Zinc-finger-dot-plot.png"><br>(以 dotplot 呈現兩條 DNA 序列各片段的相似性。圖&#x2F;wikipedia)</p><p>序列比對的方法可以依據其範圍分為全域比對 (global alignment) 和局部比對 (local alignment)。全域比對確認整段序列的關係，強調整體的相似性；局部比對則尋找彼此對應的子序列，只著重序列間相似的片段。因此，全域比對適合比較長度相近且序列相似的同源序列，局部比對則能應用在序列歧異或長度有很大落差的序列。</p><p>一對序列可能存在多種比對方式，各自的差異可用編輯距離 (edit distance or Levenshtein distance) 衡量。編輯距離是一字串經過系列編輯操作轉變為另一字串的最少操作次數，這些操作包含替換、刪除與插入。生物體內各類突變的發生機率並不相同，計算編輯距離時也需要依據採用的演化模型對不同編輯操作進行加權，以吻合我們對這些分子生物機制的理解和假設。<a href="https://en.wikipedia.org/wiki/BLOSUM">BLOSUM</a> 便依據資料庫內不同胺基酸互相轉換的比率，訂立各類替換事件的加權分數。</p><h2 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h2><p>這題要求計算兩條蛋白質序列的編輯距離，並以字串呈現全域比對的結果。先前我曾介紹如何用<a href="https://5uperb0y.com/edit-distance/">動態規劃計算編輯距離</a>。簡言之，這方法一次只考慮一個字符，判斷轉換當前兩條子序列所需的最簡操作來計算編輯距離。接著，比對下一個字符，並重複此過程直到算出完整序列的編輯距離。為了避免重複計算，這方法會記錄子序列間的編輯距離。</p><p>這方法在計算編輯距離的同時，也完成了序列比對。因此，我們只要像記錄編輯距離一樣，保留每次選擇的操作（例如插入、刪除或替換），最後就能據此重建比對結果。</p><h2 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h2><p>為了重建比對結果，我擴充了原先計算編輯距離的<a href="https://github.com/5uperb0y/rosalind/blob/main/code/edit/edit.py">程式碼</a>，新增了每一步的編輯操作紀錄。首先建立兩個用雙層嵌套 list 來模擬的表格：<code>dists</code> 記錄 <code>S</code> 和 <code>T</code> 各子字串的最小編輯距離，<code>edits</code> 則記錄對應的操作（”0”：匹配&#x2F;替換，”1”：插入，”2”：刪除）。假設 <code>S</code> 是參考序列，<code>T</code> 是對應序列。那麼，「刪除」表示 <code>S</code> 長度增長，而 <code>T</code> 長度不變，對應 <code>dists[s + 1][t]</code>；「插入」表示 <code>T</code> 長度增長，而 <code>S</code> 長度不變，對應 <code>dists[s][t + 1]</code>。</p><p>因此，初始化表格的時候，<code>edits[s][0]</code> 全為 2（刪除），<code>edits[0][t]</code> 全為 1（插入）。</p><p>計算完編輯距離後，可以參照 <code>edits</code> 從表格最右下角的位置 <code>edits[len(S)][len(T)]</code> 開始，依照編輯操作重建比對結果。我使用 <code>x</code> 和 <code>y</code> 追蹤當前的位置，並依據 <code>edits[x][y]</code> 的值決定下一步操作：</p><ul><li><code>edit[x][y] == 0</code> 表示「匹配&#x2F;替換」，<code>S[x]</code> 對應 <code>T[y]</code>，接著比對 <code>S[x - 1]</code> 和 <code>T[y - 1]</code>。</li><li><code>edit[x][y] == 1</code> 表示「插入」，”-“ 對應 <code>T[y]</code>，接著比對 <code>S[x - 1]</code> 和 <code>T[y]</code>。</li><li><code>edit[x][y] == 2</code> 表示「刪除」，<code>S[x]</code> 對應 “-“，接續比對 <code>S[x]</code> 和 <code>T[y - 1]</code>。</li></ul><p>為了簡化重建流程，我把下一個要比對的位置記錄在 <code>moves = [(1, 1), (0, 1), (1, 0)]</code>，依序為「匹配&#x2F;替換」、「插入」和「刪除」，所以我能用 <code>edits[x][y]</code> 的值來取得對應操作，並用來更新 x 和 y 的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">align</span>(<span class="params">S, T</span>):</span><br><span class="line">dists = [ [<span class="number">0</span>] * (<span class="built_in">len</span>(T) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S) + <span class="number">1</span>) ]</span><br><span class="line">edits = [ [-<span class="number">1</span>] * (<span class="built_in">len</span>(T) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S) + <span class="number">1</span>) ] <span class="comment"># 0: match, 1: insertion, 2: deletion</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(S) + <span class="number">1</span>):</span><br><span class="line">dists[s][<span class="number">0</span>] = s</span><br><span class="line">edits[s][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(T) + <span class="number">1</span>):</span><br><span class="line">dists[<span class="number">0</span>][t] = t</span><br><span class="line">edits[<span class="number">0</span>][t] = <span class="number">1</span></span><br><span class="line"><span class="comment"># Fill DP tables</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line"><span class="keyword">if</span> S[s] == T[t]:</span><br><span class="line">dists[s + <span class="number">1</span>][t + <span class="number">1</span>] = dists[s][t]</span><br><span class="line">edits[s + <span class="number">1</span>][t + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">choices = [dists[s][t], dists[s + <span class="number">1</span>][t], dists[s][t + <span class="number">1</span>]]</span><br><span class="line">dists[s + <span class="number">1</span>][t + <span class="number">1</span>] = <span class="built_in">min</span>(choices) + <span class="number">1</span></span><br><span class="line">edits[s + <span class="number">1</span>][t + <span class="number">1</span>] = choices.index(<span class="built_in">min</span>(choices))</span><br><span class="line"><span class="comment"># Reconstruct aligned sequences</span></span><br><span class="line">aln_s, aln_t = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">x, y = <span class="built_in">len</span>(S), <span class="built_in">len</span>(T)</span><br><span class="line">moves = [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)] <span class="comment"># [match, insertion, deletion]</span></span><br><span class="line"><span class="keyword">while</span> edits[x][y] &gt;= <span class="number">0</span>:</span><br><span class="line">move_x, move_y = moves[edits[x][y]]</span><br><span class="line">aln_s = (S[x - <span class="number">1</span>] <span class="keyword">if</span> move_x <span class="keyword">else</span> <span class="string">&quot;-&quot;</span>) + aln_s</span><br><span class="line">aln_t = (T[y - <span class="number">1</span>] <span class="keyword">if</span> move_y <span class="keyword">else</span> <span class="string">&quot;-&quot;</span>) + aln_t</span><br><span class="line">x, y = x - move_x, y - move_y</span><br><span class="line"><span class="keyword">return</span>([<span class="built_in">str</span>(dists[-<span class="number">1</span>][-<span class="number">1</span>]), aln_s, aln_t])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 hap.py 評估小片段變異分析的效度？</title>
      <link href="/the-hitchhikers-guide-to-benchmarking-small-variant-calling-with-happy/"/>
      <url>/the-hitchhikers-guide-to-benchmarking-small-variant-calling-with-happy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>hap.py</strong> 是比較 VCF 的工具，常配合標準資料集來評估變異分析的效度，它整合了資料處理、集合運算與指標統計等功能，方便用戶解決效度評估常見的問題。</p><span id="more"></span><h1 id="急用的時候讀這裡"><a href="#急用的時候讀這裡" class="headerlink" title="急用的時候讀這裡"></a>急用的時候讀這裡</h1><p>準備 <code>truth.vcf</code>、<code>query.vcf</code>、<code>reference.fa</code>、<code>reference.fa.fai</code>、<code>confident.bed</code> 放入工作目錄，下載並進入 hap.py 分析環境，執行腳本後檢查結果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull quay.io/biocontainers/hap.py:0.3.15--py27hcb73b3d_0</span><br><span class="line">$ docker run -it -v &lt;/path/to/workdir&gt;:&lt;/path/to/workdir&gt; -w &lt;/path/to/workdir&gt; quay.io/biocontainers/hap.py:0.3.15--py27hcb73b3d_0 bash</span><br><span class="line">$ hap.py truth.vcf query.vcf -f confident.bed -o output_prefix -r reference.fa</span><br><span class="line">$ awk <span class="string">&#x27;&#123;print $1,$14&#125;&#x27;</span> output_prefix.summary</span><br><span class="line"></span><br><span class="line">Type  METRIC.F1_Score </span><br><span class="line"></span><br><span class="line">INDEL 0.5                ← 😫 結果很不好</span><br><span class="line"></span><br><span class="line">SNP   1                  ← 😁 結果非常好</span><br></pre></td></tr></table></figure><p>等待程式運算期間可以泡杯咖啡繼續讀，了解 hap.py 的用途與結果詮釋。</p><h1 id="想比較-VCFs-的話，為什麼不直接取交集和差集？"><a href="#想比較-VCFs-的話，為什麼不直接取交集和差集？" class="headerlink" title="想比較 VCFs 的話，為什麼不直接取交集和差集？"></a>想比較 VCFs 的話，為什麼不直接取交集和差集？</h1><p>因為相同變異可能有不同的表示方式，所以變異間非一一對應關係，若僅取交集和差集會錯估變異分析的效度，例如：</p><h2 id="multi-allelic-vs-bi-allelic-variants"><a href="#multi-allelic-vs-bi-allelic-variants" class="headerlink" title="multi-allelic vs. bi-allelic variants"></a>multi-allelic vs. bi-allelic variants</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TG,C1000PASS.GT2/1</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TC1000PASS.GT0/1</span><br><span class="line">chr120000.TG1000PASS.GT0/1</span><br></pre></td></tr></table></figure><h2 id="multiple-SNVs-vs-single-MNV"><a href="#multiple-SNVs-vs-single-MNV" class="headerlink" title="multiple SNVs vs. single MNV"></a>multiple SNVs vs. single MNV</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TCCA1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TC1000PASS.GT0/1</span><br><span class="line">chr120001.CA1000PASS.GT0/1</span><br></pre></td></tr></table></figure><h2 id="left-aligned-Indels-vs-right-aligned-Indels"><a href="#left-aligned-Indels-vs-right-aligned-Indels" class="headerlink" title="left-aligned Indels vs. right-aligned Indels"></a>left-aligned Indels vs. right-aligned Indels</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr120002.TCCTTCT1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr120001.TCT1000PASS.GT0/1</span><br></pre></td></tr></table></figure><h2 id="multiple-short-Indels-vs-single-long-Indel"><a href="#multiple-short-Indels-vs-single-long-Indel" class="headerlink" title="multiple short Indels vs. single long Indel"></a>multiple short Indels vs. single long Indel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ref:   TC-C-TG</span><br><span class="line"># input: TCTCCTG</span><br><span class="line">chr120001.CCT1000PASS.GT0/1</span><br><span class="line">chr120002.CCC1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ref:   T--CCTG</span><br><span class="line"># input: TCTCCTG</span><br><span class="line">chr120000.TTCT1000PASS.GT0/1</span><br></pre></td></tr></table></figure><h1 id="具體來說，hap-py-是什麼？"><a href="#具體來說，hap-py-是什麼？" class="headerlink" title="具體來說，hap.py 是什麼？"></a>具體來說，hap.py 是什麼？</h1><p>hap.py ≈ vcf preprocessor + comparison engine + metric summarizer</p><ul><li>vcf prprocessor：統一 VCF 格式，標準化變異表示法，方便比較引擎運作</li><li>comparison engine：考量變異表示法差異，正確統計混淆矩陣的各項元素（true positive, false positive, false negative）</li><li>metric sumarizer：依照混淆矩陣計算精準度、召回率和 F1 score 等效度指標。</li></ul><h1 id="使用-hap-py-需要準備什麼？"><a href="#使用-hap-py-需要準備什麼？" class="headerlink" title="使用 hap.py 需要準備什麼？"></a>使用 hap.py 需要準備什麼？</h1><ul><li><code>truth.vcf</code> 記錄了你認為可靠的變異，用以和 query.vcf 比較。經過 Genome in a Bottle (GIAB) Consortium 認證的變異資料集可在 <a href="https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release/">NCBI FTP 資料庫</a>下載。</li><li><code>query.vcf</code> 是你打算評估的 VCF 檔，標頭至少要含有 VCF 格式版本 (<code>##fileformat</code>)、contigs（<code>##contig=&lt;...&gt;</code>）、genotype（<code>##FORMAT=&lt;ID=GT,...&gt;</code>）及欄位名稱（<code>#CHROM ...</code>）。</li><li><code>confident.bed</code> 記錄了你要求 hap.py 檢查的基因體區域，這些區域以外的變異會標記為 UNK，不納入效度計算。”confident” 這名稱沿襲 GIAB 的慣例，位於 confident region 的變異經多項技術驗證，任何額外或遺漏的變異皆可視為誤報。</li><li><code>reference.fa</code> &amp; <code>reference.fa.fai</code> 是變異分析使用的參考基因體及其索引檔。<code>hap.py</code> 需要這些資訊來依據基因體區域計算效度，還有計算 het-hom 與 Ti&#x2F;Tv ratio 等品管指標。因此，要使用生成 truth.vcf 和 query.vcf 的參考基因體版本。</li><li><code>hap.py</code> &amp; its environment 可以參考<a href="https://github.com/Illumina/hap.py?tab=readme-ov-file#installation">官方教學</a>安裝，或是使用 biocontainer 上的 <a href="https://biocontainers.pro/tools/hap.py">image</a>。dockerhub 也有一份 <a href="https://hub.docker.com/r/pkrusche/hap.py?ref=https://githubhelp.com">image</a> ，可是已數年沒有更新，所以內容落後 hap.py 的教學文件。</li></ul><p>執行分析前可以檢查一下 truth.vcf 和 query.vcf 的染色體表示法是否一致（<code>chrX</code> or <code>X</code>）、標頭內容和 INFO 欄位是否匹配，這些都是 hap.py 報錯的常見原因。</p><h1 id="如何解讀結果？"><a href="#如何解讀結果？" class="headerlink" title="如何解讀結果？"></a>如何解讀結果？</h1><p>hap.py 會在你使用 <code>-o</code> 指定的目錄輸出比對結果。精確度、召回率與 F1 score 等校度統計量紀錄在 <code>*.summary.csv</code>，其它次要的統計量則保留在 <code>*.extended.csv</code>。</p><p><code>*.summary.csv</code> 的欄位可分為數據分層和效度指標兩類，我習慣先看 Type 和 METRIC.F1_Score，只要 SNV 和 INDEL 的 F1 score 接近 1，那麼大家都會幸福。</p><table><thead><tr><th>Type</th><th>METRIC.F1_Score</th></tr></thead><tbody><tr><td>INDEL</td><td>0.99</td></tr><tr><td>SNP</td><td>0.99</td></tr></tbody></table><h2 id="數據分層-Stratification"><a href="#數據分層-Stratification" class="headerlink" title="數據分層 (Stratification)"></a>數據分層 (Stratification)</h2><p>用戶能要求 hap.py 獨立計算特定類別的變異之效度指標。因此，如果想更仔細檢驗分析結果，可以先查看數據分層的方式（詳情參考 <a href="https://github.com/Illumina/hap.py/blob/master/doc/happy.md#introduction">hap.py 的官方簡介</a>）。</p><ul><li><strong>Type</strong>：目前，hap.py 支援 SNV 和 INDEL 的效度評估，暫時沒有其它變異類型。</li><li><strong>Subtype</strong>：SNV 可細分為 transition （腺嘌呤與鳥糞嘌呤，胞嘧啶與胸腺嘧啶互換）和 transversion（嘌呤與嘧啶互換），INDEL 也有不同長度片段的插入與刪除。</li><li><strong>Filter</strong>：hap.py 能依據 VCF 檔 FILTER 欄位，獨立列出數值為 PASS 的變異之效度指標。比較合格與全數變異的效度指標，便能評估變異品管的成效。</li><li><strong>Subset</strong>：如果使用 <code>--stratification-region &lt;BED&gt;</code> 要求 hap.py 獨立計算特定區域的效度指標，就會在 <code>*extended.vsb</code>  <em>Subset</em> 欄位註記分析結果所屬區域的名稱，這些名稱對應到 BED 檔的 ID 欄（第四欄）。</li></ul><h2 id="混淆矩陣項目-Confusion-matrix-elements"><a href="#混淆矩陣項目-Confusion-matrix-elements" class="headerlink" title="混淆矩陣項目 (Confusion matrix elements)"></a>混淆矩陣項目 (Confusion matrix elements)</h2><p>比對之前，hap.py 會先統一 <code>truth.vcf</code> 和 <code>query.vcf</code> 的格式（例如 #CHROM 是否包含 <code>chr</code>），再標準化 <code>query.vcf</code> 以利比較引擎運作。標準化的方式包含將 MNV 拆分為獨立的 SNV、拆分 multi-allelic 變異、依據基因型合併相同位置的變異等，詳見<a href="https://github.com/Illumina/hap.py/blob/master/doc/normalisation.md">官方文件</a>）。</p><p>hap.py 預設的比較引擎為 <em>xmap</em>，它會考量變異表示法的差異，從而避免低估分析的正確性。假設 <code>truth.vcf</code> 包含一個 MNV，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TCCA1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>標準化之後， <code>query.vcf</code> 會將 MNV 拆分為兩個獨立的 SNV。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr120000.TC1000PASS.GT0/1</span><br><span class="line">chr120001.CA1000PASS.GT0/1</span><br></pre></td></tr></table></figure><p>這兩組 VCF 檔實際上是同一種變異的不同表示方式。如果只取交集會得到空集合，但 <em>xmap</em> 能辨識這種狀況並正確標示出來。</p><ul><li><strong>TRUTH.TP</strong> 是出現於 <code>truth.vcf</code>，而且能在標準化 <code>query.vcf</code> 找到的變異數量。</li><li><strong>QUERY.TP</strong> 是出現於標準化 <code>query.vcf</code>，而且能在<code>truth.vcf</code> 找到的變異數量。</li></ul><p>TRUTH.TP 和 QUERY.TP 的數值有可能不一樣，這是因為在不同表示方式下，變異之間非一一對應。在上述案例中，<code>truth.vcf</code> 的一個 MNV 對應 <code>query.vcf</code> 的兩個 SNV，所以 TRUTH.TP 為 1，QUERY.TP 為 2。除了 MNV 和 SNV，序列比對以及基因型也跟變異的表示法有關。多種要素混合在一起就變得沒那麼直觀，所以我也還沒掌握所有案例。不過，如果對結果有疑慮都可以查看 <code>output_prefix.vcf.gz</code> 的 <em>TRUTH</em> 和 <em>QUERY</em> 欄位。它們註記了變異真偽的判定結果，可以依此推論 hap.py 標準化和比較變異的方式。</p><ul><li><strong>TRUTH.FN</strong>：<code>truth.vcf</code> 獨有的變異數量</li><li><strong>QUERY.FP</strong>：<code>query.vcf</code> 獨有的變異數量</li><li><strong>QUERY.UNK</strong> 是 <code>query.vcf</code> 位在 <em>confident.bed</em> 以外的變異數量。</li><li><strong>TRUTH.TOTAL</strong>：<em>truch.vcf</em> 的變異總數，相當於 <em>TRUTH.TP</em> + <em>TRUTH.FN</em>。</li><li><strong>QUERY.TOTAL</strong>：<code>query.vcf</code> 的變異總數，相當於 <em>QUERY.TP</em> + <em>QUERY.FP</em> + <em>QUERY.UNK</em>。</li></ul><p>hap.py 另外將 FP 分為兩類，但其實很少用到。</p><ul><li><strong>FP.gt</strong>：Genotype errors，相同位置 (<code>POS</code>)、相同變異 (<code>REF</code>&#x2F;<code>ALT</code>)、不同基因型 (<code>GT</code>)，例如 query GT &#x3D; 1&#x2F;1，truth GT &#x3D; 0&#x2F;1。</li><li><strong>FP.al</strong>：Allele errors，相同位置、不同變異、不同基因型。</li></ul><h2 id="效度指標-Accuracy-metrics"><a href="#效度指標-Accuracy-metrics" class="headerlink" title="效度指標 (Accuracy metrics)"></a>效度指標 (Accuracy metrics)</h2><ul><li><strong>METRIC.Recall</strong>：召回率，真實變異被檢出的比率，計算方式為 TRUTH.TP &#x2F; (TRUTH.TP + TRUTH.FN)。評估變異分析的效度時，通常會用多筆 <code>query.vcf</code> 對照單一 <code>truth.vcf</code>。召回率採計 TRUTH.TP 和 TRUTH.FN 以免數值因為 <code>query.vcf</code> 的表示法差異而浮動<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="假設兩組 `query.vcf` 用不同表示方式記錄相同的變異，它們照理要有相同的召回率，所以才會用不受 `query.vcf` 表示法影響的 `truth.vcf` 來計算。">1</span></a></sup>。</li><li><strong>METRIC.Precision</strong>：精準度，檢出變異為真實變異的比率，計算方式為 QUERY.TP &#x2F; (QUERY.TP + QUERY.FP)。</li><li><strong>METRIC.F1_Score</strong>：精準度與召回率的調和平均，計算方式為 2 * METRIC.Recall* METRIC.Precision &#x2F; (METRIC.Recall + METRIC.Precision)。</li><li><strong>METRIC.Frac_NA</strong>：QUERY.UNK &#x2F; QUERY.TOTAL。</li></ul><p>召回率高但精準度低的分析過度寬鬆，納入過多偽變異徒增診斷成本（全部個案都判陽性的檢驗有百分之百的召回率，卻一點用都沒有）；精準度高但召回率低的分析過度保守，遺漏過多真實變異限縮診斷效果（不會報錯卻驗不出真實變異的檢驗也沒什麼用）。F1 score 同時衡量了召回率和精準度，提供更符合直覺的效度估計。F1 score 使用調和平均的理由可以參考 <a href="https://stackoverflow.com/questions/26355942/why-is-the-f-measure-a-harmonic-mean-and-not-an-arithmetic-mean-of-the-precision">why is the f measure a harmonic mean and not an arithmetic mean of the precision</a>。簡言之，調和平均對於差異懸殊數值的權重較低，所以唯有同時確保召回率和精準度，才能取得較高的 F1 score。</p><h2 id="品管指標-Quality-metrics"><a href="#品管指標-Quality-metrics" class="headerlink" title="品管指標 (Quality metrics)"></a>品管指標 (Quality metrics)</h2><p>Ti&#x2F;Tv ratio 和 het&#x2F;hom ratio 是評估變異分析品質的指標，和 <code>truth.vcf</code>&#x2F;<code>query.vcf</code> 的比較無關。這兩種指標在生物基因體內有一定範圍，而且其數值遠高於隨機值。通常，指標數值越高，變異分析的品質也越好。Ti&#x2F;Tv ratio 是 transition 和 transversion 兩種 SNV 數量的比值。假設鹼基發生 transition 和 transversion 的機率一致，那麼 Ti&#x2F;Tv ratio 應該要等於 0.5。因為 transition 有兩種變化途徑，但 transversions 有四種變化途徑，2 比 4 得 0.5。</p><p>依據轉譯密碼表，造成胺基酸變化的突變往往屬於 transversion，這種突變若發生在重要的蛋白質可能導致生物死亡。存在選擇壓力的情況下，生物體的 transversion 數量往往少於 transition，使得基因體的 Ti&#x2F;Tv ratio 遠高於 0.5。人類全基因體定序結果的 Ti&#x2F;Tv ratio 接近 2.1，全外顯子定序的 Ti&#x2F;Tv ratio 接近 3（因為 exon 比 intron 暴露到更多選擇壓力下）。假設定序或分析的錯誤皆為隨機發生，若全基因體變異分析的 Ti&#x2F;Tv ratio 比率遠低於 2.1，便可合理懷疑其中混入了太多隨機發生的錯誤，導致數值偏離預期。</p><p>het&#x2F;hom ratio (heterozygous&#x2F;homozygous variant ratio) 也是基於相似的原理。依據族群遺傳學的哈溫定律，het&#x2F;hom ratio 會等於 2，如果變異分析的結果偏離預期太多，也可能反映了某種錯誤存在。這兩種指標都只能用來評估一整批變異分析的結果，細節可參考 Guo et al. (2014). Three-stage quality control strategies for DNA re-sequencing data. Briefings in bioinformatics, 15(6), 879-889.</p><ul><li><strong>TRUE.TOTAL.TiTv_ratio</strong>：truth.vcf 的 Ti&#x2F;Tv ratio。</li><li><strong>QUERY.TOTAL.TiTv_ratio</strong>：query.vcf 的 Ti&#x2F;Tv ratio。</li><li><strong>TRUTH.TOTAL.het_hom_ratio</strong>：truth.vcf 的 het&#x2F;hom ratio。</li><li><strong>QUERY.TOTAL.het_hom_ratio</strong>：query.vcf 的 het&#x2F;hom ratio。</li></ul><p>在有正確答案的情況下，直接比較 <code>truth.vcf</code> 和 <code>query.vcf</code> 更為直觀且具體。不過，Ti&#x2F;Tv ratio 和 het&#x2F;hom ratio 能作為額外的查核資訊。如果它們的數值和 F1 score 呈不同趨勢，能提醒我們細查資料，確認是否發生非預期的錯誤。</p><h1 id="如果還有興趣，可以研讀以下論文與簡介"><a href="#如果還有興趣，可以研讀以下論文與簡介" class="headerlink" title="如果還有興趣，可以研讀以下論文與簡介"></a>如果還有興趣，可以研讀以下論文與簡介</h1><ul><li><a href="https://medium.com/truwl/demystifying-benchmarking-a-guide-to-germline-variant-calling-metrics-9d6eee4f8e80">Karl Sebby. (2021). Demystifying benchmarking: A guide to germline variant calling metrics.</a>：簡單明瞭的部落格文章，把變異分析效度評估解釋得很清楚。</li><li><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC6699627/">Krusche et al. (2019). Best practices for benchmarking germline small-variant calls in human genomes. Nature biotechnology, 37(5), 555-560.</a>：GA4GH Benchmarking Team 發表的效度分析指引，可以了解變異表示法相關的偏誤，以及各項指標的設計原則。</li><li><a href="https://pmc.ncbi.nlm.nih.gov/articles/instance/6699627/bin/NIHMS1533783-supplement-1.pdf">Supplementary of Krusche et al. (2019)</a>：前一則論文的補充資料，更詳盡地解釋了指標的公式。</li><li><a href="https://github.com/Illumina/hap.py/blob/master/doc/happy.md">Illumina&#x2F;hap.py&#x2F;doc&#x2F;happy.md</a> 以及 <a href="https://github.com/Illumina/hap.py">Illumina&#x2F;hap.py: Haplotype VCF comparison tools.</a>：hap.py 官方手冊，能了解程式具體做了那些處理。</li><li><a href="https://medium.com/dnanexus/benchmarking-state-of-the-art-secondary-variant-calling-pipelines-5472ca6bace7">Yih-Chii Hwang. (2020). Benchmarking state-of-the-art secondary variant calling pipelines.</a>：說明如何進行效度分析的部落格文章。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">假設兩組 <code>query.vcf</code> 用不同表示方式記錄相同的變異，它們照理要有相同的召回率，所以才會用不受 <code>query.vcf</code> 表示法影響的 <code>truth.vcf</code> 來計算。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《美好少女的垂直社會》</title>
      <link href="/wu-2021-the-vertical-society-of-good-girls/"/>
      <url>/wu-2021-the-vertical-society-of-good-girls/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近生活苦悶，想看點富含貼貼的療癒著作，正好這本《美好少女的垂直社會》現身在網路書城的推薦清單。這本書的插畫很美，而且人物也畫得很可愛，目錄除了數字命名的章節以外，只有兩個女孩的名字：江鯉庭和林鳶。</p><p>兩個人！？我想這一定是描寫女孩間純粹美好的友情吧？是那種以各自視角重述彼此接近與曖昧關係，在即將日落的末日世界互相扶持的溫馨故事吧？</p><p>讀完前兩章發現自己大錯特錯，所以決定把此書的筆記分類為 sf。</p><span id="more"></span><p>談到少女心，很容易聯想到天真、浪漫、夢幻等詞彙。然而，這其實是假象。少女不是大眾想像那樣純粹無暇，她們的人際關係也不乏鬥爭、嫉恨與落井下石，只是她們善於偽裝，迎合大眾的喜好以在爭權奪利的社會中生存。《美好少女的垂直社會》的故事發生在因為海平面上升而逐漸被淹破的群島國家。</p><p>政府為了管制僅存的高地，依據體格、智慧、社會貢獻和發展潛能將國民分等。最高等的國民可住在位於高地的複合式住宅──垂直農場，享有人工栽植的飲食與舒適的居住空間；最低等的國民則分配到低地，基礎建設匱乏還面臨淹水危機。</p><p>然而，國民等級會隨季度考核流動。個人的事業、健康與心理狀態皆為考核項目。若未過評鑑，則會被逐出垂直農場，放逐到飽受水災威脅的地區。女性，尤其是少女，是國家重點栽培對象。少女當前雖然無法提供產值，她們年輕的卵子與健康的體格是延續人口的重要資產。</p><p>江鯉庭和林鳶是好朋友，她們在家鄉淹破之後與家人分離，被政府安置到垂直農場的附屬學校。林鳶因為與祖母分離而擔憂，但是江鯉庭卻因為遠離惡毒的母親而高興。不過當江鯉庭踏入校舍之後卻發現，她只是踏入另一個人際地獄。</p><p>在真實世界裡，少女間難免競爭成績、體態、美貌與家世等條件，這種競爭在垂直農場的附屬學校被無限放大。前述所有條件不只影響個人在團體生活的愜意程度，還攸關個人的性命。成績不好又不受歡迎的話，很可能被逐出學校。江鯉庭和林鳶這些氣候難民，都是取代了退學生的位子才得以入學，因此最初並沒人給她們好臉色看。</p><p>校內的社會地位分成上、中、下三等。上等人如垂直農場經營者的女兒金幼鑾，還有附屬學校校長之女馬可薇。她們在校富有聲望，也往往是其他家長或同學羨慕的對象。平凡人則像活在姊姊陰影下的金幼鴻，還有不習慣但不至於生存不下去的林鳶。下等人則是適應不良的人，她們成績差勁，性格也多有令人煩膩之處，是眾人極力避免的交往對象。</p><p>江鯉庭是下等人的代表，其貌不揚的她並沒有與之抵銷的溫和個性。她一方面受人鄙視，自己也鄙視同類人。江鯉庭分配與另一位適應不良者同住，雖然彼此境遇相似，江鯉庭卻沒有同患難的情感，反而想迫切離開過於積極的室友。江鯉庭向室友謊稱身體不舒服，獨自到賣場閒晃。江鯉庭被發現而遭同學質問時，她室友幫忙她說話。不過江鯉庭不屑與室友為伍，主動坦承自己翹課，賣了信任自己的室友。</p><p>江鯉庭在家鄉依賴林鳶，可是林鳶到了垂直農場後卻比自己更融入社群。江鯉庭完全無法適應垂直農場的社會型態，近乎絕望地依賴任何親近自己的人，卻也不斷遭到背叛與利用。校花金幼鸞親近江鯉庭只為了展示自己的寬容與慈愛，校草金長鴿接近江鯉庭只是為了和自己表妹做愛，連被江鯉庭視為唯一救贖的王二董，也只是為了販運人口而照料她。</p><p>多數角色的名字都含有鳥類的名稱，唯有江鯉庭沒有。其他人都能在鳥籠狀的垂直農場勉強生存，江鯉庭這條擱淺陸地的魚只能在小水漥或別人吹出的泡泡中掙扎呼吸，最終被扔上魚市販售。</p><p>書名的「垂直社會」在故事中有多重含意，它既指涉少女們在為了生存，從低漥地擠進位於高處的農場，也要爭取更高的社會地位。無論是底層如江鯉庭想盡辦法擺脫室友，還是高層像金幼鸞攏絡人心和打擊他人以鞏固地位，都是社會地位的競爭。</p><p>另一方面，垂直也是指少女與直系親屬的鬥爭。故事每位少女都有個扭曲的家庭。江鯉庭的母親奉子成婚，被迫在離島過著潦倒生活，常將自己的遺憾怪罪江鯉庭。馬可薇的雙親都是天才，不了解凡人的難處。馬可薇想要爭取雙親的寵溺，只能戰戰競競努力，才不會被他人趕上。金幼鸞的母親依附丈夫才能住在垂直農場，竟把女兒當成競爭對象，透過打擊自己的子女來取得安全感。</p><p>金幼鸞想要擊潰母親，讓她的尊嚴盡失；馬可薇想要母親認同，重獲曾有過的愛；江鯉庭想要逃離母親，不再承受與自己無關的責難。這些人裡面只有林鳶因為隔代教養的緣故，受到祖母完整的愛，並沒有母女間的鬥爭。</p><p>整體來說，這故事其實還是著重少女的人際關係，科幻設定的用途則擴大了人際選擇的代價，讓角色行為更加極端。像故事裡的集團霸凌、明爭暗鬥、拐歪抹角罵人、暗地說壞話之類的破事在社群網站上很常見，甚至生活周遭就能舉好幾個例子。因此，讀這本書的時候，明明沒親自體會，還是有社交疲憊的感覺，會想著「說個話而已，可以不要那麼累嗎？」。</p><p>另外，書中有不少像是章回小說的議論，總結劇情發展、人物關係還有作者看法，能幫助讀者了解故事的主軸，例如：</p><blockquote><p>當一個少女獨處時，那往往是他最真實的狀態。她不需要顧慮其他人看法，不需要擔憂其他人對她尚未生長完全的自尊，指手指腳。落單的少女最容易感覺寂寞，但那往往卻是她最能看透自己、最自由獨立的時刻。</p></blockquote><p>（故事設定裡沒有這種情況，少女被迫擠在宿舍和學校跟其他人競爭。）</p><blockquote><p>當兩個少女親密地成為「我們」時，那是她們彼此最平衡的狀態。她們眼中只有彼此，得以好好陪伴彼此，不受其他人事物所干擾；她們能很直率地付出愛，並感受到對方所給予的愛。</p></blockquote><p>（江鯉庭和林鳶在家鄉的狀態。）</p><blockquote><p>當三位少女成群結黨時，事情就變得複雜了。三是一個最容易讓少女吃醋的數字，總是有那麼一個多餘的、又不小心容易讓人忽視的存在。三等於二加一，沒人想當那個一，那個最容易被排擠的一，卻往往有人會淪落成為那個一。知道小團體秘密的人，最好的數目是二：妳，和對方。祕密說了太多次，容易讓人感覺厭煩，也增加了祕密被洩漏的風險。</p></blockquote><p>（這是金幼鸞、馬可薇和金幼鴻的寢室。）</p><blockquote><p>當四個少女同在一塊兒時，就像蟒蛇孵了一窩蛋；無人知道心懷鬼胎的小蛇們，何時會破殼而出，於是事情總是變得有趣，甚至可稱得上不售控。少女們總是二加二，而她們總會錯認為，誰和誰特別要好是固定的，是鐵打般事實。然則現實中並不是──那個二是流動的，是虛浮的，那個二，在四人小團體中瞬息萬變，沒有人是永遠忠誠的。</p></blockquote><p>（這是描述江鯉庭和林鳶入住金幼鸞寢室後的事情。）</p><blockquote><p>這就是美好少女們的偽裝：越是聰明的少女，越是知道社會之餘她們的期望。當她們哄騙了社會，哄騙了大人，讓他們相信她們本質上的無害，她們就越安全。在成長的過程裡，少女們學會、並習得了最強大的武器：裝出無辜討喜的那面，因為這是人們最想要相信的，相信少女無害，相信少女天真，相信少女單純。於是少女們最擅長於偽裝，演戲。絕對不要相信少女是漫不經心的──漫不經心，不是少女們在垂直社會裡生存下去的法則。</p></blockquote><p>（這段總結故事前半段，少女爭取垂直農場地位的鬥爭。）</p><blockquote><p>一個只知道往上生長的都市，是殘酷的，是欲求不滿的。而少女們身處其中，順著往上長，跟著往上爬，如一朵朵盛開的向陽花。成人們訓練少女表現完美，訓練他們表現順從；而少女們模仿成人，將成人世界裡的規則有模有樣地，移植入他們的世界裡。<br>於是少女天生的美好，那四溢出的甜膩香氛，如奶密，如楓糖，如花汁，掩蓋了成人世界的腥騷與殘酷。她們既甜美，又邪惡，既無辜，又誘惑，既脆弱，又倔強，既溫順，又叛逆。少女們可以既開腿，又闔腿，可以既坦率，卻又滿口謊言。少女們完美，像是這世界爭相搶要得，但她們往往，卻不想要自己。</p></blockquote><h2 id="（這段總結故事後半段，少女光鮮表面背後的悲哀。）"><a href="#（這段總結故事後半段，少女光鮮表面背後的悲哀。）" class="headerlink" title="（這段總結故事後半段，少女光鮮表面背後的悲哀。）"></a>（這段總結故事後半段，少女光鮮表面背後的悲哀。）</h2><p>巫玠竺（2021）。美好少女的垂直社會。鏡文學。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《明日的世界將會星光燦爛 3 》</title>
      <link href="/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-3/"/>
      <url>/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>羽衣、帆乃夏和由貴離開京都回到家之後，便著手研究夜未提供的文獻和紀錄。她們從中推論，若能取得保存在東京魔術師總部的最高權杖，由貴將能發揮百分之百的魔力，擁有對抗巨型屍人的力量。驅車前往東京的路上，她們討論起災變的元兇，羽衣認為眾多證據皆指向帆乃夏的姊姊春香策畫了召喚屍人的儀式。由於帆乃夏不相信姊姊有引發災變的動機，所以反感羽衣的指控。不過更讓帆乃夏焦躁不安的是，如果最敬愛的姊姊是讓世人陷入不幸的元凶，那麼帆乃夏該如何走下一步？</p><span id="more"></span><p>離開東京前，夜未除了提供由貴她們生存物資，還準備了許多文獻與行政紀錄。當中除了魔術師發展史以外，還包含了由貴父親在內的執業紀錄，以及災變發生後一段時間蒐集的網路資料。從執業紀錄得知，由貴的父親南戶數多最初負責維護世界各地的結界，直到妻子病倒之後才開始使用魔術治療疾病。紀錄中反覆提及「鑰杖」這項工具，它似乎有不同的層級。數多在治療重症病患時，曾經動用最高層級的鑰杖。</p><p>這便是由貴需要魔杖施法的主因。由貴的祖先索斯蓋特是法力高強的魔術師，他與惡魔的交易差點毀滅世界，所以引來眾多仇家。索斯蓋特一路逃到日本，接受以魔杖封鎖自己能力的條件。受當時的魔術師，即陰陽師，組織庇護。只有在必要時刻，才會透過鑰杖解除魔力封鎖。換句話說，由貴的手杖不是媒介，而是限制裝置。一旦取得保存於東京魔術師總部的最高權杖，將能發揮由貴最強的魔力。</p><p>帆乃夏的雙親曾求診數多以治療春香的絕症。據帆乃夏所述，姊姊在病癒後似乎愛上了數多。由貴曾兩度透過屍人與春香交流，感受到她對自己無端的惡意。當時，春香還透漏她利用帆乃夏將由貴誘出數多的保護範圍。這些資訊暗示春香與災變的關聯。數多對這場災變顯然知情，甚至預期自己可能因為阻止元凶而犧牲。然而，如果春香是兇手，那她可能曾和數多交手，那為什麼還表現得一無所知，甚至大費周章誘導帆乃夏和由貴來打聽數多的蹤跡？</p><p>除了兇手的身分，她們對於引發災變的手段也有許多疑惑。羽衣和夜未相信，屍人是惡魔奪取靈魂的途徑。惡魔以開啟魔術權限為代價，讓凡人代為執行活祭，在儀式現場創造屍人的源頭──真祖。真祖在失去靈魂的屍體附魔，讓它們能遵從特定行為模式移動、追擊和殺戮。附魔的屍體殺害其它人類並奪取其靈魂後，便會施法於空蕩蕩的軀殼，創造出新的屍人。</p><p>換句話說，真祖的屍人跟羽衣的魔像類似，只是前者是附魔的屍體，後者是附魔的岩石。魔術只能用於無意識體，即使是數多也只能在患者昏迷或麻醉狀況施術。綜合這些資訊可以推論，如果被屍人攻擊後仍保留意識，很可能不會被同化。其次，擊敗真祖有可能解除屍人上的魔術，使其恢復為普通的遺體。最後，解決真祖就能解決屍便，她們未必要對抗最初的交易者，尤其目前這場災難的元兇很可能是帆乃夏敬愛的姊姊。</p><p>事實上，歷史上最後一筆惡魔交易的紀錄在十九世紀的英國，一名女子被轉換為真祖。當時為了阻止屍人擴散而焚毀全村，導致五百人罹難，只有提出交易的魔術師倖存。由於很久沒有紀錄，她們不清楚事件兇手再度與惡魔聯繫的手段。</p><p>另外，這次屍變似乎在世界各地同時迸發，她們懷疑兇手在各地同時舉行獻祭的可行性。仔細檢視網路論壇的貼文後，帆乃夏首先發現爆發屍人的地點與國際太空站的移動軌跡一致，鄰近地點爆發的時間間隔也與太空站的速率吻合。此時，由貴想起來曾在巨型屍人出現前目睹火流星，又在屍人核心發現含有複合材質的金屬碎片。災變前一周，美國發射了火箭與太空站對接。那段時間，帆乃夏一家逗留在休士頓，春香也曾短暫與一名自稱是太空人的男子來往。</p><p>串聯這些線索可推論，春香勸服邂逅的男子在太空站執行儀式，所以屍變才會迅速地沿著太空站移動軌跡擴散。倘若這項假說為真，她們得摧毀太空站內的真祖才能解決屍變，但該怎麼摧毀位於太空的目標？</p><p>這也表示帆乃夏必須做出抉擇，是要與親愛的姊姊為敵？還是背棄她同樣珍視的由貴？帆乃夏抗拒羽衣過度推論的原因，除了不願面對兩難處境，也是她不相信姊姊有摧毀世界的動機。姊姊是帆乃夏最重視、最憧憬、最虧欠、最喜歡的對象，是不斷變動的環境中唯一穩定而令人安心的存在。姊姊既溫柔又強大，照顧她、愛護她、為她解決無法克服的困難，這樣的姊姊怎麼可能會做出毀滅世界的事？</p><p>種種跡象都支持春香是事件的兇手，讓帆乃夏陷入深沉的掙扎。如果這世界只剩下她們姊妹，帆乃夏一定會選擇袒護姊姊。不過，帆乃夏身邊還有由貴、羽衣、夜未以及京都和橫賀濱潛在的倖存者。帆乃夏經過特訓終於拉近了與由貴的力量差距，卻仍舊糾結對姊姊的感情會不會傷害到由貴。雖然由貴表現得很害羞，帆乃夏仍察覺到她對自己的好感。這讓帆乃夏比先前更害怕將由貴視為姊姊不在時的替代品。</p><p>由貴與姊姊的衝突無法避免，讓帆乃夏十分焦急。在前往東京尋找最高權杖的路途上，她們寄宿溫泉旅館。夜裡，帆乃夏偷偷跟著因為害羞而打算獨自泡湯的由貴。眼見由貴仍不願袒露相見，帆乃夏從背後靠近由貴，緊貼彼此的肌膚，化解兩人間的隔閡。由貴很訝異帆乃夏今夜如此主動積極，但追根究柢也是源於不安。帆乃夏的強硬與焦躁裡有明顯的不安，她急著讓兩人感情更親近，更獨一無二。如此一來，她才能在必要的時候，果斷做出決定。</p><p>春香沿路設下拒馬並差遣屍人追擊，迫使由貴一行人落入位於澀谷的陷阱。春香打算將由貴圍困在設有監視器的十字路口，逼迫數多出面營救。她隨後現身在由貴一行人面前表示，東京魔術師協毀已被摧毀，要求帆乃夏跟自己走，她相信帆乃夏一定還依戀著自己。帆乃夏聽到姊姊的邀請確實動搖了，不過仍在盤算能雙贏的方法。帆乃夏離開前悄聲向由貴保證，她絕對不會讓由貴受傷。由貴自知不敵春香，所以也支持帆乃夏的決定。雖然由貴有些猶疑，可是這也是唯一能保證帆乃夏安全的方法。</p><p>春香帶著帆乃夏來到鄰近大樓的屋頂，解釋了帆乃夏所有的疑惑。春香被診斷出絕症時，雙親便視其為將死之人，盡量滿足她所有要求。那天起，春香抱著一分一秒都不能浪費的態度過活。帆乃夏一家反覆搬家也是為了配合春香的願望，讓她能充分體驗不同活動和學習各種技藝。對自己生命不抱期待的春香而言，爸爸、媽媽還有祖母都只是完成目標的工具，只有帆乃夏不一樣。</p><p>春香視帆乃夏為分身，即使死後也會代替自己體驗世界，所以把希望寄託在妹妹身上去疼愛她。儘管春香的病後來痊癒，還是保留這份憐愛的情感。春香單戀著數多，她認為這名寂寞的鰥夫，大概只有已經死過一次的自己才有本領陪伴他。不過數多只在乎自己的女兒由貴。被拒絕後，春香認為如果能與數多擁有相同的立場，或許能讓他回心轉意。她千方百計打聽到與惡魔交易的方式，不惜建立毀滅世界的計畫，也想要取得強大的魔力。</p><p>至此，帆乃夏終於了解姊姊出色的理由，還有摧毀世界的動機。雖然帆乃夏不認為自己能說服她，卻感到欣慰與寬心，因為眼前的還是那個令她喜歡的姊姊。春香並不是受人洗腦，而是為了極端自私的動機摧毀了世界。這股強烈的情感，就跟帆乃夏自幼感受到的關照與愛護如出一轍。帆乃夏明白姊姊的行為無法寬恕，而且也無從贖罪。不過，帆乃夏至少能阻止姊姊殺害倖存的人，所以決定刺殺姊姊後自殺謝罪。</p><p>帆乃夏假借詢問春香手上的魔杖靠近她，趁其不意開槍。不過，春香的從魔屍人擋下了子彈。眼見帆乃夏背叛自己，春香也乾脆地拋棄與妹妹的情誼，操控擊發的子彈回擊。帆乃夏自高樓墜落，被羽衣及時遣派從魔白黑接住。由貴在前掩護正在幫帆乃夏止血的羽衣，春香現身在她們上空，聚集了大量屍人和汽車殘骸，打算一舉壓碎三名倖存者。由貴凝聚起周遭空氣形成護頓，吃力地和下沉的巨物對抗。</p><p>情急之下，由貴頓悟了操控光的魔術，她凝聚周遭能量形成強力的光球發射出去。由於春香被巨物擋住視線，無法及時反操控襲來的能量球，遂被打穿身體，凝聚的物體也隨之崩落四散。但是出乎眾人意料的是，春香似乎仍活著。此時，春香棄置的魔杖發出數多的聲音。那聲音自稱是由貴父親殘留在法器上的靈魂，他操控從魔佩拉追上逃跑的春香。</p><p>原來，春香和數多早在災變後兩周的一場對決中同歸於盡。強力的衝擊讓她失去部分記憶，讓意識附魔在屍體上。當數多透漏，那場對決滿足了他某些遺憾後。得知自己已死的春香，感到滿足地舉起帆乃夏掉落的手槍自盡。春香在靈魂逗留處碰見彌留的帆乃夏，讓她回到自己的軀體上以免成為屍人，獨自前往地獄贖罪。</p><p>最終，由貴成功救活帆乃夏。在安頓一陣子後，她們算準國際太空站越過日本的時間，發動最強力的魔法摧毀之，解決了屍人的危機。平安夜那天早上，夜未來訪，羽衣哭著迎接她。由貴恍恍惚惚醒來，睡眼惺忪地看著搖動自己肩膀的帆乃夏，向她詢問發生了什麼事。</p><p>帆乃夏笑著跟由貴說：「明天已經到來了。」意識到世界終於恢復平常，由貴卻不感到惋惜，因為她終於可以和帆乃夏，還有旅途認識的其他人，擺脫停滯的日常，一起迎向明天，一起為重視的人帶來歡笑。</p><p>「早安。」由貴說，湊向帆乃夏靠近的臉，讓兩人的距離歸零，感受彼此皮膜的濕氣與溫暖的鼻息。</p></br><p>終於寫完《明日的世界將會星光燦爛》系列的筆記了。這部作品的主線和感情線都是逐漸升級的線性結構，跟純粹的末日或戀愛作品相比，欠缺多重衝突和曲折。不過，作者肯定對故事結構下過功夫。</p><p>這系列每一集都有明確的目的。第一集鋪陳世界觀，也讓由貴在最後克服自卑，主動接近帆乃夏；第二集逐步透漏線索，解決帆乃夏這邊的顧慮；第三集則解開謎底，讓由貴支持帆乃夏克服兩難局面。由貴與帆乃夏的距離也從並肩而坐、牽手、擁抱、親臉頰，直到最後一幕才接吻。而且，不管災難線還是感情線都有好好收尾，把埋設的伏筆解完。</p><p>我又特別喜歡科幻故事，所以整體的閱讀體驗都很不錯。另外一定要補充的是，畫師的圖超級可愛，已經設定成閱讀器的封面了。</p><hr><p>司（2024）。明日的世界將會星光燦爛 3（林其磊譯）。青文出版。（原著出版於 2019 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜讀取儲存於 JSON 的輸入資料</title>
      <link href="/nextflow-manage-input-with-json/"/>
      <url>/nextflow-manage-input-with-json/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>目前，nf-core 認證的分析流程皆<a href="https://nextflow-io.github.io/patterns/process-per-csv-record/">使用 CSV 管理輸入的樣本資料</a>，這方法會逐列分析 CSV 檔每一列的資料。不過，其它任務排程或系統監控軟體可能更傾向使用 JSON 作為資料傳遞媒介。為了讓 Nextflow 能直接與那些軟體互動，需要能解析 JSON 格式並且逐條執行分析的功能。</p><span id="more"></span><p>Nextflow 讀取 JSON 的方法取決於輸入資料的鍵值設計。首先，我們能依照數據類型彙整資料，記錄該屬性在各樣本的確切數值（我稱為資料框模式）。在資料框模式中，key 對應樣本的一種屬性，value 則是紀錄各樣本屬性數值的列表。Nextflow 的 <code>-params-file</code> 可以直接讀取這種格式，以 <code>channel.of</code> 將參數轉換為 nextflow channel 之後，便能用 <code>transpose</code> operator 集中各樣本的屬性資訊。</p><p><code>params.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;b&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq1&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/path/to/a_r1.fq&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/path/to/b_r1.fq&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq2&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/path/to/a_r2.fq&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/path/to/b_r2.fq&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;f&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">12</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;m&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">19</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我們也可以先集中各樣本的屬性，讓用戶更容易理解特定樣本的相關資訊（我稱為物件模式）。在物件模式裡，一個樣本的所有屬性資訊都以字典形式儲存在列表的其中一項元素內，它依賴 <code>splitJson</code> operator 讀取檔案，再用 <code>map</code> 取出需要的數值，整理成分析所需的格式。</p><p><code>input.json</code> </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/a_r1.fq&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/a_r2.fq&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">12</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/b_r1.fq&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fq2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/b_r2.fq&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;m&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">19</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>以下範例依據輸入的選項決定讀取 JSON 檔的方式：<code>-params-file &lt;JSON&gt;</code> 對應資料框模式，<code>--input &lt;JSON&gt;</code> 對應物件模式。順利讀取 JSON 檔後，程式將逐條印出每個樣本的屬性。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">process SHOW_INPUTS()&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在標準輸出印出各樣本的所有資訊。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">input:</span></span><br><span class="line">tuple val(uuid), path(fq1), path(fq2), val(meta)</span><br><span class="line"><span class="attr">output:</span></span><br><span class="line">stdout</span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">echo &quot;uuid: $&#123;uuid&#125;, gender: $&#123;meta.gender&#125;, age: $&#123;meta.age&#125;, fq1: $&#123;fq1&#125;, fq2: $&#123;fq2&#125;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line"><span class="comment">/* 依據輸入選項決定讀取 JSON 的方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">params.input = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ( params.input )  &#123;</span><br><span class="line"><span class="comment">// 以物件模式讀取 JSON 檔</span></span><br><span class="line">channel.fromPath(params.input)</span><br><span class="line">| splitJson()</span><br><span class="line">| map &#123; m -&gt; tuple(m.uuid, m.fq1, m.fq2, m.meta)&#125;</span><br><span class="line">| set&#123;ch_input&#125;</span><br><span class="line">SHOW_INPUTS(ch_input).view()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 以資料框模式讀取 JSON 檔</span></span><br><span class="line">ch_input = channel.of( [params.uuid, params.fq1, params.fq2, params.meta] ).transpose()</span><br><span class="line">SHOW_INPUTS(ch_input).view()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實際執行的結果如下，兩種模式都能順利讀取 JSON，並且逐條執行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run main.nf --input input.json (or nextflow run main.nf -params-file params.json)</span><br><span class="line"> N E X T F L O W   ~  version 24.04.4</span><br><span class="line">Launching `main.nf` [desperate_wiles] DSL2 - revision: f5b87f1e88</span><br><span class="line">executor &gt;  <span class="built_in">local</span> (2)</span><br><span class="line">[c3/14477d] SHOW_INPUTS (2) [100%] 2 of 2 ✔</span><br><span class="line">uuid: a, gender: f, age: 12, fq1: a_r1.fq, fq2: a_r2.fq</span><br><span class="line">uuid: b, gender: m, age: 19, fq1: b_r1.fq, fq2: b_r2.fq</span><br></pre></td></tr></table></figure><hr><ul><li><a href="https://nextflow-io.github.io/patterns/process-per-csv-record/">Process per CSV record</a></li><li><a href="https://www.nextflow.io/docs/latest/reference/operator.html#splitjson">splitJson operator</a></li><li><a href="https://5uperb0y.com/nextflow-combine-data-into-a-tuple-with-key/">Nextflow｜如何為輸入的資料建立辨識碼</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《明日的世界將會星光燦爛 2 》</title>
      <link href="/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-2/"/>
      <url>/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由收到的簡訊推論，帆乃夏的姊姊曾和由貴的父親往來。帆乃夏提議在宅邸內尋找相關線索，發現了由貴先前沒留意到的密室。密室內有面鏡子連通其他都市，不過目前僅有通往京都的通道正常運作。</p><p>儘管由貴期待能延續與帆乃夏度過的平凡日常，還是跟著帆乃夏穿過鏡子來到京都。她們在那發現一棟屋主遇害的和式住宅，想進一步調查周遭環境時，被一名持槍的女子喝止。那位女子名喚九条夜未，她得知來者身分後隨即封鎖返程的通道。夜未以開啟通道並且說明由貴父親的消息為條件，要求由貴與帆乃夏接受她的指導完成一項秘密任務。</p><p>於是，由貴與帆乃夏便搭上夜未的車，回到她與相依為命的外甥女羽衣在京都的庇護所，展開為期一周的特訓。</p><span id="more"></span><p>京都的九條家是歷史悠久的魔術師家族。災變後，只有年僅八歲的羽衣和事發時剛從國外回來的夜未。由於京都的核心地帶與周邊區域分別有從前的魔術師設下的結界保護，所以尚有少數倖存者在核心地帶活動。夜未和羽衣除了掃蕩屍人外，也會四處偵查確保倖存者的物資充裕。夜未擅長使用槍械與地屬性魔術，所以她決定親自訓練帆乃夏；而由貴則由九条家指定繼承人羽衣負責。</p><p>羽衣向由貴解釋了不少魔術知識，例如魔術究竟是什麼？又為何叫屍人而非殭屍或食屍鬼？簡言之，若把世界想像成某種作業系統，物理、化學或生物學等原理就是這個系統的運作規則，魔術是短暫異動和操控規則的能力。一般來說，所有人都被物質的法則支配。魔術師是一群與惡魔交易的人，他們犧牲了自己甚至其他人的靈換，換取跳脫法則的權限，讓他們能夠無視重力抬起物品，違反熱力學加熱水體，甚至突破強力凝聚粒子等。</p><p>夜未與羽衣所屬的九条家只能操控地魔術，由貴的家族則能操控地、風、水、火四種魔術。犧牲的越多，能換取的權限也越大。由此得知，由貴的先祖──著名的大魔術師，索斯蓋特──必定付出了相當大的代價，甚至犧牲了整個國家的性命才換取到全面的權限。</p><p>如今橫行的屍人，便被羽衣和夜未懷疑是有人與惡魔交易的後果。不同於殭屍，屍人為魔法的產物。喪失靈魂的軀體會被其它屍人同化，產生感染的假象。日本已有對抗屍人的悠久歷史，目前保護著京都核心地帶的結界便是過往魔術師（或稱陰陽師）的遺產。最近一筆與惡魔交易的紀錄是在十九世紀的英國小鎮，造成逾百人化為屍人。也因為惡魔已經許久未現身，羽衣與夜未不敢輕信自己的猜想。</p><p>羽衣的能力是用石塊建構魔像，魔像灌注了羽衣部分的靈魂，能自發移動、護衛和攻擊。合格的魔術師可以對被操縱的物質下達多項指令，並且同時維持多個魔術，原理很像系統工程師與終端機互動。工程師可以給出複合指令，讓軟體接續完成彼此相依的任務。其次，還能讓程式背景執行，空出當前的命令列以執行其他操作。魔術師發動魔術通常不需要媒介，不過由貴得靠魔杖才能施法，令羽衣感到十分不解。</p><p>在羽衣指導下，由貴以重現擊敗變種屍人（獸頭屍人）的招數為目標，開始練習魔術的精密操作與背景執行。不過，她們卻在訓練過程遭到新的獸頭屍人攻擊。羽衣被她的從魔運輸至安全處，由貴只好單獨對付牠。獸頭屍人無視由貴無效的攻擊，詢問由貴父親的下落。牠不滿由貴一無所知，揚言殺害她。幸好夜未與帆乃夏及時趕到，擊敗了獸頭屍人。然而，屍人透漏的資訊卻讓由貴十分不安。牠表示自己曾見過由貴，還刻意誘導她離開城市陷入危險，以逼迫由貴的父親現身。更令由貴不安的是，獸頭屍人不只認識帆乃夏，在下手還說：「永別了，他所愛的可恨對象。謝謝妳跟我妹妹做朋友。」</p><p>由貴心想，莫非獸頭屍人是帆乃夏的姊姊？而且她竟然與災變有關？若此事為真，那該怎麼向帆乃夏交代？在最需要彼此的時候，若讓帆乃夏知道夜未殺害最親愛的姊姊，會造成多大的傷害？</p><p>從小，帆乃夏的姊姊便代替公務繁忙的雙親照顧她。帆乃夏憧憬多才多藝的姊姊，姊姊也很重視帆乃夏，她們是彼此最重要而特別的存在。在不斷搬家的童年裡，只有姊姊一直陪在帆乃夏身邊。不過姊姊患有嚴重的疾病，讓帆乃夏更加依附她，深怕姊姊突然消失。</p><p>在帆乃夏一家搬到由貴居住的城鎮後，姊姊的病不藥而癒，緩解了帆乃夏的不安。可是，姊姊在這段期間也遇上了讓她著迷的對象，於是帆乃夏不再是姊姊內心最重要的人。由貴與帆乃夏相遇的時候，帆乃夏正因為姊姊的微妙轉變而陷入低潮。帆乃夏無法與周遭合不來的同學往來，才不顧被霸凌的風險為由貴挺身而出。換言之，由貴最初多少被帆乃夏當作移情的對象，暫時填補了姊姊在她心中的地位。然而，兩年前短暫的相處和災變後的重逢，讓帆乃夏明白，即使自己仍舊依戀姊姊，對由貴的感情也是獨一無二、無法取代。</p><p>由貴向帆乃夏隱瞞獸頭屍人的事情，委託夜未協助調查。因此，隔天由羽衣帶著由貴和帆乃夏到清水寺周圍特訓。休息時間，帆乃夏表示由貴這幾天眼神飄忽不定，似乎在隱瞞著什麼，要求她向自己說明清楚。由貴顧慮帆乃夏的心情不敢輕言真相，反而激怒了帆乃夏。帆乃夏希望由貴不要小看她，才讓由貴察覺她們之間的權力關係不知不覺翻轉了。</p><p>在太平盛世，帆乃夏的能力與社交手腕卓越；在屍人末日，帆乃夏卻成為最弱小的存在。帆乃夏既不懂得魔術，也不具專業技術，她只有在實戰中磨練出的經驗與直覺。由貴也意識到了這點，所以不管什麼行動，都會考慮到帆乃夏的安危，不希望她受任何傷害。然而，帆乃夏其實不像由貴想像那麼堅強。除了需要由貴的魔法來對抗屍人，帆乃夏也很重視由貴，渴望她的陪伴。</p><p>帆乃夏想跟由貴建立對等的關係，所以無法心安理得接受協助。她希望由貴信任她，相信她也能成為支持由貴的力量，而非亟欲照顧的拖油瓶。因此，帆乃夏不希望在對抗絕望的時候置身事外。她向夜未學習槍械知識和戰術技巧，也取得威力強大的附魔子彈。帆乃夏想要證明自己夠格與由貴並肩作戰，能在每一次由貴需要時伸出援手。</p><p>由貴明白帆乃夏的決心，答應在合適的時候坦白所見之事。正當她們打算返回訓練場地時，查覺到結界附近發生異變。羽衣、由貴、帆乃夏與夜未會合，在結界邊緣發現無數屍人堆疊而成的巨大屍人。巨大屍人似乎沒有單一核心，無論她們用哪些手段都無法完全摧毀之。眼見事態恐無法挽救，夜未說明了她想委託由貴與帆乃夏的任務，她希望兩人帶著羽衣回到由貴的家，在那邊好好生存下去。</p><p>夜未十分珍視自己妹妹，妹妹於災變罹難後，也代替她照顧女兒羽衣。夜未堅持要守護京都的理由，是為羽衣保留一點點希望。畢竟有機會解決屍人危機的話，至少能守住重建社會的種子。可是，目睹巨型屍人的力量，羽衣認為夜未的決定無疑送死，無論如何都不願服從這項命令，卻無力牴觸夜未。</p><p>由貴說服羽衣，她們現在只能做現在能做到的事情，像是和夜未好好溝通與道別，讓彼此都沒有遺憾，在往後的庇護處各自努力。由貴也在晚間向帆乃夏坦白，昨天她們殺害的獸頭屍人自稱是帆乃夏的姊姊。帆乃夏難以接受姊姊是事件罪魁禍首的猜想，不過仍十分感謝由貴的信任。隨後，帆乃夏提出額外的線索，她懷疑她們在日本短暫停留的時候，姊姊曾求助由貴的父親，在痊癒後愛上了他。</p><p>當晚，兩人窩在同個被窩裡。帆乃夏少見地要求由貴鼓勵她，而由貴也鼓起勇氣給予擁抱。她們在輕吻彼此的臉頰後，一起安心的睡著，準備迎接在京都的最後一日。</p><p>一早，羽衣喚醒由貴和帆乃夏，說明了她計畫。羽衣認為可以集中車站周圍的汽車，點燃其中的燃料重現由貴在高架橋上的必殺技。如果她們能夠順利毀掉巨型屍人，一定可以為夜未爭取充分時間，也能讓自己心甘情願離開。雖然由貴沒理由幫忙，不過來到京都以後，由貴首次感受到帆乃夏以外的人給予的關愛與支持，因此樂意協助羽衣的作戰。</p><p>等到她們再度來到位於結界邊緣的車站時，巨型屍人的軀體又更加具體龐大。羽衣操控魔法子彈打穿汽車並點燃油料，由貴則開始凝聚熱能。期間，帆乃夏和羽衣負責掩護由貴，爭取集中能量的時間。如今，經過特訓的帆乃夏可以熟練地使用魔法子彈對抗獸頭屍人，成為由貴有力的夥伴。不過屍潮前仆後繼湧來，巨型屍人吸收屍人又變得更加巨大，眼看牠就要伸手突破結界，一發魔法子彈打斷巨型屍人的手──得知羽衣莽撞計畫的夜未及時提供了支援。</p><p>由貴則趁此時完成施法，把宛若太陽的高能電漿球擲向巨型屍人。屍骸被高溫焚毀，露出了真正的核心。然而，藏在屍體與金屬板的碎片從燃焰噴出，砸向夜未的狙擊點。帆乃夏提醒由貴專注，再度提升電漿球的能量。溢出的強光讓由貴暈眩，意識進入空無一物的純白空間。她在那聽見帆乃夏的姊姊，春香，的聲音。春香向由貴解釋，強力的魔術與從魔的核心互動，讓春香的意識流入由貴體內。</p><p>由貴指責春香是災變的元凶，但春香反控由貴才是這個惡夢的根源。春香本打算奪取由貴的靈魂，但從魔佩拉及時現身，才讓由貴脫離險境。由貴把滿腹憤怒轉變為火焰，成功焚毀屍人核心，還燒盡群聚在結界邊緣的屍人。</p><p>隨後，她們收到夜未的信號，一行人趕回九条的本宅。自作主張的羽衣和其他兩人不免受到訓斥，但她們確實擊敗了巨型屍人，還確認春香是襲擊的幕後黑手。夜未交給她們生活物資、關於由貴父親的執業紀錄、還有從屍人彈出的破片（這塊破片疑似從天上掉下來。），在通道前與她們訣別。經歷了這些危難之後，她們都相信此行並非眷戀一成不變的日常，而是從京都啟程，為拯救世界和爭取光明的明天努力。</p></br><p>特訓的安排除了完整世界觀和埋設線索以外，也加強了帆乃夏的戰鬥能力，解決她實力無法匹配由貴的問題。她們之間沒有會撕裂關係的誤會，小小的認知落差也在共寢的橋段化解了。交代感情的發展後，這集很明顯在鋪陳解謎所需的線索：魔術的起源、春香的動機、從天而降的金屬碎片、魔術與核心的共振……等，這些線索要指向此作的終極問題：「春香是否為災變的罪魁禍首？為什麼？怎麼做？」</p><p>作者安排橋段也很工整，屍變劇情一律在特訓期間交代，感情則在寢室發展。在由貴坦白碰到自稱是春香的獸頭屍人後，帆乃夏一度陷入低潮，當晚主動靠在由貴身邊，希望和她在同一張棉被底下入睡。由貴擁抱帆乃夏後，帆乃夏親了由貴的臉頰，然後要求對方也親自己一下。</p><p>這段大概是第二集情感戲的高潮，所以總結一下她們的互動模式。首先，渴望某種互動（例如接吻）的人，會主動做出該行為。此時，對方必然會感到訝異，甚或陷入混亂。這時，主動方要說服對方做出一樣的行為，所以明明自己也一知半解，還是會擠出牽強的理由，例如：女生&#x2F;朋友&#x2F;國外都這樣啦。對方聽到這些說法通常不會照單全收，半信半疑也相當正常。</p><p>但是，基於當下的氣氛、信任對方的心情、還有自己也沒察覺到的欲望，往往會照做，甚至為了證明自己沒有很 care，表現得比主動方更加激進。明明不懂還想裝模作樣的兩人便陷入彼此都不知所措的害羞場面。</p><p>不過，角色真的會這樣反應嗎？只能說作者營造角色時已經布局好了。正因為由貴被很多人討厭，她才沒辦法判斷帆乃夏的說法是否為真。其他作品可能是從小和男生相處、不曾接觸其他人類、沒有戀愛經驗等，才會在這種場合半推半就地受主動方引導。</p><hr><p>司（2023）。明日的世界將會星光燦爛 2（林其磊譯）。青文出版。（原著出版於 2019 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《明日的世界將會星光燦爛 1 》</title>
      <link href="/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-1/"/>
      <url>/tsukasa-2019-asu-no-sekai-de-hoshi-wa-kirameku-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>高中開學日隔天，由貴的學校遭到屍人襲擊。屍人是類似殭屍的怪物，牠們嗜食人肉，而且能感染咬傷的獵物，將其轉變為新的屍人。失控的汽車衝破校門後，屍人如潮水般湧入校園，殺害了上前關心狀況的教師以及隨後逃竄而出的學生。</p><span id="more"></span><p>頃刻之間，校園各處充斥不斷嘶吼的屍人，牠們團團包圍躲在教室角落的由貴。由貴抱著書包不斷禱告，緊握出差父親臨行前贈予她的企鵝吊飾。正當屍人撞開窗戶與鐵門闖進教室時，企鵝吊飾突然膨脹成巨大的偶像，一口將由貴吞下。</p><p>巨大企鵝隱蔽氣息不讓屍人發現，帶著肚裡的由貴安全回家。由貴一時搞不清楚狀況，但起碼明白自己總算活下來。企鵝到家後縮小至一般玩偶的大小，發出嗶嗶聲引導由貴到吊鐘前。在那裡，由貴發現一把鑲有紅寶石的手杖和父親留下的信。由貴的父親告訴她，在她讀信之時，屍人必然到處肆虐，自己恐怕也已不在人世。他簡易交代了地、火、風、水等魔法的使用技巧，並且留給由貴一棟被結界保護的宅邸，還有企鵝外型的從魔，佩拉。</p><p>那天之後，由貴開始了作為魔女的生活。屍人厭惡陽光，因此由貴會趁中午出門，沿著空曠的道路蒐集食品，使用飛石排除擋道的烙單屍人。入夜前，由貴則返回那棟以木板封住窗口，還纏繞著藤蔓的古風建築，吃著即食品度過寧靜的夜晚。</p><p>由貴以往對自己的家一點好感都沒有。她的母親早逝，但父親公務繁忙，對由貴疏於關心。她的父親似乎是法力高強的魔術師，常常有人拜訪家裡懇求父親協助。然而，由貴沒有因為這樣而過得順遂。她因為父親的職業，還住在風格古怪的建築內，從小被人嘲笑為「魔女」。選擇高中志願時，由貴原想到外地就學以擺脫霸凌，父親卻一口回絕，讓她噩夢般的校園生活又持續了兩年。</p><p>如今，欺負他的同學已化為屍骸，父親也不在身邊。歷劫歸來還學會魔法的由貴反而很珍惜世界毀滅後的寧靜。只不過，由貴內心還是有一絲遺憾。有個女孩曾在她絕望之際走入她的人生，帶給她如夢境般短暫幸福。屍人肆虐的世界裡，由貴也不奢望那女孩能幸免於難。只是……要是自己那時不那麼倔強，願意跟她交換聯絡方式的話，至少在災難發生那天，還有機會跟她說聲再見。</p><p>由貴的日子就像無風日子裡的湖面，直到她在返家過程中聽見槍聲，才泛起陣陣漣漪。由貴上前一探究竟時，發現有個女孩受困公園被屍人層層包圍。眼看屍人被槍聲吸引，很快將淹沒躲在溜滑梯上的女孩，由貴卻對應否出手營救猶豫不決。她害怕自己受到非議，被指責擁有安全庇護所和強大的魔力，卻在災難發生時袖手旁觀。</p><p>此時，她腦中浮現一個念頭，當年那個女孩會不會還活著？儘管可能性很低，但也不是沒有吧？抱著渺茫的希望，由貴施法挪動鄰近河川的水體把屍人沖散，為受困的女孩爭取脫逃的時間。當女孩奔出公園那刻，由貴愣住了，眼前這名肩揹步槍踏著蹣跚步伐的，正是由貴唯一的摯友──帆乃夏。</p><p>帆乃夏在由貴高中二年級時轉入。由貴對帆乃夏的第一印象是漂亮又親切的女生──所以和自己一點瓜葛都沒有。由貴默默看著帆乃夏融入班上的社交圈，感嘆自己的想法再次印證。然而，由貴沒預料到的是，當班上同學再度欺負她時，帆乃夏不但沒有落井下石，還為由貴打抱不平。</p><p>在眾人目瞪口呆之下，帆乃夏拉著由貴離開，兩人躲到樓梯間吃飯，肩靠肩抵禦寒風。帆乃夏坦白自己不喜歡班上氛圍，以往的她可能選擇隱忍。不過，她將再度隨父母搬家而轉學，所以即使知道自己也會被欺負，也打算挺身而出。</p><p>帆乃夏對自作主張的舉動向由貴致歉，但由貴並不在意。這是由貴首次體會被人支持與保護的溫暖，所以她也想成為能支持帆乃夏的朋友。帆乃夏看出由貴不想虧欠人情，於是擅自咬了一塊麵包當作回報，並且向由貴表示，她們從今以後就是「朋友」了。由貴和帆乃夏度過了短暫而幸福的一周，在帆乃夏搬家前一天，由貴本想跟帆乃夏交換聯絡方式，卻在離別前一刻畏縮了。</p><p>由貴已經習慣被欺負的日子了，帆乃夏的出現讓她短暫脫離惡夢般的校園生活。可是，由貴害怕過度依賴帆乃夏會讓自己變得軟弱，也不利於友情的維繫。然而，與帆乃夏道別時，由貴仍期待著，如果由對方提出要求的話，自己一定會一口答應，一定。可是帆乃夏也不願強迫由貴，淡淡說聲「再見」之後便離開了——直到她們在充滿屍人的末日重逢。</p><p>兩人回到由貴的宅邸，一起吃微波咖哩，洗用魔術加熱的熱水澡，像到朋友家造訪的高中生一樣，兩人窩在棉被裡談天。帆乃夏在事故後和家人躲進自衛隊基地，不過以變種屍人為首的屍群突破防線，帆乃夏的雙親和祖母皆遇害身亡，姊姊也被能說話的變種屍人綁走。為了營救從小照顧自己的姊姊，帆乃夏在基地淪陷後持續往南方移動，尋找姊姊的下落。</p><p>聽完之後，由貴除了對這段經歷的同理心以外，也對帆乃夏的姊姊抱有苦澀的羨慕，由貴希望能得到對方同樣的關心與努力。安全的宅邸、強力的魔法、靜謐的日常，還有最好的朋友，由貴很想一直維持這樣的生活，但這只是一廂情願。帆乃夏堅信姊姊倖存，所以打算穿越遍佈屍人的都市，前往神奈川另一座自衛隊基地調查姊姊的下落。由貴的父親交代她別離開這座都市，不然沒辦法保證她的安危。</p><p>若由貴決定留在原地，就意味著再次與帆乃夏分離，但這是由貴或帆乃夏想要的嗎？由貴想要與帆乃夏一起生活，但又不願阻止朋友的願望，那麼她該怎麼做？如果這表示她得放棄現在安全的庇護所，那麼她是否有勇氣跨出第一步？</p><p>一直以來，都是帆乃夏體貼她、照顧她和保護她，即使由貴順手救了帆乃夏一命，帆乃夏也努力想要還由貴人情。相較於帆乃夏處處為由貴著想，由貴期待帆乃夏的陪伴，卻更在乎自己的感情。兩年前跟帆乃夏道別時沒有交換聯絡方式，因為想要變得堅強；現在即將與帆乃夏訣別卻猶豫不決，因為害怕離開家鄉。由貴始終受制於自己的情感需求，所以無法主動向帆乃夏提出要求或伸出援手。由貴希望帆乃夏向自己求助，希望對方能幫自己作主，這樣才有辦法跨越內心的藩籬。</p><p>然而，帆乃夏不僅是貼心的人，也是不安的人。尋找姊姊是基於沒有根據的信念，跨越屍群的存活機率也很渺茫。儘管如此，帆乃夏仍不願求助由貴，她一方面不想要為了私利而危害由貴，另一方面也怕自己過度依賴由貴的話會配不上對方。</p><p>換句話說，兩人都覺得自己配不上對方，都在勉強自己，如果沒人大膽向對方伸出手臂，那麼彼此將再度錯過。考量如今更險惡的環境，錯過也意味著永別。由貴很訝異帆乃夏竟然害怕配不上自己，儘管不知道確切理由，由貴還是察覺到，自己從來沒有好好想過帆乃夏的心情。一直以來由貴以為帆乃夏都是完美而自在的存在，從沒想過也許帆乃夏也期待和自己成為朋友，也許帆乃夏扛著槍的手仍在顫抖，也許帆乃夏也期待面對宛如山洪襲來的屍群時，自己能陪在她身旁。</p><p>由貴想親近帆乃夏，想和她成為對等的朋友，為此，她想付出自己的能力，所以當她們再次道別，帆乃夏發動引擎的時候，由貴跳上機車後座，摟著帆乃夏的腰。</p><blockquote><p>「……由貴，妳在幹什麼？」<br>「啊？那就……出發吧！」</p></blockquote><p>出發，由貴與帆乃夏，一把魔杖、一支槍，搭著摩托車向被屍群包圍的神奈川基地前進。相較於擁有魔術的由貴，帆乃夏有較多荒野求生的經驗。她們沿著屍人較少的路徑和高架橋前往神奈川，道路卻被堆積成山的屍人淹沒。她們推測，屍人聚集在橫須賀軍港和厚木基地，打算一舉殲滅倖存的人類。眼看前進的道路受到阻礙，由貴想說服帆乃夏逃跑，但帆乃夏卻認為她們可以當作誘餌引開屍人，幫基地的人爭取逃脫時間。帆乃夏相信，也許姊姊也在那群倖存的人之間。</p><p>由貴並沒有反對帆乃夏的動機，但反對她的提案。由貴不希望帆乃夏送死，也不打算置身事外。由貴從不認識帆乃夏的姊姊，也挺忌妒她能得到那麼多愛慕。然而，如果是帆乃夏的願望，她想要以能保全兩人性命的方式嘗試。由貴的策略是接近屍群後，將牠們引開到高速公路上，藉由引爆汽油的方式一舉燒毀大批屍群。期間，兩人再度碰上綁走帆乃夏姊姊的變種屍人，嘗試與牠溝通無果，帆乃夏盛怒之下向其開槍，屍人卻毫髮無傷。她們乘著機車逃跑，眼看就要被追上，由貴成功點燃高架橋上散逸的汽油，將變種屍人燒得焦黑，再由帆乃夏給出最後一擊。</p><p>望著高架橋上的熊熊烈火和遠方四散的屍群，由貴和帆乃夏也沒辦法繼續前進了，只能相信她們的努力能夠為倖存者爭取時間。兩人決定回到由貴的家整補，思考接下來的行動方針。在帆乃夏的協助下，她們蒐集了載具油箱內的汽油重啟發電機。帆乃夏立即充足手機電量，檢查是否有其他倖存者的訊息，沒想到她收到了姊姊的來訊，告訴她變種屍人是「真祖」的侍從，要求帆乃夏去找南戶數多，也就是由貴的父親。</p></br><p>據作者所述，這系列從一開始便以三集的篇幅規劃。我讀完後覺得第一集確實比較平淡一點，它主要陳述災變後的世界與由貴的心結，兩人關係發展的線索要到第二、三集才慢慢揭曉。在這部作品裡，由貴與帆乃夏對彼此皆有好感，也想更親近對方。對由貴而言，帆乃夏將她從被欺負的經歷解脫；對帆乃夏而言，由貴是她被姊姊冷落後移情的對象。短暫的相處時間，她們逐漸成為彼此不可或缺的存在，但是卻因為自卑感而無法更加靠近。</p><p>由貴認為帆乃夏正直而且率性，帆乃夏認為由貴勇敢而堅強，她們在彼此看到各自嚮往的特質，所以覺得自己不配與對方成為朋友。力量的差距是這部作品關係發展的最大障礙。最初，她們面臨的是社交場域的困境，帆乃夏圓融的交際手腕是由貴所不能及。災變後，面臨的是生存的考驗，由貴的魔力遠遠超出帆乃夏的能力，所以這邊必須讓由貴主動伸出援手。</p><p>因為她們都希望能與對方對等交往，不想成為依附對方的人，所以帆乃夏不會主動求助。由貴已經擁有生存在這世界的能力，但還困在以前的經驗，這場末日不僅給她第二次機會去弭補兩年前到別的遺憾，也是推她一把克服與帆乃夏相處時的自卑感。為對方做些什麼，去證明自己能配得上對方。</p><p>不過，由貴的心結解決後，帆乃夏仍處在力量不對等的狀況。因此，第二集的劇情也自然得交代帆乃夏的困境，才能消弭彼此關係發展的最大障礙。</p><hr><p>司（2019）。明日的世界將會星光燦爛 1（林其磊譯）。青文出版。（原著出版於 2019 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《貓與海的彼端》</title>
      <link href="/chen-2023-sea-you-there-and-us/"/>
      <url>/chen-2023-sea-you-there-and-us/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>小學三年級的開學典禮後，不擅長應對人群的筱榕獨自返回教室，卻撞見比她還早坐在位子上的女孩，可蔚。隨後分配座位時，筱榕被安排在可蔚後面。</p><p>一陣風吹進教室，牽動可蔚的高馬尾。筱榕輕握住隨風左擺右飄的髮尾。可蔚的髮質健壯而且顏色飽滿，不像自己那樣毛躁蜷曲。摸過頭髮的手輕輕拂過鼻子，還能嗅到留在指間的一股淡香。可蔚看筱榕那麼陶醉，也沒有責怪她的意思，反而和筱榕成為朋友，即使校外教學因颱風取消，可蔚也想到筱榕家共度假期。</p><span id="more"></span><p>一日，可蔚不滿動畫公司刪節原作劇情而悶悶不樂，筱榕提議由她構思劇情，可蔚繪製漫畫，兩人一起創作屬於自己的劇情後續。隔壁老師見到筱榕每節下課都眉飛色舞地編故事，推薦她參加說故事比賽。可蔚鼓勵畏縮的筱榕參賽，也在備賽過程中千方百計支持她。這讓筱榕下定決心，即使比賽結束後，也要繼續說故事給帶給她信心的可蔚聽。</p><p>過了不久，筱榕與可蔚迎來新的級任老師。新老師自稱「小楊老師」，作風開放而不拘小節，既免除了自習的義務，也鼓勵大家在美術課自由創作。於是，筱榕與可蔚各自開始創作漫畫。筱榕因畫技不如可蔚而自卑，不過可蔚卻認為她的故事很吸引人，鼓勵筱榕繼續努力。</p><p>然而，不管畫技、社交還是成績，筱榕都自認比不上可蔚。儘管如此，她還是為了與可蔚成為平起平坐的朋友而努力。然而，當筱榕順利考了滿分，表現得甚至比可蔚更耀眼時，反而感到彼此更加疏遠。筱榕覺得自己是可蔚的陪襯，不該表現得比她更好。不過拿到成績單時，被人稱讚故事有趣時，仍有股令人不安的快意產生。難道，與可蔚的關係是建立在自己的自卑上？</p><p>筱榕與可蔚的冷戰持續了整個暑假，直到可蔚在體育課受傷才出現轉機。看見可蔚被送進保健室，筱榕也顧不得彼此隔閡，一路奔進保健室。筱榕站在門口遲遲不敢進門，直到可蔚向老師示意：「她是我最好的朋友。」，才讓筱榕卸下心中的重擔，而落下眼淚。筱榕心中有無數個幸好，幸好可蔚沒事，幸好我們彼此都還是對方要好的朋友；還有無數個要是，要是早點放下那陰暗的想法，要是早點關心對方……</p><p>見筱榕哭得好像受傷的人不是自己，可蔚向她保證，自己以後會更小心，絕對不讓筱榕為自己哭泣。誰知道，兒時可愛的約定，成了未來情感的箝制。</p><p>去年的校外教學因颱風取消以後，筱榕等了一年才能實現與可蔚出遊的願望。儘管筱榕想像她與可蔚穿著可愛，一起品嘗甜點和坐旋轉木馬的畫面，可蔚卻拉著她去玩雲霄飛車和激流泛舟等讓人膽戰心驚的遊樂設施。</p><p>筱榕硬著頭皮和可蔚玩了許多設施，在大怒神前卻藏不住自己的恐懼。察覺到筱榕的害怕，可蔚把背包遞給筱榕，捏著筱榕的鼻子，笑著要她別說謊。因為，她一直都知道筱榕有懼高症，只是在勉強自己。可蔚承諾，她會在很高的地方，代替筱榕觀賞美景……</p><p>四年級的期末考，小楊老師靈機一動，決定以化裝舞會形式來決定成績，優勝的組別能獲得美術館一日遊的資格。筱榕打算與可蔚組隊，卻先收到兩名男生的邀請。她果斷回絕後向可蔚提出邀請，但對方卻猶豫女生能否同組共舞。聽到討論的小楊老師表示，從沒規定要選擇異性舞伴，於是兩人如願一同參加舞會。</p><p>筱榕與可蔚獲選化裝舞會優勝，所以跟著小楊老師一起參觀美術館。當筱榕佇立在畫作前，她想起可蔚的煩惱。可蔚想要成為漫畫家，卻一直擺脫不了他人的風格。筱榕很想安慰可蔚，卻不了解對方的想法。因為，筱榕從來沒有想要熱切追求的目標，也沒有打算完成什麼的心情。</p><p>筱榕只知道，她最想做的事，就是陪伴可蔚完成她的夢想，和可蔚一起吃冰淇淋，享受甜蜜的夏天。</p><p>不過，為了讓即將升上五年級的學生適應分班，小楊老師故意拆散筱榕與可蔚，讓她們各在不同組別準備期末分組報告。筱榕很不想和可蔚分開，可蔚安慰她這是個練習的好機會。讓筱榕訝異的是，可蔚竟然說想要練習獨立，不要再依賴自己。「依賴我？」可蔚只是戳戳筱榕的眉頭，卻沒解釋什麼。</p><p>筱榕籌畫的話劇以及可蔚準備的漫畫大獲成功，但是她們沒有如願分到相同班級。如今，筱榕成了新班級的班長，同學們對他的印象，就有如兩年前她對可蔚的印象一樣，認為她是個可靠的人。不過，筱榕對可蔚更多的是思念，而非焦慮、自卑和憂心等情緒。久違見面，可蔚帶來一本自繪漫畫，她說，她終於找到能夠呈現自己風格的主題。於是，筱榕忙於班務，可蔚潛心畫畫，她們只在放學時有機會手勾手，短暫聊聊整天下來的瑣事。</p><p>原以為事情會一切順利，劇烈地震卻於夜間襲來，筱榕與家人逃到街上，抱著媽媽祈禱可蔚平安無事。清晨，收音機不斷更新災情，但筱榕始終聯繫不到可蔚。筱榕還想跟可蔚一起過生日、還想和她再去校外教學，她抱著娃娃禱告自己的心聲能傳遞給可蔚。</p><p>當電話終於接通，她們才恍然大悟：急著確認對方安危的彼此占滿了電話線，以至於雙方都連絡不上。緊繃的心總算在通話後沉澱下來，筱榕那時相信，如果連這麼大的災難都無法拆散彼此，也許她們能永遠、永遠陪伴彼此。</p><p>地震之後，為了鼓舞仍在災難陰影下的學生，校外教學在家長會支持下照舊舉行。不過，可蔚與班上同學一起行動，只有離開前才有機會與筱榕道別：「明天見。」怎知這一次，竟是永別。返家後，筱榕接到小楊老師的電話，可蔚離開遊樂園後出車禍被送入加護病房。</p><p>班上同學號召大家一起摺紙鶴為可蔚祈福。雖然一度傳來病情好轉的消息，可蔚最終仍離世了。小楊老師通知筱榕這消息時，哭著說對不起。在分班的時候，筱榕與可蔚其實被分到同一班，但小楊老師認為她們在不同班級能夠發揮得更好，所以自作主張拆散她們。如果當時不這麼做，兩人一定能有更多相處的時光。</p><p>分班之後，筱榕有好多、好多、好多話想跟可蔚說，卻以為還有將來所以對於當下的沉默不以為意。如今，可蔚已經走了，那些話，要留給誰？該怎麼訴說？</p><p>比起哀傷，筱榕更多的是不解。為什麼是可蔚？為什麼是曾跟她說會長命百歲的可蔚？筱榕曾想像過好幾次，她們年邁的時候，仍「喵喵喵」說著貓語的搞笑畫面。筱榕在圖書館的桌面上看見裁切紙張和繪畫的痕跡，那是可蔚曾經在這裡努力追求漫畫夢想的證據。那些夢想現在到哪裡去了？為什麼？</p><p>筱榕請求母親讓她學畫，她想要代替可蔚完成那本只有封面的著作。然而，當筱榕的畫技終於追上不再進步的可蔚以後，卻無法下筆。筱榕根本不知道可蔚想像的是什麼故事。再說，即使筱榕再怎麼與可蔚相像，也沒資格為可蔚代言。可是，可是，如果不這麼做，筱榕還能做什麼？筱榕才十歲，還有很多很多年可以活，她要怎麼才不會逐漸忘記可蔚的形象與聲音？</p><p>由於感到無能為力，筱榕的心情從不解轉而感到憤怒，揮筆塗黑整張畫布，在無意識間甚至想在身上刻下可蔚的名字，直到母親前來阻止……</p><p>之後，就像熱感紙沾到光，可蔚離去的衝擊越來越淡，可是筱榕仍持續夢見可蔚。從筱榕一開始平視可蔚，直到後來得低頭看她，可蔚總是一言不發。筱榕想知道自己能為可蔚做些什麼，卻永遠得不到回應，只能自顧自地說著獨自長大後碰到的生活瑣事。</p><p>筱榕不再畫畫了，她選擇把想法化為文字，透過撰寫小說紀念她與可蔚的童年回憶。大學時，筱榕選擇戲劇系。課程內容與筱榕想像落差許多，除了創作，也有舞台架設與道具製備等環節。課務繁忙的她許久沒夢見可蔚，直到課堂上老師要求進行無實物表演——演員要在沒有道具輔助下，讓觀眾相信一段情節。</p><p>這是非常困難的表演，前幾個優秀的同學也表現得差強人意。輪到筱榕上台時，她腦袋一片空白，對接下來的表演內容完全沒有概念。然後，不知怎麼，她伸出手，指尖傳來髮尾的觸感，可蔚出現在什麼都沒有的空桌子，什麼都沒有的空椅子上。</p><p>久違重逢，筱榕不禁落下眼淚，她不再執著要為可蔚做些什麼，也不再害怕可蔚從她的記憶消失。因為，可蔚就在她的記憶中，陪著她成長老去。</p></br><p>我讀《貓與海的彼端》時，剛好看完《驀然回首》，所以對筱榕與可蔚的關係印象深刻。筱榕為了讓可蔚開心而說故事，也在過程中發現自己創作的天分。然而，筱榕本身卻沒有可蔚那樣純粹的目標。雖然筱榕認真琢磨創作技巧，也嘗試繪製漫畫，可是她所作所為無非是為了可蔚。積極面來說，筱榕想支持可蔚的夢想；消極面的話，筱榕不想落後可蔚太多。</p><p>兩人的關係最初建立在筱榕對可蔚的憧憬，所以最初可蔚與其他人同組或是交談時，關係的不確定性往往帶給筱榕很大的不安。不過，隨著她們關係加溫，筱榕的內心糾結反成了隔閡彼此的主因。</p><p>筱榕自認不如可蔚，卻漸漸在各領域表現得比可蔚耀眼。筱榕的自卑感不容許自己超越可蔚，所以在獲得成就時，會對自己的喜悅感到不安，也對可蔚感到愧疚。這樣的狀況要到後來可蔚表明筱榕是她最好的朋友，以及小楊老師循序漸進鼓勵筱榕才得以改善。到故事後半段，可蔚反而向筱榕坦白，真正更依賴對方的人，其實是自己。</p><p>雖然每一小節都不斷暗示可蔚已不在人世，讀到可蔚意外過世時還是感到太突然，讓我認為故事——很符合真實。前面鋪陳筱榕與可蔚的關係發展時，排了很多挑戰例如可蔚與其他人聊天、校外教學分組、筱榕的自卑感、分班、大地震、………等，一再化解危機的同時，也促進兩人深層的理解。原以為地震後重逢，會花一些交代兩人往後的關係（我讀的時候不知道後面有番外篇。），結果卻是生離死別。</p><p>感到真實是因為，之前跟朋友聚餐時討論起一位被視為明日之星的高中同學，正想著他現在不知過得如何，就看到一則事故新聞。我拿起手機一查，發現是剛剛討論的同學，當下入口的菜都沒味道了。</p><p>真實人生的高潮起伏，還是有戛然而止的可能……所以邊讀邊想，這本書是不是改編自的真實經歷呢？暖暖的文字還有遍處能感受到的思念，也是想向什麼人致意嗎？</p><hr><p>巧喵（2023）。貓與海的彼端。台灣角川。</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《橫濱車站sf》</title>
      <link href="/isukari-2016-yokohama-eki-sf/"/>
      <url>/isukari-2016-yokohama-eki-sf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>橫濱車站開業已逾百年，歷經三度大規模重建，至今仍持續添加建物、翻新與維修，因此被戲稱為日本的聖家堂。如果橫濱車站的工程持續下去，它會成為什麼模樣？會有完工的一天嗎？還是跟生物演化一樣，變得與往昔不同，卻沒有特定的方向？《橫濱車站sf》便是這種科幻猜想的延伸，搭配簡單的故事結構，讓讀者跟著主角進入被無限增值的車站所佔據的日本列島。</p><span id="more"></span><p>在故事發生前數百年發生了以衛星兵器為主要攻擊手段的世界大戰，為了避免政府機能因重要都市被摧毀，日本在全島的鐵路建立了分散式管理的人工智慧。由於有許多節點，即使單一節點被破壞，仍能維持大多數機能。橫濱車站被選為自組織建築的試驗品，實現了建築物自動維修、建設與拓展的機能。然而，失控的橫濱車站卻開始沿鐵路侵占其他土地，在陸地鋪滿地下鐵結構，例如電扶梯、水泥牆與隔間等。</p><p>由於人工智慧節點被車站搶占，無法維持原有的機能。失去人工智慧輔佐的人類無法阻止橫濱車站擴張，最終退守到北海道與九州等外島地區。剩餘的人類則被豢養在橫濱車站內，他們身上被安裝了特殊的晶片，受到車站自動驗票機的管理，逐漸喪失在外處生存的體力與生活常識。</p><p>儘管本州多數地帶遭橫濱車站佔據，仍有少數地帶因地形崎嶇而保留原樣。通常，這些地帶土地貧乏而無法供養人口，但「九十九段下」這一帶因為鄰近車站的廢棄物排出口，所以站外的人得以靠這些廢棄物生存。</p><p>主角尋人自小成長在九十九段下，那裡的名字來自於兩道有九十九階的下行電扶梯。孩子們總會逆著電扶梯的方向爬到車站入口，證明自己已經成年。尋人自小體格健壯，比起其他人更早登上電扶梯頂。然而，對於生長在九十九段下的居民而言，除了登上電扶梯外，沒有其他更驚心動魄的挑戰了。</p><p>隨著年齡成長，其他同儕也有能力登上電扶梯，所以尋人也不再出眾。即使登上電扶梯，也會被門口的自動驗票機擋住，因此如果繼續生存下去，他的生活也沒有其他期待。</p><p>偶爾，會有站內居民因為犯法等因素被驅逐，所以尋人可以得知站內的狀況。有一名自稱菸管同盟成員的男子告訴尋人，他們的組織想要奪取橫濱車站的控制權，讓人類不受無機物的奴役。男子給予尋人進站的臨時車票後不久便離開人世，臨終前交代他去見同盟首領，尋求推翻車站的意見。尋人雖然平時胸無大志，仍抱著進到車站見見世面的想法。</p><p>臨行前，尋人跟同樣來自站內的「教授」對談，教授建議尋人到站內尋找 42 號出口，因為那裡藏著一切的解答。</p><p>接下來的故事內容與遊記相當，尋人在尋找同盟領袖的過程中，見識了站內無所不及的廣告，被吸引到咖哩飯館，卻因為無法支付餐費被居民自發的自治管理會逮捕。在監禁處認識了來自北海道的機器特務，在特務協助下逃跑。特務於途中被另一帶的民眾摧毀，尋人只好攜帶機器特務的主要記憶體，前往他們討論出同盟領袖可能居住地。</p><p>尋人尋找維修機器特務的過程中，誤打誤撞見到現為電器行老闆的首領，她被圍困在車站地下，靠著偽造的GPS訊號誤導自動驗票機才倖存。首領告知尋人42出口的位置，於是尋人便前往該處，找到了一間研究室，開門後等待他的是投影出的人像，向尋人解釋橫濱車站的起因與解決事件的關鍵。而這段故事也穿插了一名在九州長大的幹員，因為討厭人群而主動請纓到本州調查，意外解救了從 42 號出口逃跑的尋人。</p><p>故事的結局沒有劇烈的地震和轟炸，只有橫濱車站緩慢的崩毀，尋人回到九十九段下，與居民一起學習耕種技術，為往後車站瓦解的危機做準備。</p></br><p>《橫濱車站sf》的故事情節並不跌宕，如同在 42 號出口現身的人工智慧所述，主角尋人就像是讓沙堆崩塌的最後一粒沙子，本身並沒有特殊之處，只是在正確的時間出現在對的位置，才引發了巨變。尋人進入車站的動機薄弱，想要反抗車站的想法不堅定，探索過程甚至會受到廣告吸引而偏離方向。即使故事還有四、五個角色，但他們也不是受到迫切的危機驅動而行動。橫濱車站仍緩慢地侵蝕大地，被豢養的人類也安於現狀，最大的暴力也沒有摧毀一切的血腥。</p><p>這本書最吸引人的是故事設定，角色的行動和情節的安排都是為了順利陳述一個被橫濱車站佔據的末日世界，還有別於大眾想像，一個沒有爆炸性的結尾——但這結尾可能符合作為生物研究者的作者想像。在生物體裡面，緩慢地燃燒其實就是腐敗。另外一個看點則是到處可見的致敬元素，最明顯的是章節標題致敬了許多科幻小說。內文有吐槽一些日本當地的現況，但我讀不太懂。在尋人初次碰到半身機器人的時候，也捏他了鋼彈的「腳只是裝飾，上面的人士不會懂的」。</p><p>至於從寫作的角度思考，我覺得這本書蠻適合參考的。科幻小說其中一個魅力是為讀者營造奇異的世界，讓人讀後產生「哇」的感想，這種驚嘆甚至能弭補故事情節的平淡。因此，如果能想出一套好設定，並且盡力呈現給讀者，即使採用最老套的故事情節，也有機會創造很棒的閱讀體驗。</p><hr><p>柞刈湯葉（2018）。橫濱車站sf（林哲逸譯）。台灣角川。（原著出版於 2016 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fasta index file (.fai) 是什麼？</title>
      <link href="/what-is-a-fasta-index-file/"/>
      <url>/what-is-a-fasta-index-file/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用參考基因體進行分析時，如果沒有提供對應的 Fasta index 檔 (<em>.fai</em>)，很有可能跳出以下這類錯誤訊息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># HaplotypeCaller</span><br><span class="line">ERROR MESSAGE: Fasta index file ref.fasta.fai for reference ref.fasta does not exist.</span><br><span class="line"># freebayes</span><br><span class="line">unable to find FASTA index entry for &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>這個 <em>.fai</em> 究竟是什麼？為什麼許多分析需要它？</p><span id="more"></span><h1 id="Fasta-index-file"><a href="#Fasta-index-file" class="headerlink" title="Fasta index file"></a>Fasta index file</h1><p><em>.fai</em> 是 Fasta 的索引，記錄了各序列的位置，能提升軟體擷取子序列的效率。假設我們想從一萬條 DNA 序列取出位於中間的鹼基。在沒有索引檔的情況下，每一次都得從第一個鹼基讀取，直到抵達指定位置後再回報結果（循序存取，sequential access）。循序存取的效率取決於 DNA　長度，因此其時間複雜度為 $O(n)$。</p><p>不過，如果事先掃描整個 Fasta 並建立索引檔，便能依據索引檔直接取用目標子序列，達到 $O(1)$ 的時間複雜度（隨機存取，random access）</p><h1 id="samtools-faidx"><a href="#samtools-faidx" class="headerlink" title="samtools faidx"></a>samtools faidx</h1><p><a href="https://www.htslib.org/doc/faidx.html">samtools faidx</a> 可用於建立參考基因體的索引檔。使用時應確保 Fasta 每條序列等長（除了最後一列）。輸出檔名預設為原 Fasta 檔名加上 <em>.fai</em> 後綴。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samtools faidx ref.fa</span><br></pre></td></tr></table></figure><p>以此指令建立的 <em>.fai</em> 共有五欄，</p><ul><li>NAME：序列名稱，即 “&gt;” 之後的字串</li><li>LENGTH：序列的鹼基總數</li><li>OFFSET：由 0 開始計算，序列第一個鹼基為 FASTA 檔第幾個字符（含換行符）</li><li>LINEBASES：每一列的鹼基總數</li><li>LINEWIDTH：每一列的字符總數（含換行符）</li></ul><p>舉例來說，如果換行符為 “\n”，那麼序列 s1 的總長為 10 鹼基，始於第 4 個字符，每一列有 5 鹼基、6 字符。</p><p><strong>example.fasta</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;s1</span><br><span class="line">AAAAA</span><br><span class="line">CCCCC</span><br></pre></td></tr></table></figure><p><strong>example.fasta.fai</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#NAME   LENGTH   OFFSET  LINEBASES LINEWIDTH （實際不存在此列）</span><br><span class="line">s1      10       4       5         6</span><br></pre></td></tr></table></figure><p>獨到這裡，可能有人會問為什麼 OFFSET 是 4 而不是 1？這是因為，OFFSET 是序列第一個鹼基在整個檔案的位置，而非它在序列中的座標。因此，計算位置時連序列的名稱都要一起計算。從 0 開始計算，序列 s1 的一個鹼基正好位於第 4 個字符，所以 OFFSET 才會等於 4。</p><h1 id="Python-實作：模仿-bedtools-getfasta"><a href="#Python-實作：模仿-bedtools-getfasta" class="headerlink" title="Python 實作：模仿 bedtools getfasta"></a>Python 實作：模仿 bedtools getfasta</h1><p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/getfasta.html">bedtools getfasta</a> 的功能是依據 BED 檔從 Fasta 檔擷取子字串。BED 檔是紀錄區域的格式，普遍含有染色體、起始位置、終止位置和辨識碼四個欄位。比較需要留意的是，BED 檔的位置是從 0 開始計算，和 GTF 之類的格式不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ref.fa</span><br><span class="line">&gt;chr1</span><br><span class="line">AAAAAAAACCCCCCCCCCCCCGCTACTGGGGGGGGGGGGGGGGGG</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> test.bed</span><br><span class="line">chr1 5 10 myseq</span><br><span class="line"></span><br><span class="line">$ bedtools getfasta -<span class="keyword">fi</span> ref.fa -bed test.bed -tab</span><br><span class="line">chr1 5 10 AAACC</span><br></pre></td></tr></table></figure><p>以下使用 python 模仿 bedtools getfasta，利用 <em>.fai</em> 計算子序列在 Fasta 檔的位置，再透過 f.seek() 實踐隨機存取（參考<a href="https://stackoverflow.com/questions/51801213/complexity-of-f-seek-in-python">Complexity of f.seek() in Python</a>）。簡言之，我首先讀取 BED 檔各列，存為 list 備用。*.fai* 則存為 dict，以 name 為 key，其它為 value，這樣就能依照 name 找到座標資訊。</p><p>每次讀進 BED 一個區域的 start 和 end，再用以下關係式找出該區域在 Fasta 檔的位置。</p><ul><li>目標區域在 Fasta 的起始位置 &#x3D; offset + linewidth * (start &#x2F;&#x2F; linebases) + start % linebases</li><li>目標區域在 Fasta 的終點位置 &#x3D; 子序列的起始位置 + region_length + end &#x2F;&#x2F; linebases</li></ul><p>實際執行時，先用 f.seek() 跳到起始位置，再用 f.read 讀到終點位置，刪除中間的換行符號，便能獲得目標區域的子序列了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_bed</span>(<span class="params">path</span>):</span><br><span class="line">    bed = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            chrom, start, end, name, *_ = line.strip().split()</span><br><span class="line">            bed.append([chrom, <span class="built_in">int</span>(start), <span class="built_in">int</span>(end)])</span><br><span class="line">    <span class="keyword">return</span> bed</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_fai</span>(<span class="params">path</span>):</span><br><span class="line">    fai = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            name, length, offset, linebases, linewidth = line.strip().split()</span><br><span class="line">            fai[name] = [<span class="built_in">int</span>(length), <span class="built_in">int</span>(offset), <span class="built_in">int</span>(linebases), <span class="built_in">int</span>(linewidth)]</span><br><span class="line">    <span class="keyword">return</span> fai</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_fasta</span>(<span class="params">fa_path, fai_path, bed_path</span>):</span><br><span class="line">    bed = read_bed(bed_path)</span><br><span class="line">    fai = read_fai(fai_path)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> chrom, start, end <span class="keyword">in</span> bed:</span><br><span class="line">        length, offset, linewidth, linebases = fai[chrom]</span><br><span class="line">        region_length = end - start</span><br><span class="line">        region_start = offset + linewidth * (start // linebases) + start % linebases</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fa_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.seek(region_start)</span><br><span class="line">            substring = f.read(region_length + end // linebases).replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            results.append([chrom, start, end, substring])</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">            </span><br><span class="line">get_fasta(<span class="string">&quot;ref.fa&quot;</span>, <span class="string">&quot;ref.fa.fai&quot;</span>, <span class="string">&quot;test.bed&quot;</span>)</span><br></pre></td></tr></table></figure><p>最後附上 samtools 使用手冊和國外論壇的簡介供參考：</p><ul><li><a href="https://www.htslib.org/doc/faidx.html">samtools faidx</a></li><li><a href="https://www.biostars.org/p/98885/#98966">what is in the fasta.fai</a></li><li><a href="https://www.biostars.org/p/1495/">Can You Please Tell Me Where I Find Information About .Fai File Format?</a></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎麼準備 bwa 所需的 .alt 檔？</title>
      <link href="/how-to-create-bwa-alt-files/"/>
      <url>/how-to-create-bwa-alt-files/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>因應 GRCh38 納入 alternate contigs (ALT contigs)，BWA 早在 <a href="https://sourceforge.net/p/bio-bwa/mailman/message/32845712/">2014 的更新</a> 便開始支援 alt-aware mapping（詳見 <a href="https://github.com/lh3/bwa/blob/master/README-alt.md">bwa&#x2F;README-alt.md</a> 以及 <a href="https://sites.google.com/a/broadinstitute.org/legacy-gatk-documentation/tutorials/8017-How-to-Map-reads-to-a-reference-with-alternate-contigs-like-GRCh38">GATK 的教學</a>）。</p><p>使用 alt-aware mapping 模式需要準備 <em>.alt</em> 檔，它記錄了 ALT contigs 在參考基因體 (primary contigs) 的位置，可以用 ALT contigs 拿 BWA 比對參考基因體生成。因此，*.alt* 實際上是 SAM 格式，而不是使用 bwa index 建立的索引格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bwa mem ref.fa alt.fa &gt; ref.fa.alt</span><br></pre></td></tr></table></figure><span id="more"></span><p>ALT contigs 是同段基因在不同族群的變體，納入它們可以提升參考基因體的族群代表性。人類參考基因體的建置最初僅納用少數個體的定序資料。人類基因體有一些多樣性高的區域（例如 MHC），它們的序列往往迥異於參考基因體，所以比對軟體難以定位來自這些區域的定序產物，降低變異分析的靈敏度。為了減輕參考基因體相關的偏誤，GRCh38 版本基於千人基因體 (1000 Genomes) 等計畫的研究成果，納入了將近 109 Mb 長的 ALT contigs。</p><p>然而，ALT contigs 仍保留與參考基因體相似的片段。因此，一條序列可能同時吻合 ALT contigs 或原參考基因體，導致軟體無法區別序列來源，低估了比對的可信度（即 MAPQ, Mapping Qualities）。詳情可參考 illumina 簡介：<a href="https://jp.support.illumina.com/content/dam/illumina-support/help/Illumina_DRAGEN_Bio_IT_Platform_v3_7_1000000141465/Content/SW/Informatics/Dragen/GPipelineAltMap_fDG.htm">ALT-Aware mapping</a>。</p><p>為此，需要額外資訊來記錄 ALT contigs 和參考基因體的關係，讓比對軟體能妥善處理 GRCh38 這類含有 ALT contigs 的參考基因體。在 bwa，額外資訊儲存在 <em>.alt</em>。</p><p><em>.alt</em> 的格式為 SAM，記錄了每條 ALT contigs 在原本參考基因體的位置。提供 <em>.alt</em> 之後，bwa 會註記能比對到 ALT contigs 的結果。假如序列與 ALT contigs 契合，bwa 便會以 ALT contigs 為代表來計算比對分數，最後透過 <em>.alt</em> 的座標資訊找到輸入序列在參考基因體的正確位置。</p><p>建立 <em>.alt</em> 的具體做法如下：假設有參考基因體 <em>ref.fa</em> 和 ALT contigs <em>alt.fa</em>，首先使用 bwa 創建 <em>.alt</em> 檔，再合併 <em>ref.fa</em> 和 <em>alt.fa</em> 為含有 ALT contigs 的 <em>ref_alt.fa</em>。最後再用 bwa index 生成其他序列比對所需的索引檔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bwa mem ref.fa alt.fa &gt; ref.fa.alt</span><br><span class="line"><span class="built_in">cat</span> ref.fa &gt; ref_alt.fa</span><br><span class="line"><span class="built_in">cat</span> alt.fa &gt;&gt; ref_alt.fa</span><br><span class="line">bwa index ref_alt.fa</span><br></pre></td></tr></table></figure><p>剩下步驟可參考 <a href="https://sites.google.com/a/broadinstitute.org/legacy-gatk-documentation/tutorials/8017-How-to-Map-reads-to-a-reference-with-alternate-contigs-like-GRCh38">How to Map reads to a reference with alternate contigs like GRCh38</a> ，簡言之，使用 alt-aware mapping 只是第一步，還需要用 <a href="https://github.com/lh3/bwa/tree/master/bwakit">bwa-postalt.js 腳本</a>處理那些有配對到 ALT contigs 的序列（這支腳本擺在 bwa&#x2F;bwakit 裡面，所以要去 github 下載）。</p><hr><p><em>註 1： .alt 是採用 alt-mapping 的必要檔案，但本文提到的參考資料都沒講清楚它的生成方式，才會有那麼多貼文求助。</em></p><ul><li><a href="https://github.com/lh3/bwa/issues/231">How to create .alt index file?</a></li><li><a href="https://www.reddit.com/r/bioinformatics/comments/17snuzk/bwa_fasta_alt_file_for_grch38p14/">BWA fasta alt file for GRCH38p14</a></li><li><a href="https://www.biostars.org/p/432382/">BWA .alt index file</a></li></ul><p><em>註 2：當初這方法提出時，bwa 的作者其實不鼓勵使用含有 ALT contig 的參考基因體，不過現今 WGS&#x2F;WES 成熟、註解資料庫相容、而且有許多 multi-genome mapper，風向也漸漸改變了。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>午後飛行</title>
      <link href="/lfr-2024-afternoon-flight/"/>
      <url>/lfr-2024-afternoon-flight/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 R503 實驗教室因為我擅自闖入而被封閉前，我和一起參加生物學科競賽的朋友 L 與 R 很常待在那消磨午後時光。R503 教室位於科學大樓五樓，僅在實驗課程期間開放。它平時允許選手借用，但很可能只適合準備筆試，因為顯微鏡鎖在防潮箱，滴管與玻片等耗材也堆在隔壁的儲藏室。現在想來，那裡好像只比一般教室多了水槽和有滑軌抽屜的大桌子，不過我們當時很喜歡。那裡不在教官與老師的巡堂路線上，即使嘻笑打鬧、丟紙飛機、甚至在地上打滾也沒人干涉，很適合焦躁無處宣洩的高三生。</p><span id="more"></span><p>大學入學測驗的成績公告當天，簡訊通知遲遲未到。教室裡按壓原子筆、提筆又放下的聲響此起彼落，讓人難以專心。我闔上遺傳學課本，把它和鉛筆盒一起塞進書包，趁英文老師在黑板寫字時從後門溜出。離開前，我瞥見 L 對我苦笑，於是向她揮手，表示待會見。</p><p>原以為上課時間路上不會有人，卻在樓梯轉角碰到班導。我撇開頭假裝沒看見，加快腳步繼續走，但身後很快傳來班導的聲音。「等一下，」她抱著一疊數學習題本，站在比我高兩、三級的階梯上打量我。</p><p>「去哪裡？」</p><p>「實驗教室，我想——」</p><p>「想什麼？覺得自己考很好，可以隨便翹課？還是進決賽，有學校讀了？」</p><p>「不是……呃，還沒公布……」我吞了口水，往後靠在牆上。雖然勉強擠出笑容，雙手仍背在身後微微顫抖。下課鐘聲響起，同學陸續從旁經過，我的眼神飄忽不定，手指無意識地觸摸牆面剝離的油漆，感到指尖沾到了灰塵與碎屑。</p><p>她仍不放過我，持續追問「有什麼更好的理由曠課？」正當我愣在原地不知所措時，樓上傳出一聲驚呼，隨後喧嘩聲迴盪整棟教學大樓，班導不得不上樓管秩序。看來成績總算公布了，我鬆一口氣，拍拍雙手讓細屑灑落。我趕緊下樓，穿過來往福利社的同學，獨自來到科學大樓。</p></br><p>此時接近正午，推開 R503 教室嘎吱作響的鋁門，一股熱氣帶來混合了灰塵、黴菌與水蒸氣的味道。破舊的抹布晾在水龍頭上，杯刷和洗碗精擺在水槽桌旁。清洗器皿殘留的泥土附著在排水蓋周圍，其中鑲嵌沒清理乾淨的碎玻片，映射著白熾的日光。</p><p>「我要是知道比賽結果，也不用那麼煩惱了吧。」我逐一打開窗戶，拿起筆記本走出教室，靠在外牆坐下，等待難聞的氣味消散。我閉上眼睛試著回顧遺傳圖譜的推算方式，但班導的話揮之不去。陽光穿透眼皮在視網膜上投映出建築與雲朵的輪廓，它們像是帶有雜訊的映像管電視畫面。我轉動眼球追逐這些飄忽不定的形狀，卻始終無法聚焦在任何一塊。</p><p>等我再次睜開眼睛，已經是午休時間。</p><p>「齁，翹課睡覺。」L 撿起筆記本放在我頭上。</p><p>「我在調節褪黑激素分泌好嗎？」我拿下筆記本，伸出手讓她穩穩把我拉起。</p><p>一見到 L，我忍不住抱怨上午與班導的對話。L 的回應不外乎「畢竟我們也算升學取向的學校啊。」或是「她只是注重秩序啦。」，但她的語調有讓人冷靜的效果。</p><p>進到教室後，L 本來想跟我聊一下比賽的事情，卻被「快看、快看。」的呼喊聲打斷。我不用看也知道那是 R。她調整完呼吸之後，說她在圖書館查成績的時候，從回收區找到一袋淘汰的科普雜誌。我拖了椅子到桌前，隨手抽出一本來讀。嗯，即使是過期雜誌，還是比我們的教科書新鮮。</p><p>「這不都一樣的嗎？」L 翻著袋裡剩下的雜誌。R 立刻取回袋子反覆確認。她眼睛睜得大大的，那副以為撿到便宜卻買到假貨的表情，讓我忍不住大笑。</p><p>那期的主題是飛行力學，收錄很多紙飛機的製作圖解，但可粗略分為兩種。標槍式紙飛機經反覆摺疊，只保留了短短的平衡翼，可以大幅降低空氣阻力。不過，創下世界紀錄的還是機翼寬闊的滑翔式紙飛機，它能利用上升氣流增加滯空時間，卻也因此容易受到擾動而偏離方向。</p><p>R 從書包倒出考卷躍躍欲試，我也跟她要了幾張照著步驟摺。L 遲遲沒動手，倒是撿起考卷納悶：「明明平常很粗心，為什麼考那麼好啊？」不過我們都知道，R 早已透過特殊選才錄取 T 大了。</p><p>我和 R 抱起成堆紙飛機到走廊試丟。L 雖然不感興趣，還是同意擔任裁判，在走廊末端紀錄落點。標槍式紙飛機的飛行距離似乎只取決於臂力，我和 R 練習一下都能穩穩扔過一、兩間教室。它的飛行軌跡與典型的拋物線相同，所以我覺得比起射紙飛機，自己更像在丟球。</p><p>我也摺了滑翔式紙飛機，但一直抓不到要領。出手後不是直衝天花板，就是擦撞窗戶墜機，讓我開始懷疑雜誌的可信度。L 提著裝有紙飛機的塑膠袋走回來，告訴我們走廊的挑高不夠，或許要到操場測試。R 聽了毫不猶豫把紙飛機朝外丟。科學大樓在校園最高處，兩側則是教學行政大樓，樓外有龍柏和樟樹等常見的校樹。中庭平時會有來往福利社的同學，現在卻空蕩蕩的。最初，R 的紙飛機沿直線飛行，隨後受到空氣阻力而向上攀升，過了最高點後翻了一圈，在下降時靠著機翼往前滑行、滑行、滑行，幾乎快到另一側的視聽教室了。「哇！」我不顧 L 勸阻，也立刻丟了一架，它卻在垂直爬升後失速墜落。</p><p>當我打算再試一次時，L 告訴我底下有人在看，我們三個同時蹲下。可是大概只等了五秒鐘，還是聽見 R「喝啊」一聲。這次，紙飛機筆直飛往學務處。R 臉色驟變，匆忙下樓回收紙飛機。看著 R 小小的人影跑過中庭，我揉揉因為摺紙而紅腫的指腹問：「妳剛剛想說什麼嗎？」</p><p>L 開了口，又突然停下，然後我都聽見了。</p><p>原來，在我對現況狐疑不決的時候，L 早已發現她一點也不喜歡生物學。</p></br><p>過了一周，我走進教室期待能看到決選通知單，但桌上只有警告單、午餐訂購單，以及剛收到的大考成績單。上午的自習課，有些同學在整理推甄入學的備審資料，成績不理想的也早已戴起耳塞準備七月的筆試分發。至於我，仍然猶豫要跟著準備筆試，還是爭取競賽保送名額。我把那疊通知單隨意塞到桌墊下，從抽屜抽出一本書來讀，但只翻了幾頁又放回去，腦中浮現與 L 在 R503 教室外的對話。</p><p>L 說完，我問她考得如何。</p><p>「算有達到預期。」L 說。我突然意識到，自己這麼問，好像在期待能找到同病相憐的夥伴。</p><p>「那妳……啊，算了。話說，妳之後還想繼續念生物嗎？」</p><p>「嗯啊？」</p><p>「我想跟妳說，我其實打算申請資工系。」</p><p>「那比賽呢？」</p><p>「應該不參加了。」</p><p>我捏捏臉頰避免自己又迷失在回憶裡，並且趁午休諮詢生物老師。他說：「如果給他一個小時拯救世界，他會花五十九分鐘思考解決辦法。」意思好像是要我別著急，但他又補了一句：「雖然我也不確定剩下一分鐘夠不夠用。」唉，我原本都快想通了。</p><p>我再次踏進 R503 教室，但這回只有我一個人。R 請假參加大學先修課程，L 在圖書館整理備審資料。我翻著 R 帶來的雜誌，學習其它種紙飛機的製作方法。風吹得那堆雜誌掀起又蓋下，我把普通生物學課本壓在上面，目光和封面那頭長著羽毛的恐龍對上，摺紙的興致頓時消失。我想想還是準備一下段考和筆試比較好吧，於是拿起紙筆開始畫行事曆，注意力卻被飛近的巨大蒼蠅吸引。牠被我揮開後，逐漸接近吊扇。不知道為什麼，牠很執著其中一片扇葉，試了幾次終於停在上頭，跟著快要故障的吊扇，速度不均勻地旋轉、搖晃著。</p><p>外面下著毛毛雨，我抱起紙飛機走回班上，把它們放到課桌椅的置物架晾乾，打算整理一下雜亂的桌面。然後，我在新的警告單、明天的午餐訂購單和升學講座調查表底下，看到了那封只露出一角的競賽決選通知信。</p></br><p>「很久沒人入選了。」遞給我賽事資料袋時，課務組長說。我忍不住偷看螢幕上的報名系統問：「還有其他人嗎？」</p><p>「有一個，但昨天取消了。」好吧。</p><p>「嗯？」沒事。</p><p>我撕開資料袋拎出簡章：為期一周的決選將從五十名選手挑出四名代表，參與國際生物奧林匹亞競賽。不過，只要成績名列前二十五，即可保送大學相關科系。決選將在二十八天後舉行，不到一個月？我開始後悔因為猶豫而耽誤的時間。原以為有 R 的先例，或許我也能請假備賽。然而，組長說他無法作主，我只好硬著頭皮去見班導。</p><p>我已經高三了，這次是爭取保送資格的最後機會。比起分心與全國的自然組學生競爭筆試分發，我覺得專心備賽的勝算更高——儘管風險也很大。一旦落榜，備考時間將所剩無幾。班導沒有答覆這項提議，反而問我不上課要怎麼學習。我表示能像生物科一樣自己讀。</p><p>「自己讀？」她輕笑一聲，隨手寫下一組多項式，把紙筆推到我面前：「來，積分看看。」</p><p>我拿起筆，腦袋卻一片空白。</p><p>「這是上週的進度，筆試分發也會考。」她說，「別再浪費時間逃避了，妳不會每次都那麼幸運。」</p><p>我默默收回請假申請表。誠如班導所述，我只勉強通過初試門檻。儘管把生物老師的書複習了好幾遍，也沒把握複試能夠晉級。可是，她怎麼這樣說，風險又不是她承擔。</p><p>走廊掃得很乾淨，我踢開想像出的小石子，咕噥著：「什麼嘛……」</p><p>回到班上，我拿起簡章不停翻頁。決選不只考驗理論知識，也重視實作經驗。我比較熟悉筆試，至於實驗……其實，我照著食譜都未必能端出可以吃的東西。因此，接下來如果無法有效練習，我很可能要就此止步。由於遲遲沒查到出題方向，我放下簡章，轉而去請教生物老師，可惜他對決選內容也同樣陌生。儘管如此，他還是照例借我備賽用書，但面有難色地提醒：「最後那本很少人能讀懂。」</p><p>今天也累透了，我打算到 R503 教室休息，順便寄放沉甸甸的參考書。進門時卻撞見 L 在搶 R 手上的紙。</p><p>「妳們怎麼在這？」我說。</p><p>「妳不是要我幫忙看自傳嗎？」R 說。</p><p>「但妳改得很奇怪啊。」L 說。R 作勢要唸出來，卻立刻被阻止了。我噗哧一笑，看來除了 L 桌前擺著計算機概論以外，R503 教室一如往常。</p><p>L 和 R 停下打鬧轉頭看我，「算了，跟妳們說……」我說。</p><p>「查不到歷屆題目？」L 說，「有問人嗎？那網路呢？」</p><p>「都試過了。」我嘆口氣說。官方網站只有歷屆理論試題，實作題庫的頁面顯示不出來，我還在等主辦單位回覆。資優班同學也說他們不清楚，特教組近年似乎更注重科展，所以都沒派人參賽。</p><p>我拍拍臉頰振作起來，抽出那本宣稱非常困難的書，想做點現在可以做的事。書脊用膠帶補強好幾次，頁間也夾滿便箋，看來是生物老師多年心血。不過我攤開一讀，果真看不懂，老師的字跡潦草到無法辨識，想起他遞書給我時的表情，我早該有心理準備。</p></br><p>那天起，我每天都在看書、解題、躲避老師視線看書、嘗試不同策略解題。理論部分全為申論題，有許多「如果……會怎樣……」的題型，像是評估阻斷某神經傳導物質受器對個體的影響。這些題目可以從解剖、生理和生化等方面解讀，作答需要對生物系統有全面理解。</p><p>同時，我翹課的頻率也直線攀升。我和生物老師討論後，決定先從課綱內容著手。早自習前，我會在老師協助下準備實驗器材；一到中午，就趕去 R503 教室開始練習。有時進度落後，難免要犧牲下午的課程。</p><p>過不久，我起床後感到全身無力，當時浮現的第一個念頭卻是：太好了，可以請假做實驗。那天預計要觀察溫度對澱粉酶活性的影響，我檢查桌上試劑的標籤後，問老師酵素哪裡來，他做出吐口水的動作要我自己蒐集。我忍著喉嚨痛，點燃酒精燈加熱混著唾液、澱粉液和本氏液的試管。午休時，R 一進門指著五顏六色的試管說很像彩虹。我想戳破她詩意的想像，但喉嚨如有刀割，發不出聲音。L 覺得不對勁，摸了我發燙的額頭，要我立刻去看醫生。</p><p>結果，我不但沒練習到實驗，還在宿舍床上躺了整整三天。康復後，雖然追不回時間，我還是急奔到 R503 教室。</p><p>「唔，來了。你還好嗎？」L 說，我點點頭。R 把新買的智慧手機遞給我，她在網頁庫存找到以前學長的參賽心得，而且官網的歷屆試題頁面也修復了。</p><p>「怎麼會？」我感到頭皮發麻，原來我的練習和實際落差懸殊，像是脊椎動物的解剖已因人道因素廢除，需要久候的生化實驗也不在考試範圍。而且，實作題跟理論密切相關，不是照表操課那麼簡單，例如其中一道題目要求選手用現場提供的材料，設計實驗來驗證植物細胞的滲透假說。我持續滑動文件，眼前浮現越來越多沒看過的名詞。</p><p>我對著小小的螢幕抄寫資訊，不顧午休時間衝進辦公室，想確認學校有沒有對應的試劑與器材。我屏住氣看生物老師在清單上逐一打勾，但他突然停下筆：「啊，下禮拜要實驗課。」這表示，接下來我都沒辦法進 R503 教室。</p><p>我尋常地坐在教室，卻沒把反應平衡常數或微積分基本定理放在心上。實驗器材不能外借，我憑印象到書局買了相似物品，至少能偷偷在課堂裡加強稀釋和切片等基本技巧。因為 L 提醒我這樣做的觀感不好，我後來也收斂許多，只在自習課練習。不過，班導看見我的課本沾滿植物汁液，氣得沒收實驗器材。我站起來抗議，結果全班都轉頭盯過來，我才雙手抱胸坐下。</p><p>「明明很多人也不看課本的啊。」我低聲抱怨，現在我只剩下想像力了。據說，解剖學和外科醫學最初也在無法親自動手的條件中發展。我盯著插圖，想像自己剖開昆蟲的軀幹，接著湊在補充的顯微照片旁，雙手滑動書頁假裝調整顯微鏡。這個距離，連紙上的墨點與纖維都清晰可見。意識到這只是徒勞，我渾身無力趴在桌上，側臉緊貼書面，期待知識會在睡夢中自動滲入大腦。</p><p>然而，我比較常夢到考試。正襟危坐在小學教室，被要求證明不存在的遺傳定律。但往往在半夢半醒間掙扎一晚，才發現題目前提有誤或是根本沒發考卷。理論越寫越陌生，還得煩惱實作練習。即使不是作夢，我在課桌上抖一下驚醒後，也常陷入某種錯覺：槍響之後，我抬起頭會不會發現跑道上只剩下我一個人，連頒獎典禮都結束了？</p></br><p>輪到我們班的實驗課時，因為有人不敢解剖牛蛙，生物老師同意我課後留下來練習。他叮嚀我收拾好器材後離開，教室鑰匙被忘在講台旁的課桌上。練習時，我不時瞥向那副鑰匙。收拾完畢後，我一直待在那裡。可是直到住宿生的晚自習前，老師都沒出現。我在走廊往兩側張望，心跳越來越快。我匆忙回到教室，把解剖刀和針盒裝進塑膠袋，藏在防潮箱後面，然後深吸一口氣將鑰匙放入口袋，把門反鎖後離開科學大樓。</p><p>「周末有空嗎？」我在 L 耳邊小聲講出計畫，她聽了嚇一跳，叫我趕快把鑰匙還回去。不過當天她仍以監督我的名義現身，一旁跟著不想錯過任何冒險的 R。昆蟲解剖是動物學實驗的必考項目，即使沒有試劑也能練習。本來我打算到市區找捕蟲網，還一直思考要去哪抓蟋蟀，但 L 說其實可以到爬蟲寵物店購買活餌，才解決了我的煩惱。</p><p>科學大樓本來路過的人就不多，假日午後又更加幽靜。我讓 L 和 R 在一樓把風，直到打開門鎖才呼喚她們上來。一進 R503 教室，我像到家一樣放鬆。室內殘留著藥劑與腐臭味，我打開吊扇通風，伸長手從夾縫勾起塑膠袋，拿出針盒、刀具和蠟盤，和裝著蟋蟀的塑膠杯一起擺在桌上。我夾出死掉的蟋蟀，放在蠟盤中央以大頭針固定肢體。最初我想照著書上的指示剪開腹部，但解剖牛蛙用的工具尺寸不符，只得從宿舍拿來縫紉包裡的小剪刀。</p><p>刀刃不太鋒利，我又沒正確施力，一不小心把蟋蟀身體弄得破破爛爛的。我拿起鑷子撐開牠的腹部，受損的器官糾纏在一起，很難確認眼前看到的和書上描述的是否相同。我這才明白，之前打算用示意圖認識生物構造，就跟拿捷運路線圖來熟悉巷弄一樣不切實際。</p><p>最初 L 和 R 湊過來時，我還能搭上話題，後來卻逐漸沉默。我倒水沖掉混濁的體液，把蠟盤放到解剖顯微鏡下整理，卻沒辦法把消化道和其他器官分離乾淨。她們買回晚餐時，我正在解剖第二隻蟋蟀，還是不時傷到組織。我拿針在顯微鏡下挑開肌肉，把其他器官排好，想要紀錄所觀察到的型態，還有課本沒解釋清楚的細節。然而，顯微鏡焦距不時跑掉，筆芯也畫斷好幾次。</p><p>「要休息了嗎？」L 說。</p><p>「嗯。」我離開目鏡，看著蟋蟀殘破的遺體，才嗅到濃厚的腐臭味。</p><p>收拾器材之後，R 問我們要不要走一走，她指著天花板，舉起雙手做出爬梯的動作。L 難得直接答應，還代替我回答，不留一點猶豫時間。我們把燈關上，像被印痕的小鴨跟著 R。她說要讓瞳孔適應黑暗，我們只好扶著牆壁，摸黑走到頂樓。樓梯盡頭有一把梯子，架在通往樓頂的洞口。我和 L 扶著梯子，讓 R 先上去打開鐵門。當我冒著手汗踏上樓頂，景觀卻令人失望，視線都被水塔、風管和遮雨棚擋住了。</p><p>所幸天氣很晴朗，晚風也很舒服，讓我稍稍放鬆下來。都市的燈光染白夜空周圍，我弓起手掌罩住眼睛周圍，還是能依稀看見幾顆比較亮的星星。我們跨過管線，聚在女兒牆邊聊起天，內容不外乎抱怨某某老師或討論哪個同學的傳聞，最後不知為何聊到了各自的志向。我覺得自己對往後的人生雖然沒有清晰的輪廓，卻很希望能在其中點綴不一樣的回憶，才總是搞得心神不寧。</p><p>正當我想問她們當初為什麼讀自然組時，R 突然說：「為什麼生物實驗室在五樓？」</p><p>「我國中的就在二樓。」L 說。</p><p>「但我們學校的地科教室在一樓啊。」</p><p>「有差嗎？」我說。</p><p>「生物教室接近土壤，地科教室靠近天空，不是比較對嗎？」R 說完，像是想起什麼，從口袋拿出很酸的糖果分給我們。R 說，要用它來建立條件反射，記住這個晚上。</p><p>「妳怎麼知道吃了糖果能想起夜景——」L 說。</p><p>「還是看到天空就開始滴口水啊？」我說。</p><p>「妳別說出來啊！」L 說，我們三個笑了起來。</p></br><p>接下來幾天，我求宿舍自治幹部幫忙捏造晚自習出席紀錄，好讓我有時間練習其他部位的解剖。第三天一早，我到 R503 教室開門，卻撞見生物老師。「我……」他抬手輕揮，像在說「別在意」，隨後關心我的練習狀況。他露出愧疚的神情說，班導已經知道我晚上私自練習，還非常生氣。即使他幫我求情，R503 教室也不再允許借用了。</p><p>班導用整間學務處都能聽見的音量大吼，來辦事的人全都朝我這邊看。她說我沒有運動家精神，竟然為了利益不擇手段，早已喪失初衷。在旁的生輔組長想緩和氣氛，但班導仍繼續說：因為我段考不及格，她會要求住輔組緊盯晚自習出席狀況，接著指責我個性頑劣，還模仿我爸媽的口吻說他們一定會很失望。「妳又知道什麼？」我咬著牙說。我看班導停下來，以為她的情緒就要爆發，所以繃緊身體閉上眼睛，但她像在壓抑自己，用平靜的語調說：「生物老師不會跟妳講，但我帶過很多學生，妳不知道……」不知怎麼，我開始啜泣，一句話也沒聽進去。</p><p>「妳以後會感謝我。」回到教室前她對我說。當然，我不免小過以上的處分，可是誰在乎？我趴在桌上一直想，班導堅持「妳不知道、妳不知道」但我早就知道了。當我看到學長的心得、開始寫歷屆試題、第一次剪開蟋蟀腹部的時候，我早就知道了。對啊，怎麼可能不，期待什麼的，落差懸殊，很可笑吧，可是再怎麼樣，也是我的，我只是，我想要證明。證明什麼？向誰？英文老師以為我在打瞌睡，點我起身朗讀課文，發現這個人一把鼻涕、一把眼淚，以為自己叫錯名字，又讓我坐下。</p><p>大概是賽前已經預支了眼淚，當我真的完賽回來，反而表現得很冷靜。我提著行李再次站在校門口，看見自己和 L 從大門縫隙鑽出，兩人在慘澹月色下跑過馬路。因為擔心遲到，我訂了凌晨四點半的火車前往決選縣市。L 聽了我的規劃堅持跟來，說我總是這樣，萬一碰到危險怎麼辦。</p><p>「那你呢？」</p><p>「我可以順便回家，我爸都很早起床。」</p><p>R 也說要來，不過好像睡過頭了，但我們還是約好比賽後見面。L 和 R 用期待的眼神看著我，但我只是把土產分給她們說：「為什麼有人可以那麼厲害啊……」又像以前一樣喋喋不休，說起自己拿反顯微鏡的糗事和第一次聽說用電腦做實驗的新鮮事。她們什麼都沒講，只是靜靜聽我說，陪我在校園漫步，然後一起回到宿舍。</p></br><p>比賽落幕後，我發現自己已經跟不上授課節奏。班導留意到我吃力的樣子，曾主動提出幫助，但我婉拒了。我不想成為又一個能勸服其他學生的案例。為了趕上進度，我把所有課本疊成一落，算了一下每天要讀 72 頁，相當於以時速 0.02 公分複習所有教科書。「來得及、可以的。」我提醒自己。</p><p>除了準備筆試分發，我還得定期攜帶銷過單參加愛校服務。幸好我有晉級生物競賽，功過相抵後不至於領不到畢業證書，只是畢業典禮就沒興趣參加了。當天，我照樣到圖書館自習，但說不出口的疲憊讓我格外想睡。正想趴下休息，卻聽見熟悉的腳步聲。</p><p>「妳連畢業典禮都想翹課喔。」L 說。</p><p>「這裡是圖書館喔。」我把食指按在嘴前要 L 安靜。</p><p>「又沒人，大家都去畢典了。你不參加嗎？」R 說。</p><p>「不要，我要趁大家哭哭啼啼的時候用功。」說完，我立刻趴回桌上。</p><p>「沒人會哭啦，」R 開始在我背上簽名「快點喔，不然妳背上都會是我的名字。」</p><p>「呀，」我縮起身體閃躲「我不用啦。」</p><p>「那妳不要我們的禮物嗎？」R 說，令我遲疑一下。她拉起我，讓 L 收拾桌上東西，像在鼓勵孩子上學一樣陪我走到門口，然後鄭重地把禮物遞給我。那是一張獎狀，用端正字體描述了她們眼中的我，還記錄了各自在 R503 教室印象最深的回憶。</p><p>「今天就別悶悶不樂吧。」L 說。</p><p>「我們一起想的喔。不過我的字不好看，主要是 L 寫的。她怕寫不好，還練習了好幾次。」R 說。</p><p>「喂。」L 伸手想摀住 R 的嘴巴，兩人隨即打鬧在一起，卻不忘對我說：「恭喜。」</p><p>我捏著獎狀兩角，有股酸酸的感覺從指尖延伸到胸口，驚訝、憂傷與惆悵等情感在心中碰撞。我跟著她們走向典禮會場，一路上不發一語。經過福利社時，我要她們等一下，然後抱著三瓶在學校很熱門的碳酸飲料回來。L 和 R 對望一眼後收下我的禮物，三人一起拉開拉環，讓金屬罐裡的二氧化碳代替壓抑的情感奔湧而出。</p><p>今年畢業典禮的主題是飛行，畢聯會嘗試重現人類接近天空的歷史，在通往禮堂的走道旁布置了歷代飛行器的立牌，像是拍翼機、熱氣球和滑翔機等。禮堂入口則改造成海關風格，氣窗掛著貼有航班資訊表的瓦楞板，上面顯示從學校飛往夢想的班機，準時？R 走向紙箱築成的安檢門，捲起典禮手冊在我前後揮動，模仿探測器發出嗶嗶聲響。</p><p>「悲傷是違禁品喔。」R 說。</p><p>「妳別鬧她啦。」L 敲了 R 的頭，拉著我走進禮堂。禮堂兩側各架起三面投影幕當作機窗，播映每個班級彙整的回顧照片，像掠過的雲朵一樣轉瞬即逝。在典禮的最高潮，坐在二樓的在校生都收到了事先摺好的紙飛機。當畢業歌響起時，他們會聽從主持人口令擲出，讓紙飛機在空中盤旋，像櫻花一樣緩緩墜落，形成如夢似幻的景象——才怪。</p><p>「一、二、三！」學弟妹沒有將紙飛機擲向天空，而是對準坐在一樓的畢業生。我和 L 拿起典禮手冊護著頭倉皇避難，R 則撿起紙飛機，大聲號召其他人回擊。就這樣，在笑聲、罵聲與「畢業快樂」的喊叫聲中，我們推擠著離開禮堂。我在隊伍的最後面撿起那些被踩扁的紙飛機。攤開後發現用手寫字體印刷的祝福詞，來源很像那種設計簡陋的心靈雞湯網站。我把全是鞋印的紙摺好放進離校時從補習班收到的資料夾，終於露出微笑與 L 和 R 一起走出學校。</p></br><p>帶著那些廉價祝福，我隨讀書、就業兜了台灣一圈，直到所能負擔的租屋坪數除了渾身疲憊，再也裝不下任何回憶與遐想，才不得不丟棄。如今，距我們在 R503 教室說著言不及義的話已經過了快十年。L 順利錄取資工系，並在畢業後任職資安公司；R 後來出國攻讀博士，卻在取得學位前輟學創業。我最終也沒能進學術圈，但始終放不下科研，所以一直從事研究支援工作。</p><p>上周末公司舉辦家庭日活動。我原先不打算出席，不過讀了行程表後，還是基於情懷參加了模仿國外企業舉辦的紙飛機擲遠競賽。我從接待處拿到印有公司標誌的 A4 紙走進會場，看見正在練習的大人小孩，想起在 R503 教室的其中一個午後。</p><p>很多人在丟紙飛機前會先吹一口氣，據說這樣會飛得比較遠。L 推測，吐出的水氣可以潤濕機首，平衡前後重量。不過，也有人認為這跟投球前舔一下手指一樣，純粹是儀式行為，不影響紙飛機的滯空能力。</p><p>「真的能飛比較遠嗎？」L 向對著紙飛機吹氣的 R 問。</p><p>「哼哼，」她嘴角微微上揚對我們說：「這是風洞。」</p><p>R 邊吹氣邊依照機體的震動程度調整手持位置。「就是這裡。」她用指甲在機脊輕輕擰出凹痕當作記號，接著小心折起機翼末端以降低阻力。見她認真的模樣，我卻想著紙飛機終究不是噴射機，即使做了許多調整，一旦出手還是只能順應風勢。而且，飛得再遠也不算抵達，因為擲出的人仍留在原地。</p><p>「呼、呼、呼……」不過 R 似乎不這麼想。鐘聲響起，我們不約而同看向教室內的掛鐘，感嘆午休的短暫。R 把紙飛機交給我，拎走吃完的紙餐盒和 L 一起下樓。我倚在走廊牆邊俯視中庭，突然湧起一股衝動，在 L 和 R 經過時大喊：「喂！」，迎著燦爛的陽光擲出紙飛機。她們轉過頭，遮著光線，放下餐盒，伸出手朝落點奔跑。紙飛機在著地前被風一吹，滑向龍柏樹，落在鱗片狀的枝葉上隨風搖擺。</p><hr><p>lfr（2024）。午後飛行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《時光邊緣的男人》</title>
      <link href="/haig-2017-how-to-stop-time/"/>
      <url>/haig-2017-how-to-stop-time/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>整理房間之所以費時，不只是因為雜物眾多，也是因為房間存放了太多能勾起回憶的小物，在衣物夾層或是抽屜深處找到的紙條、衣物、繪畫等都能讓我們沉浸在過往許久。《時光邊緣的男人》是這種追憶的極端。有些人認為作者滔滔絮絮的風格很難讀下去，不過我覺得這正是作品的主題。</p><span id="more"></span><p>擁有一般人數十倍壽命的男人若活在現代社會，究竟會有多少事情能勾起他的回憶，讓他佇立在街頭、市集、房間與景物前遲遲不離去。雖然題材很像獨立製作電影《來自地球的男人》，可是《時光邊緣的男人》的重點是回憶，而不是探討令人無法相信的存在。</p><p>主角因為異常的壽命和發育速度，受到獵巫行動波及，失去了摯愛的母親。自此，他開始浪跡天涯，躲避他人注目，直到碰上信天翁會的會長亨德里希，此人不擇手段保護長壽的「信天翁們」避開常人的惡意，卻也形成了主角的枷鎖。主角曾向信天翁社的使者艾格妮絲抗議他們粗暴的刺殺行為，但對方辯稱「信天翁們」擁有一般人十數倍的壽命，以平均餘命而言，是更有價值的一群人。為了長壽族群，犧牲一般人是符合功利主義的決定。</p><p>故事主要懸念是主角失蹤的女兒。主角為了保護妻女而離開她們，在妻子死後，則花了數百年時間去尋找同樣患有長壽病的女兒。信天翁會長聲稱能幫主角打聽女兒的情報，使喚主角到世界各地拉攏其他長壽者，想要形成對抗人類惡意的集團。而敘事手段則是今昔插敘，主角每到一個場景，或是在課堂上講到一個主題（主角的職業是新進的歷史老師），便會深陷回憶。</p><p>回憶的內容主要是童年的創傷（母親因獵巫風潮而死）、妻子的追憶（主角的摯愛蘿絲）以及歷史人物的側寫（例如碰到莎士比亞或庫克船長等）。許多閱讀的樂趣來自作者對長壽者的心態描述，以及對歷史人物的描寫。從以前我就察覺到，在穿越小說裡讀到歷史人物或致敬人物會產生興奮感，只是至今仍不懂這種感覺的美學解釋是什麼。</p><p>另一個動人的是作者對主角妻子蘿絲的描寫。我覺得這名角色展現了令人敬佩的魅力，她年紀比主角小，但性格卻意外強悍。她懂得爭取自己的幸福，不會屈就逆境的選擇。她願意去愛，願意為渴望主動出擊。</p><p>主角失去母親後，渾渾噩噩走到倫敦近郊，碰到了正在出售李子的蘿絲和她妹葛蕾絲。飢腸轆轆的主角向小姊妹乞求一顆水果，卻重心不穩跌在對方身上，打翻整籃李子。</p><p>蘿絲跪在地上撿起沒被弄髒的李子，抓住想一走了之的主角，大聲斥責他的魯莽行為。蘿絲要求主角償還費用，甚至要他抵押隨身攜帶的琴。不過，在得知那把琴是主角死去母親的遺物後，蘿絲放軟身段，見主角具有彈奏樂器的能力，轉而要求主角跟她們回家，藉由街頭表演賺錢還債。</p><p>從這段描述可以看出蘿絲不肯罷休的態度：</p><blockquote><p>那女孩跪在地上，忙亂地拯救能救的李子。<br>「對不起。」我說。<br>我撿起一顆沾滿泥巴的李子，轉身走開。<br>「喂！欸！喂！你！」她抓住我的肩膀，因憤怒而鼻孔大張。「看看你幹的好事！」<br>我以為我又要暈倒了，然後決定繼續往前走，以免造成更多損失。<br>「別走啊！你不能就這樣走掉！」</p></blockquote><p>另外，可以從初次見面的橋段，看出主角對蘿絲的印象有多深刻，用了三次「我可以告訴你」，來表示他想表達什麼的念頭。</p><blockquote><p>她把手臂交叉在胸前。沒錯，她看起來大概十八或十九歲。我可以告訴你，她穿著一件平凡的白裙——是中世紀人們稱為「科特爾」的長衫，還有一條樸素的紅色圍巾，她斜斜地圍著，將結打在脖子左側。我可以告訴你，她的皮膚非常乾淨——在村民之中很罕見——右臉頰上有兩顆痣，一顆比較小，就像繞著行星的月亮，還有一片如星子的雀斑橫過她的鼻子。她的黑髮有一半包在白布帽裡，一半不羈地披散在外。</p><p>她有一張大多數時候都在皺眉的那種臉，但嘴角露出一絲陶器，彷彿老是有一抹微笑想要跑出來，卻一直被她心中某個反對的權威壓抑住。我還可以告訴你，她很高。當時她比我高了四分之一個頭，後來當我的身體終於成為「大人」時，她才變得比我矮。</p></blockquote><p>而描述妹妹葛蕾絲的橋段也蠻生動的：</p><blockquote><p>一個年輕女孩走過來，站到她身邊，手上提著一模一樣但完好無缺的籃子。她是剛才在前頭看見的賣櫻桃女孩，看起來十或十一歲。很明顯她倆是姊妹，同樣的黑馬，同樣的凌厲眼神。一個醉漢試圖搶走一顆櫻桃，但她敏捷地將籃子轉向另一邊，怒目瞪著對方。</p></blockquote><p>蘿絲向主角警告，她們要求他搬入家中是希望主角承擔責任，因此除了賠償貨物損失，也得支付房租。蘿絲與葛蕾絲也是孤兒，她們的雙親分別死於產褥熱與天花，唯一的弟弟也死於傷寒。主角入住後，他們彼此都暫時填補了家人逝去的空虛。</p><p>然而，深夜裡主角還是會夢見母親被害的惡夢：</p><blockquote><p>等我再回過神，已是午夜時分，而我坐在床上，被自己的尖叫聲驚醒。窗外的月亮又大又圓，我整個身體都在顫抖，難以呼吸。恐懼從四面八方湧入我的身體。</p><p>蘿絲在我旁邊，握著我的手臂。葛蕾絲在她後面的門口，打著哈欠趕走睡意。</p><p>「沒事的，湯姆。」</p><p>「不可能會沒事的。」我說，一半清醒、一半錯亂。</p><p>「夢不是用來相信的，特別是那些不好的夢。」</p><p>我沒跟她說那個夢是一段記憶。身為湯姆．史密斯，我得試著否認我的現實，想像出一個新的。她要葛蕾絲回去睡覺，自己則在我旁邊留下來。她靠向我，在我唇上吻了一下。那個吻只是輕輕一觸，但吻在嘴唇上的就不是那麼簡單了。</p><p>「這是什麼意思？」我問。</p><p>月光下，我剛好看得見她的笑容。那不是引誘，而是坦然、就事論事的微笑。「讓你有別的事情可以想。」</p><p>「我好像沒有遇過像妳這樣的人。」我說。</p><p>「很好。如果還有一個跟我一樣的人，那我的人生不就太沒意思了？」</p></blockquote><p>如果說，第一個吻是個移情而且功能性強烈的吻，那麼隨後蘿絲逐漸習慣主角的存在，也希望他留在這失去太多的家時的吻，就是滿懷感情的吻了。</p><blockquote><p>「你接過吻嗎？湯姆？」我想起第一天晚上，她輕啄我的嘴唇。「一個真正的吻，湯姆？」蘿絲澄清，彷彿讀到我的心思。</p><p>我的沉默是尷尬地回答。</p><p>「一個吻，」她說，「就像音樂。可以停止時間……我曾經談過一次戀愛。」她簡單地說，「某個夏天。他在果園裡工作。我們接吻，一起做了快樂的事情，但我從來就不是真的喜歡他。大家說，如果你真的喜歡某個人，只要一個吻，就可以讓麻雀停止飛翔。你覺得那是有可能的嗎？」</p><p>她把魯特琴放在旁邊，然後吻我，我閉上眼，這世界逐漸遠去。沒有別的事物存在，除了她。她就是星辰、天空、海洋。除了這個片刻，還有我們在其中種下的愛之花蕾，這世界別無他物。然後，在開始後沒多久，這個吻結束了。我撫著她的頭髮，教堂的鐘在遠方想起，然後整個世界再度歸位。</p></blockquote><p>過了一陣子，主角意識到他的存在可能會危害蘿絲，於是向她談成自己來歷與症狀，想要離開對方。然而蘿絲卻不肯相信，認為愛能解決困難，而她從頭到尾都是主動的一方。</p><blockquote><p>她看起來一頭霧水。「怎麼可能呢？你是什麼意思，湯姆？怎麼可能會越差越大？你說的根本沒道理。」</p><p>「我對妳來說已經沒用了。我不能再回去南華克了。」</p><p>「沒用？沒用？你擁有我的心啊，湯姆。」</p></blockquote><p>另一個吸引人的主動女角色是主角在現代碰到的法語老師卡蜜拉：</p><blockquote><p>「我知道那張照片是你。」<br>「那是擺拍。那張照片是設計擺拍的，不是二零年代的照片。」<br>「你說謊，不要對我說謊。」<br>我站起來。「我得走了。」<br>「不，不行。拜託，拜託。我喜歡你，你不能逃避一切。」</p></blockquote><p>而卡蜜拉除了主動以外，還有某種讓吸引宅宅的特質，例如：</p><blockquote><p>「根本小巫見大巫。以前人們習慣了惡臭，從來不洗澡。過去大家認為洗澡是不好的。」<br>她嗅一嗅腋下。「那我還過得去囉？」<br>我靠近她聞了聞，「太乾淨了。其他人會對妳起疑心的。妳幾乎就跟二十世紀的人一樣乾淨。」<br>她笑出來。我發現這是世上最簡單純粹的歡愉——逗妳關心的人笑。</p></blockquote><p>劇情到最後有點乏力，剩下不到 5% 頁數時，我還在思考要怎麼收尾，結果反派亨德里希犬死澳洲，還因為冒名頂替而無人關注。然後主角與卡蜜拉結為連理，獲得幸福快樂的日子。不過說真的，這部的看點是夾敘歷史的那種感受，所以結尾有個 happy ending，主角也走出糾纏了四百年的陰影，已經是故事很好的句點了。</p><hr><p>麥特．海格（2018）。時光邊緣的男人（黃亦安譯）。寂寞出版。（原著出版於 2017 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《掉到地球上的人》</title>
      <link href="/tevis-1963-the-man-who-fell-to-earth/"/>
      <url>/tevis-1963-the-man-who-fell-to-earth/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我猜故事靈感可能來自羅斯威爾飛碟墜落事件？故事描述來自異星並化名牛頓的安西亞人，搭乘太空船迫降到地球，利用先進文明知識經營事業，以建造宇宙飛船來解救母星的同胞。</p><span id="more"></span><p>安西亞人的母星原本有數個高度發展的智慧文明。然而，經過征戰與殺戮，最終只剩安西亞人倖存。母星的資源也因為連年征戰而浩劫，無法延續文明的生存。於是，他們派遣當中最具生存能耐的牛頓，搭上僅存能源唯一能推進的逃生艇航向遙遠的太陽系。</p><p>牛頓既不是天才，也不是最堅強的安西亞人，他只不過有較好的體格，才被委任解救同族的任務。他接收地球的電波，透過電視頻道學習地球文化，製作道具喬裝自己。費盡數十年時間，牛頓終於做好啟程的準備。熬過了長途星際旅行，承受對未來的不安，還有忍耐對妻子的思念，他終於到達地球。</p><p>牛頓運用家園的科技，販售價格低廉的金戒指發跡。接著，他應用母星科技，創造當代地球遠遠無法想像的便利設施，例如更安全且無煙的燃料和能自動顯影的底片等。靠著代理人協助，牛頓經營著世界企業賺進大把鈔票，讓他有充足的資金展開研究計畫。</p><p>牛頓預計利用地球的資源建造星際飛船，開向母星接送倖存的安西亞人到地球安居。牛頓認為，地球人文明低落，在掌握核子武器後，可能很快就會因為戰爭而自我毀滅。因此，他一廂情願地認為，若能依靠安西亞人的智識與科技避免戰爭爆發，就能創造雙贏局面。</p><p>然而，牛頓所經營的事業隨即受到學界與政治圈盯上。失意的化學教授布萊恩發現世界企業的底片技術遠超當代技術，於是懷疑製造者來自外星。隨著調查此技術，布萊恩也進入牛頓的太空船開發團隊，負責研究燃料容器的材料，獲得接觸牛頓的機會。</p><p>牛頓與布萊恩逐漸熟識，最後也在參與一場化學酒會之後，向布萊恩坦承自己的身分。牛頓才感嘆自己終於交到了可以坦白的友人後，便遭到美國聯邦調查局逮捕。FBI 早已佈線許久，想查明牛頓執行的計畫為何。</p><p>儘管牛頓堅稱自己為畸形兒，但調查人員始終不相信，仍嚴刑拷問想套出他的話。所幸，富商遭無故監禁一事形成重大政治醜聞，牛頓才得以釋放。然而，在釋放前的例行檢查，負責人員無視牛頓的生理構造差異，對其敏感的眼睛照射X光，導致其失明。</p><p>原先牛頓便因獨自來到地球而備受煎熬，面對無法返回母星的哀愁，還有被無法理解的人群包圍的孤寂。在眾多打擊下，牛頓放棄了太空船計畫，他似乎認為怎麼做都無濟於事，只能揮霍那些對他沒有任何價值的錢，靠著寫詩和低聲哭泣發洩他的無助。</p><p>這本的情節和描述比較沒有打動我，不過我看科幻毒瘤給它的分數有三點五分，看起來理由是這本書算「反套路」的作品，可能是當時作品裡的外星人往往以救世主的姿態降世，並且用人類不信任的行為來諷刺愚昧人群。</p><p>而此書裡的牛頓只是一個平凡的安西亞人，他再怎麼神通廣大，也只是個內心纖細且肉體脆弱，獨自來到陌生地帶的凡人。當一切不如意且失去了重要的事物之後，仍然會因此而哭泣。</p><hr><p>沃爾特．特維斯（2022）。掉到地球上的人（呂玉嬋譯）。（原著出版於 1963 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《與其喜歡他，不如選我吧？》</title>
      <link href="/asakura-2021-karenankayori-watashi-no-hogaiidesho/"/>
      <url>/asakura-2021-karenankayori-watashi-no-hogaiidesho/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>直到音音坦白她暗戀學生會會長，鹿乃才查覺到自己對音音的感情。鹿乃不能接受心愛的對象躺在男人懷裡，打算在音音告白前擄獲她的心。</p><p>苦惱的鹿乃在廣讀百合小說後心生一計，她或許能以肉體快感誘使音音愛上自己。鹿乃下定決心，即使得不到音音的心，也想要得到她的肉體。</p><span id="more"></span><p>這本書的看點除了官能描述以外，就是鹿乃用一本正經的態度，說出牽強的理由，說服音音與她牽手、抱抱、接吻和互相愛撫。</p><p>鹿乃相信學長不會拒絕音音。她告訴音音重點不是如何告白，而是怎麼維繫感情。為了支持音音的戀情，鹿乃自願假扮男友，陪著沒有戀愛經驗的音音學習與伴侶相處的方式。</p><p>不過，鹿乃並沒有戀愛經驗，她對情侶的想像來自跆拳道道館的同儕。因此，鹿乃設計的模擬男友課程裡，除了自己對音音的性幻想，還揉合了道館那群臭男生的妄談。</p><p>例如，鹿乃是這樣解釋自己在電車上緊緊貼著對方的原因是：</p><blockquote><p>「我只是覺得要盡量減少自己占的空間，讓更多人有座位可以坐啊。」</p></blockquote><p>鹿乃跟著音音進入試衣間表面的理由是美感。實際上，鹿乃想要讓音音難為情而心跳加速，引發吊橋效應讓對方喜歡上自己。</p><blockquote><p>「我想仔細看看穿起來整體會是什麼感覺。」</p></blockquote><p>為了說服音音玩 POcky 遊戲（雙方各自咬住 Pocky 巧克力棒一端，逐漸吃掉巧克力棒卻不讓它掉下來的遊戲），鹿乃也能隨意編出這種謊言：</p><blockquote><p>「我認真的。聽說因為最近的男生都不知道怎麼引導女生跟自己接吻，所以都一定會用 POcky 遊戲來炒熱氣氛。</p></blockquote><p>更誇張的是，音音幾乎沒有猶豫便相信了這些說法。我邊看邊覺得這根本是本子或 H game 劇本吧？</p><p>雖然故事情節單純，內容還是有些巧思。鹿乃的模擬男友計畫完美契合她的私慾：首先一起買衣服，接著去看冷門電影。鹿乃刻意挑選寬鬆且暴露的衣服款式，讓她能在觀眾稀少的影廳內對音音毛手毛腳。</p><p>鹿乃也調查了學生會會長的興趣，依序設計化妝派對、KTV 密遊與泳池嬉戲等活動。兩人肢體接觸的尺度也隨著這些活動增加。然而，音音越是投入模擬男友練習，鹿乃就越心痛。她能感受音音只是把自己想像成學長，才願意接受親吻與愛撫。鹿乃一想到往後音音也會與學長如此親密就感到折磨。</p><p>在男友練習的最後一步，鹿乃打算和音音一起結束處子之身。她一面滿懷情慾地愛撫著音音，一面忍受被當作替代品的精神折磨。在鹿乃拿起情趣玩具，打算進入彼此的時候，她停手了。</p><p>鹿乃終究太喜歡音音，儘管既不甘心又痛苦，她還是希望音音能與喜歡的人……而不是別有目的的自己。</p><p>鹿乃罷手後，原本想要偷聽音音告白，了結自己的單戀。不過卻意外聽到會長向其它幹部吹噓性史和分享偷拍影片。鹿乃一想到音音的感情將被這樣的男人糟蹋，憤而闖進學生會辦公室大打出手。</p><p>所幸，鹿乃的好友掌握會長發言的錄音檔。校方與會長為了避免醜聞外揚，不願鬧大這起事件，鹿乃也因此只受到最輕微的處分。</p><p>作者最後以音音視角作結。原來，音音早已愛上鹿乃。為了刺激遲鈍的鹿乃，音音故意向鹿乃表示自己喜歡會長。沒想到鹿乃竟提出一個漏洞百出的計畫，讓音音不禁想捉弄她一番。這解釋了為什麼音音從來不拒絕鹿乃荒誕的提議，畢竟她打從一開始就很樂意與鹿乃做這些事啊。何況，如果不是有好感的對象，是很難接受鹿乃那些親密舉動的。</p><hr><p>アサクラ ネル（2022）。與其喜歡他，不如選我吧（蒼貓譯）。台灣角川（原著出版於 2021 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被百合夾擊的女子有罪嗎？》</title>
      <link href="/mikami-2020-yuri-ni-hasamareteru-onnatte-tsumidesuka/"/>
      <url>/mikami-2020-yuri-ni-hasamareteru-onnatte-tsumidesuka/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>黑幫神枝組與久利山組的龍頭之爭終於來到了最後環節。為了避免警方干預，他們一直以歌唱或大胃王等非流血項目一較高下。在決定幫派前途的最後一役，雙方決議要以戀愛決勝負：誰能獲得名警朝川真紀之女的芳心，誰就能凌駕另一方成為東京都的霸主。</p><span id="more"></span><p>神枝組的代表是首領的獨生女，神枝楓。楓從小接受特殊的英才教育，學習施展美人計來操弄目標對象。雖然這次要追求的對象是女性，楓仍對自己的容貌與手腕有充分的自信。楓與母親約定，若能在這次競爭取勝，她想要過上普通人的日子。楓唯一的隱憂是她童年玩伴與死對頭——久利山組的代表——久利山火凜。</p><p>火凜是久利山組首領的養女，同樣擅長勾引男性。火凜因為養女的身份鮮少得到關愛，使她格外珍惜與楓的友誼。火凜想贏得這次競爭，讓楓繼續不甘心，繼續在意自己。然而在楓眼裡，火凜卻是惱人的存在。楓在各項競賽無往不利，卻總是敗給火凜。更令楓不解的是，火凜竟在贏得某次遊戲後要求親吻自己。儘管楓仍然珍惜與火凜的相處時光，卻因為莫名的吻與她產生隔閡。</p><p>楓與火凜直到執行這次任務才再次相遇。她們的追求對象是朝川茉優，女僕咖啡廳的三線服務員。茉優從小憧憬被人關愛，於是投入偶像團體徵選。在擔任偶像期間，她曾短暫享受作為主角被人重視的滋味。然而她不久後便受團員的醜聞牽連而離開演藝圈。為了重溫在舞台上被擁簇的感受，茉優應徵女僕咖啡廳的服務員。不過，茉優的人氣始終不如其它紅牌，還遭她們欺負。這讓茉優相信，幸福或許與自己無緣。</p><p>為了接近茉優，楓也應徵了同一間女僕咖啡廳。楓抓準茉優未經情事的少女心理，利用新人教學的機會親近茉優，讓她體會被寵溺與認同的感受。楓也利用幫派人馬解決店內的霸凌事件。從未被人追求的茉優隨即墜入愛河，每天都期待上班，期待與楓見面。</p><p>正當楓以為勝券在握時，火凜介入了她們的感情。相較於楓細心營造曖昧氣氛，火凜的手段強勢。她在加入女僕咖啡廳不久，便以一見鍾情為由向茉優告白。就在茉優不敵火凜的霸道作風，即將回應他的告白時，楓也不甘示弱向茉優告白。茉優作夢都沒想到能同時收到兩位美人的示愛，也懊惱自己無法做出抉擇。於是，茉優以想更加了解兩人為由，推遲自己答覆的時間。</p><p>不久，茉優接受前團員的邀約共進午餐，卻受到她們的嘲笑與欺侮。楓及時出現解救了茉優，並且隨她回家。楓急著與茉優確認關係，在茉優家情不自禁吻了她，卻也讓自己心頭小鹿亂撞。火凜察覺楓與茉優可能發生肢體接觸，於是也約茉優出遊。原先茉優想藉此機會一刀兩斷，卻屈服於火凜強勢的態度。在與火凜接吻以後，茉優甚至妄想著雙方的婚後生活。</p><p>楓與火凜眼見茉優猶豫不決，便帶她到愛情旅館。她們輪流與茉優對談，要求她簽下戀愛契約書，選擇所愛的對象。可是，茉優兩個人都放不下。此時，楓接獲消息，警方已介入神枝組與久利山組的鬥爭。為了保全組織，雙方首領都同意終止楓與火凜的競賽。楓得到了夢寐以求的普通人生活，卻對茉優感到愧疚；火凜仍期望能得出勝負，保留與楓的聯繫。兩人在探望病倒的茉優時相遇，化解了兒時那個吻的芥蒂。</p><p>負責此案的朝川真紀警官表示，此案的裁決將尊重茉優的決定，她心儀一方的組織將免於刑責。然而，茉優最終誰也沒選，她意識到自己很喜歡女孩子友好的關係。在她察覺了楓與火凜之間的羈絆後，認為她們兩個在一起是再好不過的結果了。最終，神枝組與久利山組沒有分出勝負。茉優、楓與火凜成為咖啡廳的新紅牌，火凜如願留住楓，楓也離不開兒時玩伴，茉優的心仍在楓與火凜之間游移。</p><br/><p>這本書的情節不複雜。楓與火凜的目標明確，茉優又來者不拒，使得關係推進速度飛快。茉優對自己不抱期待，所以並沒有糾結別有目的的追求，反倒很享受被擁簇、飄飄然的感覺。這些設定使得她們認識、動心、接吻到互窺肉體的過程沒有任何阻礙。</p><p>因此，相較於追求茉優的劇情，我覺得火凜對楓扭曲的情感更為深刻。火凜從小欠缺關愛，所以格外重視楓。然而，火凜留住楓的方法竟是激起她的勝負欲。無論花牌還是追求女人，火凜都要狠狠擊敗楓，讓她不甘心，讓她沒辦法忘記自己。</p><p>楓與火凜的動機也影響她們追求茉優的手段。楓想要贏得回歸日常的籌碼；火凜則想贏得維持現狀的權力。楓嚮往普通人的生活，自然而然對茉優產生好感；火凜只在乎楓，才不惜對茉優採取強勢手段。</p><p>由於火凜手段霸道，我有點難感受到她對茉優的愛意。反倒火凜對楓儘管針鋒相對，感情卻很深厚。楓最初是因為不解火凜的吻而離開她。在她們參與幫派鬥爭重逢後，火凜也解釋了親吻楓的動機：接受美人計訓練的火凜即將成為組織的打手，她想在出任務前，把自己的初吻獻給真正在意的人。看到這裡，我的感想跟茉優一樣，怎麼不乾脆楓跟火凜兩位青梅竹馬在一起呢？</p><p>作者安排了許多為親密互動服務的橋段，例如楓與火凜在休息室爭相告白、愛情賓館二選一等。可以說，這本書的看點就是這些互動、令人吐槽的設定以及茉優什麼都可以的荒謬反應。以下我試著記錄作者怎麼呈現楓與茉優在家中接吻的場景。</p><ul><li>兩人對坐客廳閒聊，問起彼此對各自的看法</li><li>楓詢問茉優期待自己是怎麼樣的人。茉優怯生生地答覆，她認為普通人較好相處。</li><li>楓表露哀傷，茉優連忙澄清自己的意見，楓才嶄露笑顏說：「我是超級喜歡茉優的普通人。」，隨後坐到茉優身旁。</li><li>楓輕觸茉優的手，表示如果茉優願意與她交往，她願意表露更多自我。</li><li>楓更加貼近不知所措的茉優，在她耳邊呢喃，要她想像交往後的生活。</li><li>茉優緊張得說不出話來，本能地想要逃走，卻被楓攬住腰。</li><li>楓盯著茉優，輕輕地說著情侶的日常。然後，猝不及防地輕吻了茉優的耳垂，開始撫摸她的身體。</li><li>「茉優，妳好可愛。」楓輕輕推倒茉優，拉著她的手與她十指緊扣。</li><li>「畢竟我們都要交往了。」</li><li>楓吻了茉優。</li><li>兩人隨即分開，楓眼神搖曳地說：「……要、要記得我喔。」</li><li>「怎麼可能忘記嘛。」</li><li>楓快步離開，留下反覆觸摸嘴唇確認剛剛那股暖意的茉優在家。</li></ul><p>大概是這種感覺，這讓我對豆瓣上一則評論蠻有感觸的：</p><blockquote><p>7cm  2022-08-02 00:40:22<br>みかみてれん总能让我沉默良久。有时候他令我（迟钝地）意识到将古早BG情节中的男性角色置换成女性就能作为百合小说大卖。这不禁令人思考：除性别之外，百合真的存在足以与其他恋爱Genres区分的特异性吗？不客气地说，这是关乎百合本质的问题。而触及到这一点的这一部作品（还有他的其他好多部作品）不可谓不深刻。<br>(<a href="https://book.douban.com/subject/35660443/comments/">https://book.douban.com/subject/35660443/comments/</a>)</p></blockquote><hr><p>みかみてれん（2021）。被百合夾擊的女子有罪嗎？（馮鈺婷譯）。台灣角川（原著出版於 2020 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《妳以為我的百合人設只是商業賣點？》</title>
      <link href="/asakura-2023-watashi-no-yuri-mo-eigyo-dato-omotta/"/>
      <url>/asakura-2023-watashi-no-yuri-mo-eigyo-dato-omotta/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>偶像歌凜在引退後加入了聲優事務所，意外與帶領她的前輩鈴音成為好朋友。鈴音是歌凜的死忠粉絲，所以不願表露自己崇拜的心情，深怕粉絲與偶像的地位差異會破壞她們融洽的關係。不過隨著兩人的距離逐漸拉近，鈴音察覺自己對歌凜的感情似乎不止於景仰，還有些在意，以及很多很多的喜歡。</p><span id="more"></span><p>偶像歌凜——對角線常駐的 C 位——在引退後銷聲匿跡。歌凜的死忠粉絲，EARPO 事務所的聲優鈴音因為打聽歌凜的消息無果而悶悶不樂。鈴音放棄打聽歌凜的去向後，竟然與自己的偶像在事務所重逢：歌凜將以聲優的身份加入 EARPO。更讓鈴音興奮不已的是，經紀人巳甘茜囑咐她協助歌凜熟悉環境，讓鈴音得以接觸偶像舞台外的一面。</p><p>其它聲優質疑歌凜的配音能力，對她加入 EARPO 頗有微詞。不過在錄製聲音樣本後，鈴音確定歌凜的配音能力如同其舞台魅力令人驚艷。錄音後，巳甘茜提議她們到附近用餐交流感情。兩人度過愉快的夜晚，還交換了聯絡方式，意外變得親近。</p><p>鈴音在用餐時得知，歌凜為了成為聲優而放棄偶像事業，在役時期也在撥空向資深聲優學習技巧。即使已非現役偶像，歌凜全力以赴的敬業精神仍與舞台上的模樣一致。鈴音為此感到敬佩，而且在了解歌凜私下率真可愛的一面後，更覺得對方閃閃發光。不過，鈴音卻不敢坦白自己是歌凜的粉絲。她擔心歌凜會感到困擾，也害怕融洽的現況會因為粉絲與偶像不對等的關係生變。</p><p>歌凜與鈴音的友好關係也引人非議。玲音的前輩賀彌河懷疑歌凜別有目的，勸告鈴音與她保持距離，以免被人誤會同為趨炎附勢之人。不過鈴音卻不以為然，何況她也很樂意幫助曾經的偶像站穩聲優圈。</p><p>密友結衣香也留意到此事，於是詢問鈴音是否考慮與歌凜發展戀愛關係。鈴音表示她並非想與偶像交往的「真愛黨」，她對歌凜的好感源於憧憬。不過鈴音還是好奇，在歌凜離開舞台後，自己是被她哪些特質吸引。鈴音為自己的感情辯解，在心中列舉了歌凜種種優點：臉蛋漂亮、滿懷自信、為人親切又有敬業精神。</p><p>儘管如此，面對歌凜主動的肢體接觸，鈴音還是心動不已。一次是在試鏡後的聚餐，歌凜端著啤酒杯坐到鈴音身旁，向她坦白說自己喜歡與女孩子膩在一起。隔著衣服布料，鈴音感受到歌凜的體溫，即使回到家也對這股感覺念念不忘。</p><p>另一次則在歌凜試鏡落選後。歌凜請求鈴音陪她喝酒消愁，自己卻醉倒在店裡。因為不知道歌凜住址，鈴音只好帶著醉醺醺的她回家。擔心粉絲的身份曝光，鈴音迅速收拾好充滿周邊的房間，才帶歌凜回到臥室。看著歌凜略帶哀傷的睡顏，鈴音首次感受到偶像身為普通人脆弱的一面。鈴音拍著歌凜的背安撫她，直到對方的呼吸聲平息，才跟著緩緩入睡。</p><p>隔天鈴音為兩人準備早餐時，歌凜從後方摟住歌凜的腰，輕輕靠在她身上。鈴音默默接受歌凜的倚靠，不禁懷疑歌凜對自己是否保持好感，還是只是不擅長保持身體距離。鈴音不敢多想，擔心自己的性傾向會造成對方誤會與困擾。</p><p>為了讓歌凜心情好轉，鈴音答應在早餐後陪她逛街。她們在點心店意外相遇對角線的團員霞栞。霞栞透漏，歌凜其實相當崇拜鈴音，也受鈴音出演的作品鼓舞而想擔任聲優並加入 EARPO。這讓鈴音鬆了一口氣，也感到無比的幸福。因為，她們早在進入公司前，就注視著彼此了。隨後發生了一件插曲，霞栞離開前吻了歌凜的臉頰。鈴音驚覺自己竟對此感到不悅，發現自己已無法享受偶像的百合行為帶來的感受。</p><p>不久，鈴音和歌凜通過熱門動畫的試鏡，將成為劇中的搭檔。為了宣傳動畫，劇組安排兩人主持廣播劇賣弄百合設定，例如在節目上為對方刷牙和梳理頭髮等。在節目拍攝過程中，鈴音漸漸壓抑不住自己喜歡對方的感情。對歌凜的支持也逐漸變質，產生想要獨佔對方的念頭。</p><p>這段期間，歌凜還阻止了賀彌河的陰謀，避免鈴音遭受桃色緋聞的傷害。儘管諸多事件讓鈴音對歌凜的好感倍增，她仍堅持自己作為前輩和粉絲的立場，不敢跨過朋友的界線。直到歌凜遭受惡意毀謗，為了表達支持，鈴音才終於說出自己的心意。</p><p>在平安夜的廣播劇播出前，匿名人士上網爆料歌凜與不明男性同居。歌凜向事務所表示自己清白，也希望解釋細節時，鈴音能夠在場。歌凜表示，該男子是她姊姊的未婚夫，因此緋聞照片純屬謠傳。鈴音得知真相後，莫名感到高興。</p><p>雖然鈴音自願擔綱演出這集廣播劇，歌凜仍堅持參與錄影。儘管公司已澄清緋聞事件，廣播劇的互動環節仍湧入大量惡意留言。眼見歌凜在錄音室嚇得不知所措，鈴音決定以自己的方式表達支持。鈴音在現場向歌凜告白，歌凜聽到告白後恢復鎮定，趕緊播放歌曲爭取時間。兩人到錄音室後台，鈴音向歌凜解釋自己終於察覺喜歡的感情。鈴音不期待歌凜也喜歡自己，她只希望歌凜明白，即使歌凜被全世界唾棄，她也會全心全意支持。</p><p>不過歌凜其實也早就喜歡上鈴音了，只是因為對方的矜持而不能及早拉近彼此的距離。互表心意之後，歌凜終於恢復精神回到廣播劇現場。在觀眾眼裡，歌凜與鈴音的百合行為只是商業人設；不過兩人心知肚明，那是她們互表愛意的真實表現。</p><br/><p>雖然故事開頭拋出了出櫃的猶豫和新人聲優的挑戰等議題，劇情並沒有往這兩方面拓展，而是集中描寫兩人感情升溫的過程。鈴音與歌凜一開始就對彼此有好感，只是受限於雙方的身分（粉絲與偶像、前輩與後備），才無法坦率表達感情。作者安排了幾個惡意攻擊事件，但沒有讓雙方因為誤會而彼此傷害。因此，閱讀過程中始終能感受到甜甜的滋味，沒有讓人心痛的橋段。</p><p>我在閱讀中還察覺到「洗澡」這個情節工具的功能。寄宿隔天，鈴音留意到歌凜沐浴後的氣味與自己不同。洗澡的用途不是促進肉體接觸，而是要發現曖昧對象獨特之處。兩人在同一間浴室，使用相同沐浴用品卻散發出不同氣味時，這個多出來的部分，就是觀察者的想像。換句話說，浴室是實驗室，把曖昧雙方放到變因固定的環境下。此時多出來的異常感，便可歸類為情感造成的扭曲感官。</p><p>區分好感的緣由是這類作品重要的議題。鈴音一直想釐清自己對歌凜的感情是出於對偶像的崇敬，還是對戀愛的渴望。鈴音自知喜歡女生，但不確定歌凜的性傾向。另外，鈴音既是歌凜的粉絲也是前輩，兩種身分都會干擾她們的互動。這些限制導致鈴音在故事中始終處於被動狀態，只能用「不反對」的舉動，來模糊地表達「支持」。</p><p>主動的歌凜也因此無法大膽推進關係，導致各項事件都能往兩個方向解釋：歌凜的接近可解釋為抱有好感，也能解釋為善於權謀；醜聞事件需要鈴音在場可以解釋為在意對方的感受，也能解釋為公務所需。</p><h2 id="如果雙方都不敢踏出界線的話，劇情便無法推進了。因此安排霞栞曝光歌凜的動機，解除鈴音部分限制。最後再用醜聞事件刺激鈴音告白，化解所有關係的懸念。這也是我覺得故事寫得蠻流暢的主要原因，人物的動機和劇情安排都蠻合理的。"><a href="#如果雙方都不敢踏出界線的話，劇情便無法推進了。因此安排霞栞曝光歌凜的動機，解除鈴音部分限制。最後再用醜聞事件刺激鈴音告白，化解所有關係的懸念。這也是我覺得故事寫得蠻流暢的主要原因，人物的動機和劇情安排都蠻合理的。" class="headerlink" title="如果雙方都不敢踏出界線的話，劇情便無法推進了。因此安排霞栞曝光歌凜的動機，解除鈴音部分限制。最後再用醜聞事件刺激鈴音告白，化解所有關係的懸念。這也是我覺得故事寫得蠻流暢的主要原因，人物的動機和劇情安排都蠻合理的。"></a>如果雙方都不敢踏出界線的話，劇情便無法推進了。因此安排霞栞曝光歌凜的動機，解除鈴音部分限制。最後再用醜聞事件刺激鈴音告白，化解所有關係的懸念。這也是我覺得故事寫得蠻流暢的主要原因，人物的動機和劇情安排都蠻合理的。</h2><p>アサクラ ネル（2024）。妳以為我的百合人設只是商業賣點？（李君暉譯）。台灣角川。（原著出版於 2023 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《少女妄想中》</title>
      <link href="/iruma-2017-shojo-mousouchu/"/>
      <url>/iruma-2017-shojo-mousouchu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《少女妄想中》是四則彼此相關的短篇組成的故事，描述三名少女幻想的、無望的以及悖德的愛戀。</p><span id="more"></span><h1 id="〈Girls-on-the-run〉"><a href="#〈Girls-on-the-run〉" class="headerlink" title="〈Girls on the run〉"></a>〈Girls on the run〉</h1><p>從幼稚園起，小藍就迷戀一位只在全速奔跑時才會現身的女孩。為了再次見到她，小藍加入了田徑社。雖然不擅長跑步，小藍的兒時玩伴小芹也為了接近小藍而隨之入。然而，即使一直生活在小藍身邊，小芽不曾被小藍重視。畢竟小藍的眼裡，始終只有那名如幻影的女子。</p><p>隨著畢業與就業，小藍見到女孩的頻率也隨跑步次數下降。雪上加霜的是，小藍還因為跑姿不良受傷。腳傷期間，小藍一度打算放棄跑步，打算正視小芹的感情。不過在跑友的鼓勵下，小藍在傷癒後再次邁步奔跑，終於追上夢想中的女孩，相約在海邊並肩而行。</p><h1 id="〈不會消失的銀之手〉"><a href="#〈不會消失的銀之手〉" class="headerlink" title="〈不會消失的銀之手〉"></a>〈不會消失的銀之手〉</h1><p>三島是個平凡的高中女生，單調無奇的日常讓她察覺到自己活在某個人的夢裡。夢裡欠缺逐漸累積的感覺，當中事物的細節也模糊不明。這種情況延續到三島在海邊遇見白音才發生變化。三島發現，周遭景觀會隨白音的想像變動。這個觀察印證了她的想法：她活在白音的夢中，卻不知道理由是什麼？</p><p>三島跟著白音在小鎮閒逛，也漸漸察覺到自己對白音的好感。這種感情讓三島顫慄，猜想白音是否因為傾慕真實的自己而創造了夢境。從故事提供的線索我們可以得知，白音其實是小芹在夢裡的化身，她想像自己與小藍能像白音與三島一樣共度日常。</p><p>在故事最後，白音邀請三島一起搭火車前往夢境的邊緣。隨著列車遠離小鎮，三島卻越來越害怕。她告別白音，在列車駛過橋時從車窗一躍而下，逆著河流游回海灘上。在那裡，三島再度碰見她傾慕的女孩。</p><h1 id="〈凝視著妳〉"><a href="#〈凝視著妳〉" class="headerlink" title="〈凝視著妳〉"></a>〈凝視著妳〉</h1><p>小芹畢業後不久便離職返鄉，繼承家裡的茶水店。她的右眼意外被姪女戳傷而失明，讓她的哥哥感到十分愧疚。小芹的姪女長大後喜歡上小芹，趁著假日在她的茶水店打工。由於事發時年紀太小，姪女對於弄傷小芹一事不感到愧疚。她反而有種陰暗的佔有欲，期望小芹能因此在意她。</p><p>然而，小芹卻無意追究右眼失明一事，這讓姪女感到失落。小芹察覺姪女對自己的好感，想起過往自己追著小藍背影的模樣，勸告姪女三思。姪女仍堅持自己的情感，在過年期間借酒壯膽向小芹告白。小芹從姪女身上看見自己的影子，也感受到被愛的幸福，於是接受了姪女的告白。</p><h1 id="〈在海天一線〉"><a href="#〈在海天一線〉" class="headerlink" title="〈在海天一線〉"></a>〈在海天一線〉</h1><p>最終，小芹與姪女相約海邊。她看著身旁的姪女，心想自己再也不用追逐心儀對象的背影。恍惚間，小芹感到身旁有兩名女子跑過，卻因為右眼失明無法確認。不過，小芹也不在乎了。在右眼失明後，小芹逐漸能區分幻想與現實的分界，放下對小藍的依戀。看著緩緩沉入海面的夕陽，小芹更想要把我與姪女此刻的幸福。</p><br/><p>《少女妄想中》的少女在妄想什麼？小藍追逐著幻影般的女子，小芹沉浸在小藍愛上她的夢中，打工女孩則期望與自己的小姑姑相愛。這本書讀起來有種作夢的感覺。各節故事間的背景跳躍，時間流逝也很迅速。敘事也圍繞角色的內心想法，讓場景描述顯得模糊。</p><p>之前讀過入間人間的《無法成為神明的少女》，覺得入間其實也能寫景。或許是為了配合「妄想」的氣氛，才採取不同的敘事模式。比起少女間的親密互動，其實有更多篇幅是以象徵手段，描述小芹對小藍無望的欽慕，例如小藍追不上的背影以及彼此平行的天空與海面。</p><p>小芹與小藍其實都容易沉溺在自己的想像，甚至無法區分現實與幻境。小藍用了整段青春去追逐一個形象飄渺的女子，而小芹則緊跟在永遠不會回首的小藍身後。</p><p>小藍因腳傷沉寂一時，卻在痊癒後繼續追求自己的夢想。小芹的空想構成了〈不會消失的銀之手〉這節故事，迷戀的程度不惶多讓。然而，在右眼失明後，小芹難以忽視視野的落差，以至於現實與幻境的分野愈發明顯。</p><p>在這個時候，姪女出現了。姪女「慶幸她弄傷小芹的眼睛」，因為這起事件連結了原本彼此無關的姑姪。可是為什麼小芹對此不覺得生氣，甚至也有同感？因為失明的右眼一再提醒小芹，讓她正視現實，才有機會把握現今愛慕著她的姪女。</p><p>最後，全書最喜歡的部分是作者對夢境的詮釋。夢與真實有什麼差異？夢裡欠缺累積的感覺。</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Mars Direct》</title>
      <link href="/zubrin-2016-mars-direct/"/>
      <url>/zubrin-2016-mars-direct/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>火星是最靠近地球的適居行星。探索火星不僅具有科學價值、也能刺激技術發展、凝聚人類社群。作者 Robert Zubrin 主張，我們現今已具備載人火星任務所需的技術。因此，任務的成敗不在於更先進的能源或引擎，而在於政府的決心與大眾的支持。</p><span id="more"></span><p>Zubrin 提倡火星直航 (Mars Direct) 方案，反對 NASA 提出的複雜計畫和艾德林的循環軌道方案。他向讀者說明，探索火星不只能促進科學發展，也能凝聚人心和建立進取精神的新文化。</p><p>此書首章簡述了火星的特性：火星的公轉半徑約為地球的 1.5 倍，赤道一帶的日照量約與挪威或阿拉斯加相當，日間均溫可達攝氏十度。火星的表面積與地球陸地面積接近，大氣富含二氧化碳與氮氣。火星地表雖然沒有流體，但水分蘊藏在冰冠、永凍土與地下水。</p><p>火星是比較行星學和天文生物學的重要研究標的，也是潛在的星際移民地點。火星富含鈣、磷、硫等生命元素，也存在鐵、鎳、鋅等工業礦物。火星自轉週期與地球相似，符合植物的晝夜節律有利於農業發展。登陸火星能試驗我們在地外擴張的能力，它考驗人類集體的智慧，促使工程、醫學、管理和科學的發展。</p><p>第二章則簡述了基於火星直航策略的漸進式開發計畫。火星直航策略的重點在於就地利用資源和漸次擴張基地。這項計畫將利用載荷能力與農神五號相當的火箭，搭載以氧氣和甲烷推進的返程載具（ERV, Earth Return Vehicle）、核能反應爐、液態氫、探測車、化學反應爐。經過六至八個月飛行抵達火星，利用大氣剎車進入軌道，再配合降落傘著陸。</p><p>器具登陸後即開始生產登陸組員的生命維持資源以及載具燃料。核能反應爐供應能源，讓化學反應爐將火星大氣的二氧化碳與液態氫生成甲烷跟水，水則進而電解為氧氣與氫氣。氫氣將回收利用，甲烷則儲存以供 ERV 與探測車運用。氧氣可供人員呼吸、作為載具燃料或是重新合成水。由於可以從火星大氣取得碳和氧，登陸計畫便只需攜帶液態氫，大幅降低荷重需求。</p><p>等到最初的登陸點儲備了足夠的燃料和生命維持資源（約費時十個月），登陸組員即可出發。第二批任務共發射兩組火箭。第一組搭載組員、輜重和探測車，負責進行科學與工程任務。第二組則與第一批火箭相同，為下一次登陸準備資源，也是這次登陸的備援。這項方案不依賴月球基地、軌道母艦或是太空站。任務期間，登陸組員全數停留在火星表面以減少輻射傷害。在 2 年任務期滿後，登陸組員再搭乘 ERV 循自由返回軌道回到地球。除了第一年外，接下來平均每年發射一組火箭，逐步擴張火星的探測基地。</p><p>作者早在 1985 年即提出火星直航策略，可是 NASA 自阿波羅計畫後不再有近地軌道外的載人太空任務。作者將 NASA 的沉寂歸咎於保守且失能的官僚主義。在阿波羅計畫期間，NASA 採用目標導向的專案管理。政府設定登月目標後，NASA 依此目標規畫策略和執行計畫。登月相關的技術則隨專案進度發展。</p><p>進入二十一世紀後，NASA 則受制於委員會導向的專案管理，美國舉國上下沒有明確一致的太空發展目標，執政黨屢次推翻既有的太空計畫。在這種情況下，NASA 放任各項專案彼此競爭，導致技術發展嘉惠特定利益團體，卻未必吻合指定的探索目標。委員會導向的專案管理看似彈性，實則因為內容易變，最終一事無成。</p><p>NASA 的失能反映在火星計畫的廢止和計畫的異想天開上。雖然精神號、機會號與好奇號等地面探測任務皆獲得豐富成果，但是它們反映的是前任政府的政績。當今這些任務逐漸廢止，使得軌道衛星失聯後無以為繼，降低登陸器探索效率。在機具故障與計畫廢止之後，NASA 也面臨技術人才的斷層。</p><p>NASA 縮編預算後，不但沒有把錢花在刀口上，反而投資在科研成效較差的火星採樣計畫（MSR, Mars Sample Return）。除了目標選定的瑕疵，任務規劃上也顯得疊床架屋。NASA 並沒有採取直航方案，而是把火星採樣計畫分為數個階段：樣本首先在火星表面採集，接著送上軌道的母船，轉移至返回艙再帶回鄰近地球拉格朗日點的太空站。專案科學家再前往太空站進行樣本的分析與解讀。</p><p>這過程涉及複數太空任務，增加了失敗的風險，也推遲了完成的時機。作者認為，這樣的計畫是為了合理化既有專案，卻與目標不符。此外，失敗的專案排擠既有專案的延續，也沒有為往後的太空任務創造更優良的條件。</p><p>載人火星任務的採樣效率遠比無人機好，但 NASA 遲遲不願推行載人火星任務的理由是安全。為了降低太空飛行的輻射傷害與零重力失能，NASA 計畫發展更快速的引擎，例如 VASIMR 推進系統（Variable Specific Impulse Magnetoplasma Rocket）。然而，VASIMR 依賴至今仍不存在的超導體，也需要高效能的核反應器。</p><p>作者認為，指望尚未存在的高速引擎能克服傷害毋寧是逃避現實。如果按照第二章提出的火星探索計畫，太空人的輻射暴露量約與當今國際太空站組員相當，所以並沒有承擔額外的風險。此外，利用離心力製造人造重力也能解決零重力失能。</p><p>錯誤方向不只虛擲預算，也平白錯失機會。畢竟，國家財政與國際局勢不會永遠平靜，預算安排與國民信任也非恆時持續高漲。確保任務組員的生命安全固然重要，但生命是太空任務要考量的因素，而不是目標。</p><p>作者認為 NASA 應在風險與目標之間取得平衡，並且以量化方式輔助決策，不應訴諸情緒或印象。太空人的價值可從三個方向估計：其作為國民的價格（對應政府確保國民健康的預算規劃）、作為專業人士的價值（對應受訓與培養的成本）、太空人往後的產值（太空任務能發揮的價值）。由這三項因素可以算出太空人的價值，再乘上任務失敗的機率，即構成執行太空任務的風險，可與任務的價值比較。</p><p>作者以修復哈伯望遠鏡的任務為例。哈伯望遠鏡造價約五十億美元，而作者估計每位太空人政府投資五千萬美元，而太空梭任務的失敗率為 2%（挑戰者號與哥倫比亞號），加上太空梭的造價三十億美元，修復哈伯望遠鏡的風險為 2% * (30 + 7 * 0.5) &#x3D; 0.67億美元。若為了 0.67 億美元的損失放棄 50 億美元顯然不符比例。藉此案例，作者想表示 NASA 以太空人性命為由暫停計畫的理由並不充分。</p><p>另外，認為發展相關計畫能提升載人火星任務的安全性的假設也不合理。NASA 至今投入在太空站、重返月球、太空梭上的經費對於人員安全的改善有限（期間仍然發生了挑戰者號和哥倫比亞號事故）。作者認為風險須與報酬相符，NASA 獲得的預算若挹注到其他部門，能影響數千萬人的生計。載人火星任務的報酬巨大，作者認為 NASA 需要認真考慮載人任務的風險，不應無限推遲計畫。</p><p>與政府的保守態度相反，作者指出 SpaceX 或許是太空探索的另一條途徑。公司化的太空事業由負責人全權決定，使得它的開發效率比 NASA 更具彈性。因應 SpaceX 獵鷹系列的技術，作者也提出了改良式的火星拓展計劃，讓它能適用當前的技術。</p><p>最後一章，作者以另一種角度解讀馬爾薩斯人口論，提供了思考太空探索重要性的新觀點。人口論提及人口為等比增長，但糧食為等差增長。若沒加以限制則人口數增長會遠超糧食供給。</p><p>面對人口論的觀察，作者指出有兩種解讀方式。第一種是相信資源有限，為了延續生命，族群內需要管制，族群間需要競爭。管制帶來暴政，競爭引發戰爭，兩者皆限制了人類的自由。而另一種替代觀點則相信資源可以拓展，增長的人口與嶄新的社會型態能培養更多發明家，促進科技進展，改變資源供給的曲線，從而避免競爭並帶來合作。</p><p>依照資源限制觀點，族群延續的關鍵在於佔有，新生兒、移民、外地人都是在地人的威脅；依照資源拓展觀點，族群延續的關鍵在於合作，新生兒、移民、外地人都是在地人將是促進發展的夥伴。</p><p>有別於火星資源開採論，作者以社會學的角度看待火星探索的重要性。過往，戰爭促進了許多科技的發展，但也犧牲了大量人命。在當今，火星探索能夠取代戰爭，作為促進技術發展與人道主義的遠大目標。在探索火星的過程中，除了創造對應的科技外，也給予人類機會去扶植一種新的社會與進取的文明精神。開放、互助與自由的風氣是科技發展的基石，將使人類將更有能力去應對考驗文明的難題。</p><br/>除了火星直航策略，巴茲艾德林也提出火星巡航模式，提倡建立往復火星地球間的太空船班，可參考他的著作《前進火星：尋找人類文明的下一個棲息地》。而 Zubrin 對這類計畫的回應也可在 《How to live on Mars》等書看到。<p>我覺得這本書最精采的論述在於太空探索的目的解讀。截至目前為止，甚至未來幾百年內，探勘地球資源的成本還是遠低於火星。人類的人口倍時也不斷縮短，所以指望移民火星能滿足人類的資源消耗是不切實際。</p><p>然而，火星載人任務仍是重要的槓桿，它是人類對長遠未來的投資，讓我們培養出能對應毀滅災難的能力。過去，戰爭以大量傷亡與數代人的創傷為代價，推進了科技發展。作者在此書則提出另一種選項：火星任務。一方面，它就像某種祈禱，希望人類過剩的激情與憤怒不是往彼此發洩，而是讓這些毀滅力量能朝向太空，前往人類未竟之地。另一方面，火星任務也算是一種社會運動，期望能創造出可以促進科技發展的正向循環，讓文明能夠延續。</p><p>綜上所述，這本書不長，單字也算簡單，還蠻適合了解火星計畫的入門。</p><hr><p>Robert Zubrin. (2016). Mars direct. Polaris Books.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《巴黎馬卡龍之謎》</title>
      <link href="/honobu-2020-pari-macaron-no-nazo/"/>
      <url>/honobu-2020-pari-macaron-no-nazo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《巴黎馬卡龍之謎》是小市民系列的番外篇，收錄了米澤在 2009 至 2020 年間創作的四則短篇故事。這些故事發生在春季篇與夏季篇之間，描述小鳩跟隨小佐內四處品嘗甜點時發生的事件。</p><span id="more"></span><p>每則故事都以小佐內邀請小鳩吃甜點為開端。儘管小鳩一再強調他們彼此為互惠關係，每次收到邀請，他還是會找出各種理由赴約。這天，他們將拜訪位於名古屋的法式甜點店，品嘗它們招牌的馬卡龍套餐。這間甜點店名為「Patisserie Kogi Annex Ruriko」，是東京總店的分店。甜點店的創辦人是從法國學成歸國的古城春臣，而名古屋的分店則由他的左右手田坂瑠璃子經營。店名「Ruriko」正是以她的名字命名。</p><p>店員送上套餐後，小佐內發現盤裡多了一顆招牌口味的馬卡龍。她認為這並非店員的疏失，而是某人的蓄意行為。如果貿然通知店家，將使兇手稱心如意。於是，小佐內與小鳩開始推測兇手的身份與動機。首先，店員沒有告知相關資訊，所以額外的馬卡龍顯然不是招待品。其次，他們的視線僅在上廁所和鐘聲響起時離開餐桌。除非兇手能預料這些時機，不然難以預謀犯案。兇手也不太可能掉包整盤馬卡龍，又保證口味與小佐內訂單內容一致。由此推知，兇手可能臨使起意把馬卡龍放到小佐內的盤中。</p><p>小佐內發現一枚戒指夾在額外的馬卡龍內。馬卡龍的作工精細，上下瓣可輕易撥開，宛如精緻的戒指盒。目前甜點店未開放外帶，小鳩推測這個馬卡龍是某甜點師的私物，而非店家的客製產品。</p><p>小鳩與小佐內認為，藏有戒指的馬卡龍將作為求婚禮物贈與店內某人。小佐內認為，古城春臣的形象符合用馬卡龍求婚的象徵意義。田坂瑠璃子是店家負責人，也是古城春臣的親密對象。小佐內推測，兇手想阻止古城春臣向田坂瑠璃子求婚，也想以藏有異物的食品破壞店家聲譽。</p><p>基於這些線索，小鳩與小佐內認為兇手的動機幼稚、手段粗糙。他們藉此鎖定身後的中學生，並且向對方搭話。這名中學生坦白犯案，表明自己身分。她叫古城秋櫻，是古城春臣之女。這解釋了為什麼兇手能掌握古城春臣的動向，也擁有進入員工休息室的權限。古城同學自述，自己對父親續絃懷恨在心，打算搞垮店家讓父親顏面掃地。小佐內以請她幫忙做甜點為條件原諒了她，也留下自己的聯絡方式。</p><p>這起事件後，小佐內與古城同學逐漸親近。古城同學十分仰慕小佐內，頻頻聯繫小佐內並邀約出遊，還不時致贈她小點心。正逢學校園遊會，古城同學邀請小佐內到他們班級享用紐約起司蛋糕。小佐內要求小鳩同行以暗示古城同學不要過度干擾她的私生活。</p><p>在吃完蛋糕後，他們捲入一起涉及柔道社霸凌的事件。小佐內和古城同學在篝火旁烤棉花糖時，被一名男同學撞倒。男同學遞給小佐內一張光碟。她察覺光碟內容或不尋常，隨即將它藏起來。隨後，三名壯碩的高年級生走近小佐內。他們訊問男同學之後，指控小佐內私藏光碟並要求她跟隨他們走。小佐內沒有拒絕要求，反而囑咐古城同學求助小鳩，自己會爭取時間讓他們調查光碟的內容。</p><p>小鳩聽了古城同學的說明後，苦思小佐內如何在眾目睽睽下把光碟藏起來。他聯想到紐約起司蛋糕的製作方法，推測小佐內把光碟放入裝了水的盒子中，再藏在篝火底下。他們順利在篝火下找到光碟，也委託電腦社員播放光碟。光碟的內容是柔道社霸凌社員的錄影。小鳩恍然大悟，那三名高年級生為了避免醜聞爆發而想奪回光碟。</p><p>小鳩和古城同學準備營救小佐內時，她突然現身電腦教室。小佐內表示，她出示學生證後順利脫身。小鳩好奇小佐內為什麼不打算報復。她解釋那名電腦社員似乎不滿柔道社的作風，即使自己不出手，他也會帶著光碟向學校檢舉。</p><p>起司蛋糕事件後不久，小佐內接到古城同學的電話，說她被誣陷在派對飲酒而停學。小佐內與小鳩接受古城同學的委託展開調查。與古城同被停學的有茅津、槴野和佐多。茅津是三人的頭頭，槴野與古城關係不佳，而佐多和古城幾乎沒有交集。在拜訪茅津之後，他們獲知有人拍照告發才會牽連古城。即使茅津為古城辯護，仍因個人誠信而未被採信。小佐內與小鳩相信古城的為人，因此懷疑證據遭到捏造。</p><p>他們求助古城的繼母田坂，希望她能出面與校方交涉以獲取證據照片。田坂雖然忙於店務，卻二話不說答應出席。在現場，田坂堅持女兒的清白，讓校方不得不拿出證據照片。那張照片顯然經過變造，古城的臉被移花接木到派對照片上。從合成照片的來源，小鳩推論嫌疑人是能同時拿到派對照片和交流會照片的槴野父女。雖然小鳩與小佐內已接露真相，但事件既然已經平息，他們也選擇不再追究。</p><p>這一系列事件使得古城與繼母田坂關係改善。為了感謝小佐內與小鳩的幫助，他們招待了整桌的甜點，彌補了小佐內經常遇上事故而無法好好品嘗甜點的遺憾。</p><br/><p>我覺得這集讀起來比正篇輕快，小鳩幾乎沒有糾結要當個小市民，故事充滿了推理和解謎環節。儘管如此，古城同學與繼母田坂的關係發展仍是重要的主線。古城同學是單純熱心的孩子，十分討喜。她會在目睹不良行為時出聲制止，也願為朋友出力幫忙。小佐內在小鳩眼裡雖然笑裡藏刀，卻深深吸引古城同學。可能受到近期閱讀的輕百合作品影響，這種女孩子間的友好關係讓我讀得很開心。</p><p>田坂是古城同學的繼母，雖然一開始關係疏遠，但在古城同學需要幫忙時，毫不猶豫就出面交涉，堅持相信自己女兒的清白。我看到最後母女和解還蠻感動的。</p><p>除了主要情節，還有一篇校刊社的事件：為了報導麵包店的簡介，校刊社員決議在麵包當中放入芥末，由吃到加工麵包者負責撰寫專欄。結果卻沒人承認吃到麵包。正好到校刊社繳交問券調查的小鳩接受委託調查此案。這則的兇手很明顯，閱讀的樂趣在於欣賞作者如何串聯線索，推翻角色最初認為不可能的假說。嫌疑犯也侷限在少數現身的角色。調查線索時，每個人也會因為各自的顧慮而歪曲線索或誤導方向。最終的真相就是一開始覺得最不可能的事件。</p><p>總而言之，這本算是看得很舒服，結尾也好溫馨的作品。近期改編動畫播出，我不想被透漏劇情，所以趕緊讀完小說。沒想到冬季篇在今年四月才出版，國內目前還沒有代理。如今總算看完，可以慢慢期待冬季篇以及動畫了！</p><hr><p>米澤穗信（2022）。巴黎馬卡龍之謎。尖端出版（原著出版於 2020 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mystery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夏日計劃(3)》</title>
      <link href="/irene309-2024-summer-project-season-3/"/>
      <url>/irene309-2024-summer-project-season-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《夏日計劃》的完結篇為眾神的恩怨畫下句點。陳晞、浩瑜與秋天再度回到過去。這一次，陳晞將魔力歸還世界之樹，捨棄作為巴德爾轉世者的身份，期望能以此終結與霍德爾的宿仇。</p><span id="more"></span><p>除了交代主線劇情，這集也用了許多篇幅解釋角色的動機，使劇情的銜接更合理。例如，秋天跟隨浩瑜回到過去，除了對感情因素外，也有現實的考量。秋天擔任處刑者的第一項任務是處決自己的雙親。秋天在故事中表現得率性樂天，可是此事仍成為她餘生的遺憾。她已經為又夏背叛政府，勢必難逃事後清算。因此，回到過去不僅給自己重來的機會，也能避免政府的懲處。秋天也深知浩瑜必隨陳晞而去。如果秋天執意留下，也只剩她獨自一人。回到過去不一定能改善現狀，卻能爭取更多與浩瑜相處的時光，或許能拉近彼此的距離。</p><p>不過，浩瑜依舊回絕秋天的告白。一方面，浩瑜認為自己仍然依戀陳晞，另一方面，她不認為秋天能從這段關係中獲得幸福。浩瑜的父親既無能又酗酒，為了獲得政府補助，他主動將浩瑜送到機構管訓，導致她度過不幸的童年。或許是因為擁有預知能力，相較於其他角色，浩瑜對於命運深信不疑，也對不平等的待遇表現得逆來順受。</p><p>相較於自己的福祉，浩瑜更在乎他人的幸福。在其它時空，陳晞和秋天都曾為浩瑜的境遇動下殺機。浩瑜不希望他們因此鑄下大錯，她尤其擔心一直喜歡著自己的秋天。在浩瑜預見的未來中，秋天每一次都因殺害浩瑜的父親而被處死。因此，浩瑜一再拒絕秋天，希望與其保持距離能避免悲劇發生。</p><p>陳晞因為讓渡魔法而失去記憶，所以依靠浩瑜促成她與又夏的重逢。在這個時空，浩瑜與又夏成為摯友。由於這份交情，浩瑜順利說服又夏吞下世界樹的果實，取回前一時空的記憶。重獲記憶的又夏仍保持初衷，她想要保護孤兒院，改善無能力者的處境。另一方面，又夏也想起陳晞，想起她說：「一起改變世界。」，想起她們在上個時空一起相處的點點滴滴。儘管否認自己的渴望發自喜歡，又夏仍期盼見到陳晞並且和她共度日常。</p><p>即使陳晞不再擁有魔力，她善解人意的個性以及想改變世界的熱情卻始終如一。陳晞的家境優渥，雙親都是著名的魔法使，兩人發明的魔力機械大幅改善人類生活品質。目睹無能力者的悲慘處境，陳晞認為自己獲得不應得的關注與待遇。她期望能擺脫雙親的名聲，靠自己達成目標；也想化解社會的不平等，不辜負她擁有的優越條件。</p><p>又夏與陳晞在高中入學考試當天相遇。陳晞誤以為又夏需要幫忙而搭話，卻被對方的容貌吸引。她好奇對方如何得知自己的名字，也很好奇對方為何面露惆悵、欲言又止。</p><p>此時，在校園另一角落的浩瑜與秋天，感受到又夏與陳晞相遇引發的魔力波動。至此，浩瑜也完成了她來到這個時空的任務，心中卻不免感到遺憾。她深知陳晞即使失去記憶也不會喜歡上她。在陳晞與又夏重逢後，只剩下自己還被困在原生家庭與政府機構的壓迫中。</p><p>面對秋天毫不隱瞞的好感，浩瑜的內心感到十分矛盾。秋天是現在身邊唯一的熟人，與她相處也不用刻意掩飾。然而，浩瑜不希望秋天因為自己而受傷。她不在乎自己，只希望朋友平安。儘管預知能力為浩瑜帶來不幸，她相信同樣的能力可以促成他人幸福。在預知孤兒院被縱火之後，浩瑜以幫忙整理房間為由支離又夏，想要避免她因為目睹火警而失控。</p><p>於是，又夏直到火警發生後才回到孤兒院。在現場，她碰到前來幫忙的陳晞。又夏想起陳晞的記憶不會受時空倒退影響，所以請她幫忙疏散孤兒院院生。時間倒轉後，陳晞提議使用魔力管理裝置緩慢釋放時間魔法，讓孤兒院建物的時間停滯以避免火災。</p><p>為此，兩人再度來到陳晞的家中。不過在完整裝置設定後，陳晞卻發現自己希望又夏能夠留下。陳晞對又夏感興趣，想要與她相處，理解她的哀愁，分擔她受過的惡意。於是，她們再度同居，一起吃早餐、睡覺、出門上班、十指緊扣、親吻額頭、討論喜歡的定義、試探彼此的心意。</p><p>她們各自下定決心。陳晞想要改善社會，她一方面認為自己擁有得太多，想要反抗自己的出身；另一方面，則想為又夏做點什麼，讓那張漂亮的臉蛋綻放笑容。又夏想要實現陳晞的願望，她不想辜負陳晞、浩瑜與秋天為自己的付出，也想認真回應陳晞的好感。</p><p>在浩瑜提議下，又夏在高中成立了疑難雜症處理社，期望能從周圍開始改變世界。陳晞雖然加入弓道社，但也作為兼任社員協助又夏解決來自學生五花八門的難題。另外，陳晞也動用關係，說服爸媽成立了無能力者學校，培養他們一技之長。</p><p>在參與弓道社活動時，陳晞喚起了其他時空的部分記憶。浩瑜和又夏向她解釋其他時空的事情，她們表示在陳晞主動放棄魔法之後，黑暗也隨之消失，從而化解巴德爾與霍德爾的恩怨。浩瑜表示，如果一切順利，這將是他們尋找已久的歸宿。</p><p>一切看似一切好轉之時，他們接到魔法機構的委託：以浩瑜與秋天脫離機構條件，治療垂死的部長；相反地，若任務失敗，又夏將被徵收。陳晞一行人推論機構有不可告人的祕密，才會在擁有充足醫療資源的情況下，求助同樣需要隱瞞身分的又夏。果不其然，他們抵達現場，發現眼前瀕死的部長竟是奧丁之弟洛基。</p><p>在又夏發動時間魔法，回溯洛基的軀體時，過往的記憶湧入陳晞腦中，讓她明白一切真相：洛基因為沒能獲得世界樹的能量，挑播巴德爾和霍德爾兄弟。霍德爾因為忌妒巴德爾受人愛戴而將其殺害。祂們的母親弗麗嘉震怒之下懲處洛基，引發了諸神黃昏。眾神在戰爭中死去，形成無數個平行時空。</p><p>在所有的時空裡，洛基都一再煽動霍德爾殺害巴德爾以及不斷礙事的「時間」。得知又夏和自己的分離全是洛基促成的鬧劇，陳晞衝動地想殺了洛基，但被又夏勸阻。然而，陳晞看出契約的破綻，在洛基痊癒後才擊斃祂。</p><p>失去部長後，魔法管制機構瓦解。浩瑜與秋天順利離開機構，但也失去經濟來源。因此，她們兩人共租套房並且到點心店打工。雖然她們關係密切，但浩瑜仍然堅稱自己沒有和秋天交往。又夏發動魔力後再次消失，所以浩瑜繼任疑難雜症處理社的負責人，維持社團的經營。由於失去又夏的保護，孤兒院還是付之一炬，但是因為無能力者學校蒸蒸日上，院生也有了新的去處。陳晞還是思念又夏，在她們約定的那天，她帶著一束花來到命運之神化為的世界樹下，與即使跨越了數個時空也想再次見面的女孩重逢。</p><br/> <p>故事總算在第三集迎來 True End。在 Galgame 或 RPG 遊戲中，如果玩家只顧著走主線，通常會錯過影響角色性格與決策的事件，導致劇情走向 Bad&#x2F;Normal End。想要達成 True End 不外乎要參與角色的成長背景與一些哩哩叩叩的支線（然後每個支線都要做出正確的選擇）。</p><p>這一集，讀起來的氛圍也很像這種設計。前兩集（對應遊戲的第一、第二周目）培養角色好感度，並且通關多數的主線任務。最後一集反而少了很多解謎的情節，主要篇幅是在圓滿角色的形象。不管是陳晞想要改變世界的動機，或是浩瑜拒絕秋天的心理，都在這集有詳細的解釋。在最後也是用計對抗幕後黑手洛基，而不是經歷一場魔法大戰。</p><p>這集最喜歡的是浩瑜初吻的場景。在成功喚起又夏的記憶後，浩瑜與秋天的任務也告一段落。秋天希望浩瑜能更關注她，但浩瑜卻堅持不肯，認為對方不會因此而開心。可是，雖然說著不要，但她還是接受秋天的 kiss 了。這種淒美ㄉ關係真是令人疼惜。最後浩瑜與秋天一起逃離機構、一起租屋、一起打工賺錢，雖然浩瑜否認正在交往，不過我覺得可以，有遺憾的兩人彼此陪伴也沒有不好啊。</p><p>（另外，浩瑜以前的宿舍位於 27 樓，這數字跟作者的新作有關嗎？）</p><hr><p>Irene309（2024）。夏日計劃(3)。台灣角川。</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Duplicate alleles in VCFs derived from tvc</title>
      <link href="/duplicate-alleles-in-vcfs-derived-from-tvc/"/>
      <url>/duplicate-alleles-in-vcfs-derived-from-tvc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近，我們碰到一個棘手的技術問題。其他同仁反映，我們開發的變異分析工具在執行 GATK 時意外中止，並呈現以下錯誤訊息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The provided VCF file is malformed at approximately line number 1: Duplicate allele added to VariantContext: TA</span><br></pre></td></tr></table></figure><p>我檢查該步驟使用的 VCF 檔，發現其中一列的 REF 與 ALT 欄位內容重複，導致 GATK 報錯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr1100.TAGT,TA</span><br></pre></td></tr></table></figure><p>標準的 VCF 檔只記錄實際存在的變異，不應出現 REF 和 ALT 欄位相同的狀況。即使該位置沒有變異，通常也會以點號（<code>.</code>）標記。因此，我推測問題的源頭不是分析工具本身，而是上游的 variant caller。</p><span id="more"></span><p>由於這份 VCF 檔源於 Torrent variant caller 5.18 (tvc)，所以我研究了它的說明書。tvc 允許用戶透過 hotspot VCF，自訂分析區域以及必須報告的變異。在醫療檢驗服務中，我們通常會把具有臨床價值的變異位點納入 hotspot VCF，提升 tvc 對這些變異位點的靈敏度。由於出錯的條目恰好是這些臨床位點，我推測異常行為可能跟 hotspot VCF 的內容有關。</p><p>經過一系列測試，我發現這項錯誤可以在特定情境重現：</p><ol><li>樣本中存在 MNV (multi-nucleotide variant)，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr1100.TAGT</span><br></pre></td></tr></table></figure></li><li>Hotspot VCF 在相同位置存在兩個必須回報的 SNV (single nucleotide variant)，而且這兩個 SNV 的 REF 和 ALT 一致。（其中，<code>*</code> 表示任何非 “T” 鹼基）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chr1100.TG</span><br><span class="line">chr1100.*T</span><br></pre></td></tr></table></figure></li></ol><p>在這種情境，tvc 表現出一些令人意外的行為</p><ul><li>當偵測到 MNV 時，tvc 不會單獨報告 SNV，而是合併相同位置的變異。</li><li>在偵測變異時，tvc 只考慮 hotspot VCF 的 POSITION 和 ALT 欄位。</li></ul><p>這些因素共同作用，導致 tvc 產生了以下異常結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chr1100.TAGT,TA</span><br></pre></td></tr></table></figure><p>在這個結果中，”GT” 是樣本原有的 MNV，而異常的 “TA” 則分別來自第二個 SNV 的 ALT（”T”），以及參考基因體上的 “A”。</p><p>成功重現這個錯誤之後，我曾懷疑是否在使用 tvc 時誤植了 hotspot VCF 內容。然而，經過實際測試，我發現在最新版的 tvc 中，即使使用完整的 hotspot 也會面臨同樣問題。這表示可能有其他未考慮的因素與這個錯誤有關。</p><p>總而言之，鑒於網路上關於 tvc 的資源匱乏，希望這些紀錄能幫助陷入類似問題的同行，感謝大家。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夏日計劃(2)》</title>
      <link href="/irene309-2023-summer-project-season-2/"/>
      <url>/irene309-2023-summer-project-season-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為了再次見到又夏，陳晞費時多年打造了一台時光機。然而重逢後，陳晞發現又夏喪失了與她相處的所有回憶。儘管想重新追求對方，身患重病的陳晞深知自己來日無多。因此，陳晞決定全力阻止迫在眉睫的「諸神黃昏」，只為留給又夏一個安穩的未來。於此同時，單戀陳晞的浩瑜也隨她回到過去，竭力尋找能拯救世界又可以挽救陳晞性命的方法。</p><span id="more"></span><p>在事故發生後，陳晞因為覺醒了魔法能力而被政府徵用。除了定期貢獻魔力以外，她也負責處決政府的眼中釘。陳晞因此罹患了思覺失調，情感也逐漸變得木。儘管如此，陳晞不曾忘記和又夏的約定。她暗中挪用政府資源打造了時光機，也運用職權調查事故的起因。</p><p>回到過去後，陳晞發現又夏在其他時空的記憶因為襲擊而消失。壓抑著傾訴一切的衝動，陳晞選擇重新認識又夏。儘管又夏的友好態度一如既往，其中卻沒有往昔的情愫。陳晞對兩人間的隔閡感到沮喪，卻無暇自憐——末日危機迫在眉睫，她的時間又所剩無幾。</p><p>陳晞與浩瑜在這個時空，仍持續鑽研上古魔法史，從中獲悉事故的起因。在很久以前，黑暗之神霍德爾殺害光明之神巴德爾，引發了諸神黃昏，導致神界毀滅。然而，過往的恩怨沒有平息。霍德爾在轉世後仍執著於復仇，鎖定了轉世為陳晞的巴德爾，造成陳晞與又夏分離。因此，為了保護又夏並且避免諸神黃昏重演，陳晞決定與霍德爾正面對決。</p><p>然而，陳晞的生命正因魔力汙染而逐漸消逝。浩瑜看著陳晞不惜犧牲性命也要守護又夏，深知自己永遠不會得到相同的關注。儘管略感疲憊，浩瑜仍堅持在旁協助，竭力尋找既能拯救世界又能挽救為陳晞的性命的方法。與此同時，浩瑜的學妹秋天也向她表白。秋天也是政府的處刑者，她從不掩飾對浩瑜的喜歡。秋天的積極屢次讓浩瑜反思自己的感情。然而，浩瑜始終沒有接受秋天的告白。不過善良的浩瑜，也不願看到喜歡自己的秋天，因為執行任務而像陳晞一樣變得麻木冷淡。</p><p>不久，霍德爾再度現身，抹除又夏生活周遭的建築與事物。為了擊敗對方，陳晞闖入對方設下的黑暗領域，卻因魔力汙染症狀而力不從心。被霍德爾引發的異象吸引，浩瑜與秋天趕到現場，催促又夏倒轉時間，才讓陳晞脫離險境。</p><p>隨後，浩瑜囑咐又夏照料陳晞，於是兩人再度同居。儘管他們偶爾攜手散步，也會共枕而眠，但又夏卻沒有因此心動。又夏明白自己出於關心而親近陳晞，所以婉拒了她的追求。然而，又夏仍答應陳晞的邀約，一起參加夏祭一夥大會。陳晞被拒後接受現實。即使無法重新相愛，她仍希望能排除威脅，留給又夏一個安穩的世界。於是，在另一個時空她們曾接吻的山丘，陳晞決定做個了斷。</p><p>陳晞推論，如果霍德爾的復仇引發了諸神黃昏，那麼她一死就能終結這段恩怨，阻止眾神的戰爭與末日。然而，在陳晞舉槍自盡前，命運之神烏爾德現身。祂阻止陳晞開槍，並提示她尋找世界樹以獲得困境的其他解法。</p><p>除了陳晞，政府也試圖阻止諸神黃昏。他們指派處刑者秋天刺殺又夏，期望能犧牲「時間」來阻止災難發生。得知此消息，浩瑜立即連絡又夏。考量陳晞的身體狀況，浩瑜懇求又夏再次倒轉時間，以在政府採取行動前，找到治療陳晞和避免末日的方法。</p><p>儘管又夏訝異自己願意為陳晞付出如此之多，仍然同意將時間倒轉到高中前的暑假。彷彿出於對將死之人的憐憫，又夏向陳晞提出交往的要求，給對方一個讓自己心動的機會。然而，陳晞卻無法坦然接受，向又夏坦白前一個時空的回憶，可是又夏僅能像個旁觀者一樣安慰她。</p><p>於此同時，浩瑜和秋天也計畫背叛政府。他們打算捏造處刑的場景，瞞騙政府與霍德爾。為此，他們請求又夏和陳晞援助。然而，政府早已察覺這個陰謀，派遣特務包圍浩瑜一行人。陳晞發動能力阻止政府的特務，卻因魔力過度而倒下。</p><p>此時，命運之神再度現身。又夏懇求祂挽救陳晞性命，然而命運之神卻無能為力。儘管不明白自己確切的感情，又夏仍自願奉獻魔力，犧牲自己讓陳晞恢復意識。見識又夏的決心後，命運之神也隨之自盡，化為世界樹。至此，時間已經消逝，命運也已安息，陳晞頓悟這是解決諸神黃昏的另一種途徑。她舉槍射殺了隨後現身眼前的霍德爾，讓千古的恩怨畫下句點。</p><p>陳晞與又夏重逢耗費了近三十年光陰，不過對方卻為守護陳晞而犧牲性命。浩瑜相信這不是最圓滿的結局，於是提議再度回到過去。而在一旁目睹一切的秋天則決定要追隨浩瑜，不願放棄自己的感情。</p><br/><p>這集投入大量篇幅推進主線，解釋又夏和陳晞遇襲的原因。如果用 galgame 常見分類，這個結局或許可以歸類為 normal end 吧。陳晞在政府機構裡被馴化成冷血的劊子手，心儀對象又夏又喪失記憶。如果不動用能力，陳晞或許尚存一線生機。然而，作為光明之神的轉世者，陳晞是唯一有能力阻止諸神黃昏的人。而且，如果她不出手，最終政府也會殺害又夏。</p><p>肩負又夏的承諾與世界的命運，本就不善社交的陳晞試圖像前一個時空的又夏一樣主動，卻適得其反，始終沒有打動又夏。最令人扼腕的是，陳晞幾乎犧牲了一切，結果又夏最終選擇相信她。明明聲稱還沒愛上自己，為何最後要出手相助？如果又夏更加絕情，陳晞或許能更坦然接受命運。可是故事的最後，又夏才希望陳晞「努力讓我愛上妳」，卻沒等到陳晞打動自己的心，就為她犧牲性命。</p><p>這集第二喜歡的場景是浩瑜跟秋天去夜市玩，然後秋天幫浩瑜贏得了一隻兩棲類娃娃。第一喜歡是後來浩瑜要求又夏倒轉時空時，千交代萬交代又夏不要弄丟她這個夏天的回憶。笑了，這不是很懂ㄇ。</p><hr><p>Irene309（2023）。夏日計劃(2)。台灣角川。</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夏日計劃(1)》</title>
      <link href="/irene309-2023-summer-project-season-1/"/>
      <url>/irene309-2023-summer-project-season-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在孤兒院長大的又夏擁有操控時空的能力。為了保護心儀對象陳晞免遭不幸，同時確保孤兒院院生的安全，又夏穿越不同的時空，試圖阻止悲劇發生。在這段過程中，她反覆經歷與陳晞的相處與離別，累積了深厚的感情。</p><span id="more"></span><p>起初，又夏並不明白自己為什麼對陳晞一見鍾情。然而，當她跨越不同時空，卻發現自己始終會愛上陳晞的時候，才終於領悟到她喜歡陳晞的溫柔體貼、那副不善於表達情感的彆扭模樣、以及總是笨拙地詢問「還好嗎」的口吻。這些不因時空跳躍而改變的特質，深深打動又夏的心。</p><p>為了找到彼此都能平安無事的時空，又夏一再發動能力。在故事發生的時空裡，又夏因為兩度幫助陳晞而與她相識。出於對又夏的謝意，陳晞在孤兒院遭到縱火後，讓無家可歸的又夏寄宿在自己的家中。在這段期間，又夏總是不避諱與陳晞肢體接觸。由於欠缺與女生相處的經驗，陳晞對內心湧現的陌生感受感到困惑，也不知道如何回應又夏莫名的好感。</p><p>在確認院生脫離險境後，又夏原以為事件能就此平息。然而，她們卻再次遭到黑暗能力的持有者襲擊，周遭的事物被黑暗吞噬消失。比起自己安危，又夏更擔心陳晞的處境。又夏已經在這時空創造了許多難忘的回憶，不願再度放棄與陳晞的關係。因此，當她接到陳晞來電時鬆了一口氣。</p><p>見到匆忙趕來的又夏，陳晞除了安心感以外，也漸漸察覺一些異樣的情感。她不明白自己為什麼對又夏可能消失感到不安，也不解為什麼對方陪在自己身邊時會感到害臊。隨著孤兒院裝修工程接近尾聲，又夏即將結束寄宿生活，陳晞也持續探索著內心那股難以名狀的失落感。</p><p>開學以後，又夏在校園巧遇陳晞的青梅竹馬浩瑜。浩瑜擁有預知能力，卻因此被政府徵用而與同齡人格格不入。由於只有陳晞願意接納她，所以浩瑜一直對陳晞心存好感。儘管得知又夏與陳晞關係密切，浩瑜在預知陳晞的未來一片漆黑之後，仍決定與又夏合作以保護陳晞。</p><p>又夏和浩瑜推測，預知的內容以及先前的攻擊都和黑暗之神相關。他們懷疑，近期發生的異象是遠古眾神鬥爭的餘波。基於這項推測，他們認為如果能向光明之神求援，便能找到解決問題的契機。然而，這些推論僅依據一本古籍，因此又夏與浩瑜決定調查該書作者以取得更多資訊。</p><p>在確認作者的住處後，又夏和浩瑜決定潛入一探究竟。不過，途中再次遭遇襲擊。所幸，又夏及時發動能力倒轉時間，才讓他們脫離險境。這次襲擊也揭漏了對方的動機，祂打算利用又夏操控時空的能力來達成永恆。另外，他們也意外發現陳晞的記憶不受時間回溯影響，於是決定讓她參與行動，轉而調查古籍的出版社。</p><p>在調查期間，又夏與陳晞的感情悄悄變化。又夏向陳晞告白，而陳晞也表示喜歡對方。然而，陳晞卻不確定「喜歡」一詞能否概括她此時的複雜感受。與又夏在一起時，陳晞能感受到與青梅竹馬相處時的自在，也很樂意更了解又夏。除此之外，她還察覺到一些令自己訝異的情感。例如，她開始關注又夏的班級與成績、在對方離開時擔心她的安危、甚至為了保護對方而選修了槍械課程。</p><p>另外，儘管又夏不吝於肢體接觸，也坦率地表達了喜歡，陳晞還是很在意又夏的真實想法。她一直對自身條件缺乏信心，在得知又夏被其他男生告白時，竟然開始胡思亂想，對於可能無法繼續與又夏一起上學聊天而感到遺憾。</p><p>隨著他們之間更多的互動，陳晞也終於領悟又夏的心意。無論是又夏親暱把弄頭髮的舉動、還是夏季煙火大會那個吻，都不是普通朋友的相處。這段期間，浩瑜也曾半玩笑地向自己提出交往請求，但陳晞發現，雖然她能在與浩瑜的關係中感到理解、信任與感謝，卻少了某種關鍵因素。於是，陳晞終於確認自己對又夏的感情與眾不同。</p><p>然而，在陳晞領悟自己的情感之後，卻沒有機會正式向又夏表白。他們的行動再次失敗，黑暗能力的持有者挾持了又夏。眼見自己的攻擊毫無效果，陳晞只能懇求又夏逃離這個時空。在分離前，兩人彼此許諾一定要重逢。隨著又夏離開這個時空，黑暗也在一陣怒吼後消失。</p><p>在這場衝突之中，陳晞的魔法能力覺醒，隨即被政府調查與徵用。雖然被迫接受政府的任務安排，為國家貢獻魔法能力，但是陳晞始終沒有忘記與又夏的約定，她暗中利用國家資源開發了時光機，決定回到過去尋找又夏。而一直暗戀陳晞的浩瑜也下定決心，儘管知道這是沒有回報的付出，仍願意支持陳晞，陪伴她回到與又夏相遇的那個炎熱夏天。</p><br/><p>我蠻喜歡這部作品對於角色情感的安排。例如，在孤兒院遭遇縱火之後，又夏曾提及，如果沒有紀錄的話，那麼遺忘的事物就會消失，彷彿不曾存在過。這段話在故事結尾得到呼應，陳稀在又夏遺留的筆記本中，發現她記下了在每個時空與自己相遇的回憶。</p><p>當事件惡化到無法挽回時，又夏總是選擇離開以保護陳晞與孤兒院。儘管浩瑜無法原諒又夏一次次拋棄陳晞的舉動，但實際上又夏也非心甘情願。每一次跨越時空，她都不得不放棄與陳晞的回憶，還得承受彼此從陌生到熟悉的忐忑過程。而且，在跨越時空之後，又夏什麼都帶不走，只能憑藉自己的記憶，試圖留住與陳晞相處的點點滴滴。</p><p>又例如在又夏向陳晞解釋何謂喜歡的情感的時候，她曾抓著對方的手感受自己的心跳。當下陳晞雖然感到又夏快速的心跳，卻沒意會她的暗示。直到後來雙方接吻時，陳晞感到自己劇烈跳動的心臟，這一刻她才真正理解當時又夏的意思。</p><p>另外，我還發現「不討厭」這個詞在作品中反覆出現。這個看似模糊的字眼，實際蘊藏著豐富的情感層次。又夏在故事的開端已對陳晞滿懷好感，所以雖然表現的方式不同，但對於陳晞各項舉動的反應無一例外是「喜歡得要死」。然而，陳晞就不一樣了，她無法精確把握自己的想法。因此，當她面對又夏時會有三種狀況：</p><ul><li>好奇對方的感受時，對方不表示喜不喜歡，而是說「不討厭」時，到底是什麼意思啊？討厭的相反是喜歡，還是不在乎？如果不在乎，為什麼要回應我啊？</li><li>懷疑自己感受時，無法描述當下的情感，卻感到「不討厭」時，到底是怎麼回事啊？討厭的相反是在意，還是不感興趣？如果不感興趣，那麼現在誰的大腦正在胡思亂想啊？</li><li>被詢問自己想法時，難以肯定內心的意思，於是說出「不討厭」時，到底是什麼目的啊？討厭的相反是同意，還是不坦率？如果不坦率，為什麼還要說出來期待被對方察覺啊？</li></ul><p>於是，「我不討厭喔」就像是沐浴乳一樣，在兩人關係的摩擦中持續搓出曖昧的泡泡，醞釀出讓人心癢的氛圍。如果用故事的拓樸學（我隨意創造的名詞，研究故事連續變化的性質，而不是具體內容）的觀點分析，或許他們的故事可以看作是「不討厭」的訓詁。</p><p>這個理論其實充滿破綻，看來我需要更多貼貼，為了研究用途。</p><hr><p>Irene309（2023）。夏日計劃(1)。台灣角川。</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>軟體測試的無限後退</title>
      <link href="/infinite-regress-in-software-testing/"/>
      <url>/infinite-regress-in-software-testing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在修改程式碼之後，開發人員會執行測試以確保軟體的各項功能運行無誤。由於測試通常以程式碼實現，所以它們也可能存在 bug。鑒於這種風險，有些人可能考慮撰寫測試的測試，試圖為軟體的品質把關。</p><p>不過，依據這個想法，測試的測試也應該被檢驗其正確性，因此需要額外的測試來支持既有的測試。以此類推，它們會衍生出無窮個測試，形成軟體測試的無限後退難題（infinite regress）。</p><p>在實務上，無窮測試顯然不可行，那麼開發人員應該如何確保測試的可信度與有效性呢？</p><span id="more"></span><p>這個挑戰來自我們公司的法規管制部門（Regulatory Affairs, RA）。在生醫軟體的開發環境裡，RA 部門負責監督各團隊的作業流程，以確保產品遵循 IVDs 或 LDTs 等政府規範。因此，他們特別在意軟體更新與架構異動的風險。</p><p>當我們為了引進自動化測試而諮詢 RA 部門時，雖然他們認同這項提議立意良善，但仍不免從風險管控的立場，要求我們驗證測試手段的有效性。在會議當下，我隱約感到這方法不實際，卻提不出完整的理由說服對方。</p><p>因此，我對驗證測試的方法做了一些調查。最終發現，比起撰寫測試的測試，善用其他手段更能保障測試的有效性。</p><p>首先，撰寫簡單易懂的測試程式碼，讓它不證自明，就不需要額外覆核，從而終止測試的後退。另外，簡潔的程式碼也有助於辨識錯誤和手動調試。</p><p>其次，讓軟體與測試互相支持，形成循環論證來避免無限後退。例如在測試導線開發（Test-Driven Development, TDD）裡，在設計一項功能前，會先建立對應的測試。如果功能尚未完成，卻通過其測試，就表示測試程式碼有誤。反之，如果完成功能後無法通過測試，就表示兩者之一需要修正。隨著軟體迭代，這些測試一方面保障既有的功能，另一方面也受到新增的功能挑戰，達到兩者彼此檢驗與支持的效果。</p><p>最後一種觀點則涉及測試的本質。測試是除錯的手段而非證成的依據，測試通過能提供的線索有限，但測試失敗卻直接指引了修改程式碼的方向。因此，與其去證明已經通過的測試，不如提升既有測試的覆蓋度與靈敏度，增加改善軟體品質的機會。</p><p>綜上所述，如果想要保障測試的可信度與有效性，我們不需要為測試撰寫測試。更有效的手段是維護簡要而精準的測試，讓軟體與測試隨著開發歷程彼此支持與改善。</p><ul><li><a href="https://stackoverflow.com/questions/2113601/how-do-you-solve-the-infinite-regress-problem-in-tdd">How do you solve the infinite regress problem in TDD?</a></li><li><a href="https://coderefinery.nz/2019/08/15/an-adversarial-process-to-improve-your-tests/">How to Improve Your Tests by Being an Evil Coder</a></li><li><a href="https://pragprog.com/titles/utj2/pragmatic-unit-testing-in-java-8-with-junit/">Pragmatic Unit Testing in Java 8 with JUnit</a></li><li><a href="https://enterprisecraftsmanship.com/posts/tdd-not-tdd/">To TDD or not to TDD</a></li><li><a href="https://mephilosophy.ccu.edu.tw/entry.php?entry_name=%E5%8D%A1%E7%88%BE%EF%BC%8E%E6%B3%A2%E6%9F%8F">卡爾．波柏（華文哲學百科）</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《美學：打開未知的美感體驗》</title>
      <link href="/nanay-2019-aesthetics-a-very-short-introduction/"/>
      <url>/nanay-2019-aesthetics-a-very-short-introduction/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這本書介紹了美學的定義，以及其與日常生活的關係。作者澄清，美學探討人們的美感體驗，而不是引發這些經驗的事物。因此，研究美學的價值在於提升我們的美感體驗。此外，他主張審美是運用注意力的獨特方式，而且深受個人經驗與文化背景影響。因此，在面對審美分歧或欣賞多元藝術時，要抱持「美學謙遜」的態度，了解彼此理解的侷限並努力化解個人與作品間的隔閡。</p><span id="more"></span><p>作者首先澄清，美學既不評論作品的優劣，也不判斷個人感受的對錯。美學研究人們如何感受美，聚焦那些我們珍視卻難以界定的美好經驗，而非引發這些經驗的事物。與藝術哲學不同，美學不探討藝術的定義以及其社會政治影響，它更著重人們體驗事物的心理與認知過程。</p><p>為了深入討論，作者提出三項核心概念：美學欣賞（接觸或關注美的行為）、美感體驗（欣賞過程產生的感受）與美學批判（欣賞對象的價值判斷）。然而，並非所有感受都屬於美學範疇。例如對高處的恐懼或是撿到錢的喜悅等便難以歸類為美感體驗。</p><p>值得留意的是，有些經驗與美感體驗的界線模糊。性愛、吸毒與聽搖滾樂同樣能帶來美好的感受，但它們與欣賞畫作時引發的情感有什麼不同？為了探討這個問題，作者梳理了四種傳統的美學觀點，並指出它們各自的優點與限制。</p><p>美學沙龍方式（beauty-salon approach）定義美感體驗為對美的事物的體驗，它排除了性愛、吸毒與搖滾樂等既不美也非由實物引發的體驗。這個觀點強調美學批判，但忽略了美感欣賞的情境要素。作品是否為美顯然受到觀眾的偏好、心情、知識與專注力影響，建立一個評斷美的統一標準似乎不切實際。為了補救這個限制，美學沙龍方式也演變出「美感體驗是體驗到事物為美」的觀點。這個變體雖然迴避了界定美醜的困境，卻欠缺能幫助我們感受美的操作性。</p><p>第二種觀點則著重在愉悅感，認為美感欣賞能帶來讓人沉浸其中的正向感受，因此它理應涵蓋性愛、毒品與搖滾樂等體驗。愉悅感觀點成功捕捉到人們在美感體驗裡的正向回饋，但它得面對區分美學與非美學愉悅的挑戰。</p><p>第三種觀點將美感體驗定義為能引起特定情感的體驗，而不僅僅是愉悅感而已。這個觀點與美學沙龍方式面臨相似的挑戰，它假設美學欣賞能引發普遍一致的情感體驗，也仰賴能區分美的標準。此外，有些作品確實能引發情感共鳴，但也存在純粹仰賴感官或是抽離而寧靜的美感體驗。</p><p>最後一種觀點主張美感體驗即是審美本身的體驗，強調美感欣賞的過程與其無目的性。這種觀點精確地描述了人們在美學欣賞時能自由觀察與聯想的特性，不過它忽略了某些講究目的性卻仍能帶來美感體驗的活動，像是看電影或是讀小說等能夠回應人們情感期待的藝術活動。</p><p>這四種傳統觀點雖然不夠全面，但仍點出了美感體驗能引發情感、令人沉浸其中與重視過程等特質。綜合這些觀點，作者提出一種新的美學理解，他主張美感體驗源於人們運用注意力的特定方式。人類的任何經驗都來自關注，只有被注意到的事物才會進入個人經驗。注意力的運用會影響美感體驗的品質。舉例來說，閱讀小說時，我們可能會因為不合理的設定而出戲，錯過了細膩的人物刻劃；也可能因為發現巧妙的伏筆，而對作品有全新的觀感。</p><p>此外，美感欣賞不只關注外在對象，也包括自身感受。以登山為例，吸引我們的不只是眼前的美景，還有登頂的期待與成就感。這種體驗建立在觀察自由的基礎上，它允許我們的注意力在不同對象間切換，發現它們之間的關係，感受作品與經驗的共鳴，從而激發驚喜與愉悅。一個被迫執行緊急任務的人，沒有選擇關注對象的權利，當下的感受也說不上是美學的了。</p><p>注意力的運用也深受個人經驗影響，不同的運用方式也會產生不同的美感體驗。重複曝光效應（mere exposure effect）是指我們的審美偏好會受到反覆出現的事物影響。由於家庭、社會與文化差異，每個人會暴露於不同的事物中，造就了獨特的個人經驗與審美品味。</p><p>審美品味是個人風格的體現，也形塑著自我認同。因此，對於同樣的作品產生不同看法是相當自然的現象。在歐美國家，美學批判因為認識論哲學的發展而受到重視，它的價值是創造客觀交流的基礎，但可能無助於化解審美分歧。</p><p>美感體驗是極度私人的經驗。一個人即使缺乏美學批判能力，也能擁有珍貴的美感體驗。相反地，再高明的美學批判，也無法保證所有人都能獲得同樣品質的感受。因此，美學是一門規範性的學問，它不會像倫理學一樣，提出能滿足道德目標的規範。如果接受這個觀點，那麼就不存在審美的對錯問題。作者認為，更重要的是透過改善注意力的運作方式來提升美感體驗。對作品的評論要能引導觀眾的注意力，突破他們的經驗侷限，發現作品值得欣賞的地方，從而豐富他們的體驗。</p><p>基於這種理解，作者提出了「美學謙遜」的概念。由於文化背景與個人經驗差異，我們很難完全站在創作者的角度去欣賞作品。因此，即使進行美學批判，也要意識到兩者之間的距離，審慎地做出判斷。儘管如此，如果能主動吸收背景資訊，可以幫助我們縮短與作品間的距離，從而提升獲得的美感體驗。這種態度適合欣賞來自不同文化或時代背景的作品，也是我們面對多元藝術的理想方式。</p><p>最後，作者描述了美學與日常生活的關係。他不贊同把生活視為藝術或是以抽離的態度觀察生活。作者認為美學在生活中的作用是當我們經歷美感體驗以後，這種情感會在我們內心盤繞，暫時改變我們看待事物的方式。這種新鮮感持續一陣子後，美感體驗逐漸融入我們的習慣，影響我們的注意力，直到我們再次經歷其他的美感體驗。這種循環，構成了我們平凡卻時而被美所治癒的日常。</p><hr><p>本斯．納內（2022）。美學：打開未知的美感體驗（蔡宜真譯）。（原著出版於 2019 年）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《秋季限定栗金飩事件》</title>
      <link href="/honobu-2009-shuki-gentei-kurikinton-jiken/"/>
      <url>/honobu-2009-shuki-gentei-kurikinton-jiken/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>小鳩與小佐內分手後，各自接受陌生同學的告白，展開新的校園生活。小佐內的交往對象是校刊社的新生瓜野，他認為校刊社的作風保守，所以提議在校刊報導校外題材。瓜野盯上了暑假發生的綁架事件，想藉此展現自己的能力，也期望小佐內能對其刮目相看。然而，因為顧慮小佐內，社長堂島起初拒絕了瓜野的提議。不過在小佐內穿針引線下，一名不起眼的社員以公益為由說服堂島，在校刊開設編輯專欄讓社員自由發揮。</p><span id="more"></span><p>面對期待已久的機會，瓜野卻苦無寫作題材。了解瓜野的煩惱後，他的朋友冰谷提供了瓜野數份火警報導。這些火警皆於周五深夜發生，且規模有逐漸擴大的趨勢。瓜野懷疑這是一起連續縱火案件，於是著手調查火災發生的模式。他發現，嫌犯似乎是依照市內防災區劃的順序挑選做案地點，因此在編輯專欄大膽預測下一次的火警發生地點。</p><p>由於瓜野屢次預測成功，所以讓原本乏人問津的校刊得到許多關注。瓜野想向小佐內炫耀自己的成就，但她卻表現得不感興趣的樣子，讓瓜野感到受到冷落。不過，小佐內雖然輕易接受告白，卻沒有怠慢這段關係。她為了顧及瓜野的自尊，所以總是背地裡幫忙瓜野，讓他得到報導的機會。因為擔心校刊社的預測會招致警方懷疑，所以小佐內一直隱諱地勸阻瓜野。</p><p>然而，瓜野卻誤會小佐內的態度為冷漠，而且也不願放棄到手的熱門題材，仍然繼續追蹤縱火案，直到學生指導處下令制止。指導處的老師認為捕風捉影的報導會招致懷疑，因此下令校刊社停止報導。因此，校刊社舉行編輯會議決定於下期校刊公布他們預測縱火地點的依據，以反駁他人的懷疑並證明自己的立場。</p><p>不過，學生指導部的負責人在校刊發行前調職，所以瓜野撤回原本的稿件，繼續報導縱火案的預測。這個自作主張的舉動引發社內衝突。其餘社員認為瓜野違反編輯會議的決定，還置校刊社於校規處分的風險之中。在聽了瓜野的解釋與對案件的推論後，堂島雖然不全然支持瓜野的主張，但認為在嫌犯被逮捕前，公布作案手段可能引發模仿，從而為校刊社惹來爭端。</p><p>會後，堂島以準備升學為由卸任，而其他不滿瓜野作風的社員也相繼退社。於是，瓜野如願繼任校刊社社長，也招募到數名新血，決定以追捕縱火犯為社團新學期的活動方針。小佐內對瓜野的企圖不以為然，想要勸他收手，但瓜野仍一意孤行。瓜野雖然當上了社長，也讓校刊社的名聲水漲船高，他卻始終認為被小佐內冷落。瓜野與小佐內見面時，克制不住內心衝動而向她索吻。瓜野強硬的舉動讓小佐內十分不滿，於是轉而開始規畫對瓜野的報復行動。</p><p>雖然堂島已經退社，不過他認為如果對嫌犯坐視不管，可能會讓校刊社陷入騎虎難下的局面，因此決定求助小鳩。小鳩這段期間則與女友仲丸過著想像中普通情侶的生活，例如周末出遊和討論時尚等。小鳩偶爾還會破例發揮他的推理能力來體貼仲丸，像是在壅擠的公車上找出即將騰出的空位等。</p><p>不過，他過人的推理能力也讓他難以享受相處的樂趣，他對女友分享的奇聞感到稀鬆平常，也常為女友無法與他共享破解謎團的樂趣而抱憾。最終，仲丸同學因為不滿小鳩對她出軌心無波瀾而提出分手，終結了這段關係。</p><p>在堂島求助小鳩前，小鳩已對縱火案產生興趣。他在其中一起縱火案的現場發現毀損的廂型車，那台車正好是綁架小佐內的車子。小鳩懷疑小佐內可能與此有關，於是接受了堂島的委託。聽了堂島轉述瓜野的推測後，小鳩認為他的假設不可信。小鳩查證防災規劃後，發現該資訊過時且與現今則屬不符，所以排除了嫌犯在災防體制內的假說。</p><p>小鳩推測嫌犯是基於校刊報導的地點縱火，並且認為嫌犯是瓜野的密友，才能在報導乏人問津的時候，就能依據其內容犯案。在打聽到小佐內與瓜野的關係後，小鳩一度懷疑小佐內涉案。因此，他委託堂島與其它校刊社員合作，透過操弄情報來鎖定嫌犯。</p><p>因為瓜野無心管理校刊的送印與發行，所以他們趁隙調整了的校刊內容，依據班級寫了不同的火點預測。於是，他們透過隔月的火警發生地點，鎖定了嫌犯所在的班級，從中打聽到涉有重嫌的冰谷，也排除了小佐內的嫌疑。在次月預期犯案的夜裡，小鳩與堂島埋伏在嫌犯預計出現的地方，準備與嫌犯正面對決。</p><p>不過嫌犯卻比預期早犯案。雖然無法阻止犯案，但小鳩仍努力阻止火勢延燒。小鳩在火場碰到同樣前來幫忙的小佐內，還有隨後緩緩來遲的瓜野。小佐內看見瓜野後，隨即跑離現場，來到附近的公園。瓜野追上小佐內，並且指控她為縱火者。瓜野解釋，小佐內行跡不僅與起火點重疊，而且總是欲言又止地阻止自己的舉動。</p><p>不過，小佐內反駁，瓜野的指控與證據不經推敲，而且同樣的理由也能用於懷疑瓜野。另外，瓜野也不知道，小佐內因為對瓜野索吻的舉動懷恨在心，所以刻意誤導瓜野懷疑自己。於是，小佐內放任瓜野繼續說明理由，讓他沉浸在指控他人的滿足中，直到最後才戳破他基礎不穩的推論，讓瓜野了解自己所掙得的威望，其實都有小佐內在背後操作的痕跡。小佐內嘲笑著瓜野的無能，徹底瓦解他的自尊，令其羞愧地不能自己而離去。</p><p>而在縱火現場附近的堂島，也順利追上縱火者，將其移送警方處理。縱火者的身分如小鳩推論，是瓜野的好友冰谷。他原先便常為了發洩煩悶的情緒而隨機縱火，不過在聽聞瓜野的野心後，十分看不起他那卑微的願望，於是在瓜野展示縱火案的推理後，投其所好地犯案，只為了看他被友人操弄卻仍自鳴得意的模樣。</p><p>小鳩與小佐內在公園重逢，談起彼此在新關係的挫敗。小佐內原想了解戀愛的感覺而接受瓜野的告白，卻因為對方不領情自己的努力而失望；小鳩雖然開心能過上正常情侶的生活，卻因為自己得出精巧推論時，沒有可以分享的對象而感到落寞。</p><p>他們害怕自己自視甚高的態度，所以用小市民的名義互相約束，也同時享受彼此的包容。然而這樣的心態卻與目標違背，所以他們才在去年夏天分開。然而，經過一年，他們終於意識到，想要避免他人反感並維持良好的社交關係，其實不需要違背自己本性去扮演平凡人，他們只需要能夠彼此理解與傾訴的對象。</p><p>意識到彼此為了辯護復合的合理性已經廢了過多唇舌，小佐內挖苦地說其他人只需一句告白就能解決的事，他們卻要迂迴地討論一陣子。於是，小鳩如同表白般，向小佐內說她是自己不可或缺的存在。就這樣，在言不及義與顧及自尊的語句中，兩人總算恢復關係。<br><br/><br>這集的推理比前兩集更有張力，連續縱火案的調查縱貫全書，除了校刊社的調查外，也有小鳩的調查路線，中間還故佈疑陣讓小佐內也成為嫌疑人，最後才在火場前讓各方人馬集結，一次揭發真相。我也很佩服作者安排情節的細膩，每個角色的性格與做事風格相符，也都構成犯案與破案的要素。角色在各個場景的行為都有合理動機，不會讓他們成為完成推理與謎團的機關。</p><p>例如小佐內的行跡雖然與火場相符，但她的做事風格卻不該如此粗糙，所以形成作品的懸念。相反地，從書本開頭，冰谷就淡淡表現出對瓜野的不屑，而他也順利讓校刊社的預言成了一場笑話。至於瓜野的自負不僅讓他錯過小佐內的勸告，也因為這種不在乎瑣事的個性，讓小鳩等人得以借重其他社員對校刊動手腳，達到操弄情報的目的。</p><p>在描述小鳩情侶生活時穿插的兩則日常推理也很有趣。有次，小鳩和仲丸出遊時，在公車上看到有人誤觸下車鈴，卻不確定是座席上何人做的。他想要為仲丸找個座位，於是開始推論座席上一老一少何者會先下車。因為兩人的神情與儀態無法區分誰會先起身，所以小鳩是從掏零錢的舉動才看出端倪。兩人都有優惠票，但是票券只在木良市生效，所以掏錢的人應該會在市外才下車，從而推理出先下車的人。</p><p>另一起事件則是仲丸同學的趣談（雖然小鳩覺得一點也不有趣）。她說她有個熱愛重金屬的哥哥在出遊期間遭闖空門，卻沒有財物損失。令人訝異的是，他還在隔天碰到那名小偷。小鳩還沒聽完，就已推論出事情全貌，他想仲丸的哥哥因為粗心大意忘了關音樂，而鄰居忍受不了噪音，卻聯絡不上住戶，只好破門而入。</p><p>因為我也被鄰居吵鬧過，每天也在車上期待空位，所以對這些小故事特別有共鳴，還讓人覺得也許推理另一個魅力就在於，讓人想要更加努力去觀察周邊的世界吧，起碼我自己就躍躍欲試想找到下個空位了。</p><p>在這集，小鳩與小佐內的關係仍是重要的主線。在夏季篇，米澤用棉花糖比喻兩人自視甚高，卻虛偽地裝成小市民的自覺。而這集，則把他們各自尋找新交往對象的舉動描述為糖漬栗子。栗子本身帶有一定的澀味，為了去除它，有兩種做法。第一種是利用層層糖漿果覆，讓糖分滲入栗子中，直到整顆都充滿甜滋滋的口味。</p><h2 id="仲丸和瓜野就是他們的糖，被兩人期待能去除自己人生中的澀味，但即使他們努力了，仍然沒達到預期的效果。他們沒辦法違背自己本性去過常人的生活，壓抑自己的喜好終究會造成反彈，所以最後他們決定複合。不過，儘管他們一直為情感的決定找理由，但實際上卻未必需要那麼多解釋，但這也是他們關係獨特且讓彼此覺得自在的地方吧。"><a href="#仲丸和瓜野就是他們的糖，被兩人期待能去除自己人生中的澀味，但即使他們努力了，仍然沒達到預期的效果。他們沒辦法違背自己本性去過常人的生活，壓抑自己的喜好終究會造成反彈，所以最後他們決定複合。不過，儘管他們一直為情感的決定找理由，但實際上卻未必需要那麼多解釋，但這也是他們關係獨特且讓彼此覺得自在的地方吧。" class="headerlink" title="仲丸和瓜野就是他們的糖，被兩人期待能去除自己人生中的澀味，但即使他們努力了，仍然沒達到預期的效果。他們沒辦法違背自己本性去過常人的生活，壓抑自己的喜好終究會造成反彈，所以最後他們決定複合。不過，儘管他們一直為情感的決定找理由，但實際上卻未必需要那麼多解釋，但這也是他們關係獨特且讓彼此覺得自在的地方吧。"></a>仲丸和瓜野就是他們的糖，被兩人期待能去除自己人生中的澀味，但即使他們努力了，仍然沒達到預期的效果。他們沒辦法違背自己本性去過常人的生活，壓抑自己的喜好終究會造成反彈，所以最後他們決定複合。不過，儘管他們一直為情感的決定找理由，但實際上卻未必需要那麼多解釋，但這也是他們關係獨特且讓彼此覺得自在的地方吧。</h2><p>米澤穗信（2022）。秋季限定栗金飩事件（上）（HANA譯）。尖端出版（原著出版於 2009 年）<br>米澤穗信（2022）。秋季限定栗金飩事件（下）（HANA譯）。尖端出版（原著出版於 2009 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mystery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夏季限定熱帶水果百匯事件》</title>
      <link href="/honobu-2006-kaki-gentei-toropikaru-pafe-jiken/"/>
      <url>/honobu-2006-kaki-gentei-toropikaru-pafe-jiken/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>草莓塔事件的一年後，小鳩和小佐內仍然維持著他們理想中小市民應有的生活，一人壓抑著揭穿祕密的嗜好，一人克制追求復仇的欲望，約束彼此多管閒事和挾怨報復的衝動。小鳩一直認為他與小佐內只是互利共生的關係，因此私底下不會有過多的互動。然而，這個夏天，小佐內反常地頻頻邀約，讓小鳩對於她的動機困惑不已。</p><span id="more"></span><p>暑假的第一天，小佐內主動拜訪小鳩，送給他一張標註了木良市知名甜點店的地圖。她神祕地表示，有項計畫無論如何都需要小鳩的協助，而且這項計劃的成敗將決定了她今夏的命運。儘管對此一頭霧水，小鳩仍答應了小佐內的邀約。隔天，小佐內臨時改變計畫，委託小鳩幫忙外帶甜點到她家。小鳩出於挑戰小佐內的心態，趁她接聽電話的時候偷吃了一塊蛋糕，再把現場恢復原狀。不過小佐內輕易識破小鳩的小伎倆。作為懲罰，她要求小鳩在這個夏天陪她拜訪清單上的每一家店。</p><p>於是，小鳩開始跟著小佐內探訪木良市的甜點店。不過，小佐內時不時做出出人意表的舉動，讓小鳩十分好奇她的真實動機。有次，小佐內不直接告知集合地點，反而提出謎題讓他猜測。小鳩順利破解謎題，在集合處附近的速食店休息時巧遇堂島。他向小鳩透漏，自己應女友請託調查她姊姊川俁涉入的藥物濫用組織。儘管小鳩無意介入，堂島離開前仍匆匆留下一張寫有「半」的紙條，囑咐他若有任何發現便聯絡他。正當小鳩苦思紙條含意時，意外撞見喬裝後的小佐內。小鳩向小佐內解釋謎題時，小佐內雖然面露猶豫，卻沒有阻止他，反而在旁協助。當小鳩成功解讀紙條含意時，破解紙條的涵義時，小佐內甚至雀躍地要請他吃點心。</p><p>不久，堂島約小鳩見面以更新調查進度。堂島說他總算聯絡到川俁，但對方因為不信任堂島而且畏懼主謀石和而不願脫身。小鳩雖然能體諒堂島的困境，可是也不願過度涉入他的行動。當晚，小佐內反常地來電，叮嚀小鳩明天要在她家集合一起去吃甜點，還特別強調這次會為這個夏天做個圓滿的總結，顯得格外重視這次約會。</p><p>然而，到了隔天約定的時間，小佐內卻不見蹤影。在小佐內家等候的小鳩從她母親得知一則震驚的消息：小佐內被綁架了，綁匪還索要五百萬贖金。儘管小鳩不願意承認，但他不禁湧起一股陰暗的興奮感，期待這起事件能從單調乏味的日子解救他。不過，因為小佐內的母親已經報警，他其實沒有插手餘地。正當他準備放棄時，卻收到小佐內傳來的求救訊息，內容表面上是要求小鳩幫忙購買指定數量的甜點，實際上則暗示著她與各家甜點店的相對位置。</p><p>考量到在現場可能發生衝突的風險，也不想在他人面前暴露自己的推理能力，小鳩不得不再次求助堂島。他們按照訊息的提示，追蹤小佐內刻意留下的糖果包裝紙，來到綁匪的據點。在確認小佐內的位置後，他們立即報警協助。小佐內瞥見前來營救的他們，也虛張聲勢爭取時間。眼見綁匪即將對小佐內下手，小鳩與堂島闖進現場阻止對方，而隨後趕到的警方也順利將整個犯罪組織一網打盡。<br><br/><br>在事件平息後，小鳩與小佐內相約甜點店，一起品嘗她期待已久的夏日限定熱帶水果百匯。小鳩開始梳理整起事件的疑點，但是小佐內卻對此不感興趣，總是顧左右而言他。為什麼小佐內要邀請自己出遊？為什麼綁架小佐內的主謀恰好是堂島追查的對象？為什麼總是喬裝自己的小佐內在綁架當天卻一反常態？經過縝密的分析，小鳩推測小佐內早已預料到自己會被綁架，於是策畫了甜點店巡禮，讓小鳩熟悉木良市地圖，才能在事發時第一時間解讀謎題救出自己。這項推論解釋了為什麼小佐內總是用謎題指示集合地點，為什麼她樂見小鳩解讀堂島的地圖謎題，也解釋了為什麼她很高興看到小鳩記住地圖上的店家。</p><p>小佐內坦承她曾與主謀有過節，所以才會未雨綢繆。然而，小鳩不解小佐內為什麼不願意坦白求助。對此，小佐內解釋她雖然需要幫助，卻不願意見到小鳩因介入而受傷，才會採取隱晦的方式求援。說明原委後，她暗示小鳩別再細究此事，但小鳩顯然不願善罷甘休。</p><p>小鳩認為小佐內的行為仍有令人費解的之處。首先，為什麼小佐內在脫困後，非但沒有表現應有的憤怒或不平，反而顯得異常雀躍。另外，為什麼小佐內能精準掌握綁架的時間與地點，還能在事發當下一字不誤地送出求救訊息？基於對小佐內個性的理解，小鳩認為她在幕後策劃了整起綁架案。她利用潛伏在對方組織的內應，煽動對方綁架自己而涉入重案，從而達到報復對方的目的。</p><p>面對小鳩的懷疑，小佐內也不再偽裝，向他吐露事件的始末，她不只利用內應煽動犯罪，還誘使內應撥打勒贖電話，讓他們罪加一等。小佐內解釋，她這麼做是為了自保，讓對方不再有機會威脅自己。然而，小鳩得知真相後，卻對小佐內濫用能力的行為感到不以為然。他指控小佐內不僅誣陷他人，還利用了關心她安危的自己，這些舉動完全違背他們彼此的約定。</p><p>小佐內對此指控感到心寒，她反駁說小鳩在揭發秘密時同樣難掩興奮，因此沒有資格指責自己。小佐內也不滿小鳩毫不體諒的態度，提到她們的關係實際上也是一場謊言，因為彼此都不願割捨自己陰暗的喜好。小佐內認為，即使自己如此坦白，小鳩恐怕也無法感同身受。因此，她提議結束這段沒意義又虛偽的關係。</p><p>不過，小佐內隨即又提出另一種折衷方案，他們可以繼續相處，但不再堅持成為小市民，私下分享高人一等的感受。然而，小鳩卻認為他們關係的基礎是雙方對平靜生活的渴望，所以不認同小佐內的想法。</p><p>小佐內原本期待自己提議分手後，小鳩的回應中會有更多情感波動，但是他只顧著堅持原則與分析利弊，絲毫沒有顧慮她的情感需求。最後，小鳩平靜地接受分手提議。小佐內含著淚道歉，並且表示她其實很享受與小鳩相處的時光，隨即轉身離開，留下困惑不已的小鳩，獨自嚐著甜膩得無法下嚥的水果百匯。<br><br/><br>在讀完《夏季限定熱帶水果百匯事件》之後，回顧第一集才發現，米澤穂信早在小鳩與小佐內涉入的第一起事件中，就鋪陳了兩人對彼此關係的認知落差。在斜背包竊案的最後，嫌犯高田同學向他們坦白，他為了取回投入被害者背包的情書才會冒險犯案。情緒崩潰的高田質問表面為情侶的兩人，能否體諒他出於愛意的彆扭行為。他們當下並未回應，不過小佐內卻在兩人共進甜點時主動提到此事。小鳩坦白自己對高田同學的心情毫不在意，也無法了解什麼戀愛關係。這時，小佐內猶豫了一下，才勉強附和小鳩的觀點。</p><p>第二集延續他們對彼此關係的認知落差，還發展成這集的核心謎題。小鳩始終認為小佐內的邀約別有用心，基於這項假設，他成功推敲出這起綁架事件不只是小佐內自保的手段，也是她復仇的一環。對小鳩而言，小佐內在相處過程中的所有愉快表現都支持他的推論。然而，在故事結尾，小佐內在臨走前卻表示自己很享受與小鳩相處的時光。</p><p>這讓我回想起以前讀過的劇本寫作書，推理或懸疑小說其中一個魅力在於，它們利用同一份文本講述了兩個截然不同的故事。在這本書中，小鳩的推理成功解釋了小佐內的復仇，但是從我們讀者的角度，它和從不是個苦澀的青春故事？</p><hr><p>米澤穂信（2022）。夏季限定熱帶水果百匯事件（HANA譯）。尖端出版。（原著出版於 2006 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mystery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Edit Distance (EDIT)</title>
      <link href="/edit-distance/"/>
      <url>/edit-distance/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定兩條以 FASTA 格式儲存的蛋白質字串，計算兩者互相轉換所需的最少編輯次數。編輯方式包含置換、刪除與插入。</p><blockquote><p>Given: Two protein strings s and t in FASTA format (each of length at most 1000 aa).</p><p>Return: The edit distance d(s,t).</p></blockquote><p>(<a href="https://rosalind.info/problems/edit/">https://rosalind.info/problems/edit/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>在先前的 Rosalind 練習題，我已經陸續介紹兩種評估序列差異的方式，它們各自反映了特定的基因體變化，因此可用於推論親緣關係或演化途徑。</p><ul><li><a href="https://5uperb0y.com/counting-point-mutations/">Hamming distance</a>：兩等長序列彼此轉換所需的鹼基置換次數</li><li><a href="https://5uperb0y.com/reversal-distance/">reversal distance</a>：兩序列彼此轉換所需的子序列反轉次數</li></ul><p>這一題在置換（substitution）的基礎上，額外納入插入（insertion）與刪除（deletion）兩種點突變類型，將 Hamming distance 推廣為編輯距離（edit distance，字串互相轉換所需的編輯次數），以適用於長度不等的序列。</p><p>由於引進了新的突變類型，計算距離時也要考慮不同突變類別的權重。舉例來說，插入或刪除鹼基可能導致 readframe 移位，所以它們對基因體的影響可能比置換更為顯著。不過，這道題目只考慮最簡單的狀況，即所有突變類型對編輯距離的權重一致。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>假設有兩個蛋白質字串 $S$ 與 $T$，兩者之間的最短編輯距離記為 $d(S,T)$。原則上，$S$ 和 $T$ 的長度越長，$d(S,T)$ 的上限也越高。為了評估延長這兩個字串對編輯距離的影響，可以由後往前，逐一比較各自的最後一位字符 $s$ 和 $t$，將字串重新表示為 $S&#x3D;S_{sub}+s$ 與 $T&#x3D;T_{sub}+t$。</p><p>如果 $s$ 與 $t$ 相同，表示添加它們不會增加編輯距離，所以 $d(S,T)&#x3D;d(S_{sub},T_{sub})$。</p><p>如果 $s$ 與 $t$ 相異，則有三種可能的編輯方式，每種方式都會讓編輯距離增加 1。</p><ul><li>把 $s$ 置換為 $t$，所以 $d(S,T)&#x3D;d(S_{sub},T_{sub}) + 1$</li><li>從 $S$ 刪除 $s$（或在 $T_{sub}$ 末端插入 $t$），所以 $d(S,T)&#x3D;d(S_{sub}, T_{sub} + t) + 1$</li><li>從 $T$ 刪除 $t$（或在 $S_{sub}$ 末端插入 $s$），所以 $d(S,T)&#x3D;d(S_{sub} + s, T_{sub}) + 1$</li></ul><p>每次延長字串時，我們都選擇增加最少編輯距離的方式，最終可得 $d(S,T)$。</p><h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>我使用 <code>dist</code> 儲存 $S$ 和 $T$ 各個子字串的編輯距離。<code>dist</code> 是一個雙層嵌套的 list，它的大小比兩個字串的長度多 1，以包含空字串的狀況。</p><p>由於空字串只能透過插入轉換為其它字串，所以 <code>dist</code> 的第 0 列和第 0 欄被設定為各子串的長度，其餘元素則初始化為 0，表示未知的編輯距離。</p><p>接著，由上至下，由左至右遍歷 <code>dist</code>，比較兩個子字串的最後一位字符，依據前述關係判斷當前的最小編輯距離。最終，<code>dist</code> 右下角的元素即為兩個完整字串的最小編輯距離。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">S, T</span>):</span><br><span class="line">    <span class="comment"># The edit distance between S&#x27;s and T&#x27;s substrings</span></span><br><span class="line">    dist = [</span><br><span class="line">        [<span class="number">0</span>] * (<span class="built_in">len</span>(T) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S) + <span class="number">1</span>)</span><br><span class="line">        ]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(S) + <span class="number">1</span>):</span><br><span class="line">        dist[s][<span class="number">0</span>] = s</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(T) + <span class="number">1</span>):</span><br><span class="line">        dist[<span class="number">0</span>][t] = t</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line">            <span class="keyword">if</span> S[s] == T[t]:</span><br><span class="line">                dist[s + <span class="number">1</span>][t + <span class="number">1</span>] = dist[s][t]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dist[s + <span class="number">1</span>][t + <span class="number">1</span>] = <span class="built_in">min</span>(dist[s][t], dist[s + <span class="number">1</span>][t], dist[s][t + <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dist[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>運用 VSCode snippets 管理並活用個人寫作語料庫</title>
      <link href="/manage-your-writing-corpus-with-vs-code-user-snippets/"/>
      <url>/manage-your-writing-corpus-with-vs-code-user-snippets/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>學習寫作的一個有效方法是透過閱讀優秀作品，並細心記錄值得借鑒的用字與段落，進而運用在自己的作品中。市面上已經有場景辭典或詞彙工具書幫我們分類詞條，但是自建語料庫能按照習慣規劃，更符合個人需求。</p><p>然而，無論是使用現成的還是自建的語料庫，查閱過程往往會打斷寫作節奏，降低其實用性。那麼，要如何管理這些精心收集的語料，才能及時更新又方便取用呢？這篇文章將介紹如何使用 VSCode snippets 的提示與管理功能，將語料庫的應用整合到 markdown 文檔的寫作流程中。</p><span id="more"></span><p>VSCode snippets 原本用於管理常用程式碼片段，它允許用戶透過關鍵字快速查詢和插入這些片段。憑藉這些特性，再稍加調整後，VSCode snippets 同樣能用來管理寫作的常用詞條，幫助我們推敲用字與學習新詞彙。</p><h1 id="VSCode-snippets-使用教學"><a href="#VSCode-snippets-使用教學" class="headerlink" title="VSCode snippets 使用教學"></a>VSCode snippets 使用教學</h1><h2 id="啟用-VSCode-markdown-snippets"><a href="#啟用-VSCode-markdown-snippets" class="headerlink" title="啟用 VSCode markdown snippets"></a>啟用 VSCode markdown snippets</h2><p>由於 markdown snippets 功能預設為關閉狀態，所以需要編輯設置檔來啟用它。</p><ol><li>按下 <code>Ctrl</code> + <code>Shift</code> + <code>p</code> 打開指令列</li><li>查詢 “Preferences: Open Settings (JSON)” 並開啟 <code>setting.json</code></li><li>在 <code>setting.json</code> 添加以下設置<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="參考[[踩雷紀錄] Vscode markdown snippets 無作用](https://bingdoal.github.io/others/2021/12/markdown-snippets-not-working-in-vscode/)">1</span></a></sup>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// markdonw snippets activation</span></span><br><span class="line">  <span class="attr">&quot;[markdown]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;editor.quickSuggestions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li>儲存並離開</li></ol><h2 id="編輯-user-snippets"><a href="#編輯-user-snippets" class="headerlink" title="編輯 user snippets"></a>編輯 user snippets</h2><ol><li>依序點選 “File”、”Preferences”、”Configure User Snippets”</li><li>在彈出的選單中選擇 “markdown.json”<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這裡介紹的是編輯 global snippets 的方式。VSCode 也提供用戶依照專案資料夾調整 snippets 的彈性，所以可以為不同文章類型準備各自的語料庫，詳見官方說明：[Snippets in Visual Studio Code](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_project-snippet-scope)">2</span></a></sup></li><li><code>markdown.json</code> 使用以下格式記錄用戶的 snippets<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">&quot;[提示文字]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[觸發文字]&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[詞條主體]&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;[詞條描述]&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>提示文字（key）：顯示於建議用字選單右側，概述詞條內容</li><li>觸發文字（prefix）：輸入後，VSCode 會在它的右下方顯示相符的建議用字選單</li><li>詞條主體（body）：將插入的實際詞條內容</li><li>詞條描述（description）：詞條的補充說明，不會出現在建議用自選單中</li></ul></li></ol><h2 id="使用個人語料庫"><a href="#使用個人語料庫" class="headerlink" title="使用個人語料庫"></a>使用個人語料庫</h2><p>在啟用提示功能和添加個人語料後，即可在 markdown 文檔使用個人語料庫。以下範例使用器官來分類詞彙<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="範例取自於《如何捷進寫作詞彙》（黃淑貞。2023。商周出版）">3</span></a></sup>，只要輸入 “@鼻”，VSCode 就會自動建議相關用字。因為 user snippets 支援模糊搜索，即使輸入不完整，也能提示部分匹配的詞條。</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/thesaurus/main/demo.png"></p><p>這個示範使用以下的設置檔。為了提升建議選單的可讀性，我把詞條、類別與解釋三種資訊並列於 “prefix”，並在每個 “prefix” 前添加特殊符號，確保提示功能只在必要時被觸發。另外，我也省略了不會顯示的 “description” 以節省篇幅。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// markdown.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;秀挺&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@鼻  秀挺：秀麗高挺&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;秀挺&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;高峙&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@鼻  高峙：高挺&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高峙&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;齊勻高整&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@鼻  齊勻高整：形容鼻樑勻稱高挺&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;齊勻高整&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="改善個人語料庫的管理方式"><a href="#改善個人語料庫的管理方式" class="headerlink" title="改善個人語料庫的管理方式"></a>改善個人語料庫的管理方式</h1><p>收集到的詞條可以使用 <a href="https://snippet-generator.app/?description=&tabtrigger=&snippet=&mode=vscode">snippet generator</a> 轉換為 JSON 格式，再添加到 <code>markdown.json</code> 當中。不過這個流程較為繁瑣，<code>markdown.json</code> 本身也不易瀏覽與操作。因此，我打算從以下幾個方向改善語料庫的管理方式。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這裡提到的程式碼與表格可到我的 [Github](https://github.com/5uperb0y/corpus) 查看。">4</span></a></sup></p><h2 id="改以表格紀錄個人語料庫"><a href="#改以表格紀錄個人語料庫" class="headerlink" title="改以表格紀錄個人語料庫"></a>改以表格紀錄個人語料庫</h2><p>相較於 JSON 格式，純文字表格更容易閱讀與維護。畢竟，表格既能以 Git 進行版本控管，還相容於 Excel&#x2F;Google sheet 等試算表工具。</p><p>我採用 TSV 格式儲存語料，把資訊分為觸發符號、類別、詞彙與解釋四欄。觸發符號除了防止誤用以外，也能用來篩選詞條。例如 “@” 表示詞彙，而”~”表示片語，以此區分不同語料性質。類別則參考《如何捷進寫作詞彙》和《場景設定創意辭海》的架構，但內容會由我自己補充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#觸發符號類別詞彙解釋</span><br><span class="line">@鼻秀挺秀麗高挺</span><br><span class="line">@鼻高峙高挺</span><br></pre></td></tr></table></figure><h2 id="使用程式把表格轉換為-JSON-格式"><a href="#使用程式把表格轉換為-JSON-格式" class="headerlink" title="使用程式把表格轉換為 JSON 格式"></a>使用程式把表格轉換為 JSON 格式</h2><p>由於表格需要額外轉檔才能符合 VSCode snippet 的格式要求，我寫了一個腳本。它能夠逐列切割表格，重新組合各欄元素，填入 JSON 檔中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">grep <span class="string">&quot;^[^#]&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="keyword">while</span> IFS=$<span class="string">&#x27;\t&#x27;</span> <span class="built_in">read</span> -r trigger category word explanation</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">  &quot;$word&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;prefix&quot;: &quot;$trigger$category  $word：$explanation&quot;,</span></span><br><span class="line"><span class="string">    &quot;body&quot;: &quot;$word&quot;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="用-Git-Hook-實現流程自動化"><a href="#用-Git-Hook-實現流程自動化" class="headerlink" title="用 Git Hook 實現流程自動化"></a>用 Git Hook 實現流程自動化</h2><p>為了減輕格式轉換的負擔，可以在專案資料夾新增 <code>.git/hook/pre-commit</code><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="git hook 的自動化教學可參考[官方文件](https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks)">5</span></a></sup>，讓程式在每次 commit 前，自動生成 VSCode snippet 要求的 JSON 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./snippet_generator.sh corpus.tsv &gt; corpus.json</span><br></pre></td></tr></table></figure><p>接著，為 <code>corpus.json</code> 建立軟連結，取代 VSCode 預設的 snippet 設置檔。如此一來，就能即時套用語料庫的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/corpus.json /path/to/markdown.json</span><br></pre></td></tr></table></figure><h1 id="結論：閱讀、紀錄、寫作、潤稿"><a href="#結論：閱讀、紀錄、寫作、潤稿" class="headerlink" title="結論：閱讀、紀錄、寫作、潤稿"></a>結論：閱讀、紀錄、寫作、潤稿</h1><p>綜上所述，應用 VSCode snippets 提供的自動補全、建議選單以及詞條管理等功能，能夠降低管理與應用語料庫的成本，讓學習、紀錄與運用等過程更加緊密連結。理想的使用情境是在閱讀後，記錄值得值得的詞條與段落，並在撰寫文章時加以利用。透過定期回顧與編修語料庫，能逐步精煉其內容，讓它更符合個人所需。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">參考<a href="https://bingdoal.github.io/others/2021/12/markdown-snippets-not-working-in-vscode/">[踩雷紀錄] Vscode markdown snippets 無作用</a><a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這裡介紹的是編輯 global snippets 的方式。VSCode 也提供用戶依照專案資料夾調整 snippets 的彈性，所以可以為不同文章類型準備各自的語料庫，詳見官方說明：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_project-snippet-scope">Snippets in Visual Studio Code</a><a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">範例取自於《如何捷進寫作詞彙》（黃淑貞。2023。商周出版）<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這裡提到的程式碼與表格可到我的 <a href="https://github.com/5uperb0y/corpus">Github</a> 查看。<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">git hook 的自動化教學可參考<a href="https://git-scm.com/book/zh-tw/v2/Customizing-Git-Git-Hooks">官方文件</a><a href="#fnref:5" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《無法成為神明的少女》</title>
      <link href="/iruma-2017-kitto-kanojo-wa-kamisama-nanka-janai/"/>
      <url>/iruma-2017-kitto-kanojo-wa-kamisama-nanka-janai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>熱愛大海的異鄉少女八代，因為食物短缺而與家人各奔東西，不得不滯留在一個熱愛大地的部落。因為她與部落文化格格不入，所以只能自食其力。一日，部落的長老召喚八代，希望她能前往神之岩向神明求援，幫助他們對抗來自東方部族的威脅。神之岩位於部落外圍的海洋深處，據傳是部落守護神的住所。據目擊者描述，神之岩會發射光束摧毀任何靠近它的物體，所以八代深知此行必死無疑。然而，如果她拒絕這項命令，同樣會遭到其他敵視她的部族成員放逐。</p><span id="more"></span><p>因此，儘管她心知肚明長老想除己後快的企圖，仍認命地持著唯一能保護自己的石槍躍入海中。她緊靠著一頭巨蛇的身側，奮力抵抗洋流，朝神之岩前進。當神之岩感應到逼近的巨蛇，並且發出的光束擊中牠時，躲在巨蛇身後的八代幸運躲過一劫，得以趁隙游向神之岩。當她伸手觸摸它的表面時，一股強勁的力量將她吸入其中，跌落在神之岩的內部空間。</p><p>神之岩的內部與八代所熟悉的原始部落截然不同，這裡由堅固的金屬打造，格局整齊劃一，還有許多用途不明的空間與裝置。因為誤觸機關，八代被電梯帶到神之岩的更深處。她在那裡撞見一名沉睡在管狀水箱中的女性。這名女性身材高大、衣著精緻，所以八代推測她就是傳聞中的「神明」</p><p>於此同時，被光束激怒的海蛇折返回來，猛烈衝撞年久失修的神之岩。八代感受到劇烈震動，聽見海水不斷滲入的聲響。眼見情況緊急，八代打破水箱將女子喚醒。她們簡單交換資訊後，八代發現這名女子對現況一無所知，甚至沒有體力單獨行走，絲毫沒有神明的架式與威嚴。然而，八代仍需要女子的指示來逃生，於是揹著她來到疑似機房的區域。</p><p>不過，因為電力中斷，她們無法啟動逃生門，只能強行破門而出。兩人趕在海蛇扯碎神之岩之前，撞開艙門逃出。不諳水性的女子在激流湧入後失去意識。八代試圖拉著女子的手前進，卻感到格外費力。八代心急如焚地奮力游動，一度萌生獨自逃生的念頭。不過，她最終還是放下為了自保而攜帶的石槍，雙手緊抱女子，逆著洶湧的水流游向灑滿陽光的海面。</p><p>謎樣的女子被帶回部落後，被長老與其他族人奉為上賓，不僅獲得在最高級的住處，也享有美食佳餚。然而，八代對此卻不以為然。她堅信人生在世唯有自己能夠依靠，在親眼目睹女子軟弱無能的模樣後，更不相信對方是能解救部落免於外敵侵擾的神明。儘管八代對女子不感興趣，而且因為身分敏感被要求與之保持距離。可是，女子卻要求與八代見面，希望她能帶著自己參觀部落。對於成為神明嚮導一事，八代感到匪夷所思。不過，即使八代追問，也只得到女子「覺得她很可愛」這樣含糊不明（卻又莫名令人暗自欣喜）的回答。</p><p>瞞著其他族人，女子溜出來與八代見面，跟著她前往部落邊境換哨。途經平原、樹林、草叢，她們細細談起那天在神之岩來不及說的話題。八代來自西方，因為糧食匱乏而與家人分散，獨自留在這個部落中。不過八代始終沒有融入部落生活，她銀色的頭髮與眾不同，對大海的熱情也不被接納。因此，八代只能自食其力，抱著隨時可能喪命的覺悟，用她的石槍在這弱肉強食的世界掙扎生存。</p><p>來自水底的女子名喚芽衣。相較於八代對群體的疏離，芽衣則表現出對時空的陌生感。她在水底沉睡的時間長到一切熟悉的事物都已消逝，而今面對原始的生活，她感到無所適從。芽衣雖然身材高挑、線條優美，可是體力不佳，也欠缺在荒野生存的知識與覺悟。</p><p>儘管如此，芽衣卻掌握許多關於遠古文明的先進知識。例如，從芽衣口中，八代才知道自己心心念念的大海，實際上只是一座湖泊。回程途中，她們經過這座湖泊，並且應芽衣的要求在此稍作停歇。似乎受到芽衣逐漸放鬆的心情感染，八代也放下了警惕，卸下石矛，任由自己泡在清涼的水中，和芽衣閒聊嬉戲。</p><p>她們的話題從彼此的身材特徵延伸到未來的規劃。對八代而言，在部落的生活無非是為生存而不斷努力，採集、獵捕、警戒等日常活動就已經全部費盡精力。芽衣聽聞後，露出一絲失落的神情，這不禁讓八代懷疑救出對方的決定。然而，芽衣卻懇求八代別這麼想。望著芽衣故作開朗的笑容，八代感受到一種不曾在家族或部落體會過的情感，她再度想起芽衣描述的大海，第一次萌生了在單調乏味的日子外，嘗試做些什麼的渴望。</p><p>不久之後，八代與族人為了採集供奉芽衣的果實，深入中央森林地區，卻在那裏遭遇兩名東方部族的成員。東方部族的身體結構與常人迥異，他們體格魁梧、肌肉發達，行進時四足並用，還能操作類似神之岩的光束武器。通常，一名東方部族人能輕易對付數個普通人，但錯綜複雜的叢林地形削弱了體格優勢。</p><p>因此，雖然八代極力勸阻，卻制止不了認為機不可失的同伴。所幸，當他們發動突襲時，其中一個敵人拋下同伴逃跑，這讓八代等人充分利用人數優勢擊敗對方。八代原以為自己提著敵人首級回到部落時，會贏得族人的歡呼與致意。沒想到，前來迎接的芽衣一看到那顆頭顱就昏厥倒地。眾人連忙圍繞在芽衣身邊，無人理會奮力舉起頭顱的八代。八代放下頭顱，走近芽衣，聽到她喃喃自語某個人的名字。</p><p>芽衣目睹熟人遇害之後，陷入嚴重的低潮。八代為了表達歉意——更多是出於關心（又或許還帶著一絲擔憂？），製作了一把石刃要送給芽衣。考慮到東方部族的威脅，八代希望芽衣在自己不在她身邊時，至少要有自保的能力。雖然一碰面芽衣便指責八代為殺人犯，但芽衣也自知非常情況下這些指控站不住腳，於是向八代道歉後，再次請求她的幫忙。</p><p>如同八代所推論，芽衣確實與東方部族有某種關聯。她要求八代帶她前往東方部族出沒的地點，卻被八代以太過危險為由拒絕了。芽衣轉而希望八代能帶著她出去散心，揮別陰鬱的情緒。於是，八代邀請芽衣到崖上野餐。在度過一段輕鬆愉快的用餐時光後，八代表示，雖然不能讓芽衣直接接觸東方部族，但可以帶著她參觀一座位於洞窟深處，被東方部族棄置的遺址。部落周圍有不少類似的遺址，不過其它較為完整的遺址似乎仍有東方部族活動的跡象。</p><p>在幽暗的洞窟中，她們扶著牆摸黑前進。八代因為擔憂芽衣的安危而出言提醒，卻引來一番調侃。八代對芽衣不以為意的態度十分不快，於是兩人陷入沉默。一路上，八代顯得心煩意亂，困惑於自己對芽衣日漸增長的在意。明明出自於關心，卻因為對方回應不如預期而動怒。八代承受不住尷尬氣氛與複雜情緒，突然擁抱了芽衣。驚訝的芽衣也在放鬆下來後回抱了八代。兩人在黑暗中感受彼此的溫度、溫柔的觸感還有髮絲輕拂帶來的微妙搔癢，逐漸化解了彼此的隔閡，繼續向洞窟深處前進。</p><p>儘管被稱為遺跡，這些古老建物的形象卻與芽衣久遠的記憶吻合，使得芽衣更加疑惑自己身處何處。隨後，為了讓芽衣開心，八代帶著她到另一個洞穴，欣賞發光昆蟲佈滿岩壁的壯觀景象，宛如在地底撐起的一片星空。目睹這幕景象的芽衣，腦中湧現一個想法。在回程時，八代把自己製作的短刀交給芽衣，而芽衣則與八代約定入夜後在崖邊見面，她打算確認自己對現況的猜想。</p><p>夜裡，兩人再度相聚。芽衣仰臥在地凝望星空，梳理至今目睹的種種現象，試圖推論它們與自身命運的關聯：</p><p>隨著環境汙染日益嚴重，人類逐漸演化出能對抗惡劣環境的特徵。他們的壽命倍增，肌肉發達，還擁有驚人的癒合力，能輕易對抗狩獵者、天災與瘟疫的威脅。然而，儘管肉體與外觀發生了變化，他們的審美觀仍與過往一致，始終無法接受自己日漸猙獰的面目，所以嚮往著有朝一日能回歸舊人類脆弱但標緻的模樣。這個夢想被寄託在芽衣這名奇蹟似地保有舊人類樣貌的女性身上，他們建立了能橫跨星系的太空船，打算消滅其他星球的原生種，以芽衣為遺傳基礎，在當地重建舊人類的家園。</p><p>然而，在目睹了被稱為遺跡的熟悉建物、不動的星座分布、還有熟悉的東方部族臉孔之後，芽衣漸漸明白，太空船恐怕從未離開過地球。太空船失事墜落後，在都市外圍撞出一個巨大的坑洞。儘管承受劇烈的衝擊，太空船的機能卻奇蹟保全，仍如計畫啟動了殖民星球的程序，反過來以光束兵器屠殺它的建造者們。等到環境改善，太空船釋出了重新培育的舊人類，他們被植入了崇拜芽衣和仇視新人類的制約，也種下了八代的部落與東方部族長年衝突的根源。</p><p>芽衣唯一的好友皋月也參與了殖民計畫。在芽衣的回憶裡，她們雖然彼此親近、共享生活空間，卻難以真正分享內心感受。因為身高落差，相處時無法平視對方；因為體格懸殊，哭泣時也無法互相擁抱。皋月對芽衣的感情中，始終摻雜著羨慕與忌妒的苦澀；而芽衣對皋月乃至整個舊人類族群，也擺脫不了格格不入的疏離感。</p><p>芽衣起身撒嬌，主動抱起八代，珍惜著那份未曾與友人體會過的溫暖。經過了許多匪夷所思的事情，芽衣也逐漸接受自己將在這個陌生世界生存下去，不過現在她有八代陪在身邊；而八代也能想像芽衣作伴的日子，也許能為一成不變的日常增添樂趣。她們在星空下暢談大海，天馬行空地規劃著一趟見證真正海洋的旅行，儘管兩人心中各存在一些陰霾：芽衣顧慮著可能身處敵營的皋月，八代則憂心得因東方部族與芽衣決裂。</p><p>深夜時，東方部族為中央森林之仇襲來，八代立刻持槍趕赴芽衣身邊。然而，不敵對手而想向芽衣求救的逃難群眾也引來東方部族的追兵。雙方在布篷前對峙時，芽衣認出帶領東方部族的，正是自己的青梅竹馬，皋月——同時也是殺害八代最多族人的剝臉者。這一刻，時間彷彿凝固。皋月淚流滿面地凝視著芽衣、族人哭號著跪求芽衣出手協助、八代堅定不移地注視著芽衣，等待她的決定。最終，在八代鼓勵下，芽衣決定與她一起逃離村莊。他們在走投無路而奮勇抗戰的族人掩護下拔腿狂奔，擺脫追兵抵達了森林深處。</p><p>至此，芽衣對八代而言，已經不再是傳聞中的神明，也非毫無關聯的外人，而是自己渴望守護的對象。而八代對芽衣而言，不僅是第一個與自己形態類似的友人，更是與她同樣難以融入群體、缺乏歸屬感的知己。她們一個有卓越的生存技巧，一個有遠古文明殘存的知識；一個著重現實，一個懷抱夢想，彼此都是在社會崩解後，獨一無二的對象。</p><p>甩開部落的追兵後，東方部落的首領皋月負傷追上芽衣與八代，她們試圖溝通，卻因為語言的變化而徒勞無功。眼見衝突一觸即發，八代挾持芽衣為人質，拖著她一同逃離。八代下定決心除掉皋月，而芽衣則含淚同意。隨後，她們以芽衣為誘餌，趁皋月露出破綻時，八代一槍刺入她體內。經過一番激烈搏鬥後，她們成功了重創皋月。</p><p>此時，芽衣決定親自與昔日好友告別，她示意八代停手，俯身向重傷的皋月低語，訴說著自己在這個陌生世界終於體會到前所未有的心動感覺，還有不受隔閡的真摯關係，以及不再忍受周遭世界束縛的自由。</p><p>為了生存下去，為了與八代共度未來，為了親眼見證更多有趣的事情，芽衣認清自己必須學會殺戮這個殘酷的生存法則。承受著回憶與愧疚，芽衣顫抖地下刀，割下了皋月的首級。終結了跨越了時間的情誼和她們短暫的重逢。</p><p>含淚與過往訣別後，芽衣與八代決定攜手踏上尋找真正大海的旅途。她們無法預知明天的模樣，也不確定接下來的遭遇。但他們約定無論面臨什麼困難，都要堅定守候在對方身邊。她們懷抱著這個或許能夠實現的願望，它指引著她們在致個曾經喪失意義的世界前進，讓她們不再迷失方向。</p><br/><p>讀這本書之前，我沒有瀏覽任何書評與介紹，所以對內容除了百合以外一無所知。讀完後，才知道除了預期的甜蜜互動以外，還有一個末日後的科幻故事。這個故事意外有趣，雖然它有許多背景設定，卻能融入情節慢慢透漏給讀者，所以讀起來並不會覺得枯燥，反而被營造出的懸疑感而吸引，想跟著角色揭開世界的秘密。</p><p>至於角色的情感與互動，可能是因為我第一次讀這類小說，所以覺得寫得還蠻讓人心動的。可能呼應了故事設定，芽衣與八代肢體接觸的尺度不大，畢竟在芽衣的時代並沒有人能跟她這樣親密交流。然而，從肢體動作和心理描述，還是能感受兩人相遇、相識乃至相惜的過程。</p><p>舉例來說，石槍象徵著八代獨自謀生的決心，不過逃離海底時，她卻甘願丟棄石槍以拯救虛弱的芽衣。在後續的故事，八代每次放下石槍，也都跟芽衣有關。另外，八代一直不喜歡自己的銀色頭髮，不過從一開始芽衣的開口稱讚，到最後她們能觸摸彼此的髮絲，代替自己纏繞在一起等互動，都能感受到兩人的心彼此接近。</p><p>看動畫時，還能透過螢幕剪取保留畫面。可是看書時，碰到打動自己的橋段，卻沒什麼方便的手段可以保存和回顧，只好一邊抄寫一邊寫下這則故事摘要。不過，越是想保留這些內容，就越花時間在記錄，反而減少的閱讀的時間，這還真是兩難啊。</p><hr><p>入間人間（2018）。無法成為神明的少女（李逸凡譯）。台灣角川（原著出版於 2017 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> yuri </tag>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Finding a Shared Spliced Motif (LCSQ)</title>
      <link href="/finding-a-shared-spliced-motif/"/>
      <url>/finding-a-shared-spliced-motif/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定兩條以 FASTA 格式儲存的 DNA 序列，求兩序列最長的共同子序列。</p><blockquote><p>Given: Two DNA strings s and t (each having length at most 1 kbp) in FASTA format.</p><p>Return: A longest common subsequence of s and t. (If more than one solution exists, you may return any one.)</p></blockquote><p>(<a href="https://rosalind.info/problems/lcsq/">https://rosalind.info/problems/lcsq/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>在實際的基因體研究中，我們可能需要比對多條 DNA 序列，來找出重複出現的 motif 序列。這題要求找出兩條序列最長的共同子序列，它代表了被 introns 分隔的最長 mofif。</p><p>較長的序列通常涵蓋更多功能基因，但也因此更容易受到突變和基因重排的影響。如果一段涉及多種功能的長序列能在物種的基因體長期保存，沒有因為演化過程中的偶發事件而被打斷或消失，就暗示著這段序列可能與該物種的核心功能有關。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>這題是最長共同子序列（LCS, longest common subsequnce）問題的變體，我推薦閱讀<a href="https://web.ntnu.edu.tw/~algo/Subsequence2.html">演算法筆記</a>的介紹，它清楚解釋了 LCS 的核心觀念與不同解題方法，也有程式實作可供參考。這裡我會依據自己的理解，重述其中一種基於動態規劃的解題方法。</p><p>假設有兩個序列 $S$ 與 $T$，它們的最長共同子序列記為 $LCS(S, T)$。如果單獨考慮兩序列的最後一個元素，可以將 $S$ 與 $T$ 重新表示為 $S &#x3D; S_{sub} + s$ 和 $T &#x3D; T_{sub} + t$。</p><p>那麼根據最後一個元素的狀況，我們可以得出以下關係：</p><ul><li>如果 $s &#x3D; t$，那麼這兩個元素都可以納入 $LCS(S, T)$，即 $LCS(S, T) &#x3D; LCS(S_{sub}, T_{sub}) + s$。</li><li>如果 $s \neq t$，表示不需要檢查完整的序列即可找到 $LCS(S, T)$，<ul><li>$LCS(S, T)$ 不包含 $s$ 或 $t$，即 $LCS(S, T) &#x3D; LongerOne(LCS(S_{sub}, T), LCS(S, T_{sub}))$</li><li>$LCS(S, T)$ 不包含 $s$ 與 $t$，即 $LCS(S, T) &#x3D; LCS(S_{sub}, T_{sub})$</li></ul></li></ul><p>因為 $LCS(S_{sub}, T_{sub})$ 小於等於 $LCS(S_{sub}, T)$ 和 $LCS(S, T_{sub})$，所以這些關係可以化簡為：</p><p>$$ LCS(S, T)&#x3D;<br>\begin{cases}<br>LCS(S_{sub}, T_{sub}) + s &amp; when &amp; s &#x3D; t\<br>LongerOne(LCS(S_{sub}, T), LCS(S, T_{sub})) &amp; when &amp; s\neq t <br>\end{cases}<br>$$</p><p>這個關係式表明，兩序列的 LCS 可以從各自子序列的 LCS 推論出來，這構成了應用動態規劃的基礎。</p><p>我們可以使用一個二維陣列來記錄 $S$ 和 $T$ 所有子序列的 LCS，再逐一檢視各個子序列的最後一個元素，參考前述關係式填滿這個陣列。最終，陣列右下角的元素就是題目要求的最常共同子序列。</p><h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>動態規劃的實作通常包含三個步驟：定義資料結構、釐清子結構間的關係，確認初始值<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="我覺得動態規劃難在看得懂但是想不到。不過別人花了一輩子研究才想出來的演算法，要我們在周末下午憑空刻出來也是強人所難。因此，我覺得適度原諒遲鈍的自己也是很值得鼓勵的行為喔。順道一提，我蠻喜歡這篇關於動態規劃的文章，推薦給大家:) [动态规划很难？DP连刷40道题，我总结出了这些套路](https://github.com/iamshuaidi/algo-basic/blob/master/%E5%AD%A6%E7%AE%97%E6%B3%95/%E5%AD%A6%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BE%88%E9%9A%BE%EF%BC%9FDP%E8%BF%9E%E5%88%B740%E9%81%93%E9%A2%98%EF%BC%8C%E6%88%91%E6%80%BB%E7%BB%93%E5%87%BA%E4%BA%86%E8%BF%99%E4%BA%9B%E5%A5%97%E8%B7%AF.md)">1</span></a></sup>。考量這題要求找出 DNA 序列的最長共同子序列（為了方便討論，此處字串視為廣義的序列），我選擇以巢狀 list 來模擬二維陣列。每個元素代表對應的 DNA 子序列的最長共同子序列。</p><p>這樣方法雖然需要額外的儲存空間，但我覺得比較直觀易懂，因為它需要不額外的步驟來回溯最長共同子序列的內容。</p><p>以下實作需要注意幾點：</p><ul><li>二維矩陣的長與寬都要比兩條 DNA 序列的長度各多 1，因為它儲存的是 <code>S[:index]</code> 的最長共同子序列</li><li>兩條 DNA 序列最短的子序列是空序列，所以它們的初始值是一個空字串。</li><li>填表時依照前述的關係式來進行，這裡用了 <code>max(a, b, key=len)</code> 來簡化程式碼。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcsq</span>(<span class="params">S, T</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate and return the longest common subsequence (LCS) of two strings S and T.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        S, T (str): The two input DNA strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        str: A longest common subsequence of s1 and t.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># lcs denotes the longest subsequence of all s1&#x27;s and s2&#x27;s substring</span></span><br><span class="line">    lcs = [</span><br><span class="line">        [<span class="string">&quot;&quot;</span>] * (<span class="built_in">len</span>(T) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S) + <span class="number">1</span>)</span><br><span class="line">        ]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)):</span><br><span class="line">            <span class="keyword">if</span> S[s] == T[t]:</span><br><span class="line">                lcs[s + <span class="number">1</span>][t + <span class="number">1</span>] = lcs[s][t] + S[s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lcs[s + <span class="number">1</span>][t + <span class="number">1</span>] = <span class="built_in">max</span>(lcs[s + <span class="number">1</span>][t], lcs[s][t + <span class="number">1</span>], key=<span class="built_in">len</span>)</span><br><span class="line">    <span class="keyword">return</span> lcs[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">我覺得動態規劃難在看得懂但是想不到。不過別人花了一輩子研究才想出來的演算法，要我們在周末下午憑空刻出來也是強人所難。因此，我覺得適度原諒遲鈍的自己也是很值得鼓勵的行為喔。順道一提，我蠻喜歡這篇關於動態規劃的文章，推薦給大家:) <a href="https://github.com/iamshuaidi/algo-basic/blob/master/%E5%AD%A6%E7%AE%97%E6%B3%95/%E5%AD%A6%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BE%88%E9%9A%BE%EF%BC%9FDP%E8%BF%9E%E5%88%B740%E9%81%93%E9%A2%98%EF%BC%8C%E6%88%91%E6%80%BB%E7%BB%93%E5%87%BA%E4%BA%86%E8%BF%99%E4%BA%9B%E5%A5%97%E8%B7%AF.md">动态规划很难？DP连刷40道题，我总结出了这些套路</a><a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《春季限定草莓塔事件》</title>
      <link href="/honobu-2004-shunki-gentei-ichigo-taruto-jiken/"/>
      <url>/honobu-2004-shunki-gentei-ichigo-taruto-jiken/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在船戶高中新學期的開始，兩名看似普通的新生——小鳩常悟朗和小佐內由紀，默默地遵守著一個不尋常的約定。他們決定成為安分守己的小市民，度過平靜安穩的高中生活。為了促成這項目標，他們彼此承諾，在發生危險時，對方可以用自己的名義脫身；在衝動不已時，自己也要提醒對方守住約定。然而，兩人追求的平穩生活，卻受到一系列事件打斷，讓他們不得不面對各自的陰暗本性。</p><span id="more"></span><p>小鳩是觀察敏銳而且喜好解謎的男生，但是因為一段不快的經歷，所以他極力隱藏這些特質。小佐內是個子嬌小而且性格害羞的女生，喜歡甜食，心情不好時總會到點心店大快朵頤；不過，最令她滿足的，還是復仇之後的快感。雖然他們之間既沒有戀愛關係，也沒有傳統意義上的友情，但是卻為了彼此的共同目標而結盟。小鳩和小佐內在校園裡扮成普通的情侶，既不惹事生非，也不參與爭端；在周末，他們各自分開，互不打擾，盡可能低調度日。</p><p>然而，小鳩昔日的同窗堂島健吾，卻無意間成了打亂他們計畫的關鍵因素。同樣考上船高的堂島是個體格壯碩而且性格直率的男生，他為人熱心甚至有些多管閒事，在開學不久便打破了小鳩的平穩生活。原本小鳩與小佐內課後相約嘗鮮新開幕的可麗餅店，小鳩卻因為堂島的求助，先參與了一起斜背包竊案的調查。堂島召集了熱心的同學搜遍校舍卻一無所獲，因此打算隔天報警處理。</p><p>小鳩在散會後與小佐內商量此事。雖然他不想違背承諾，但也不樂見警方介入而讓事情鬧大。因此，小鳩在小佐內勉強同意下破例出手，打算在引起騷動前私下解決問題。小鳩根據一名同學在幫忙尋找背包時的古怪舉動，推論他是竊案的罪魁禍首。考量這名同學與受害者的關係沒有異狀，小鳩認為他的犯案動機更可能是想對背包動手腳。隨後，小鳩與小佐內找到了背包的藏匿處，卻在現場撞見前來取回斜背包的同學。眼看可能引發衝突，小佐內以告發此事來威脅對方，才讓他們平安離開，也順利讓背包物歸原主。</p><p>過了不久，堂島再次求助小鳩。剛加入校刊社的堂島因為採訪美術社得知，他們正困擾著如何處理畢業前輩寄放的兩幅畫作。這兩幅畫的內容相同，而且筆觸童稚，不見高深技巧。不過，前輩卻向保管畫作的學姊強調，這兩幅是「世上最高尚」的畫。在讀完一份關於前輩作畫理念的訪談後，小鳩就想到了確認畫作含意的方法。然而，他一方面擔憂主動釋疑的舉動，可能招致賣弄小聰明的名聲；另一方面也對束手旁觀堂島的困境感到不安。</p><p>小鳩回到教室後，意外碰見還在學校的小佐內，她表示想為昨天發生的插曲道歉。他們昨天買完限購的草莓塔在鄰近便利商店停留時，小佐內的腳踏車連同置物籃的點心被一名少年偷走。儘管小鳩一再安慰失落的小佐內，但她都沒有任何回應。小佐內了解小鳩左右為難的困境後，基於內心愧疚向他提議，用她的名義向美術社成員解釋解謎的邏輯，或許能免於他人閒言閒語。</p><p>於是，小鳩謊稱他的朋友看出了畫作的意圖，向美術社成員轉述朋友的觀察。基於兩幅畫細微的差異、技巧的拙劣、內容的平實、作品名的玄機等線索推論，這組作品是為討姪兒開心而設計的找碴遊戲。然而，因為未知的理由被前輩遺忘在美術社。隨著畫作饋贈的對象長大，它現在也失去任何價值了。</p><p>儘管是以小佐內的名義解決疑難，小鳩在解釋畫作謎團時，仍然害怕他人因為自己故弄玄虛的態度而感到不快。然而，一旁的堂島非但沒有表現焦躁不耐的情緒，還十分感謝小鳩的幫忙，更敬佩小佐內的聰慧。因此，堂島邀請兩人到他家玩，還招待了他們自家獨傳的熱可可。然而，堂島邀約小鳩的真實目的，是想打聽小鳩的過去。在堂島的印象中，小鳩是個聰明過人、言語刺耳而且口無遮攔的臭屁小子。他很好奇為什麼小鳩現在總是口是心非，做事畏畏縮縮而且逆來順受？不過小鳩極力迴避解釋自己的變化，連忙以上廁所為理由離開現場。</p><p>他在經過廚房時，碰到了先一步起身的小佐內與堂島的姊姊知里，兩人正為了堂島如何用有限的容器沖泡熱可可而絞盡腦汁。儘管小佐內小聲提醒小鳩，他仍然在知里的煽動下，接下了這個謎團的挑戰：如果連被視為笨蛋的堂島都做得到，那麼小鳩沒理由不知道熱可可的做法。</p><p>在順利解決熱可可的謎團後，小鳩向一直保持沉默的小佐內自清，這回踰矩只是周末的放縱，他其實不願意再賣弄小聰明了。然而，小佐內卻反常地表示，如果小鳩能活得更自在，她願意尊重小鳩的選擇，不會因此限制他的做法。畢竟，兩人雖然都以成為小市民為目標，各自想要迴避的陰暗本性卻不一樣，小鳩想壓抑揭露他人秘密的渴望，而小佐內也得克服追求復仇的狂熱。</p><p>在小佐內的腳踏車失竊後不久，那台車在一起印章竊案的現場被發現。雖然沒有逮到竊賊，但是警方從民眾通報的停車證號碼得知小佐內的身分。儘管她也是受害者，卻仍遭訓導處問話，蒙受無端的指控與檢討。這段期間，小佐內還在考試時遇上瓶罐砸破的事件，害得她表現不佳。受了這麼多委屈，她只能以甜食洩憤。小佐內刻意邀請小鳩同行，向他說明事情始末並且表達出自己的氣憤與不甘。小佐內懷疑瓶罐事件是人為造成，一再暗示小鳩出手協助。不過，小鳩雖然能理解小佐內忿忿不平的原因，但是基於兩人之間的約定，他還是沒有說出自己的想法，只能在旁聽著小佐內的抱怨。</p><p>腳踏車事件並沒有就此平息。小鳩和小佐內在徒步返家的路上，撞見竊賊騎著贓車急速離去。眼見小佐內想追上已遠去的對方，小鳩阻止了這個徒勞的舉動，並試圖安慰她。然而，小鳩從小佐內僵硬的笑容察覺到，雖然她的舉止看似釋然，其實內心仍然對自己的遭遇耿耿於懷。隔日，小佐內再次被訓導處傳喚，因為熱心民眾發現腳踏車被棄置在昨天他們看見竊賊的路旁。小鳩陪著小佐內回到現場，發現腳踏車的損壞比預期嚴重，似乎還受到惡意破壞。</p><p>慍怒的小佐內無視彼此的約定，和小鳩討論起單車被棄置的原因。他們推論，竊車賊可能是駕訓班的學員，在趕上交通車後便丟下了小佐內的腳踏車。謎團解開後，小鳩原以為事件就此告一段落。然而，小佐內卻不願善罷甘休。既然已經掌握線索，她打算為毀棄的腳踏車、蒙受的誤會以及限量的草莓塔報仇，讓嫌犯付出應有的代價。</p><p>眼見自己無力規勸陷入復仇狂熱的小佐內，小鳩異想天開地要幫助她達成目標。不過，小佐內一口回絕了這項提議。畢竟，兩人雖然互相承諾要為彼此脫身，卻沒規定要為對方的決定負責。然而，小鳩卻無法對小佐內的行動袖手旁觀。即使他一再壓抑推理的衝動，卻無法忽略自己不祥的預感，即小佐內可能會因為此案而陷入險境。因此，小鳩只好向堂島求助，希望他能協助維護小佐內的人身安全。</p><p>不過，堂島聽完事發經過後卻感到十分不滿，他既看不慣小鳩猶豫不決的態度，也認為他刻意隱瞞細節，反而讓人無所適從。因此，堂島向小鳩下了最後通牒，如果小鳩不願意解釋自己產生不祥預感的具體原因，那麼他就不會幫忙。至此，小鳩再度陷入兩難的局面，他一方面擔憂小佐內的安危，另一面也害怕自己解釋事情的態度會傷害他人。他最終放棄掙扎，向堂島吐漏一切。儘管堂島與他姊很欣賞小鳩的推理本領，可是其他人總是不耐他以往高人一等和裝腔作勢的態度。</p><p>小鳩雖然有過人的觀察和推理能力，卻不懂得顧慮他人的心情；他能對案情至微的線索抽絲剝繭，卻不擅長化解緊繃的場面。因此，即使他每每都順利看破案件的真相，卻也無意間揭露他人的瘡疤，搞砸了團體的氣氛。正是因為討厭他人不快的目光，小鳩才想擺脫這樣的過去，追求一個平穩的高中生活。但是，為了保護小佐內，他不得不故技重施。</p><p>小鳩發揮了他的推理能力，檢視了至今蒐集到的線索：偏遠的駕訓班、棄置的腳踏車、嫌犯的年齡、失竊的印章等。小鳩沒有一步到位說出內心的答案，而是用一系列的問題引導堂島逐步跟上他的思考。小鳩很排斥自己拐彎抹角的說話習慣，因為他曾經為了做出連貫而精彩的推理，錯過了避免事件發生的機會。不過，小鳩現在卻很享受這種表演的過程，他從既有線索誘導堂島相信一個直觀的結論，再逐一點破理論的破綻，將線索串接為截然不同的敘事，從而圓滿地化解看似矛盾的觀察。最終，小鳩得出結論，竊賊盜用了他人身分報名駕訓班，他考駕照的動機不是取得駕駛的資格，而是需要一張身分證明行騙。</p><p>換句話說，小佐內想調查的竊賊，很可能受犯罪組織指使。堂島聽完小鳩的解釋後恍然大悟，雖然還是不甘落入小鳩設計的推理陷阱，卻對他能直率展現自己感到高興。就在堂島承諾要幫助小佐內時，小鳩收到了她傳來的訊息，那是一條點開來一片空白的網址。這小鳩擔心不已，害怕自己又因為裝腔作勢的推理表演，再次延誤挽救事態的機會。他們倆人騎著腳踏車在山路奔馳，終於趕上駕訓班接駁車。抵達報名大廳後，他們在那碰到喬裝後的小佐內。</p><p>原來，小佐內早已掌握竊賊盜用身分上課的關鍵證據。那封訊息其實是她拍攝的照片，只是因為小鳩的手機不支援瀏覽功能，才造成了小佐內急需求助的誤會。事後，小佐內將相關事證寄送給市內的借貸公司，讓他們對詐騙集團的行動有所提防。隔幾天，各大報章雜誌皆刊登了五名高中生因為使用非法駕照從事詐欺而被捕的新聞。</p><p>小鳩和小佐內在咖啡廳會面，討論事情的始末與後續。小佐內翻閱著攤開的報紙，明白自己已經報了草莓塔的仇，卻沒有露出一絲喜悅。小佐內愧疚地向小鳩表示，她很苦惱自己違背約定獨自報仇的舉動。這讓小鳩想起他和堂島前往駕訓班前的對話。他向堂島解釋了兩人成為小市民的動機，小鳩想要避免的是裝腔作勢的小聰明；而小佐內，與她那看起來羸弱無害的外貌不同，她極力避免的是向虧待自己的人復仇，不響放任自己沉浸在蹂躪對方的滿足感中。</p><p>於是，小鳩也為自己屢次打破約定道歉。儘管小佐內提議雙方遵從本性放棄目標，可是小鳩卻認為這是糾正缺點的必經之路，鼓勵小佐內不必太過沮喪。在兩人達成共識的當下，小佐內被鄰桌情侶吵架扔出的水杯波及。她渾身濕透地跟上奔出咖啡廳的情侶檔。至於小鳩雖然表現上想勸阻小佐內，卻不由自主推論起情侶檔的身分——小鳩常悟朗和小佐內由紀，兩人作為小市民的生活，仍存在許多挑戰等著他們去克服。</p><hr><p>米澤穂信（2022）。春季限定草莓塔事件（HANA譯）。尖端出版。（原著出版於 2004 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mystery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Finding a Spliced Motif (SSEQ)</title>
      <link href="/finding-a-spliced-motif/"/>
      <url>/finding-a-spliced-motif/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>透過 FASTQ 格式給定 s 與 t 兩個 DNA 字串，求 t 的各個字符依序出現在 s 中的位置，使得這些字符構成 s 的子序列（subsequence）。（只需提供其中一組解，不用列出所有可能的子序列位置。）</p><blockquote><p>Given: Two DNA strings s and t (each of length at most 1 kbp) in FASTA format.</p><p>Return: One collection of indices of s in which the symbols of t appear as a subsequence of s. If multiple solutions exist, you may return any one.</p></blockquote><p>(<a href="https://rosalind.info/problems/sseq/">https://rosalind.info/problems/sseq/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>在真核生物基因體中，introns 會在轉錄後加工時被移除，所以 DNA 序列不會完全呈現在 mRNA 上。因此，某些 motif 可能以不連續的方式出現基因體上。因此，透過 DNA 序列尋找這些 motif 時，不僅要考慮彼此相連的序列，還要納入可能被 introns 分隔的序列。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>這題涉及「子字串」和「子序列」的區別。在生物資訊領域，我們常用序列來描述 DNA，所以這兩個概念可能產生歧義。</p><ul><li>子字串（substring）：字串的一部分，要求字符間彼此相鄰。例如 “abc” 是 “abcde” 的子字串，但 “ac” 不是。</li><li>子序列（subsequence）：序列的一部份，僅要求元素出現的順序與原序列一致，不要求子序列各元素彼此相鄰。例如 [a,b,c] 和 [a,c] 都是 [a,b,c,d,e] 的子序列。</li></ul><p>這一題等價於尋找子序列的位置，而且我們只須找到其中一組解。其中一個方法是依序檢查序列，當碰到與子序列相符的字符時，紀錄它的位置，然後繼續在序列中尋找子序列的下一個元素，直到找到子序列的所有元素。</p><h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>實作時，從 motif 的第一個字符開始，逐一檢查 DNA 序列中的每個字符。一旦發現 DNA 中的字符與當前檢查的 motif 字符相同時，就把該字符的位置記錄到 motif_pos（因為題目要求從 1 開始計數，所以索引值要加 1）。接著，繼續在 DNA 中尋找與 motif 下一個字符相符的字符，直到找到 motif 中所有字符為止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sseq</span>(<span class="params">dna, motif</span>):</span><br><span class="line">    motif_pos = []</span><br><span class="line">    <span class="keyword">for</span> pos, nt <span class="keyword">in</span> <span class="built_in">enumerate</span>(dna):</span><br><span class="line">        <span class="keyword">if</span> motif:</span><br><span class="line">            <span class="keyword">if</span> nt == motif[<span class="number">0</span>]:</span><br><span class="line">                motif_pos.append(pos + <span class="number">1</span>) </span><br><span class="line">                motif = motif[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> motif_pos</span><br></pre></td></tr></table></figure><h1 id="討論：找出所有-spliced-motif-的位置"><a href="#討論：找出所有-spliced-motif-的位置" class="headerlink" title="討論：找出所有 spliced motif 的位置"></a>討論：找出所有 spliced motif 的位置</h1><p>為了挑戰自己，我在解完這題之後，開始研究怎麼找出所有 spliced motif 的位置。不過最終仍沒想出來，也看不太懂 AI 建議的解答。因此，我暫時先把程式碼和自己的見解記錄下來，期待自己在練習更多題目之後能夠開竅😥。</p><h2 id="動態規劃"><a href="#動態規劃" class="headerlink" title="動態規劃"></a>動態規劃</h2><p>使用動態規劃解題的關鍵在於使用 dp[j] 記錄 motif[:j] 在 DNA 中所有可能的子序列位置。對於 DNA 序列中的每個字符，從後往前檢查 motif 的字符是否匹配。一旦兩者當前檢查的字符一致時，舊更新 dp。這個更新的過程利用了一個特性：由於已知 motif[:j] 在 DNA 中所有可能的子序列位置，那麼 motif[:j+1] 的所有可能子序列就可以透過將當前匹配的字符位置添加到 motif[:j] 所有的解來獲得。</p><p>這裡有個技術細節是，因為 tple 無法像是 list 使用 append 添加元素，所以用 <code>prev + (i + 1, )</code> 來創建新 tuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_spliced_motifs_dp</span>(<span class="params">dna, motif</span>):</span><br><span class="line">    dp = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(motif) + <span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>].add(())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dna)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(motif))):</span><br><span class="line">            <span class="keyword">if</span> dna[i] == motif[j]:</span><br><span class="line">                <span class="keyword">for</span> prev <span class="keyword">in</span> dp[j]:</span><br><span class="line">                    dp[j + <span class="number">1</span>].add(prev + (i + <span class="number">1</span>, ) )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="遞迴"><a href="#遞迴" class="headerlink" title="遞迴"></a>遞迴</h2><p>至於遞迴，先擺著等著開悟&#x3D; &#x3D;。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_spliced_motifs_rc</span>(<span class="params">dna, motif</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">start, path, index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(motif):</span><br><span class="line">            <span class="keyword">return</span> &#123;path&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        results = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(dna)):</span><br><span class="line">            <span class="keyword">if</span> dna[i] == motif[index]:</span><br><span class="line">                results.update(search(i + <span class="number">1</span>, path + (i + <span class="number">1</span>, ), index + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    <span class="keyword">return</span> search(<span class="number">0</span>, (), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除不必要元件，打造精簡的 JupyterLab 使用者介面</title>
      <link href="/remove-unnecessary-elements-to-make-the-jupyterlab-ui-cleaner/"/>
      <url>/remove-unnecessary-elements-to-make-the-jupyterlab-ui-cleaner/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>JupyterLab 是數據分析領域廣泛使用的互動式編輯器，它整合了文件編輯、程式碼編譯、圖像呈現與檔案管理等功能。這個編輯器最大的特色是支援 Notebook 這種多媒體文件格式，能夠將程式碼、說明文字與輸出結果同時呈現在同一份文件中。</p><p>這種設計帶來兩個主要優勢：首先，簡化了數據分析過程中的參數調試流程。開發人員可以在同一頁面上檢視結果並即時更新參數。其次，它促進了資訊與分析結果的交流。用戶可以通過文件內的描述了解分析背景與相關知識，從程式碼中掌握具體執行方式，同時能夠即時查看結果和相應說明。</p><p>JupyterLab 的另一個優勢在於它能夠建立伺服器，讓用戶通過瀏覽器進行操作，提供了一個現成的使用者介面。這一特性使得開發者無需額外花費精力在 UI 設計上，因此除了作為開發編輯器和資訊傳遞媒介外，JupyterLab 也被數據分析團隊或各類平台用作分析服務的工具。開發者可以在雲端伺服器上架設基於 JupyterLab&#x2F;JupyterHub 的服務，使非技術背景的用戶也能夠連線使用這些分析工具。</p><p>我在本文要探討的，是如何在提供分析服務的情景下，透過調整系統設置來建立更精簡的 JupyterLab 介面，從而改善用戶的使用體驗。</p><span id="more"></span><h1 id="JupyterLab-預設的使用者介面"><a href="#JupyterLab-預設的使用者介面" class="headerlink" title="JupyterLab 預設的使用者介面"></a>JupyterLab 預設的使用者介面</h1><p>JupyterLab 預設的使用者介面包含多個功能區塊：</p><ul><li>頂部的選單列（main menu）陳列了檔案存取、程式碼編輯、分頁管理、外觀設置與介面調整等選單。</li><li>左側的功能欄（side bar）顯示當前使用的擴充套件。預設的擴充套件為檔案瀏覽器（File browser），它讓用戶可以在這裡管理工作目錄中的資料夾和檔案。</li><li>中央則是瀏覽和編輯檔案的主要工作區，它允許用戶使用分頁管理不同工作視窗，例如 python&#x2F;R 互動視窗、Linux 終端或是任何一種文件。工作區的文件管理器（Document manager）能把文件渲染為 notebook、html、markdown 或是純文字等方便瀏覽與操作的格式。</li></ul><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/remove-unnecessary-elements-to-make-the-jupyterlab-ui-cleaner/interface-elements.png"></p><p>除了主要功能區塊以外，JupyterLab 的使用者介面還有其他資訊面板。左右兩側的活動欄（activity bar）會列出了已安裝的擴充套件。以 JupyterLab 4.2.3 版為例，內建的套件包含文件目錄（table of contents, 列出文件的章節標題）、終端與核心管理器（running terminals &amp; kernels，查看當前正在執行的核心與終端機）、除錯器（debugger，支援單步執行與變項追蹤等除錯功能）與屬性檢查器（property inspector，可以查看程式碼區塊的屬性）。</p><p>而位於底部的狀態列（status bar）則顯示了程式執行狀況、標準輸出訊息、游標位置與當前核心等資訊。如果不習慣分頁管理，也可以在此切換為簡易介面（simple interface），讓系統一次只呈現單一文件。</p><p>JupyterLab 整合了這些豐富的功能元件，讓開發者能集中管理與調用所需的工具；它也提供多元的自訂選項，容許開發者依據個人喜好調整介面風格。然而，這些彈性可能對非技術用戶而言太過複雜。因此，為了打造更適合非技術用戶使用的分析服務，有必要調整 JupyterLab 的預設介面。</p><h1 id="理想的分析介面與其實踐方案"><a href="#理想的分析介面與其實踐方案" class="headerlink" title="理想的分析介面與其實踐方案"></a>理想的分析介面與其實踐方案</h1><p>JupyterLab 的預設介面有數個引導不佳的地方。首先，如果啟動 JupyterLab 伺服器時沒有指定要開啟的文件，那麼系統預設會跳出啟動頁（Launcher），用戶需要自行挑選要打開的視窗。其次，系統預設用 notebook 打開 .jpynb 檔案。notebook 模式能讓程式碼與輸出結果並陳，有助於開發者在調整參數時即時得到回饋。不過，這項設計要求用戶具備調整程式碼與執行程式的能力。最後，JupyterLab 內建許多開發相關套件，這些功能與使用分析無關，反而可能混淆用戶，降低應用軟體分析的體驗。</p><p>考量到這些可能導致混淆的狀況，我們可以從以下幾個方面著手以改善使用者介面。</p><ul><li>自動載入：啟動服務時，自動開啟對應的 notebook。</li><li>圖形介面：提供圖形操作介面，避免用戶直接接觸程式碼。</li><li>精簡功能：移除與用戶無關的按鈕、選單與資訊，只保留分析服務本身。</li></ul><p>以下是調整後的範例，它只保留系統內建的檔案管理器，以及位於主要工作區的分析服務介面。</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/remove-unnecessary-elements-to-make-the-jupyterlab-ui-cleaner/modified-jupyterlab-user-interface.png"></p><h1 id="調整使用者介面的途徑"><a href="#調整使用者介面的途徑" class="headerlink" title="調整使用者介面的途徑"></a>調整使用者介面的途徑</h1><p>為了達到精簡使用者介面的目的，不只要調整 JupyterLab 的系統設置，也需要改動程式碼的觸發方式。</p><h2 id="–LabApp-default-url-：指定開啟的頁面"><a href="#–LabApp-default-url-：指定開啟的頁面" class="headerlink" title="–LabApp.default_url&#x3D;：指定開啟的頁面"></a>–LabApp.default_url&#x3D;<url>：指定開啟的頁面</h2><p>啟動 JupyterLab 時，只要添加 <code>--LabApp.default_url=&lt;url&gt;</code> 就能指定要開啟的文件和瀏覽模式，假設工作目錄底下有一個 <code>row_counter.ipynb</code> 的話，那麼不同的 URL 會以不同方式打開文件。</p><ul><li>以 notebook 模式打開文件：<code>jupyter lab --LabApp.default_url=/notebook/tree/row_counter.ipynb</code></li><li>以 lab 模式打開文件：<code>juptyer lab --LabApp.default_url=/lab/tree/row_counter.ipynb</code></li><li>以 simple 模式打開文件：<code>jupyter lab --LabApp.default_url=/doc/tree/row_counter.ipytnb</code></li></ul><h2 id="ipywidgets：建立互動元件與圖形介面"><a href="#ipywidgets：建立互動元件與圖形介面" class="headerlink" title="ipywidgets：建立互動元件與圖形介面"></a>ipywidgets：建立互動元件與圖形介面</h2><p><a href="https://ipywidgets.readthedocs.io/en/stable/">IPyWidgets</a> 允許開發者在 Jupyter notebook 建立按鈕、拉桿、文字框等可互動元件。這些元件能夠控制 Python 程式碼的行為，讓用戶能透過圖形介面執行分析，避免直接接觸程式碼與底層運作。IPyWidgets 的效果如下圖所示，執行程式之後，互動元件會呈現在程式碼區塊底下的輸出區塊。</p><p><img data-src="https://i.sstatic.net/YHGEd.png"><br>（圖片來源：<a href="https://stackoverflow.com/questions/37013489/how-to-align-and-place-ipywidgets%EF%BC%89">https://stackoverflow.com/questions/37013489/how-to-align-and-place-ipywidgets）</a></p><h2 id="Voila：呈現渲染過的使用者介面"><a href="#Voila：呈現渲染過的使用者介面" class="headerlink" title="Voila：呈現渲染過的使用者介面"></a>Voila：呈現渲染過的使用者介面</h2><p><a href="https://voila.readthedocs.io/en/stable/">Voila</a> 可以把 notebook 轉換獨立的網頁應用程式。如同官方網站的範例，Voila 會隱藏 JupyterLab 原生介面和程式碼區塊，只呈現 notebook 輸出內容，從而建立精簡的圖形介面。</p><p><img data-src="https://voila.readthedocs.io/en/stable/_images/voila-basics.gif"><br>（圖片來源：<a href="https://voila.readthedocs.io/en/stable/%EF%BC%89">https://voila.readthedocs.io/en/stable/）</a></p><h2 id="JupyterLab：調整介面與套件設置"><a href="#JupyterLab：調整介面與套件設置" class="headerlink" title="JupyterLab：調整介面與套件設置"></a>JupyterLab：調整介面與套件設置</h2><p>假如你的分析服務不仰賴 JupyterLab 內建的互動元件，那麼只要使用 Voila 就能建立一個精簡的服務介面了。但是，如果想要保留一些好用預設工具（例如檔案瀏覽器與內容目錄），又不希望額外的元件影響用戶體驗，就需要調整 JupyterLab 的參數設置。</p><p>JupyterLab 的每個區塊都能在頂部的 Settings 選單調整。依序點選 “Settings”、”Settings Editor”、”Plugin Manger” or “JSON Settings Editor” 即可打開介面編輯器。不過，如果想管理這些異動，並且讓自訂的參數長期生效，就需要透過修改設置檔來調整介面。</p><h3 id="關閉不必要的擴充套件"><a href="#關閉不必要的擴充套件" class="headerlink" title="關閉不必要的擴充套件"></a>關閉不必要的擴充套件</h3><p>我們可以編輯 <code>~/.jupyter/labconfig/page_config.json</code> 來停用不必要的擴充套件，並且移除它們在活動欄的圖示。（如果家目錄內沒有這個目錄與檔案，那就自行建立一組。）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 停用除錯器、目錄、屬性檢查器、終端與核心檢查器</span></span><br><span class="line">    <span class="attr">&quot;disabledExtensions&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@jupyterlab/debugger&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@jupyterlab/debugger-extension&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@jupyterlab/toc-extension&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@jupyterlab/application-extension:property-inspector&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@jupyterlab/running-extension&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="移除不需要的功能元件"><a href="#移除不需要的功能元件" class="headerlink" title="移除不需要的功能元件"></a>移除不需要的功能元件</h3><p>至於 JupyterLab 的功能元件則可以編輯 <code>&lt;sys.prefix&gt;/share/jupyter/lab/settings/overrides.json</code> 來調整（如前所述，如果沒有這個目錄與檔案，就自行建立）。因為每部主機的系統路徑都不一樣，所以要以 <code>jupyter lab path</code> 這個指令顯示的 Application directory 為準。關於設置檔的路徑說明與調整，可以參考<a href="https://jupyterlab.readthedocs.io/en/stable/user/directories.html">官方文件</a>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 啟用 Simple mode 介面</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/application-extension:shell&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;startMode&quot;</span><span class="punctuation">:</span><span class="string">&quot;single&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 以 voila 開啟 notebook</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/docmanager-extension:plugin&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;defaultViewers&quot;</span><span class="punctuation">:</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;notebook&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Voila Preview&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 關閉位於畫面底部的 status bar</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/statusbar-extension:plugin&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;visible&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 關閉 extension manager，隱藏它在側欄的圖示</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/extensionmanager-extension:plugin&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 隱藏 new launcher 按鈕，以免用戶誤觸</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/filebrowser-extension:widget&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;toolbar&quot;</span><span class="punctuation">:</span></span><br><span class="line">        <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;new-launcher&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 移除 main menu</span></span><br><span class="line">    <span class="attr">&quot;@jupyterlab/mainmenu-extension:plugin&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span></span><br><span class="line">        <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-file&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-run&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-edit&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-help&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-tabs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-view&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jp-mainmenu-settings&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>JupyterLab 是功能豐富的互動式編輯器，不僅適用於開發者，也能提供分析介面供非技術用戶使用。然而，它的預設介面含有許多可能造成混淆的功能元件。為了改善 JupyterLab 分析服務介面的引導性與清晰度，可以從調整以下四個項目：</p><ul><li>啟動伺服器時，添加 <code>--LabApp.default_url=&lt;url&gt;</code> 選項，自動載入目標頁面。</li><li>以 IpyWidgets 設計互動式元件，再用 Voila 將 notebook 轉換為網頁應用程式。</li><li>編輯 <code>override.json</code> 移除不必要的功能元件，例如按鈕、選單與資訊欄。</li><li>編輯 <code>page_config.json</code> 停用開發者擴充套件。</li></ul><p>透過這些方法，便能精簡 JupyterLab 的介面，降低分析服務的使用門檻，提升用戶體驗。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜RNA Splicing (SPLC)</title>
      <link href="/rna-splicing/"/>
      <url>/rna-splicing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一條 DNA 序列與其 intron 序列（兩者儲存於同一個 FASTA 檔案），求此序列經過轉錄、剪切與轉譯後所產生的蛋白質序列。</p><blockquote><p>After identifying the exons and introns of an RNA string, we only need to delete the introns and concatenate the exons to form a new string ready for translation.</p><p>Given: A DNA string s (of length at most 1 kbp) and a collection of substrings of s acting as introns. All strings are given in FASTA format.</p><p>Return: A protein string resulting from transcribing and translating the exons of s. (Note: Only one solution will exist for the dataset provided.)</p></blockquote><p>(<a href="https://rosalind.info/problems/splc/">https://rosalind.info/problems/splc/</a>)</p><span id="more"></span><h1 id="知識背景"><a href="#知識背景" class="headerlink" title="知識背景"></a>知識背景</h1><p>在轉錄時，參與這個過程的酵素子單元與輔助蛋白質（例如 transcription factors）會附著到位於目標基因上游的 promoter 序列，組成以 RNA 聚合酶（RNA polymerase）為中心的轉錄複合體 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="轉譯啟動機制的詳細說明可參考 [Clancy. (2008) DNA transcription. Nature Education.](https://www.nature.com/scitable/topicpage/dna-transcription-426/) 的 Transcription Initiation 一節。">1</span></a></sup> 。在 RNA 聚合酶與其它酵素的催化下，轉錄複合體會解開 DNA 的雙股螺旋並且打破其間的氫鍵，再以其中一股為模板（模板股，template strand），從 5’ 端至 3’ 端逐一添加與模板股互補的核苷酸來合成 mRNA，這個過程會持續到複合體抵達 terminator 序列為止。</p><p>轉錄的原始產物被稱為 precursor mRNA，它的序列組成與模板股的互補股（密碼股，coding strand）一致，除了其中的 Thymine 被 Uracil 所取代。在真核生物中，這些 precursor mRNA 會停留在細胞核內被剪切體（splicesome）進一步加工<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="RNA 裁切機制的詳細說明可參考 [Clancy. (2008) RNA Splicing: Introns, Exons and Spliceosome. Nature Educaiton.](https://www.nature.com/scitable/topicpage/rna-splicing-introns-exons-and-spliceosome-12375/)。">2</span></a></sup>，移除其中部分的序列，再把剩餘的片段連結成 mature mRNA，送往細胞質完成後續的轉譯。</p><p><img data-src="https://rosalind.info/media/coding_template_strands.png" alt="Coding strand and template strand"><br>（圖片來源：<a href="https://rosalind.info/problems/splc/%EF%BC%89">https://rosalind.info/problems/splc/）</a></p><p>在剪切過程中，從 pre-mRNA 移除的片段被稱為 introns，而那些保留在 mature mRNA 的片段則叫做 exons。由於存在轉錄後加工，所以 DNA 序列無法透過轉譯密碼表直譯為蛋白質序列。此外，即使是 DNA 上相同的區域，在轉錄後也可能因為剪接的方式不同（alternative splicing），而產生相異的 mature mRNA，使得同一段 DNA 序列可以對應到多種蛋白質。</p><p>依據 DNA 片段在轉錄與轉譯後加工的狀況，真核生物的基因體可以劃分出以下幾種結構：</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/rna-splicing/eukaryotic-genome-structure.png" alt="Eukaryotic genome structure"></p><ul><li><strong>ORF</strong>：起始密碼子（start codon）到終止密碼子（stop codon）之間的 DNA 片段，它是理論上能夠轉譯出蛋白質的區域。<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這張示意圖只呈現了其中一種 mRNA 的剪接方式。在其他剪接方式下，終止密碼子可能落在範例 ORF 的內部，對應著長度較範例短的蛋白質。">3</span></a></sup></li><li><strong>intron</strong>：轉錄後加工時，從 precursor mRNA 移除的片段。</li><li><strong>exon</strong>：轉錄後加工後，保留在 mature mRNA 的片段。</li><li><strong>transcript</strong>：轉錄時合成的任何 mRNA 序列，包含 precursor mRNA 與 mature mRNA。由於同一段 DNA 可以對應多種 mature mRNA，所以 <a href="https://asia.ensembl.org/Help/View?id=151">ensembl</a> 等資料庫也會用 transcript 指稱 DNA 的特定剪接方式，以區分屬於不同 mature mRNA 的基因體註解資訊。</li><li><strong>CDS</strong>：coding sequence，mature mRNA 中實際轉譯出蛋白質的片段，它通常介於起始密碼子到終止密碼子（但不包含終止密碼子）之間。</li><li><strong>UTR</strong>：untranslated region， mature mRNA 5’ 和 3’ 兩端未經轉譯的片段。</li></ul><p>我把這些片段的長度關係歸納如下：</p><ul><li>transcript &#x3D; introns + exons</li><li>exon &#x3D; CDSs + 5’&#x2F;3’ UTR + stop codon</li><li>intron &#x3D; transcript - exons</li><li>CDSs &#x3D; exons - 5’&#x2F;3’ UTR - stop codon</li></ul><p>這一題要求我們模擬轉錄、剪接與轉譯的過程，移除指定 DNA 當中的 introns，求出特定 transcript 對應的蛋白質序列。雖然題目裡沒有明確註記，但是測試序列必定是一個長度為三的倍數的 ORF，而且移除 introns 不會產生其它 ORFs。因此，作答時不需要考慮不同 readframe 的影響。</p><p>另外，雖然測試資料使用 FASTA 檔案儲存 DNA 和 introns 序列，可是它其實不適合儲存基因體結構資訊。首先，FASTA 檔案依賴自身以外的補充資訊來說明各序列的屬性。以這題為例，我們無法從測試資料得知何者為 DNA 或 intron，還得參考題目的說明。其次，只憑序列資訊難以區分位於目標基因內&#x2F;外的 introns，這些重複的 intron 可能導致程式誤判。最後，序列比對不只較費時，紀錄完整序列也需要更多儲存空間，兩者都會影響程式執行效率。</p><p>因此，實務上會以 <a href="https://asia.ensembl.org/info/website/upload/gff.html">genome feature format（GTF&#x2F;GRF）</a> 儲存基因體各區域的屬性與特徵。GTF&#x2F;GRF 是以 tab 分隔的文字檔案，包含 transcript 的名稱、特徵的類型、還有它在基因體的座標等欄位。因此，在比對樣本序列與參考基因體之後，即可透過 <a href="https://www.ncbi.nlm.nih.gov/genbank/genomes_gff/">NCBI 的基因特徵資料庫</a>配合座標資訊，標示出各序列的屬性。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>這個練習的解題步驟依序為讀取 FASTA、移除 introns和轉譯 DNA。因為我在之前的文章已經解釋過部分功能，所以這裡只說明移除 intron 的方式，其它步驟的程式碼可參考我的 <a href="https://github.com/5uperb0y/rosalind/blob/main/code/splc/splc.py">Github</a>。</p><p>剪接 DNA&#x2F;mRNA 的問題，可以視為移除字串內多個子字串的問題<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可以參考 [Replacing Multiple Patterns in a Single Pass](https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s15.html) 或 [How to replace multiple substrings of a string?](https://stackoverflow.com/questions/6116978/how-to-replace-multiple-substrings-of-a-string) 等討論。">4</span></a></sup>。我們可以用多次字串取代（str.replace()）或是用一次正則表達式，把 intron 字串抽換為空字串。</p><p>這兩種策略的運算效率相去不遠<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="依據 [Fastest implementation to do multiple string substitutions in python](https://stackoverflow.com/questions/3411006/fastest-implementation-to-do-multiple-string-substitutions-in-python) 的測試，使用正則表達式或多重 str.replace() 的表現到長度數百萬的字串仍難分軒輊。因此從效能角度來看，這兩種方式對於幾 kb 的 DNA 字串其實沒有太大的差異。">5</span></a></sup>，不過如果採用多次字串取代的策略，需要考量執行順序與重複取代的問題。畢竟，DNA 序列會隨字串取代而變化，如果途中產生新的 intron 片段，就會造成額外的剪切。</p><h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><h2 id="以-str-replace-實作"><a href="#以-str-replace-實作" class="headerlink" title="以 str.replace() 實作"></a>以 str.replace() 實作</h2><p>即遍歷所有 intron，以空字串取代 DNA 內相符的片段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm_introns</span>(<span class="params">dna, introns</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Remove intron strings from a DNA string using replace().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA sequence that starts with ATG and ends with TGA, TAG, or TAA.</span></span><br><span class="line"><span class="string">        introns (list): Intron strings to be removed from the DNA string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        str: A modified DNA string with all specified introns removed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> intron <span class="keyword">in</span> introns:</span><br><span class="line">        dna = dna.replace(intron, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> dna</span><br></pre></td></tr></table></figure><h2 id="以正則表達式實作"><a href="#以正則表達式實作" class="headerlink" title="以正則表達式實作"></a>以正則表達式實作</h2><p>Python 的正則表達式套件（re）可以處理多字串的比對、取代與分割。此處應用的是 substitution 功能，它的語法為 <code>re.sub(r&quot;&lt;pattern&gt;&quot;, new, str)</code>，其中 <code>&lt;pattern&gt;</code> 是擷取特定字串的正則表達式語法。以這題為例，我們可以透過 <code>pattern_1|pattern_2|pattern_3</code> ( <code>|</code> 表示「或」) 來擷取任一指定字串。因為我預設 intron 以 list 輸入，所以才用 str.join() 建立字串擷取的正則表達式<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="這題也可以用 re.split()，以 introns 為分隔符切斷 DNA 序列，再用 str.joint() 合併剩餘的序列。">6</span></a></sup>。</p><p>因為許多生物資訊工具運行於 linux 命令列，所以我們常用正則表達式配合 grep、sed、awk 等工具，快速從 FASTA、BED、VCF 等容量龐大的檔案擷取所需的資訊，以檢視分析結果是否符合預期。儘管現在很多 AI 工具都能幫忙生成正則表達式，不過我認為如果要把命令寫成腳本，還是有必要學習表達式的規則，以了解程式碼運作的邏輯，避免軟體出現非預期的錯誤。</p><p>在搜尋引擎查詢 regex introduction 即可找到許多學習資源，其中我特別喜歡 <a href="https://refrf.dev/">Regular Expressions for Regular Folk</a> 的編排。如果自認已經掌握正則表達式的精隨，可以移步 <a href="https://alf.nu/RegexGolf?world=regex&level=r00">Regex Golf</a> 挑戰用最短的式子擷取題目指定的匹配字串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rm_introns_with_regex</span>(<span class="params">dna, introns</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Remove intron strings from a DNA string using regular expression substitution.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA sequence that starts with ATG and ends with TGA, TAG, or TAA.</span></span><br><span class="line"><span class="string">        introns (list): Intron strings to be removed from the DNA string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        str: A modified DNA string with all specified introns removed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r&quot;|&quot;</span>.join(introns), <span class="string">&quot;&quot;</span>, dna)</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">轉譯啟動機制的詳細說明可參考 <a href="https://www.nature.com/scitable/topicpage/dna-transcription-426/">Clancy. (2008) DNA transcription. Nature Education.</a> 的 Transcription Initiation 一節。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">RNA 裁切機制的詳細說明可參考 <a href="https://www.nature.com/scitable/topicpage/rna-splicing-introns-exons-and-spliceosome-12375/">Clancy. (2008) RNA Splicing: Introns, Exons and Spliceosome. Nature Educaiton.</a>。<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這張示意圖只呈現了其中一種 mRNA 的剪接方式。在其他剪接方式下，終止密碼子可能落在範例 ORF 的內部，對應著長度較範例短的蛋白質。<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可以參考 <a href="https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s15.html">Replacing Multiple Patterns in a Single Pass</a> 或 <a href="https://stackoverflow.com/questions/6116978/how-to-replace-multiple-substrings-of-a-string">How to replace multiple substrings of a string?</a> 等討論。<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">依據 <a href="https://stackoverflow.com/questions/3411006/fastest-implementation-to-do-multiple-string-substitutions-in-python">Fastest implementation to do multiple string substitutions in python</a> 的測試，使用正則表達式或多重 str.replace() 的表現到長度數百萬的字串仍難分軒輊。因此從效能角度來看，這兩種方式對於幾 kb 的 DNA 字串其實沒有太大的差異。<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">這題也可以用 re.split()，以 introns 為分隔符切斷 DNA 序列，再用 str.joint() 合併剩餘的序列。<a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「什麼是 Pipette？」</title>
      <link href="/what-is-a-pipette/"/>
      <url>/what-is-a-pipette/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>至今，我仍記得第一次競賽培訓，坐在 512 教室那骯髒而灰暗的生物實驗室裡，上午時分，人煙希罕，有些悠閒的感覺。</p><p>講完理論的阿灰老師開始介紹實驗，他強調︰</p><p>「做實驗時，你們要注意一些基本操作，不要給人見笑。我們學校培育出來的學生，要有不一樣的氣度，除了桌子整潔而且動作井然有序外，像是稀釋溶液或看顯微鏡等都要一步到位，不要在那邊滴半天、轉半天還調不出所需濃度、看不到東西！」</p><p>接著，他抽起不知為何插在筆筒裡的塑膠滴管︰</p><p>「你看這上頭寫著 3 cc，但你們就這樣相信了嗎？你們要去嘗試，統計滴管的實際容量，還有你們每次操作會擠出多少 cc！這樣調配溶液才會快而精準！」</p><p>「操作顯微鏡，沒有人從 40 倍開始看的啦！都是從 100 倍開始，你們要練習、練習再練習，直到不用注視目鏡，光看物鏡和物體的距離就能把焦距調好！」</p><p>聽到這些嚴格要求，當時的我油然升起「太帥了」的念頭。沒錯，每位實驗者都要有他獨門的必殺絕招，所以我也要有。</p><span id="more"></span><p>於是，剛開始練習實驗的時候，我什麼都沒幹，就拿著滴管不斷滴水、滴水和滴水。實驗室關門了，就把幾支滴管帶回教室，配一組水杯練習。</p><p>那陣子就不斷演練以提升穩定度和準確度。阿灰老師提供的數據是每滴 $\frac{1}{20}$ cc，但我的操作大概是  $\frac{1}{18}$ cc。為了保證能在實戰中維持這能力，我邊上數學課邊滴水，企圖鍛鍊邊計算邊調配溶液的本事。</p><p>然而，這個鍛鍊在弄濕數學課本幾次後終止了。不過課本的犧牲並非白費的，因為我已將「精準滴定」練得爐火純青。為更上一層樓，我開始發展「精準汲取」的能力。</p><p>所謂精準汲取，是能憑自由意志汲取所需的溶液量。假如手邊沒有滴定管或量筒時想要拿取準確量溶液會很困擾，滴管吸上來再慢慢滴回去又很浪費時間，唯一的辦法就是一次吸到位。</p><p>因此，我的課題從滴水改變為吸水。而「精準汲取」的訓練比精準滴定還要吵，為了把水排掉緊接著下次操作，每次用力擠滴管都會發出「酥嚕嚕，ㄐ一ˇU～，咭！」的聲音，這聲音混和了水從滴管射入杯子的撞擊聲和滴管內剩餘水分被擠壓的掙扎聲。</p><p>除了吵雜，吸取也比滴定更難控制。當時想用統計方法協助，也就是試試擠壓不同長度的空氣柱來吸水，當可以正好吸到 3cc 時候就在那個地方劃線。嘗試了好幾次得出結論：從筒底算起擠壓 1.5 公分的空氣柱再吸水，正好可以吸到 3 cc。</p><p>為了標記擠壓位置，連劃線要用哪種筆都精挑細選。換了好幾種筆，結果只有奇異筆劃的上去。不過，最後我也沒有用筆劃了，畢竟不是隨身帶筆，可是拇指卻是與生俱來。因此之後我都是以拇指，估算適當的擠壓位置。不過拇指的形狀也會隨擠壓改變，所以我也測試了各種替代方式，結果還是拇指比較好用，量完就馬上可以擠壓，減少發生誤差的機會。</p><p>儘管用拇指或各種尺規輔助，但也不是每次擠壓都剛好吸到 3 cc。因此，我開始思考造成誤差的因素。例如，我發現擠壓的姿勢也會影響吸取量，於是嘗試了各種手勢，有的舒服、有的會讓關節互相撞擊很不適、有的還要兩隻手偕同操作。最終，我選擇了「會讓關節稍微摩擦」的方式，這是在&#x3D;速度、舒適以及準確三者的妥協。我很想讓讀者知道，可是 blogger 留下的空間太小了，沒辦法繪製出來。</p><p>當在當初從實驗室帶出來的滴管練成滴定與汲取的技術以後，我轉而練習其它的滴管。此時才發現，練習的時候沒有考慮到塑膠滴管的機械強度會隨著多次擠壓而改變。</p><p>練了很久的滴管和新滴管比較起來，擠壓處的質地軟 Q 不少。雖然感到驚慌，我仍拿起其他管子練習了。這次不僅要考慮到哪種比較好壓，還得看看能否禁得起上百次擠壓的考驗。（我個人覺得從縫合線壓比較不容易變形。）</p><p>就這樣，在同學的祝福以及困惑下，我練習了好久，終於將滴定與汲取的誤差壓到 $10^{-4}$ 公升。換句話說，$3 \pm 0.1$ cc 的範圍內，我是無敵的。</p><p>不過，因為和滴管共同經歷這段艱苦的磨練，我也對於這些器物也產生了感情，所以我總是將滴管一洗再洗、重複利用。直到實驗室阿姨提醒我這些是拋棄式滴管，塵歸塵，土歸土，塑膠完成了它的使命後，應該回到它出生的地方，我才放心地把這些滴管送往生物安全廢棄筒。</p><p>比賽前一天，阿灰老師再次招集培訓班的同學，做賽前的信心喊話。內容不外乎應對心態、賽場布置和競試規定等。招集結束後，我跟其他同學上前跟阿灰老師追問競賽的實驗器材細節時，資優班的阿文同學問道：</p><p>「老師，大會有附 pipette 嗎？」</p><p>「什麼是 pipette？」我說。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從奈米到光年：有趣的度量衡簡史</title>
      <link href="/lee-2020-from-nanometers-to-light-years-a-brief-history-of-measurements/"/>
      <url>/lee-2020-from-nanometers-to-light-years-a-brief-history-of-measurements/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為了認識世界和交流想法，人類發明了度量衡制度。度量衡的發展不只與經濟產業的需求密切相關，也深受政治社會環境的影響。因此，不僅各個國家有其獨特的度量衡制度，不同產業也發展出各自慣用的度量衡系統。</p><p>這些系統既因為地域而異，也隨時間推進不斷演變。這本書的目的是介紹長度、面積、體積與重量等生活常見的度量衡單位，探討各個國家與產業的度量衡差異與其流變，並且探討這些差異與變化的可能成因。</p><p>（李開周（2020），從奈米到光年：有趣的度量衡簡史。）</p><span id="more"></span><p>這本書的編排較為鬆散，作者沒有按照嚴格的架構來陳述各項觀察與論點。然而，書中仍有幾個貫穿全文的議題。</p><p>首先，度量衡的發展源於需求。例如，幾乎每個文化都發展出以身體部位來度量長度的方法。古中國將拇指與中指展開的距離定義為尺，古埃及則以手掌和前臂的長度定義為肘（cubit），希臘和羅馬文化則以定義腳掌長為足尺（pes）。</p><p>透過這些單位，人們能直觀地描述物體尺寸，便於日常的測量與溝通。相似的案例還有歐洲與中亞的商人使用角豆來測量貴金屬的重量，隨後演變為重量單位克拉（carat）；以及英國用口腔能含入的水量測量，定義小杯、傑克、品脫（pint）等容量單位。</p><p>其次，單位的使用有其彈性，某些單位的定義還會因地制宜。中國使用畝來評估農地土地面積。然而，農地的價值源自作物產能。相同面積下，肥沃土地和貧脊土地的作物產量不能一概而論。因此，畝的定義還會因農地的肥沃程度而異，越是肥沃的農地，畝的面積就越小。</p><p>由於土地測量的技術困難，有些農地交易甚至用產量取代面積來衡量土地價值。這些事例反映了當代人們如何因應測量與溝通的需求而調整單位的定義。</p><p>另外，經濟、社會與政治因素深刻影響度量衡制度的發展。例如中國新朝時期的王莽基於儒道思想，相信度量衡的標準原器來自天界，所以採用音律來制定長度標準<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="管樂的音色取決於銅管的長度。長度愈長，音調愈低。王莽請樂師制定符合預期的音調後，再以管長作為長度的標準。">1</span></a></sup>。</p><p>他認為這方法比起人為標準，更接近天意。由於樂器音調不只與其長度有關，也受材質影響，所以這種方法有明顯的缺陷。然而，這反映了政治理念如何影響度量衡制度的制定。</p><p>- </p><p>另一方面，政治與經濟因素或許也解釋了，中國長度與面積隨政權交替膨脹的原因（1 尺的長度從商朝到民國約從 15 公分漲到 30 公分。）。作者認為政府為了增加絲絹稅收，微幅增加單位標準原器的尺寸，在不改變表面稅率的情況下，增加實際的稅收。</p><p>隨著社會發展與度量衡制度的普及，為了降低溝通與管理成本，統一度量衡標準成為必要。建立一致的度量衡制度只是第一步，確保其廣泛使用則是各國政府另一項挑戰。在測量工具不普及的情況下，人們往往使用自然物體作為參照。</p><p>例如，英吋（inch）最初定義為腳拇指末節的長度，隨後英國愛德華二世則將其規定為三顆大麥麥粒首尾相連的長度。這定義利用了種子尺寸的一致性，既提供了校準工具的穩定手段，又方面人民取得，確保校準方法的普及性。</p><p>之後，英國亨利六世時期也曾製造出大量度量衡原器，分發到各地行政單位，當民間出現度量衡交易的爭議時，可以向官方求助請求仲裁，藉此維護度量衡的統一與公正。</p><p>在度量衡制度的歷史中，公制的發展是近代最重要的事件，它呈現了幾個重要趨勢。首先，使用更普遍的物理現象定義單位，例如長度單位最初使用地球周長為依據，後來則採用光於單位時間行近距離。</p><p>測量手段也越來越抽象，不再依賴具體實物（即標準原器）來定義單位。公制單位也力求純粹，讓它們能夠衍生出其他常用單位。然而，作者認為採用公制能減少溝通成本並且有利於科學發展，但是它失去了早期度量衡單位的直觀性。</p><p>度量衡制度的發展有其歷史根基，各項產業都有各自慣用的單位，像美國這樣基於英制建立起的工商業體系，全面採用公制的成本高昂，所以難以全面採用公制。</p><p>書中還提出了一些值得深思的問題。如果度量衡單位是應需求而生，那為什麼會產生毫、絲、忽等極為精確的單位（1 忽 &#x3D; 0.32 微米）？作者說明，這是為了滿足官僚體系的文書需求而創造的單位，它們能確保讓稅賦額度能精確劃分到各層政府單位，達到帳面的公正與平衡。</p><p>另外，不是所有單位都是十進位制。例如羅馬的長度單位採用十二進位制可能源於人體比例。如前所述，羅馬尺最初定義為腳掌長，而羅馬吋則為腳拇指長，兩者比值正好為十二，所以成為長度轉換的標準。</p><p>而許多重量單位採用二進位制（或二的倍數進位）則與測量方式有關。天秤是過往最普遍的測重儀器，用它來測量時，是以砝碼二分逼近物體重量的過程。以二的倍數鑄造砝碼能提升過程的效率。</p><p>雖然書中沒有詳細討論，但各文明最初發展的度量衡單位也是個有趣的問題。最初發展的度量衡單位是否因文明而異？這些體系發展的次序和多樣性又跟哪些地理、生理、文化因素相關。</p><p>綜上所述，雖然《從奈米到光年》的篇幅不長，但作者還是使用許多例子幫助讀者了解陌生的單位，讓讀者能對文獻中的量化內容有具體的印象。另外，書中關於度量衡的介紹，也讓我們了解到，制度發展其實也反映了人類認識世界的管道與途徑，這是我從前讀物理課本時沒想過的觀點。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">管樂的音色取決於銅管的長度。長度愈長，音調愈低。王莽請樂師制定符合預期的音調後，再以管長作為長度的標準。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rosalind，生物資訊的 LeetCode</title>
      <link href="/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving/"/>
      <url>/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Rosalind 是一個以生物資訊為主題的程式解題平台，它與 LeetCode 等解題網站類似，能提供測試資料並且自動核對用戶上傳的答案。不過，Rosalind 的特色在於它收錄了生物資訊領域的經典問題，例如序列比對、譜系分析與基因重組等。</p><p>因此，在解決這些問題的同時，不僅能熟悉程式語言特性和了解演算法內涵，還能學習如何將生物學問題轉換為資訊科學問題，培養建模思考的方式。</p><span id="more"></span><p>目前，Rosalind 平台有近三百道題目，這些題目依據其性質、解法與來源分為以下五類。</p><ul><li><a href="https://rosalind.info/problems/list-view/?location=python-village">Python Village</a>：涵蓋解題所需的 Python 基礎知識，內容包含資料型態、條件判斷、迴圈語法與檔案讀寫等核心概念。</li><li><a href="https://rosalind.info/problems/list-view/">Bioinformatics Stronghold</a>：透過解題來學習解決生物資訊常用的演算法與其應用情境。適合已具備 Python 基礎的用戶學習。</li><li><a href="https://rosalind.info/problems/list-view/?location=bioinformatics-armory">Bioinformatics Armory</a>：介紹生物資訊常用的第三方軟體，學習使用這些工具解決實務難題。</li><li><a href="https://rosalind.info/problems/list-view/?location=bioinformatics-textbook-track">Bioinformatics Textbook Track</a>：收錄 <a href="https://www.bioinformaticsalgorithms.org/">Compeau &amp; Pevzner (2014) Bioinformatics Algorithms</a> 的練習題，可以配合教科書的進度練習。</li><li><a href="https://rosalind.info/problems/list-view/?location=algorithmic-heights">Algorithmic Heights</a>：收錄 <a href="http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf">Dasgupta et al. (2006) Algorithm</a> 的練習題，可以配合教科書進度練習。</li></ul><p>Rosalind 收錄的題目依據其所需的知識與所考量的前提，可以分為基礎、進階以及綜合三個層次。基礎項目是隨後幾個項目的鋪陳，用戶需要先完成基礎題目才能解鎖進階題目，而通過必要的進階題目後，才能挑戰綜合題目。</p><p>透過清單列的 “Problems” 選項，用戶可以切換題目的陳列模式。<a href="https://rosalind.info/problems/list-view/">List</a> 模式依照題目釋出時間排序，提供題目回答率與正確率等資訊。<a href="https://rosalind.info/problems/topics/">Topics</a> 模式則依照題目性質分類，方便用戶鑽研特定住提。<a href="https://rosalind.info/problems/tree-view/">Tree</a> 模式則呈現了題目彼此依賴的關係，有助於用戶沿特定途徑學習，了解特定知識點的脈絡與變化。</p><p>我個人喜歡透過 Tree 模式學習，透過深度優先策略來解題。這方法的優點在於，進階題目建立在基礎題目的概念之上，所以解題時不至於毫無頭緒。此外，當觀念一再出現，也能夠達到複習的目的，強化學習效果。</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving_problems.png"></p><p>在陳列頁面點擊題目名稱即可瀏覽詳細的題目說明，每道題目都包含一段背景知識描述、名詞釋義、題目陳述以及輸出入範例。</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving_description.png"></p><p>由於 Rosalind 的伺服器沒有程式碼編譯器，所以作答時需要點擊 “Download Dataset” 手動下載測試資料，接著在自己的電腦完成計算，再把答案上傳或貼到解答區域。</p><p>每道題目的作答時間為五分鐘，相對於 LeetCode 的時間限制是相當寬鬆。目前我寫過的題目中，只有 <a href="https://5uperb0y.com/reversal-distance/">Reversal Distance</a> 這道題需要考量效能問題，其餘題目即使使用暴力法都能在時限內解決。</p><p>點選 “Submit” 提交答案之後，Rosalind 就會檢查答案是否正確。由於系統僅檢查用戶上傳的答案，而不是上傳的 function，所以實際上不限制用戶以特定程式語言作答。</p><p>然而，也因為這項特性，Rosalind 平台不像 LeetCode 能用許多邊緣案例來測試 function 的穩健性。因此，除了自行設計測試資料，也建議多下載幾筆平台提供的資料進行測試，確保解法的正確性。</p><p>一旦解題成功，系統會解鎖這道題的討論區，其中包含解法分享與問題討論，這些內容都是由 Rosalind 的熱心用戶共同維護。</p><p><img data-src="https://raw.githubusercontent.com/5uperb0y/blog-media/main/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving/rosalind-a-platform-for-learning-bioinformatics-through-problem-solving_answering.png"></p><p>綜上所述，Rosalind 平台的宗旨是讓用戶透過解題來學習生物資訊學。雖然在學界和產業界，比起從頭構思演算法和重新撰寫程式，開發人員其實花更多時間在選擇與調試既有的工具。</p><p>可是，我覺得這樣的練習仍有其價值，因為它能幫助我們掌握必要的生物學知識、熟悉程式語言特性、學習演算法核心概念、培養問題建模的思考方式。這些都是解決實際生物資訊問題的重要素養。</p><p>以下是我的解題記錄與學習筆記，希望能為讀者（還有未來的自己）提供一些參考和啟發。</p><table><thead><tr><th>ID</th><th>Title</th><th>Information</th><th>Solution</th><th>Note</th></tr></thead><tbody><tr><td>DNA</td><td>Counting DNA Nucleotides</td><td><a href="https://rosalind.info/problems/dna/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/dna/dna.py">Code</a></td><td><a href="https://5uperb0y.com/counting-dna-nucleotides/">Note</a></td></tr><tr><td>RNA</td><td>Transcribing DNA into RNA</td><td><a href="https://rosalind.info/problems/rna/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/rna/rna.py">Code</a></td><td><a href="https://5uperb0y.com/transcribing-dna-into-rna/">Note</a></td></tr><tr><td>HAMM</td><td>Counting Point Mutations</td><td><a href="https://rosalind.info/problems/hamm/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/hamm/hamm.py">Code</a></td><td><a href="https://5uperb0y.com/counting-point-mutations/">Note</a></td></tr><tr><td>REVC</td><td>Complementing a Strand of DNA</td><td><a href="https://rosalind.info/problems/revc/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/revc/revc.py">Code</a></td><td><a href="https://5uperb0y.com/complementing-a-strand-of-dna/">Note</a></td></tr><tr><td>PERM</td><td>Enumerating Gene Orders</td><td><a href="https://rosalind.info/problems/perm/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/perm/perm.py">Code</a></td><td><a href="https://5uperb0y.com/enumerating-gene-orders/">Note</a></td></tr><tr><td>SIGN</td><td>Enumerating Oriented Gene Orderings</td><td><a href="https://rosalind.info/problems/sign/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/sign/sign.py">Code</a></td><td><a href="https://5uperb0y.com/enumerating-oriented-gene-orderings/">Note</a></td></tr><tr><td>LEXF</td><td>Enumerating k-mers Lexicographically</td><td><a href="https://rosalind.info/problems/lexf/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/lexf/lexf.py">Code</a></td><td><a href="https://5uperb0y.com/enumerating-k-mers-lexicographically/">Note</a></td></tr><tr><td>LEXV</td><td>Ordering Strings of Varying Length Lexicographically</td><td><a href="https://rosalind.info/problems/lexv/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/lexv/lexv.py">Code</a></td><td><a href="https://5uperb0y.com/ordering-strings-of-varying-length-lexicographically/">Note</a></td></tr><tr><td>SUBS</td><td>Finding a Motif in DNA</td><td><a href="https://rosalind.info/problems/subs/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/subs/subs.py">Code</a></td><td><a href="https://5uperb0y.com/finding-a-motif-in-dna/">Note</a></td></tr><tr><td>LCSM</td><td>Finding a Shared Motif</td><td><a href="https://rosalind.info/problems/lcsm/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/lcsm/lcsm.py">Code</a></td><td><a href="https://5uperb0y.com/finding-a-shared-motif/">Note</a></td></tr><tr><td>LGIS</td><td>Longest Increasing Subsequence</td><td><a href="https://rosalind.info/problems/lgis/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/lgis/lgis.py">Code</a></td><td><a href="https://5uperb0y.com/longest-increasing-subsequence/">Note</a></td></tr><tr><td>REAR</td><td>Reversal Distance</td><td><a href="https://rosalind.info/problems/rear/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/rear/rear.py">Code</a></td><td><a href="https://5uperb0y.com/reversal-distance/">Note</a></td></tr><tr><td>SORT</td><td>Sorting by Reversals</td><td><a href="https://rosalind.info/problems/sort/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/sort/sort.py">Code</a></td><td><a href="https://5uperb0y.com/sorting-by-reversals/">Note</a></td></tr><tr><td>PROT</td><td>Translating RNA into Protein</td><td><a href="https://rosalind.info/problems/prot/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/prot/prot.py">Code</a></td><td><a href="https://5uperb0y.com/translating-rna-into-protein/">Note</a></td></tr><tr><td>ORF</td><td>Open Reading Frames</td><td><a href="https://rosalind.info/problems/orf/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/orf/orf.py">Code</a></td><td><a href="https://5uperb0y.com/open-reading-frames/">Note</a></td></tr><tr><td>REVP</td><td>Locating Restriction Sites</td><td><a href="https://rosalind.info/problems/revp/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/revp/revp.py">Code</a></td><td><a href="https://5uperb0y.com/locating-restriction-sites/">Note</a></td></tr><tr><td>SPLC</td><td>RNA Splicing</td><td><a href="https://rosalind.info/problems/splc/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/splc/splc.py">Code</a></td><td><a href="https://5uperb0y.com/rna-splicing/">Note</a></td></tr><tr><td>SSEQ</td><td>Finding a Spliced Motif</td><td><a href="https://rosalind.info/problems/sseq/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/sseq/sseq.py">Code</a></td><td><a href="https://5uperb0y.com/finding-a-spliced-motif/">Note</a></td></tr><tr><td>LCSQ</td><td>Finding a Shared Spliced Motif</td><td><a href="https://rosalind.info/problems/scsq/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/lcsq/lcsq.py">Code</a></td><td><a href="https://5uperb0y.com/finding-a-shared-spliced-motif/">Note</a></td></tr><tr><td>EDIT</td><td>Edit Distance</td><td><a href="https://rosalind.info/problems/edit/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/edit/edit.py">Code</a></td><td><a href="https://5uperb0y.com/edit-distance/">Note</a></td></tr><tr><td>EDTA</td><td>Edit Distance Alignment</td><td><a href="https://rosalind.info/problems/edta/">Info</a></td><td><a href="https://github.com/5uperb0y/rosalind/blob/main/edta/edta.py">Code</a></td><td><a href="https://5uperb0y.com/edit-distance-alignment/">Note</a></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>橋下俱樂部與都市不對稱性</title>
      <link href="/underbridge-clubs-and-urban-asymmetry/"/>
      <url>/underbridge-clubs-and-urban-asymmetry/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>「你有去過橋下俱樂部嗎？」</p><p>橋下俱樂部，是我家鄉某個村民聯絡感情的地方。俱樂部的位置在中山高某段陸橋底下，旁邊則是一條長滿雜草的臭水溝。整個空間只有一個排球場大，高度也不高，稍微伸展就能摸到因車流而震動的橋底。</p><p>原本橋下沒什麼人的，好像某次有一整套家具被棄置到這邊，才吸引了沒事幹的中老年人聚到這，甚至一些被子女拋棄的老人把更多家具堆積到橋下，經營著自己真正的家。</p><p>我的舅舅對於這現象有個精闢的見解，他說橋下俱樂部是沒有神的地方。橋下正好位於那邊幾個宮廟的中心，由於橋下附近的居民離廟宇都很遠，所以一旦橋下俱樂部的硬體成形後，村民都聚集到這裡來了。</p><p>橋下俱樂部的興盛可能從我幼稚園開始，而衰退是什麼時候我不清楚，因為等我再次造訪橋下時，「橋下俱樂部」的塗鴉已經被抹去，先前堆積的雜物也被清空，只剩下公路工人在此小憩留下的菸蒂和飲料瓶。</p><p>新店溪左右岸兩岸的橋下俱樂部呈現某種不對稱性。</p><p>不對稱性的其中一層含義是某種事物比另一種多：重子不對稱性是重子的數量大與反重子，掌性不對稱是自然界的胺基酸多數左旋。而都市的不對稱性應該可以說是某種不平衡，例如區域的環境、硬體和人流組成差異等。</p><span id="more"></span><h1 id="永福橋"><a href="#永福橋" class="headerlink" title="永福橋"></a>永福橋</h1><p>永福橋左岸端是新北市永和區長春老人健康會，娛樂設施完備，例如歌舞機和桌球桌等，路過總能聽到卡啦ok和桌球乒乒乓乓的聲音。相較之下，右岸端是交通義勇警察大隊中正二中隊的中隊部，未開放給民眾使用。</p><h1 id="福和橋"><a href="#福和橋" class="headerlink" title="福和橋"></a>福和橋</h1><p>福和橋左岸端光線明亮且空間寬闊，下層河階有大尺寸的象棋與棋盤為裝置藝術，棋盤周邊則有幾張石椅，幾個中年人躺在椅上睡覺。上層河階則有一溜冰場，上頭幾張聚在一起的滑輪辦公椅，反映了社交活動的蹤跡。（我覺得這些椅子就像恐龍踩在泥土上的腳印一樣，雖然不是恐龍本身，但都是某種生活的證明。假如這世界人類突然消失，那這些尋常的椅子也會是外人研究當今人類的珍貴資產吧？）目光所及有六名老人，但只有一位女性。遠方傳來的乒乓聲暗示桌球場的存在。</p><p>福和橋右岸端緊鄰公館河濱公園，但空間狹窄，草坪雜亂。雖然在停留的十分鐘間有百人通過，但無人駐足，僅有剛到時即在此處休憩的是兩名自行車騎士和兩名睡覺的人。（15時00分）</p><h1 id="秀朗橋"><a href="#秀朗橋" class="headerlink" title="秀朗橋"></a>秀朗橋</h1><p>秀朗橋左岸端的空間也很寬闊，一旁是溜冰場和籃球場，有許多傳統台式建築的彩繪。共有五位中年人逗留此處，其中有一位演奏家，一名自行車騎士，一名步行者，兩個在餵鴿子。地上有重型機具拖曳重物留下的刮痕，正好劃出一張空白的五線譜。（13時30分）</p><p>秀朗橋右岸端和左岸端截然不同，空間狹窄且陰暗，雖然有十二人在此休息（六小孩，八女性），但多不久留。待我離去時，僅剩一人在此發呆。（14時49分）</p><h1 id="陽光橋"><a href="#陽光橋" class="headerlink" title="陽光橋"></a>陽光橋</h1><p>陽光橋左岸端是近河岸的小平臺，因為陽光橋很狹窄，所以此處沒什麼遮蔭。然而，因鄰近陽光運動公園，仍有一家大小在此處閒聊嬉鬧。（13時45分）</p><p>陽光橋右岸端則是很大的廣場，地面是石磚鋪成，和其他地點的水泥地很不一樣。和左岸端類似，幾乎沒有遮蔭。現場有二十人，七個小孩，大人都坐著看小孩玩耍。（14時30分？）</p><h1 id="中央路橋"><a href="#中央路橋" class="headerlink" title="中央路橋"></a>中央路橋</h1><p>中央路橋左岸端在陽光運動公園往碧潭處腳踏車程十分鐘。地面跟陽光橋右岸端一樣由石磚鋪成。共有十四張石椅子，但有十七人在此休息，幸好有三個小孩，他們只坐半張椅子。（13時55分）</p><p>中央路橋右岸端則是微樂山丘腳踏車躍動體驗區。場址如其名，位於新店溪畔自行車道一旁約四米到五高的小丘。現場佈置了越野腳踏車賽道（例如高低起伏、極度傾斜、蜿蜒的車道等），原本想去體驗躍動感的，但將近三十名小孩在排隊，於是打消此念頭。（14時20分）</p><h1 id="碧潭大橋"><a href="#碧潭大橋" class="headerlink" title="碧潭大橋"></a>碧潭大橋</h1><p>碧潭大橋左岸端就像是宮廟旁的涼亭一樣，擺放了陳舊的桌椅。有一家庭在此處嗑瓜子，兩個中年人躺在木椅上滑手機打瞌睡。現場有五小孩，七女性。跟其他站點相比，這裡零碎的桌椅、野餐的家庭、慵懶的氣氛和低落的人群流動率更像家鄉那個被棄置的橋下俱樂部。（14時00分）</p><p>碧潭大橋右岸端的附近是碧潭風景區，但沒一個人在此處逗留。周邊有一張告示牌，若不細看的話，感覺像在說這幾張石椅子是某些文物（14時14分）</p>]]></content>
      
      
      
        <tags>
            
            <tag> modernology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Locating Restriction Sites (REVP)</title>
      <link href="/locating-restriction-sites/"/>
      <url>/locating-restriction-sites/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一條以 FASTA 儲存的 DNA 序列，求長度介於 4 到 12 之間的反向迴文（reverse palindrome）的起始位置與長度。</p><blockquote><p>A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.</p><p>Given: A DNA string of length at most 1 kbp in FASTA format.</p><p>Return: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.</p></blockquote><p>(<a href="https://rosalind.info/problems/revp/">https://rosalind.info/problems/revp/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>限制酶（restriction enzyme）是一種存在於細菌中的酵素，它能夠識別並切割特定的 DNA 序列。這些酵素是細菌免疫系統的一環，主要的功能是抵禦外源 DNA 的威脅，例如噬菌體（bacterial phage）或是質體（plasmid）等。</p><p>限制酶的發現可追溯到 1950 年代 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Loenen et al. (2014). Highlights of the DNA cutters: a short history of the restriction enzymes. Nucleic acids research, 42(1), 3-19.">1</span></a></sup>。當時，Luria 和 Human 發現，有些噬菌體感染新宿主的能力會受到前宿主的影響，而且這種影響是可逆的，不依賴基因突變。這一現象後來被證明是因為宿主細菌的限制酶切割了噬菌體的核酸，從而「限制」了它們的感染能力。</p><p>細菌和外源 DNA 都可能成為限制酶的作用對象，而細菌和噬菌體也各自演化出能對抗限制酶的機制。細菌能透過甲基化酶，修飾限制酶識別位置的核苷酸，讓自身的 DNA 免受傷害。限制酶與甲基化酶組成了細菌的限制與修飾系統，兩者的平衡影響著細菌基因體的穩定性<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Shaw et al. (2023). Restriction-modification systems have shaped the evolution and distribution of plasmids across bacteria. Nucleic acids research, 51(13), 6806-6818.">2</span></a></sup>。另一方面，在部分細菌和病毒基因體中，限制酶識別序列的出現頻率偏低，這可能是一種適應性的演化，能減少 DNA 被限制酶切割的機率<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Rusinov et al. (2018). Avoidance of recognition sites of restriction-modification systems is a widespread but not universal anti-restriction strategy of prokaryotic viruses. BMC genomics, 19, 1-11.">3</span></a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Rusinov et al. (2015). Lifespan of restriction-modification systems critically affects avoidance of their recognition sites in host genomes. BMC genomics, 16, 1-15.">4</span></a></sup>。</p><p>限制酶切割後可能留下黏性端（Sticky end），這些黏性端能讓不同來源 DNA 片段互相配對，如果使用 DNA 接合酶連接比次，就能達成重組基因的目的。</p><p>不同類型的限制酶識別和切割 DNA 的模式與反應條件不同。其中，II 型限制酶的識別和切割位置相近，這種切割的精準性與可預測性，使其在生物科技上有廣泛的應用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Sticky End</span><br><span class="line">5&#x27;-...A   TAT...-3&#x27;</span><br><span class="line">3&#x27;-...TAT   A...-5&#x27;</span><br><span class="line"></span><br><span class="line"># Blunt End</span><br><span class="line">5&#x27;-...AT   AT...-3&#x27;</span><br><span class="line">3&#x27;-...TA   TA...-5&#x27;</span><br></pre></td></tr></table></figure><p>其次，由於個體間基因體的微小差異，若這些差異恰好出現在限制酶辨識位置，那麼使用相同的限制酶切割 DNA 時，會產生長度不同的片段。</p><p>這些 DNA 片段能透過電泳技術分離，提供基因體比較的資訊，這使得限制酶也成為物種鑑定、遺傳變異分析、鑑識科學等的工具 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Di Felice et al. (2019). Restriction enzymes and their use in molecular biology: An overview. Journal of biosciences, 44(2), 38.">5</span></a></sup>。</p><p>在基因體學，反向迴文（reverse palindom）是指一段 DNA 序列與其反向互補序列一致。許多 II 型限制酶會識別基因體上這種迴文序列。</p><p>儘管不是所有限制酶都是如此，不過迴文序列的對稱性讓它能夠與同一股 DNA 序列的其它部分配對，形成可能有利於酵素作用的特殊結構，例如髮夾（hairpin）結構等。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/DNA_palindrome.svg/1280px-DNA_palindrome.svg.png" alt="DNA palindromes"><br>（圖片源自：<a href="https://en.wikipedia.org/wiki/Palindromic_sequence%EF%BC%89">https://en.wikipedia.org/wiki/Palindromic_sequence）</a></p><p>其次，迴文序列表示，酵素能透過相同序列來辨識相同位置。這有助於限制酶單體聚集在鄰近位置而形成更有效率的雙聯體，同時切斷兩股序列，造成難以修補的傷害。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5&#x27;-...ATAT...-3&#x27;</span><br><span class="line">3&#x27;-...TATA...-5&#x27;</span><br></pre></td></tr></table></figure><p>反之，如果限制酶辨識的不是迴文序列，那麼兩股 DNA 的識別位置可能相距很遠，這不僅降低切割的效率。即使順利切割，也可能形成較長的黏性端，使其更容易被連接酶修復。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5&#x27;-GAGA......-3&#x27;</span><br><span class="line">3&#x27;-......AGAG-5&#x27;</span><br></pre></td></tr></table></figure><p>若想了解限制酶偏好迴文序列的解釋，可參考以下幾個討論串：</p><ul><li><a href="https://biology.stackexchange.com/questions/9913/why-do-type-ii-restriction-endonucleases-cleave-at-palindromic-sequences">Why do Type II Restriction Endonucleases cleave at palindromic sequences?</a></li><li><a href="https://biology.stackexchange.com/questions/81626/why-are-restriction-sites-palindromic-in-nature">Why are restriction sites palindromic in nature?</a></li><li><a href="https://biology.stackexchange.com/questions/1167/why-do-restriction-enzymes-tend-to-have-an-even-number-of-bases-in-their-recogni">Why do restriction enzymes tend to have an even number of bases in their recognition site?</a></li></ul><p>綜上所述，雖然不是所有限制酶都辨識迴文序列 <sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://en.wikipedia.org/wiki/List_of_restriction_enzyme_cutting_sites">6</span></a></sup>，但迴文序列對於限制酶而言，似乎有一些結構上的優勢。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>嚴格來說，這道題其實不是找出限制酶的位置，畢竟限制酶是透過實驗決定的。題目的要求是尋找長度介於 4 - 12 之間的反向迴文序列，這是 II 型限制酶識別位置的常見長度。我們可以先設計出能找出所有反向迴文序列的方式，再移除超出範圍的序列即可滿足題目要求。</p><p>窮舉法是解決這個問題最直觀的方式，也就是逐一生成 DNA 所有子字串，判斷它們是否為反向迴文。生成子字串的過程需要 $O(n^2)$ 的時間複雜度，加上判斷反向迴文所需的 $O(n)$，共計 $O(n^3)$。因此，窮舉法雖然直觀而且全面，可是效率不高。</p><p>然而，依據迴文的對稱特性，我們其實沒有必要檢查所有的子字串。迴文字串兩側的字符必然完全對應且相等。因此，如果一個字串不是迴文，那麼從相同中心往兩側延長的字串也必然不是迴文。</p><table><thead><tr><th>座標</th><th>子字串</th><th>反向迴文</th></tr></thead><tbody><tr><td><code>s[i-1:j-1]</code></td><td><code>...11...</code></td><td>是</td></tr><tr><td><code>s[i:j]</code></td><td><code>..2110..</code></td><td>否</td></tr><tr><td><code>s[i-1:j+1]</code></td><td><code>.321103.</code></td><td>否</td></tr></tbody></table><p>（為了方便，這一節暫時使用一般的迴文定義來解說演算法）</p><p>基於這項特性，中心擴展法（middle expansion method）應運而生。這個方法逐一檢查每個位置，將其視為潛在的迴文中心。接著，從中心往兩側擴展，直到兩側的字符不再對稱相等。</p><p>擴展過程中得到的子字串，就是以該位置為中心的迴文。由於這過程需要遍歷所有字符兩次，所以它的時間複雜度為$O(n^2)$。</p><p>1975 年，Manacher 演算法的發現進一步提升了搜尋迴文的效率。這個算法仍以中心擴展法為核心，但利用迴文的對稱特性，避免巢狀迴文的重複計算，使得時間複雜度降至 $O(n)$。</p><p>具體來說，在使用中心擴展法時，如果檢查點位於已知迴文 $S$ 內，就能透過 $S$ 的中心找到與檢查點的對稱點。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   |-迴文字串-|</span><br><span class="line">...ooooo.ooooo...</span><br><span class="line">     |  |  └ 檢查點</span><br><span class="line">     |  └ 迴文中心</span><br><span class="line">     └ 對稱點</span><br></pre></td></tr></table></figure><p>根據迴文的特性，中心兩側字符必然彼此對應且相等。因此，如果左側存在迴文字串，那麼右側對應片段也會有完全相同的迴文字串。</p><p>假設檢查點與對稱點分別是迴文 $s$ 和 $s’$ 的中心，那麼根據它們的長度，可能存在兩種狀況。</p><p>第一，對稱點迴文 $s’$ 完全被 $S$ 覆蓋。根據兩側對稱特性，$s’$ 與 $s$ 的組成和長度完全一致，所以可以透過對稱點來確認檢查點的迴文資訊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...xoooooooo.oooooooox...</span><br><span class="line">    |&lt;-s&#x27;&gt;|   |&lt;-s-&gt;| </span><br><span class="line">   |&lt;-------S-------&gt;|</span><br></pre></td></tr></table></figure><p>第二，對稱點迴文只有部分在 $S$ 內。這表示不能完全依賴對稱點來確認檢查點的迴文資訊，因為 $s’$ 有部分擴展到 $S$ 的邊界外。</p><p>此時，仍要回歸中心擴展法，但這次是從 $S$ 的邊界開始檢查，確認 $s$ 能否繼續延伸並形成新的迴文。如果 $s$ 能繼續延伸，形成更長的迴文，那麼它就會成為新的 $S$，能用來確認其後檢查點的迴文資訊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...ooooooo.oooooox...</span><br><span class="line">   |&lt;-s&#x27;&gt;|  &lt;-s-&gt;</span><br><span class="line">    |&lt;----S----&gt;|</span><br></pre></td></tr></table></figure><p>這種作法確保了尋找迴文時，只在必要的情形使用中心擴展，其餘情形都可以透過儲存的資訊取得結果。查詢迴文資訊為常數時間，而且中心擴展始於 $S$ 的邊界，而非從頭開始。</p><p>即使沒有對應的迴文資訊，這方法仍持續延伸並記錄各位置的迴文資訊。因此，它才能避免重複計算，達到 $O(n)$ 的時間複雜度。</p><table><thead><tr><th>方法</th><th>改進</th><th>時間複雜度</th><th>空間複雜度</th></tr></thead><tbody><tr><td>窮舉法（brute force）</td><td></td><td>$O(n^3)$</td><td>$O(1)$</td></tr><tr><td>中心擴展法（middle expansion）</td><td>跳過不可能形成迴文的字串</td><td>$O(n^2)$</td><td>$O(1)$</td></tr><tr><td>Manacher 法（Manacher’s algorithm）</td><td>只在必要時使用中心擴展法</td><td>$O(n)$</td><td>$O(n)$</td></tr></tbody></table><h1 id="python-實作"><a href="#python-實作" class="headerlink" title="python 實作"></a>python 實作</h1><p>如前所述，根據基因體學的定義，迴文序列與其反向互補序列一致。為了讓程式碼易讀，我新增了 <code>complement</code> function 來生成 DNA 的互補序列。這意味著如果字串 <code>dna</code> 是迴文，那麼它應該滿足 <code>dna == complement(dna)[::-1]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Complementing a DNA sequence.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> dna.translate(<span class="built_in">str</span>.maketrans(<span class="string">&quot;ATCG&quot;</span>, <span class="string">&quot;TAGC&quot;</span>))</span><br></pre></td></tr></table></figure><p>考慮到反向迴文的定義，只有偶數長度的 DNA 序列才能形成完全一致的反向互補序列。因此這裡我們只尋找偶數長度的迴文。</p><h2 id="窮舉法"><a href="#窮舉法" class="headerlink" title="窮舉法"></a>窮舉法</h2><p>窮舉法的步驟是列出 DNA 序列的所有子序列，同時確認它們是否滿足反向迴文。根據題目要求，DNA 序列的位置由 1 開始計數，所以在記錄迴文起始位置時，需要額外加 1 以滿足要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">revp_bf</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find a list of all palindromes&#x27; positions and their length, in the DNA</span></span><br><span class="line"><span class="string">    sequence using brute force.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA string composed of nucleotides (&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list: A list of tuple, recording the position and length of every</span></span><br><span class="line"><span class="string">              reverse palindrome, like [(&lt;position&gt;, &lt;length&gt;)]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        (i + <span class="number">1</span>, j - i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dna) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j)</span><br><span class="line">        <span class="keyword">if</span> dna[i:j] == complement(dna[i:j])[::-<span class="number">1</span>]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="中心擴展法"><a href="#中心擴展法" class="headerlink" title="中心擴展法"></a>中心擴展法</h2><p>應用中心擴展法時，我們要逐一檢查序列各個位置，將其視為潛在的迴文中心點 <code>mid</code>，再從中心往兩側檢查序列的對稱互補性。</p><p>在這個題目的條件下，DNA 迴文的長度必為偶數，所以 <code>mid</code> 不是特定字符的位置，而是字符間隙的位置。</p><p>其次，DNA 首尾兩個位置無法作為中心點，所以 <code>mid</code> 的數值介於 1 到 <code>len(dna) - 1</code>之間。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DNA   A T C G A G G A G</span><br><span class="line">Pos  0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">      mid-&gt;</span><br></pre></td></tr></table></figure><p><code>span</code> 則是從 <code>mid</code> 向兩側擴展的距離（或說潛在迴文的半徑）。因為這個距離不會超出 DNA 序列的邊界，所以 <code>span</code> 它的最大值取決於 <code>mid</code> 到 DNA 序列兩端的最短距離。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DNA   A T C G A G G A G</span><br><span class="line">Pos  0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">Span |&lt;---------&gt;|</span><br><span class="line">          mid</span><br></pre></td></tr></table></figure><p>在每個 <code>mid</code> 對應的 <code>span</code> 值域內，我們逐步增加 <code>span</code> 的長度，再依次檢查擴展範圍內的 DNA 序列是否滿足迴文（即左側與右側的核苷酸對稱互補）。</p><p>如果兩側核苷酸彼此互補，則記錄它的起始位置和長度，並且持續擴展 <code>span</code>；兩者不匹配，則中斷當前 <code>mid</code> 的擴展，轉向下一個中心點，直到所有位置都檢查過為止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">revp_me</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find a list of all palindromes&#x27; positions and their length, in the DNA</span></span><br><span class="line"><span class="string">    sequence using middle expansion approach.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA string composed of nucleotides (&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list: A list of tuple, recording the position and length of every</span></span><br><span class="line"><span class="string">              reverse palindrome, like [(&lt;position&gt;, &lt;length&gt;)]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    palindromes = []</span><br><span class="line">    <span class="keyword">for</span> mid <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dna)):</span><br><span class="line">        <span class="keyword">for</span> span <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(mid, <span class="built_in">len</span>(dna) - mid) + <span class="number">1</span>):</span><br><span class="line">            left_nt = dna[mid - span]</span><br><span class="line">            right_nt = dna[mid - <span class="number">1</span> + span]</span><br><span class="line">            <span class="keyword">if</span> left_nt == complement(right_nt):</span><br><span class="line">                palindromes.append((mid - span + <span class="number">1</span>, span * <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> palindromes</span><br></pre></td></tr></table></figure><h2 id="Manacher-演算法"><a href="#Manacher-演算法" class="headerlink" title="Manacher 演算法"></a>Manacher 演算法</h2><p>Manacher 演算法最初是設計來尋找最長的迴文字串。不過，如果知道每個中心點的最長迴文字串，其實也能重建出以同樣位置為中心，只是長度較短的迴文字串。因此，這個方法只需一些調整就能用來解這這題。</p><p>另外，迴文中心在偶數長度字串位於兩字符間，而在奇數長度字串則位於特定字符上。為了解決這項分歧，原始的 Manacher 演算法會在字符間安插特殊符號（例如 <code>#</code>，<code>abc</code> -&gt; <code>#a#b#c#</code>），將任何字串統一為奇數長度的形式。</p><p>對於這題，由於已知所有迴文長度都為偶數，所以可以省略插入特殊符號的步驟，直接處理原始的 DNA 序列。</p><p>為了讓程式碼的結構更清晰，我把中心擴展法的功能獨立到 <code>extend</code> function。這個 function 負責從指定的中心點開始，向兩側擴展來檢查序列的對稱互補性。<code>extend</code> function 允許用戶從已知的迴文邊界開始擴展，減少了重複檢查的狀況。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">dna, mid, start_span=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Extend the palindrome from the middle point to the maximum span.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA string composed of nucleotides (&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;).</span></span><br><span class="line"><span class="string">        mid (int): Index of the middle point from which to check symmetry.</span></span><br><span class="line"><span class="string">        start_span (int): Initial distance from the middle to start checking.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: Maximum span where the sequence remains a palindrome.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    max_span = start_span</span><br><span class="line">    <span class="keyword">for</span> span <span class="keyword">in</span> <span class="built_in">range</span>(start_span, <span class="built_in">min</span>(mid, <span class="built_in">len</span>(dna) - mid) + <span class="number">1</span>):</span><br><span class="line">        left_nt = dna[mid - span]</span><br><span class="line">        right_nt = dna[mid - <span class="number">1</span> + span]</span><br><span class="line">        <span class="keyword">if</span> left_nt == complement(right_nt):</span><br><span class="line">            max_span = span</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> max_span</span><br></pre></td></tr></table></figure><p>Manacher 演算法的核心是利用已知的迴文資訊來避免重複檢查，它需要額外的空間來記錄以下三項資訊：</p><ul><li><code>max_spans</code> 儲存字串各個中心點的最大迴文半徑。它們的數值預設為 -1，表示該位置未經檢查。隨著檢查進度，相應位置的數值會逐步更新。</li><li><code>right</code> 是最靠近 DNA 序列右端的已知迴文的右邊界位置。我們可以透過它來判斷檢查點是否位於已知的迴文內，從而利用已知的迴文資訊。</li><li><code>center</code> 是 <code>right</code> 對應迴文的中心位置。它能幫助我們找到檢查點的對稱點位置。</li></ul><p>Manacher 演算法的計算流程與中心擴展法相似，仍須依序檢查 DNA 序列各個位置。不過在這基礎上，還要額外判斷當前位置是否位於某個已知的迴文內。</p><p>假設當前的檢查點 <code>mid</code> 小於 <code>right</code>，表示我們有機會利用已知的回文資訊。此時，要先找到檢查點在較大迴文中的對稱點 <code>mirror</code>。</p><p>如果對稱點的最大迴文半徑小於 <code>right - mid</code>，表示以對稱點為中心的迴文完全被較大的迴文覆蓋。因此，檢查點的迴文半徑就等於對稱點的迴文半徑。</p><p>如果對稱點的最大迴文半徑大於 <code>right - mid</code>，表示較大的迴文沒有完全覆蓋對稱點的迴文，所以檢查點的迴文半徑最多只能延伸到 <code>right</code> 的位置。</p><p>反之，如果 <code>mid</code> 在 <code>right</code> 之外，表示沒有任何可參考的資訊，所以檢查點的迴文半徑設定為 0，意味著得從頭開始進行中心擴展。</p><p>在判斷了 <code>mid</code> 與 <code>right</code> 的關係後，就能從已知的迴文半徑開始執行中心擴展，避免重複檢查已經擴展過的片段。擴展結束後，需要判斷擴展後的迴文半徑是否超出 <code>right</code>。若是，則要更新 <code>right</code> 與 <code>center</code> 的值。</p><p>最後，從 <code>max_span</code> 可以得到所有位置的最大迴文半徑，進而依據這些資訊還原其他較短迴文的位置和長度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">revp_manacher</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find a list of all palindromes&#x27; positions and their length, in the DNA</span></span><br><span class="line"><span class="string">    sequence using the Manacher&#x27;s algorithm.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA string composed of nucleotides (&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list: A list of tuple, recording the position and length of every</span></span><br><span class="line"><span class="string">              reverse palindrome, like [(&lt;position&gt;, &lt;length&gt;)]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    max_spans = [-<span class="number">1</span>] * <span class="built_in">len</span>(dna)</span><br><span class="line">    right = center = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> mid <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dna)):</span><br><span class="line">        <span class="keyword">if</span> mid &lt; right:</span><br><span class="line">            mirror = <span class="number">2</span> * center - mid</span><br><span class="line">            max_spans[mid] = <span class="built_in">min</span>(max_spans[mirror], right - mid)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_spans[mid] = <span class="number">0</span></span><br><span class="line">        max_spans[mid] = extend(dna, mid, max_spans[mid])</span><br><span class="line">        <span class="keyword">if</span> max_spans[mid] + mid &gt; right:</span><br><span class="line">            right = max_spans[mid] + mid</span><br><span class="line">            center = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        (idx - span + <span class="number">1</span>, span * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> idx, max_span <span class="keyword">in</span> <span class="built_in">enumerate</span>(max_spans)</span><br><span class="line">        <span class="keyword">for</span> span <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_span + <span class="number">1</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h1 id="討論：為什麼-Manacher-演算法好像沒快很多？"><a href="#討論：為什麼-Manacher-演算法好像沒快很多？" class="headerlink" title="討論：為什麼 Manacher 演算法好像沒快很多？"></a>討論：為什麼 Manacher 演算法好像沒快很多？</h1><p>為了檢查寫出來的 function 是否實現了 Manacher 演算法，所以我也使用題目提供的範例數據，比較了不同窮舉法、中心擴展法和 Manacher 法的計算效率。</p><p>窮舉法顯然是三者最慢的，不過為什麼 Manacher 法（$O(n)$）好像沒有比中心擴展法（$O(n^2)$）快？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Using DNA sequnce TCAATGCATGCGGGTCTATATGCAT * 100</span><br><span class="line">Timing revp_bf:</span><br><span class="line">5.213197014000002</span><br><span class="line">Timing revp_me:</span><br><span class="line">0.0027632010000502305</span><br><span class="line">Timing revp_manacher:</span><br><span class="line">0.004045999999959804</span><br></pre></td></tr></table></figure><p>雖然我有添加一些程式碼來重建所有長度的迴文序列，但這些應該不至於拖累太多吧？後來回想起來，時間複雜度是基於最差情況的計算，題目提供的示範數據可能無法區分不同算法的效率差異。</p><p>II 型限制酶的長度多半在 4 到 12 之間。由於示範數據是依據這項觀察所設計，所以其中的迴文序列彼此嵌套或重疊的狀況也比較少。因此，即使使用 Manacher 演算法，多數片段仍要依賴中心擴展法。這導致 Manacher 演算法和中心擴展法在這個案例的效率相似。</p><p>為了驗證這個假說，我用 ATAT 組成的序列進行測試，因為它在所有位置都能形成迴文。而結果也如預期，對於多重嵌套的迴文結構，Manacher 演算法展現了它應有的效能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Using DNA sequnce ATAT * 100</span><br><span class="line">Timing revp_bf:</span><br><span class="line">0.06110990399997718</span><br><span class="line">Timing revp_me:</span><br><span class="line">0.018740201000014167</span><br><span class="line">Timing revp_manacher:</span><br><span class="line">0.004075799999952778</span><br></pre></td></tr></table></figure><p>測試的程式碼可參考我的 <a href="https://github.com/5uperb0y/rosalind/blob/main/code/revp/performance.py">Github</a>。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Loenen et al. (2014). Highlights of the DNA cutters: a short history of the restriction enzymes. Nucleic acids research, 42(1), 3-19.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Shaw et al. (2023). Restriction-modification systems have shaped the evolution and distribution of plasmids across bacteria. Nucleic acids research, 51(13), 6806-6818.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Rusinov et al. (2018). Avoidance of recognition sites of restriction-modification systems is a widespread but not universal anti-restriction strategy of prokaryotic viruses. BMC genomics, 19, 1-11.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Rusinov et al. (2015). Lifespan of restriction-modification systems critically affects avoidance of their recognition sites in host genomes. BMC genomics, 16, 1-15.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Di Felice et al. (2019). Restriction enzymes and their use in molecular biology: An overview. Journal of biosciences, 44(2), 38.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/List_of_restriction_enzyme_cutting_sites">https://en.wikipedia.org/wiki/List_of_restriction_enzyme_cutting_sites</a><a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《第十四道門 Coraline》</title>
      <link href="/gailman-2002-coraline/"/>
      <url>/gailman-2002-coraline/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>童話故事都是千真萬確的：不是因為它們告訴我們惡龍真的存在，而是因為它們告訴我們，惡龍是可以打敗的。——G．K．切斯特頓</p></blockquote><blockquote><p>勇敢不代表不害怕，勇敢代表你怕，真的很怕，非常害怕，但你還是作出正確的選擇。</p></blockquote><span id="more"></span><p>這是一個發生在門的另一側的故事。</p><p>寇洛琳（Coraline）與爸媽搬進一間古老的公寓。他們樓上住著一名怪老頭，時常吹噓自己正在訓練一支老鼠馬戲團；樓下則住著兩名老婦人，史小姐和福小姐，兩人的話題總是離不開年輕時登台表演的往事。這些鄰居很歡迎寇洛琳的拜訪，只是每個人都把寇洛琳的名字搞錯成卡洛琳（Caroline）了。公寓外是雜草叢生的庭園，園裡有許多高大的樹、一座荒廢的玫瑰園還有一座深不見底的井。寇洛琳在庭園探險時，總會有隻高傲的黑貓在樹下或牆上盯著她，可是一旦寇洛琳靠近，那隻貓便不見蹤影。</p><p>一個下著傾盆大雨的日子裡，寇洛琳被吩咐要乖乖待在家裡。她已經讀遍所有藏書、玩盡所有玩具、也早已厭倦每一台電視節目。可是，寇洛琳的爸媽卻因為忙於工作，沒有空陪她打發時間。於是，寇洛琳只好在屋內探險。她發現這她們家總共有一百五十三個藍色的東西、二十一扇窗、還有十四扇門！</p><p>這十四扇門裡，唯有在起居室深處的那扇門上了鎖。寇洛琳想像那裡會是某個地方的入口，不過當媽媽用一雙生鏽的鑰匙打開門時，映入她們眼簾的除了一面牆，再沒有其他東西。儘管如此，寇洛琳仍堅信那扇門一定通往某個地方。</p><p>隔天，雨停了，白茫茫的大霧籠罩整間公寓。被爸爸媽媽忽視的寇洛琳去找她的鄰居玩，這些鄰居不約而同警告她，千萬不要接近那扇門，不然將大難臨頭。離開前，樓下的史小姐交給寇洛琳一顆有洞的石頭，當作她的護身符。史小姐和福小姐希望護身符能幫助寇洛琳度過難關。不過，寇洛琳心想：「危機？那也未嘗不可。」興奮地握著那顆小石頭。</p><p>又過了一天，終於放晴。寇洛琳的爸媽分別為了拜訪他人與採購食材而出門，所以獨留寇洛琳在家。她想起起居室那扇門，於是從廚房取下那把生鏽的鑰匙，將它插入鑰匙孔。寇洛琳打開門卻發現門後那堵牆消失了。她走進門，沿著漆黑的長廊小心翼翼地走著，最終卻停在一個熟悉的地方。</p><p>「我還在……家裡？」正當寇洛琳疑惑地看著似曾相識的裝潢時，她聽見媽媽對她的呼喚聲。她走進廚房，看著那個女人的背影，覺得確實有些神似媽媽。不過，那個女人的身子比媽媽高一點，膚色也蒼白許多，當她轉過身，寇洛琳留意到她有雙黑色鈕扣組成的眼睛，還有雙塗滿鮮紅指甲油的纖細手指。</p><p>那個女人自稱是寇洛琳的「另一個媽媽」，她邀請寇洛琳還有「另一個爸爸」共進午餐。寇洛琳從來不曾吃過那麼好吃的料理，畢竟她的爸爸總是不肯照著食譜做菜，偏偏要嘗試些古靈精怪的想法，那些成品總是讓寇洛琳倒盡胃口。飯後，寇洛琳繞著她另一個家閒晃。儘管這裡的裝潢與色彩讓她有些不太舒服，卻充滿了新奇的事物：會說話的動物、有自我意識的玩具、紫色的山丘，而且，她的另一個爸爸和媽媽不會阻止她去探險。</p><p>當寇洛琳拜訪過房子周遭之後，她清楚知道，雖然這裡和印象中的房子有些相似，卻不是她真正的家。在門的這一側，樓下的史小姐和福小姐仍然年輕，她們的住處經營著一座劇院，接待狗頭人身的觀眾。在一系列精湛的雜耍表演之後，兩人會睜著黑色鈕扣的眼睛，向台下鼓譟的觀眾致謝。樓上的怪老頭依舊和老鼠混在一起，不過不知怎了，卻曉得寇洛琳名字的正確發音。他講話時的神情，讓寇洛琳不寒而慄。唯一讓寇洛琳感到兩邊一致的是那隻黑貓，即使學會說話了，態度還是一樣高傲冷峻。</p><p>回到另一個家後，另一個媽媽撫著寇洛琳的頭髮，問她願不願意永遠待在這裡。寇洛琳甩開那隻手說：「這裡是挺有趣的，但是……」</p><p>「我們希望妳留下來，」 另一個媽媽指著餐桌上的棉線、鈕扣和銀針，向另一個爸爸點點頭。</p><p>「如果妳想留下來，」另一個爸爸說，「妳只要做一件很小很小的事，不會痛的。」</p><p>「我們只希望妳得到最好的。」另一個媽媽笑著說。</p><p>「我得走了。」寇洛琳說。她緊抓著口袋裡那顆有孔洞的石頭，連忙跑回起居室，跨入那扇門。在長廊摸黑行走時，寇洛琳感覺有人尾隨在後，她回過頭，卻只看到另一個媽媽挽著另一個爸爸的手，微笑著用他們黑色的鈕扣眼睛望著她。寇洛琳再度轉過身走入黑暗，她隱隱約約聽見另一個媽媽的聲音仍輕輕地迴盪在隧道之中：「我們很快就會見面，然後——不再分開。」</p><p>寇洛琳回到家，發現爸媽還沒回來，只好自己想辦法打點吃的。爸媽失蹤的第三天，寇洛琳在半夜醒來，她想著他們會不會突然回來，於是跑到爸媽的臥室，卻只看見空蕩蕩的床鋪，她不禁哭了出來，噙著淚孤零零地在那張床上睡著。不過才入睡不久，她就被那隻黑貓喚醒。</p><p>寇洛琳起初對黑貓的現身感到詫異，不過很快意識到牠可能有話想說，連忙向黑貓詢問爸媽的去向。黑貓只是眨眼示意，帶著寇洛琳走道長廊盡頭的全身鏡前。透過走廊昏暗的橙色燈光，寇洛琳看見爸媽無助地在鏡子的倒影裡向她揮手求救。寇洛琳看見爸爸在開口說話，卻聽不到他的聲音。媽媽走近鏡子，對著鏡面呼了一口氣，在一層水霧上比劃著：「救命」。隨著霧氣消失，鏡子裡再次剩下寇洛琳、黑貓還有走廊的倒影。</p><p>寇洛琳意識到爸媽都被另一個媽媽綁架了。為了營救他們，寇洛琳需要別人的協助。然而，樓下的史小姐和福小姐已經出門探親，樓上的老頭又瘋又怪；她報警求救，電話那頭的警員卻不把這樣離奇的案件當一回事。因此，寇洛琳清楚知道，現在夠拯救爸爸媽媽的，只有她自己。</p><p>寇洛琳走回臥室，翻遍房間才找到一支照明用的蠟燭。她把有孔洞的石頭還有幾顆充飢的蘋果放進口袋，接著到廚房取下那把生鏽的鑰匙，走到起居室盡頭的門前。</p><p>她用火柴點亮蠟燭，再把鑰匙插入鎖孔。彷彿想要壓抑自己不安的情緒，她緩緩地向黑貓說起小時候和爸爸出門探險，被黃蜂襲擊的回憶。</p><p>「那時啊，」寇洛琳轉動鑰匙，說著當時的狀況：她的爸爸為了掩護寇洛琳逃跑，一個人在原地給黃蜂螫。當時，寇洛琳覺得爸爸真是勇敢。不過爸爸卻說：「那可不是真正的勇敢。」</p><p>寇洛琳打開門，門後那面牆再次消失，她感受到從長廊吹來的寒風。</p><p>「事後，爸爸為了撿回眼鏡，冒著風險回到黃蜂棲居的空地。」寇洛琳一邊對著黑貓說，一邊踏進長廊的黑暗中。</p><p>「他說被螫的時候，他只想保護妳，所以不感到害怕。」寇洛琳停下腳步，低頭看著蹲在一旁的黑貓，接著說：「可是明知道有黃蜂在，卻不得不回頭撿眼鏡的舉動，那時展現的就是真正的勇敢了。」</p><p>「勇氣不是不害怕，而是害怕之餘，仍願意做出正確的決定。」她說，然後前邁開步伐。</p><p>「這就是妳回來門的另一側的原因嗎？」黑貓終於開口。</p><p>「就像那時一樣，如果今天是我出事了，爸媽他們也一定會來救我的」寇洛琳說。</p><p>聊著聊著，他們不知不覺走到長廊的盡頭，來到另一個家。風吹熄寇洛琳手上的蠟燭，只剩下從門口照來的刺眼燈光。</p><p>「寇洛琳？」另一個媽媽在門口守候著，用力擁抱寇洛琳。寇洛琳趕緊掙脫另一個媽媽，質問自己爸媽的去向。不理會她的質問，另一個媽媽告訴寇洛琳，其實是她的爸媽主動遺棄了她。另一個媽媽端出了一面全身鏡，透過那面鏡子，寇洛琳看見爸爸媽媽剛從旅行回來，還很慶幸有人能照顧她，讓她們夫妻能享有不受打擾的恩愛時光。</p><p>另一個媽媽使喚老鼠奴僕取回門的鑰匙，鎖上通往兩個世界的門，再把鑰匙藏在圍裙口袋裡。寇洛琳不肯相信鏡中反映的幻影，於是獨自躲到戶外。在那裡，她再度碰到那隻會說話的黑貓。</p><p>寇洛琳向黑貓請教另一個媽媽的動機和應對的手段，黑貓跟她說，另一個媽媽無疑是個怪物，它需要愛的對象，或是填飽肚子的東西。對付這種怪物，最好要用遊戲激起它的挑戰心，讓它接受寇洛琳提出的條件。於是，寇洛琳返回臥房，一面想著所謂的對策，一面沉沉入睡。</p><p>隔天是個起大霧的日子，寇洛琳走出門，卻感受不到這片霧的真實感，既沒有溫度也沒有濕度，它就像有人調整了這個世界的透明度似的。寇洛琳走進庭園樹林的深處，隨著與樹林的距離接近，它的模樣越來越潦草，等她站到一棵樹旁，它的形象就不比小孩子的塗鴉還要真實多少。她一直走，走到了世界的邊緣，在那碰到了黑貓。</p><p>「外頭會是什麼呢？」她盯著霧白的遠方問。</p><p>「外頭什麼都沒有。」黑貓說，門的這一側都是另一個媽媽想像出來的，只有它接觸到的地方才會變得具體，而它記憶裡也感到殘缺不全之處，自然也不會有什麼東西了。</p><p>正當寇洛琳與黑貓爭論著外面世界的形象時，那棟房子突然現身眼前，讓寇洛琳不得不懷疑她是否已繞了地球一圈。進門後，另一個媽媽在家裡邀請寇洛琳一起玩遊戲。不過寇洛琳一口回絕，還要求另一個媽媽把她的爸媽還回來，讓他們回到原來世界去。另一個媽媽覺得她的態度任性得不可愛，為了讓寇洛琳學習禮節，於是把她關進鏡子背後陰暗的空間。「直到妳準備好當我的乖女兒為止，愛妳」它說。</p><p>鏡子背後什麼都沒有，只有無盡的黑暗。在黑暗中，寇洛琳隱約聽到一些聲音。那些聲音來自其他被拐騙到這裡的孩子，他們的軀體已經消逝，靈魂也被剝奪，只剩虛空受困於此，逐漸遺忘了一切。從他們口中，寇洛琳得知另一個媽媽雖然口口聲聲說著愛他們，實際上只想奪去他們的生命，收藏他們的靈魂。這些可憐的孩子們勸告寇洛琳千萬別放棄，一定要把握機會逃走，不然會落得與他們一樣的下場。寇洛琳自知有重責大任在身，不能輕易逃走。想著想著，她再度進入夢鄉。恍惚之間，那些孩子告訴寇洛琳，如果透過石頭的孔洞，她將能看見藏匿在物件裡的靈魂光芒。</p><p>隔天，另一個媽媽釋放了寇洛琳，因為它覺得也許她已經學夠了教訓。不過寇洛琳仍不服氣，她以自己為賭注向另一個媽媽發出挑戰：如果她能夠找到爸媽還有那幾個孩子的靈魂，她要求另一個媽媽釋放他們所有人；反之，她願意在眼睛縫上黑色鈕扣，永遠待在這裡當它的乖寶寶。</p><p>另一個媽媽笑著接受挑戰，於是坐在一旁的桌上，看著寇洛琳翻箱倒櫃。它不發一語地托著下巴，用它又長又紅的指甲敲著鈕扣眼睛，發出「答、答、答」的聲音。寇洛琳想著，既然另一個媽媽沒辦法創造出記憶以外的世界，那麼爸爸、媽媽還有那些小孩的靈魂應該就藏在這棟建築某處。</p><p>她從臥室開始搜索，透過那顆石頭的孔洞，寇洛琳看見一片灰白的世界。不過從玩具箱的蓋子，似乎逸散出紅橙色的光，她倒出所有玩具，發現一顆閃著火焰光芒的彈珠。寇洛琳知道，那就是其中一個孩子的靈魂。她頂著另一個媽媽狂怒而掀起的狂風離開臥室，在那個靈魂的鼓勵下離開房子，走到史小姐和福小姐的家。</p><p>劇院已經打烊，觀眾也已經散場，現在裡頭只剩下沾滿灰塵的觀眾席、結滿蜘蛛網的布幔、還有潮濕難聞的氣味。寇洛琳往裡面走，不時還有狗頭蝙蝠飛出，圍繞在她身邊拍著翅膀。寇洛琳看見舞台後方的牆上掛著一團黏糊糊的囊袋，就像一隻肥碩的蛞蝓。她透過石頭孔洞，看見囊袋內發出光芒，於是撕開囊袋的外皮。她發現，長得很像史小姐和福小姐的怪物蜷縮在囊袋裡沉睡著，其中一個手中緊握靈魂的彈珠。當寇洛琳試著鬆開它的手時，怪物張開眼大喊：「小偷！」寇洛琳拿走彈珠，急忙跳開。所幸那頭怪物被囊袋外的蜘蛛網和黏液困住，才讓寇洛琳得以穿過在戲院裡飛來飛去的蝙蝠群跑出來。</p><p>正當寇洛琳在房子外大口喘氣，思考該去哪找第三個彈珠時，另一個媽媽突然現身。「我可以給你一點提示。」它說，接著把那細長的手指伸入喉嚨，伴隨著乾咳與嘔吐聲，它從裡面拖出一把能打開隔壁公寓門的鑰匙。</p><p>寇洛琳接下那把沾滿口水的鑰匙，打開隔壁公寓的大門，發現裡頭有一座地窖。她深入地窖，透過石頭的孔洞四處檢查，卻沒發現任何光芒。只有看到一個臉上縫著黑色鈕扣的巨大蛆蟲，那曾是她另一個爸爸。如今卻因為它對寇洛琳的同情，而被另一個媽媽關押在地窖。寇洛琳發現它的膚色比之前更加蒼白，臉孔如同發酵的麵團，浮腫得-難以辨識出五官的位置。那頭怪物壓抑著自己殺戮的渴望，勸告寇洛琳趕快逃跑。然而，它終究控制不住，撲向寇洛琳。她沒有放任自己的恐懼鬼叫，而是趁勢扯開怪物的鈕扣眼睛，趁著它失去視力的時候逃出地窖。</p><p>寇洛琳走出隔壁公寓的時候明白，這又是另一個媽媽的詭計，它要讓我們自相殘殺。她開始覺得，即使找到所有靈魂，另一個媽媽也不會兌現諾言，因為它的目標是把他們永遠困在這世界。寇洛琳走回另一個家，發現這棟房子的形象，隨著靈魂回歸，逐漸變得潦草而平面。她沿著階梯走上頂樓，進入養著老鼠的瘋老頭的家。</p><p>「我知道妳想要什麼。」另一個老頭說。他問寇洛琳，回到原來的家有什麼好處？那裡既沒有會動的玩具，也沒有會說話的動物，而且她的爸媽還時常忽略她。「但是，留在這裡，」老頭繼續說：「我們能永遠陪伴妳，另一個媽媽會建立出玩也玩不膩的世界，每天都有美食佳餚可以享受，每一樣渴望的玩具、裝飾甚至天氣，另一個媽媽都能實現。」</p><p>「留下來陪我們吧！」他說。</p><p>「但是我拒絕，如果要什麼有什麼，那樣多沒意思。」寇洛琳說。畢竟，比起匱乏，這世上最無聊的莫過於什麼都不做就有所得。</p><p>眼看多說無益，另一個老頭轟隆一聲塌陷，一群老鼠從他的袍子、袖子和帽子湧出，老頭子已不見蹤影，只剩那些服飾攤在地上。寇洛琳掀開那些衣服，沒有發現彈珠的蹤跡。不過她在眼角餘光發現，奔逃的鼠群裡面，有隻特別肥碩的老鼠，前爪正抱著一顆彈珠。她透過石頭的孔洞確認那顆彈珠發出陣陣光芒，便趕緊追上去。</p><p>此時，隨著真相逐漸揭示，房子、牆壁乃至階梯也漸漸扭曲起，再次也不像當初造訪時那樣令人迷惑的相似。被扭曲的階梯給絆倒，寇洛琳跌落在地面擦得渾身是傷。她視線中已經沒有鼠群的影子，正當她想著是否功虧一簣時，那隻黑貓及時現身，抓住那隻大老鼠，讓寇洛琳集齊三顆彈珠和那些小孩的靈魂。</p><p>她回頭走進另一個家，現在這座建築連房子的輪廓沒有了，更像是某個狂怒的人，用炭筆在紙上反覆筆畫留下的線條。寇洛琳掀開勉強還看得出像門的東西，走進畫布上這團雜亂的線條斑塊，即將與另一個媽媽當面對峙。</p><p>「我找到三個小孩的靈魂了。」寇洛琳說。</p><p>「那麼，你的爸爸媽媽在哪呢？」另一個媽媽藏著怒意說。</p><p>她指著起居室的那扇門後，「我想他們躲在這個世界和另一個世界間。」</p><p>「是嗎？」另一個媽媽喜孜孜地從圍裙掏出鑰匙，心想她們就要永遠、永遠、永遠待在一起。它打開那扇門，轉身對寇洛琳說：「妳看，裡頭什麼都沒有，是我贏了。妳可不能食言喔，那麼……」</p><p>寇洛琳沒等另一個媽媽說完，就把黑貓丟到另一個媽媽身上，趁著黑貓與另一個媽媽搏鬥的時候，寇洛琳拿走放在壁爐上的玻璃球——她早該想到爸媽被藏到那顆沒見過的玻璃球了。寇洛琳呼喊著黑貓，然後一起躲進門後的長廊裡。另一個媽媽不死心，從門縫伸出手想抓住寇洛琳，她在爸媽和孩子們的鼓勵下湧起一股力量，順利把門關上。然而，她急著逃跑，卻沒注意到門關上後有個東西跟著落下，還隨著她穿過長廊，來到這一側的世界。</p><p>回到原本的世界後，寇洛琳發現爸媽媽都沒有這段時間的回憶。雖然她還是很想吐槽爸爸的料理品味，不過這回倒是勉強把晚餐吃完，還久違地給了爸爸一個擁抱和親吻。那晚，寇洛琳在夢中終於見到三名受困小孩的樣貌，他們在草原上野餐玩耍，一起慶祝彼此脫困。在臨走之前，小孩們向寇洛琳道謝，並且提醒她事情還沒了解，因為那頭怪物的執念太深，甚至追逐寇洛琳到這個世界來。寇洛琳從夢中醒來，隱約看見一隻手從椅子下竄出，在房間爬來爬去。被發現後，那隻手從房門逃走。寇洛琳恍然大悟，那是另一個媽媽的手，它想要奪走那把生鏽的鑰匙。</p><p>寇洛琳接連聽說那隻手到處闖禍的消息，史小姐和福小姐的蘇格蘭犬被莫名的生物抓傷，樓上波波先生（對，怪老頭的名字是波波先生）的老鼠也被神出鬼沒的野生動物嚇壞了。而寇洛琳自己，也會在夜半時，聽見指甲摩擦水管與窗戶的刺耳聲音，拉開窗簾，她甚至能看到那隻擦著紅色指甲油的手越過空中，躲到漆黑角落的殘影。</p><p>隔天，寇洛琳想到一個辦法。她借來野餐布和洋娃娃，還帶著鑰匙出門。為了讓另一個媽媽的手聽見，寇洛琳刻意向著屋內大喊自己要去庭院的古井附近玩家家酒。到了那口井之後，她挪開上頭的厚重木板，將野餐布鋪在上面，用裝了水的杯子沿著井口輕輕壓住野餐布。然後她一邊哼著歌，一邊把鑰匙放在野餐布的中央。</p><p>這時，那隻手正從樹林竄出，爬過草皮衝向那支鑰匙。寇洛琳假意沒看見那隻手，仍自顧自地跟玩偶說話，等到那隻手跳到井口中央時，水杯因為衝勁被打翻，讓鑰匙和那隻手失去支撐而跌落深處。寇洛琳確認井底發出「咚」」一聲，才把厚重的木板蓋上。因為她既不希望再有東西掉進去，也不願意看到有什麼東西從裡頭爬出來。</p><p>寇洛琳回到家，聽說史小姐和福小姐的狗的傷勢好轉；而波波先生的老鼠也恢復安寧，他說老鼠們已經做好準備，希望能請寇洛琳來看牠們的表演。那隻高傲的黑貓，如今也接納了寇洛琳，還肯露出肚子讓她幫忙抓癢。隔天就要開學了，媽媽買來的制服放在她的椅子上。以往，寇洛琳總會對開學感到緊張害怕，不過經歷了這麼多冒險，她發現自己現在還能感到放鬆。</p><p>那晚，她在床上躺著，幻想自己和那三個小孩在庭園的草原野餐，聽著從樓上傳來交響樂的聲響。在悠悠的晚風下，寇洛琳微笑地睡著。</p><hr><p>尼爾．蓋曼（2023）。第十四道門（馮瓊儀譯）。皇冠。（原著出版於 2002 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我的職業是網路小說家：韓國人氣作家的致富寫作教室》</title>
      <link href="/jeong-2021-i-make-a-living-by-writing-webnovels/"/>
      <url>/jeong-2021-i-make-a-living-by-writing-webnovels/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我們的競爭對手不是綜合榜的暢銷書，而是YouTube、網路漫畫、遊戲、Netflix等。下班回家的路上，在客滿的地鐵裡用手機看網路小說的讀者，因為周邊環境嘈雜，再加上一整天上班後的疲勞，使得他們的眼睛十分乾澀。你覺得他們會想看哪種句子呢？</p></blockquote><blockquote><p>讀者要的是趣味性！還有情感的宣洩！以及能夠讓他們忘記苦澀人生的汽水！網路小說家則是販售趣味性的人，所以商業價值當然比文學性來得重要。……網路小說是個完全繞著讀者轉的市場。</p></blockquote><p>鄭穆尼（2021），我的職業是網路小說家：韓國人氣作家的致富寫作教室。</p><span id="more"></span><p>作者鄭穆尼是韓國一名網路小說家。據她所述，她從小就有撰寫文章的習慣，也屢次在各大文藝獎獲獎。不過在獲頒新春文藝獎得獎以後，卻遲遲未能出道。不過她仍夢想自己能以寫作維生，於是毅然決然地投入陌生的網路小說領域，經過退稿、惡評、乏人問津等掙扎，終於以網路小說家的身分出道，獲得一筆堪比正職的收入。</p><p>這本書是作者的經歷總結，內容涵蓋從事網路寫作營利的方方面面，介紹了網路小說與紙本小說的差異、韓國網路小說的平台與生態、出道與發跡的途徑、寫作與投稿的指引以及職業小說家的心態調整等等。作者也大方在書中附上自己作品的企劃書為範例，解釋投稿出版的要點與訣竅。</p><p>不過從書中的描述得知，韓國的網路小說市場比台灣熱絡許多，不僅平台的營利模式較為成熟，讀者的基數也很龐大。一部出色的網路小說在簽約後，除了作品本身的收入以外，還有機會改編漫畫、動畫、影劇與電影等途徑擴大收益。雖然我們能透過這些介紹了解韓國網路小說的現況，可是對於打算以中文寫作的讀者幫助有限。如果想多了解台灣的網路小說現況，或是素人作家的出道途徑，可以參考熱心網友的資訊統整與心路歷程：</p><table><thead><tr><th>類型</th><th>作者</th><th>標題</th></tr></thead><tbody><tr><td>平台介紹</td><td>佐渡遼歌</td><td><a href="https://home.gamer.com.tw/creationDetail.php?sn=5881155">台灣小說平台的使用心得【2024年版本】</a></td></tr><tr><td>出版途徑</td><td>risedance</td><td><a href="https://www.ptt.cc/bbs/eWriter/M.1652841658.A.3D8.html">從網路寫作到出版的閒聊</a></td></tr><tr><td>出版途徑</td><td>maktubyu</td><td><a href="https://www.ptt.cc/bbs/eWriter/M.1670141938.A.076.html">出書心得《我不是怪物》與寫作歷程分享</a></td></tr><tr><td>出版途徑</td><td>ann1201</td><td><a href="https://www.ptt.cc/bbs/eWriter/M.1667469033.A.2F0.html">素人投稿蓋亞到成功出版的分享</a></td></tr><tr><td>產業現況</td><td>hermis</td><td><a href="https://www.ptt.cc/bbs/CFantasy/M.1689645302.A.14B.html">Re: [閒聊] 倒底台灣不能吸引中文圈作者的問題在那?</a></td></tr></tbody></table><p>除了出版、簽約與出道等經營層面，這本書的另一部份則與讀者分享了撰寫網路小說需要的觀念、心態、能力與訓練。如果要我總結，那麼全書最重要的觀念莫過於「讀者至上」。網路小說成功與否取決於吸引到多少讀者，而不是突破了哪些文學觀念；衡量網路小說價值的是流量與收益，而不是文學性。</p><p>不過，實際上也有許多打入主流且兼具文學性的作品，所以作者強調這番話並不是貶低網路小說的意義，而是釐清它的定位。想寫出讓自己也能感動或欣賞的作品是很棒的動機，可是寫作時仍要衡量個人抱負與讀者期待之間的距離。畢竟，不受讀者青睞的作品，是無法獲得流量，更遑論收益了。</p><p>這也是為什麼暢銷的網路小說往往招來刻板、老套等印象：因為它們忠實反映了讀者根深柢固的愛好。畢竟，喜怒哀樂等情緒與生離死別等經歷，是人類共同的難題，所以在大眾喜好的故事中，難免會找到類似的影子。因此，並非小說家喪失創新的本領，而是他們盡責地滿足讀者渴望的情感衝擊與救贖。</p><p>儘管如此，情節老套不代表內容生硬。暢銷故事固然可以被歸納出幾種熟悉的模式，但是填充情節的場景描繪、人物對話與性格塑造等細節差異就能營造不同的滋味。老套的故事結構搭配新鮮的敘事細節，正是網路小說雖然表面上雷同，卻能一再推陳出新，吸引讀者買單的原因。</p><p>綜上所述，如果想要在市場生存，一名網路寫作者就不能只憑自己的直覺來決定寫作主題與體裁，還要配合流行趨勢的分析來評估作品的潛力。趨勢分析越精準，也越能把握可以吸引讀者的題材。雖然這種能力仰賴個人閱歷，但是作者以自身經驗提供了幾個閱讀小說時能格外留意的細節：</p><ul><li>如何設定標題？這些標題透過哪些機制吸引讀者？又引發了讀者什麼情緒？</li><li>出版社怎麼行銷這部作品？他們怎麼撰寫吸引人的作品概述？又為作品貼上哪些標籤？</li><li>故事怎麼開頭？運用了哪些元素留住讀者的專注力？</li><li>每一章節的篇幅如何？場景間怎麼流暢地轉換？怎麼設計每一章的結尾，讓讀者願意讀下去？</li><li>如何展現角色魅力？最能讓讀者感受角色形象的是那些橋段與敘述？</li><li>故事大致遵循怎麼樣的結構？它是常見的結構嗎？小說家是怎麼在熟悉的結構創造新鮮感？</li></ul><p>至於網路小說的典型結構、寫作技巧與練習方式等技術細節，作者也提點了不少。我覺得其中最常被輕忽的訣竅是「區分寫草稿和改文章的心態」。剛從讀者的身分轉換為作者的身分時，往往會以為在第一次下筆時，就要寫出能夠出版的內容。然而，這本書的作者澄清，完成草稿只是寫作的門檻，仍要後續的修改與編輯，才能讓作品脫胎換骨。</p><p>寫作通常是撰寫與修改的迭代。期望在撰寫故事的同時，還能毫無瑕疵地安排劇情或用字遣詞，毋寧是一廂情願的想法。一般人抱持這樣的心態，很容易過於倚重修改，反而耽誤了寫作進度。作者建議，一旦設定好寫作目標（字數、範圍或章節等）與內容（情節與對話等），就要全神貫注地寫作，直到完成預定進度才可停筆。</p><p>這段期間的目標是讓寫作的速度跟上思考的速度（反之亦然），讓自己拋開任何寫作理論的框架，不要擔心情節是否合理、用字是否精確、內容是否誘人等問題。這些煩惱都等到達成目標後，再冷靜下來仔細分析與修改。</p><p>當然，人們總會面臨寫不出東西的窘境。要克服這個難關有賴寫作者日常的積累與練習，這意味著盡情地去享受生活、激發自己的好奇心、樂於沉浸在幻想的世界中無法自拔——畢竟對於作家而言，沒有無用的經歷，要學著尋找只有自己看得到的細節，從中看出故事感。</p><p>此外，人的記憶有限，所以除了用心活著，還要勤於寫筆記，把當下多維的五感體驗，刻劃在線性的文字裡面。作者建議，可以先從所見所聞開始，漸漸在事實之外添加自己的想法，直到熟練於摘要、重組和具現化所觀察到的內在與外在世界。</p><p>如果對自己的文筆沒信心，那麼參考優秀作家的筆法也是很好的練習途徑。讀書時，隨手畫記值得參考的片段，抄錄在筆記本中分門別類，再透過重述這些片段來磨練自己的寫作能力。往後需要描述特定的情感或場景時，就有一座豐富的語料供自己參考了。</p><p>我相當認同作者的建議。這一、兩年，我刻意迴避談論寫作方法的著作。主要原因在於，即使我花了許多時間熟悉撰寫特定文體的訣竅，等到需要動筆時，腦袋還是時常一片空白，或是陷入修改文字的迴圈，遲遲推進不了進度。</p><p>我體會到，無論寫小說、技術文章還是旅行遊記，寫作是一個持續把自己掏空，將思想與經驗轉換為文字的過程。如果腦中沒有想法與經驗，或是無力傳達所思所想，即使熟悉寫作的理論與架構，要完成一部作品仍是一場煎熬。</p><p>意識到這種情形以後，雖然我偶爾還是會從寫作書得到一些鼓勵，或是學到解讀作品的新鮮觀點，不過在學習寫作方面，還是採取「多讀多寫」策略。畢竟，有時我們欠缺的是表達的習慣，而不是鑑賞與分析表達內容的能力。我相信優秀作品本身就是很棒的導師，它們比理論更具體也更容易模仿與轉化為個人的經驗。透過比較自己總結的經驗和書中主張的結論，我期待能激發更多寶貴想法，並從中找到適合自己的實踐方式。</p><p>這本書的最後，作者提到了資質與努力之爭。我也認同作者的想法，資質固然不是成功的保證，但這也不表示努力就能克服一切。對於寫作（或其他職涯）的選擇，每個人都有各自背負的事情。只要考慮清楚並為自己負責，那麼無論最終要繼續前進或果斷放棄，在作者眼裡都是耀眼的決定。她以過來人的經驗提醒讀者，感到著急或自我懷疑都是稀鬆平常的事，但一定要記得：只要你曾動念寫一則自己的故事，那你已經擁有成為作家最珍貴的資質。所以，「加油！你一定可以的！」</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Open Reading Frames (ORF)</title>
      <link href="/open-reading-frames/"/>
      <url>/open-reading-frames/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一條以 FASTA 格式儲存的 DNA 序列，依據它的 open reading frames，列出所有可能由這條 DNA 序列轉譯出的蛋白質序列。</p><blockquote><p>An open reading frame (ORF) is one which starts from the start codon and ends by stop codon, without any other stop codons in between. Thus, a candidate protein string is derived by translating an open reading frame into amino acids until a stop codon is reached.</p><p>Given: A DNA string s of length at most 1 kbp in FASTA format.</p><p>Return: Every distinct candidate protein string that can be translated from ORFs of s. Strings can be returned in any order.</p></blockquote><p>(<a href="https://rosalind.info/problems/orf/">https://rosalind.info/problems/orf/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>在合成蛋白質時，核醣體會以三個核苷酸一組讀取 RNA 序列，添加各組核苷酸對應的胺基酸。核醣體開始讀取 RNA 序列的位置，會影響核苷酸的分組方式以及隨後轉譯出的蛋白質種類。由於 RNA 密碼子的長度為三，所以依據開始讀取序列的位置，每條 RNA 都會有三種劃分核苷酸的方式。</p><p>如下所示，這樣將核酸序列依照密碼子長度劃分，讓核醣體讀取的方式，被稱作 reading frame。每個 reading frame 都定義了一個從不同核苷酸開始讀取的密碼子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AAA GGG CCC</span><br><span class="line">A AAG GGC CC</span><br><span class="line">AA AGG GCC C</span><br></pre></td></tr></table></figure><p>相較於 RNA，DNA 兩股序列的任一股都可能轉錄為 RNA 並且轉譯為蛋白質。因此，每條 DNA 有六種可能的 reading frame，其中三種來自順向股，另外三種則來自逆向股的 reverse complemnt。DNA 這六種 reading frame 對應的蛋白質序列叫做 six-frame translating sequences。</p><p>以下表格呈現了 DNA 序列 <code>AAAGGGCCC</code> 的 six-frame translating sequences，感興趣的人可以到<a href="https://www.bioline.com/media/calculator/01_13.html">這個網頁</a>試試看怎麼計算。</p><table><thead><tr><th></th><th>translation in forward direction</th><th>translation in reverse direction</th></tr></thead><tbody><tr><td>frame 1</td><td>KGP</td><td>GPF</td></tr><tr><td>frame 2</td><td>KG</td><td>GP</td></tr><tr><td>frame 3</td><td>RA</td><td>AL</td></tr></tbody></table><p>Open reading frames (ORFs) 則是指 DNA 序列中，可能轉錄為 RNA 並且轉譯為蛋白質的片段。具體地說，ORFs 是由起始密碼子（<code>ATG</code>）延伸至終止密碼子（<code>TAG</code>、<code>TGA</code>、<code>TAA</code>）的區域。</p><p>辨識基因體 ORFs 和 six-frame translating sequences 是尋找蛋白質譯碼基因的重要步驟。在許多臨床與研究場合，DNA 資料比起 RNA 或蛋白質資料更容易取得（或更經濟實惠），研究人員只能依賴 ORFs 和 six-frame translating sequences 來預測蛋白質譯碼基因，已進行功能分析或是基於蛋白質序列比較的親緣關係分析。</p><p>例如在癌症基因檢測中，通常只對部分腫瘤熱點的 DNA 進行定序，再透過變異分析和註解來研究致病或治療相關的基因體功能變化。在微生物總基因體研究（metagenomics）中，也是透過定序環境 DNA 以及隨後的物種註解來普查群落的組成。</p><p>此外，在缺乏足夠基因體註解資訊的情況下，ORFs 和 six-frame translating sequences 能成為尋找新的譯碼基因或預測基因功能的依據。而相較於 six-frame translating sequences，ORFs 更有機會反映真實的蛋白質譯碼基因，所以使用 ORFs 進行後續分析時，能減少數據分析的雜訊，降低計算的複雜性。</p><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>這題要求從 FASTA 檔案讀取一條 DNA 序列，再列出它所有的 ORFs 對應的蛋白質序列。這一種情況與<a href="https://5uperb0y.com/translating-rna-into-protein/">轉譯 mature mRNA 那題</a>的情境不同。在真核生物的基因體中，有許多不參與蛋白質表現的 DNA，例如內含子、偽基因和調控子等非譯碼 DNA （non-coding DNA，它們有些不會被轉錄，有些則在轉錄後被切除，這導致 DNA 序列和實際會被轉譯出蛋白質的 mature mRNA 序列有所不同。</p><p>即使 mRNA 能忠實地保留 DNA 的大部分序列，read frame 也取決於起始密碼子的位置。以 DNA 序列 <code>ATGCATGTAA</code> 為例，從前後兩個起始密碼子轉譯會產生兩種不同的蛋白質序列，它們各自來自不同的 read frame。因此，直接從 DNA 序列預測蛋白質序列時，必須考慮所有可能的 read frames，以確保不遺漏任何潛在的 ORFs。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 從第一個起始密碼子開始轉譯</span><br><span class="line">ATG CAT GTA A</span><br><span class="line"># 從第二個起始密碼子開始轉譯</span><br><span class="line">. ... ATG TAA</span><br></pre></td></tr></table></figure><p>在此提供一個辨識 ORFs 的策略：</p><ol><li>由 5’ 到 3’ 一一讀取 DNA 序列。</li><li>讀到起始密碼子時，暫存它的座標，再記錄當下的 read frame。</li><li>如果碰到多個起始密碼子，都按步驟 2. 依照所在的 read frame 儲存它們的座標。</li><li>一旦碰到終止密碼子，就取出對應 read frame 的起始密碼子座標，直到取出所有暫存的座標。</li><li>ORFs 正是終止密碼子與起始密碼子之間的區域</li><li>持續讀取 DNA 序列直到最後一個核苷酸為止。</li></ol><p>接著再用同樣的流程讀取反向互補序列，就能得到 DNA 所有 read frame 的 ORFs。最後根據 DNA 密碼表把 ORFs 序列轉換為對應的蛋白質序列即可滿足題目要求。</p><h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>因為完成這題所需的幾項功能在先前的文章已經解釋過了，所以接下來我只會解釋要怎麼用 python 實作 ORFs 的辨識。解題的完整程式碼可參考<a href="https://github.com/5uperb0y/rosalind/blob/main/code/orf/orf.py">我的 github</a>。</p><table><thead><tr><th>功能</th><th>題目</th><th>連結</th></tr></thead><tbody><tr><td>讀取 FASTA 檔案</td><td>Finding a Shared Motif</td><td><a href="https://5uperb0y.com/finding-a-shared-motif/">Link</a></td></tr><tr><td>取得反向互補序列</td><td>Complementing a Strand of DNA</td><td><a href="https://5uperb0y.com/complementing-a-strand-of-dna/">Link</a></td></tr><tr><td>轉譯RNA序列</td><td>Translating RNA into Protein</td><td><a href="https://5uperb0y.com/translating-rna-into-protein/">Link</a></td></tr></tbody></table><p>我使用 orf_locs (list) 儲存所有 ORFs 的座標。為了暫存不同 read frame 上發現的起始密碼子座標，我建立了一個由 3 個 lists 組成的 list，start_locs。其中的三個 list 分別對應 DNA 序列三種可能的 read frame (0, 1, 2)。</p><p>在讀取 DNA 序列的過程中，透過將當前核苷酸的位置索引值對 3 取模數 ($position \mod 3$)，可以得知當前所在的 read frame 索引值。一旦遇到起始密碼子，將其座標存入 start_locs 對應 read frame 的 list；直到碰到終止密碼子，才把 start_locs 對應 list 的起始密碼子座標清空，與當前終止密碼子的座標組成 ORFs 區段，存入 orf_locs。</p><p>讀取完整條序列後，再根據 ORFs 座標擷取所有 ORFs 對應的 DNA 子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">orf</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Identifies all open reading frames (ORFs) from all read frames in a DNA sequence</span></span><br><span class="line"><span class="string">    that start with &#x27;ATG&#x27; and end with a stop codon (&#x27;TAA&#x27;, &#x27;TAG&#x27;, &#x27;TGA&#x27;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA sequence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list: A list of ORF sequences.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    orf_locs = []</span><br><span class="line">    start_locs = [[], [], []]</span><br><span class="line">    <span class="keyword">for</span> pos, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(dna):</span><br><span class="line">        frame = pos % <span class="number">3</span></span><br><span class="line">        codon = dna[pos: pos + <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> codon == <span class="string">&quot;ATG&quot;</span>:</span><br><span class="line">            start_locs[frame].append(pos)</span><br><span class="line">        <span class="keyword">elif</span> codon <span class="keyword">in</span> [<span class="string">&quot;TGA&quot;</span>, <span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;TAA&quot;</span>]:</span><br><span class="line">            <span class="keyword">while</span> start_locs[frame]:</span><br><span class="line">                orf_locs.append((start_locs[frame].pop(), pos))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> [ dna[i:j] <span class="keyword">for</span> i, j <span class="keyword">in</span> orf_locs ]</span><br></pre></td></tr></table></figure><h1 id="討論：open-reading-frame-的定義"><a href="#討論：open-reading-frame-的定義" class="headerlink" title="討論：open reading frame 的定義"></a>討論：open reading frame 的定義</h1><p>Open reading frame 一詞的字面意思是：”Frames that remain open to keep ribosome reading”，指的是核酸序列中未被終止密碼子中斷的一段區域。由於 ORFs 主要用於預測蛋白質譯碼基因，所以也衍伸出許多能用於設計演算法的操作型定義 (Sievar et al., 2018)</p><ul><li>定義1：ORFs 是指長度為 3 的倍數，而且介於起始密碼子和終止密碼子之間的序列。</li><li>定義2：ORFs 是指長度為 3 的倍數，而且介於兩組終止密碼子之間的序列。</li><li>定義3：ORFs 是介於核酸裁切位點之間的序列。</li></ul><p><img data-src="https://ars.els-cdn.com/content/image/1-s2.0-S0168952517302299-gr1.jpg"></p><p>（當中橘色線條標記的區域即為各種定義下的 ORFs，圖片來源：Sieber et al., 2018.）</p><p>在這些定義中，第一種最為常見，包含這道題目都採用起始和終止密碼子來定義 ORFs 的範圍。定義 1 適用於基因體結構相對單純的原核生物，但在應用於真核生物時會有些問題。</p><p>首先，位於內含子中的終止密碼子會導致 ORFs 短於實際可以轉譯出蛋白質的序列。其次，由於起始密碼子既作為開始轉譯的訊號，也是甲硫胺酸的密碼子，定義 1 在實務上難以區分這兩種狀況。</p><p>相較之下，定義 2 只考慮終止密碼子，因此可以避免起始密碼子帶來的混淆問題。此外，定義 2 所構成的 ORFs 能夠較全面涵蓋到外顯子的位置，因此 Sievar et al. 推薦使用定義 2。至於第三種定義，則要仰賴基因體註解資訊（通常是在基因預測之後的步驟），而且只能用於真核生物，並不是偵測 ORF 演算法的常見方式。</p><p>Sieber et al. (2018). The definition of open reading frame revisited. Trends in Genetics, 34(3), 167-170.</p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Translating RNA into Protein (PROT)</title>
      <link href="/translating-rna-into-protein/"/>
      <url>/translating-rna-into-protein/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>轉譯RNA字串為蛋白質字串</p><blockquote><p>Given: An RNA string s corresponding to a strand of mRNA (of length at most 10 kbp).</p><p>Return: The protein string encoded by s.</p></blockquote><p>(<a href="https://rosalind.info/problems/prot/">https://rosalind.info/problems/prot/</a>)</p><span id="more"></span><h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>mRNA 紀錄了由 DNA 轉錄而來的基因資訊，其上每三個核苷酸會對應到一個胺基酸或終止密碼子。在轉譯時，tRNA 會攜帶對應的胺基酸，以 mRNA 為模板，於核醣體合成蛋白質。</p><ul><li>genetic code：核苷酸 codon 及其轉譯時對應的胺基酸。</li><li>codon：密碼子，解讀遺傳密碼表的單位。mRNA 上每三個核苷酸為一個 codon。由於有 A、U、C、G 四種核苷酸，所以存在 4^3 &#x3D; 64 種 codon，對應著 20 種胺基酸和終止密碼子。</li><li>anticodon：即 codon 的互補序列。</li><li>start codon：起始密碼子，代表轉譯開始的訊號，會轉譯出 methionine。AUG 是常見的 start codon，但也有其他序列可啟動轉譯。</li><li>stop codons：終止密碼子，代表轉譯停止的訊號，不會轉譯出胺基酸。對應的核苷酸序列為 UAA&#x2F;UAG&#x2F;UGA。</li></ul><h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>轉譯的過程可分解為：構建密碼表、分割 mRNA 序列、查找密碼表、處理終止密碼子。</p><ul><li>構建密碼表：遺傳密碼需要以特定的資料型態（例如：list、hash table、table 等），儲存的型態會影響翻譯的方式。</li><li>分割 mRNA 序列：將 mRNA 切成三個一組的 codon，以逐一查找密碼表。</li><li>查找密碼表：逐一查詢 codon 對應的胺基酸，再傳接所有得出的胺基酸。</li><li>處理終止密碼子：由於終止密碼子不轉譯胺基酸，所以要移除終止密碼子以後的序列。</li></ul><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>密碼表可以 dictionary 儲存。python 的 dictionary 由數個 items 組成，每個 item 則包含 key 和 value 兩部分：value 是欲儲存的資訊，其資料型態可為數值、字串、list 甚或其他的 dictionary (nested dictionary)；而 key 則為查找 value 的依據，每個 key 對應一個 value。</p><p>dictionary 的特性是item無序性和資料型態可變性，前者意味著 dictionary 的 item 間沒有依照順序排列，因此無法依照索引取值；後者則是指可以透過新增、刪除、取代等操作改變 dictionary 內各 item 的內容。</p><p>詳細的 dictionary 介紹可參考<a href="https://selflearningsuccess.com/python-dictionary/">Python字典（dictionary）基礎與16種操作</a>和<a href="https://www.learncodewithmike.com/2019/12/python-dictionary.html">Python Dictionary完全教學一次搞懂</a>。在此題中，主要是應用 dictionary 的 key 和 value 互相查找的特性來儲存密碼表。</p><p>首先，依照取值策略，可以兩種方式儲存密碼表。第一種取值策略為正向索引，即透過 key 來查找 value，可以 codon 為 key，胺基酸為 value 儲存，轉譯時每三個字符從 dictionary 取值。在這張密碼表中，終止密碼子對應到空字串，表示它們不會轉譯出任何胺基酸。</p><h3 id="Get-values-by-keys"><a href="#Get-values-by-keys" class="headerlink" title="Get values by keys"></a>Get values by keys</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">rna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Translate a RNA string into a proten string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        rna (str): A RNA string composed of nucleotides (&#x27;U&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;G&#x27;), length must be a multiple of three.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        str: Amino acid sequence derived from the RNA</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    code = &#123;</span><br><span class="line">    <span class="string">&quot;UUU&quot;</span>: <span class="string">&quot;F&quot;</span>, <span class="string">&quot;UUC&quot;</span>: <span class="string">&quot;F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UUA&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;UUG&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUU&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUC&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUA&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUG&quot;</span>: <span class="string">&quot;L&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AUU&quot;</span>: <span class="string">&quot;I&quot;</span>, <span class="string">&quot;AUC&quot;</span>: <span class="string">&quot;I&quot;</span>, <span class="string">&quot;AUA&quot;</span>: <span class="string">&quot;I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AUG&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GUU&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUA&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUC&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUG&quot;</span>: <span class="string">&quot;V&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UCU&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCC&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCA&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCG&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;AGU&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;AGC&quot;</span>: <span class="string">&quot;S&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CCU&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCC&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCA&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCG&quot;</span>: <span class="string">&quot;P&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ACU&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACC&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACA&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACG&quot;</span>: <span class="string">&quot;T&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GCU&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCC&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCA&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCG&quot;</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UAU&quot;</span>: <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;UAC&quot;</span>: <span class="string">&quot;Y&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CAU&quot;</span>: <span class="string">&quot;H&quot;</span>, <span class="string">&quot;CAC&quot;</span>: <span class="string">&quot;H&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CAA&quot;</span>: <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;CAG&quot;</span>: <span class="string">&quot;Q&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AAU&quot;</span>: <span class="string">&quot;N&quot;</span>, <span class="string">&quot;AAC&quot;</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AAA&quot;</span>: <span class="string">&quot;K&quot;</span>, <span class="string">&quot;AAG&quot;</span>: <span class="string">&quot;K&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GAU&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;GAC&quot;</span>: <span class="string">&quot;D&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GAA&quot;</span>: <span class="string">&quot;E&quot;</span>, <span class="string">&quot;GAG&quot;</span>: <span class="string">&quot;E&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGU&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;UGC&quot;</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGG&quot;</span>: <span class="string">&quot;W&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CGU&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGA&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGC&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGG&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;AGA&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;AGG&quot;</span>: <span class="string">&quot;R&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GGU&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGA&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGC&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGG&quot;</span>: <span class="string">&quot;G&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGA&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;UAG&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;UAA&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    protein = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> code.get(rna[pos: pos + <span class="number">3</span>], <span class="string">&quot;&quot;</span>):</span><br><span class="line">        protein = protein + code.get(rna[pos: pos + <span class="number">3</span>], <span class="string">&quot;&quot;</span>)</span><br><span class="line">        pos = pos + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> protein</span><br></pre></td></tr></table></figure><p>終止密碼子會讓轉譯進度提前結束，為了處理這種情況，我使用 while 來控制迴圈的執行。</p><ul><li>轉譯到終止密碼子：終止密碼子對應到空字串，於是迴圈停止。</li><li>轉譯到RNA尾端：list slicing 在索引值超出範圍時不會報錯，而只會回傳空字串，於是迴圈照樣停止。</li></ul><p>透過這兩種機制，我就能讓轉譯在碰到終止密碼子或RNA尾端時自然結束。</p><h3 id="Get-keys-by-values-in-list-form"><a href="#Get-keys-by-values-in-list-form" class="headerlink" title="Get keys by values (in list form)"></a>Get keys by values (in list form)</h3><p>第二種取值策略則為逆向索引，即透過 value 來查找 key，可以胺基酸為 key，codon 為 value 儲存。由於 value 為 list 形式，無法直接取值，所以定義 function 來判斷 codon 是否位於 value 並回傳對應的 Key：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_val</span>(<span class="params">d, target</span>):</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> val:</span><br><span class="line">            <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure><p>而實踐轉譯的方式則是利用 for 依序找出所有 codon 對應的胺基酸，並在每次迴圈延伸已知的蛋白質序列。相較於第一種方式，這方法會用到兩個迴圈，第一個迴圈用以尋找 value，第二個迴圈則用以取出所有 codon 對應的 key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;F&quot;</span>: [<span class="string">&quot;UUU&quot;</span>, <span class="string">&quot;UUC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;L&quot;</span>: [<span class="string">&quot;UUA&quot;</span>, <span class="string">&quot;UUG&quot;</span>, <span class="string">&quot;CUU&quot;</span>, <span class="string">&quot;CUC&quot;</span>, <span class="string">&quot;CUA&quot;</span>, <span class="string">&quot;CUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;I&quot;</span>: [<span class="string">&quot;AUU&quot;</span>, <span class="string">&quot;AUC&quot;</span>, <span class="string">&quot;AUA&quot;</span>],</span><br><span class="line">    <span class="string">&quot;M&quot;</span>: [<span class="string">&quot;AUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;V&quot;</span>: [<span class="string">&quot;GUU&quot;</span>, <span class="string">&quot;GUA&quot;</span>, <span class="string">&quot;GUC&quot;</span>, <span class="string">&quot;GUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: [<span class="string">&quot;UCU&quot;</span>, <span class="string">&quot;UCC&quot;</span>, <span class="string">&quot;UCA&quot;</span>, <span class="string">&quot;UCG&quot;</span>, <span class="string">&quot;AGU&quot;</span>, <span class="string">&quot;AGC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;P&quot;</span>: [<span class="string">&quot;CCU&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CCA&quot;</span>, <span class="string">&quot;CCG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;T&quot;</span>: [<span class="string">&quot;ACU&quot;</span>, <span class="string">&quot;ACC&quot;</span>, <span class="string">&quot;ACA&quot;</span>, <span class="string">&quot;ACG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: [<span class="string">&quot;GCU&quot;</span>, <span class="string">&quot;GCC&quot;</span>, <span class="string">&quot;GCA&quot;</span>, <span class="string">&quot;GCG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;Y&quot;</span>: [<span class="string">&quot;UAU&quot;</span>, <span class="string">&quot;UAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;H&quot;</span>: [<span class="string">&quot;CAU&quot;</span>, <span class="string">&quot;CAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;Q&quot;</span>: [<span class="string">&quot;CAA&quot;</span>, <span class="string">&quot;CAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;N&quot;</span>: [<span class="string">&quot;AAU&quot;</span>, <span class="string">&quot;AAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;K&quot;</span>: [<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;AAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;D&quot;</span>: [<span class="string">&quot;GAU&quot;</span>, <span class="string">&quot;GAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;E&quot;</span>: [<span class="string">&quot;GAA&quot;</span>, <span class="string">&quot;GAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;C&quot;</span>: [<span class="string">&quot;UGU&quot;</span>, <span class="string">&quot;UGC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;W&quot;</span>: [<span class="string">&quot;UGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;R&quot;</span>: [<span class="string">&quot;CGU&quot;</span>, <span class="string">&quot;CGA&quot;</span>, <span class="string">&quot;CGC&quot;</span>, <span class="string">&quot;CGG&quot;</span>, <span class="string">&quot;AGA&quot;</span>, <span class="string">&quot;AGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;G&quot;</span>: [<span class="string">&quot;GGU&quot;</span>, <span class="string">&quot;GGA&quot;</span>, <span class="string">&quot;GGC&quot;</span>, <span class="string">&quot;GGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&quot;</span> : [<span class="string">&quot;UGA&quot;</span>, <span class="string">&quot;UAG&quot;</span>, <span class="string">&quot;UAA&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">rna, code</span>):</span><br><span class="line">    p = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [s[i:i+<span class="number">3</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">3</span>)]:</span><br><span class="line">        p += find_val(code, i)</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>在 R 中，則可以用 list 儲存密碼表。 list 可以儲存不同類型的資料型態（例如：整數、浮點數、邏輯、向量等），每個儲存的元素皆有其編號，可以透過元素的索引值取值。除了固有的編號，也能於創建 list 時為元素命名，以便使用名稱取值。</p><p>在此題中，是利用 list 能同時紀錄內容和其名稱的特性來儲存密碼表。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># extract a element by index</span></span><br><span class="line"><span class="operator">&gt;</span> l <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>l<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># extract a element by name</span></span><br><span class="line"><span class="operator">&gt;</span> l <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span> <span class="operator">=</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span> <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>l<span class="punctuation">[[</span><span class="string">&quot;A&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;dog&quot;</span></span><br></pre></td></tr></table></figure><p>示範數據如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rna <span class="operator">&lt;-</span> <span class="string">&quot;AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA&quot;</span></span><br></pre></td></tr></table></figure><p>首先，定義將 mRNA 序列三個一組分為 codon 的副程式。簡言之，以 strsplit 將字串切割為由 list 儲存且長度為三字符的一批短字串[4]，再用 unlist 將之轉換為 vector [5]。 其他寫法可參考 <a href="https://statisticsglobe.com/split-character-string-into-chunks-in-r">Split Character String into Chunks in R (2 Examples)</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunks <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>s<span class="punctuation">,</span> n<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  unlist<span class="punctuation">(</span>strsplit<span class="punctuation">(</span>s<span class="punctuation">,</span> paste0<span class="punctuation">(</span><span class="string">&quot;(?&lt;=.&#123;&quot;</span><span class="punctuation">,</span> n<span class="punctuation">,</span> <span class="string">&quot;&#125;)&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接著同樣可依照取值策略循兩種方式儲存密碼表。第一種是正向索引，以 codon 為名，胺基酸為元素，將密碼表存為 list。接著，以 lapply 依序對照密碼表，取出 codon 對應的胺基酸字符，再用 paste0 接合為蛋白質字串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">code <span class="operator">&lt;-</span>  </span><br><span class="line">  <span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">  <span class="string">&quot;UUU&quot;</span><span class="operator">=</span> <span class="string">&quot;F&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUC&quot;</span><span class="operator">=</span> <span class="string">&quot;F&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UUA&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUG&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUU&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUC&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUA&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUG&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AUU&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUC&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUA&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AUG&quot;</span><span class="operator">=</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GUU&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUA&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUC&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUG&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UCU&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCC&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCA&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCG&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGU&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGC&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CCU&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCC&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCA&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCG&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;ACU&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACC&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACA&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACG&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GCU&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCC&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCA&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCG&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UAU&quot;</span><span class="operator">=</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAC&quot;</span><span class="operator">=</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CAU&quot;</span><span class="operator">=</span> <span class="string">&quot;H&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAC&quot;</span><span class="operator">=</span> <span class="string">&quot;H&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CAA&quot;</span><span class="operator">=</span> <span class="string">&quot;Q&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAG&quot;</span><span class="operator">=</span> <span class="string">&quot;Q&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AAU&quot;</span><span class="operator">=</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAC&quot;</span><span class="operator">=</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AAA&quot;</span><span class="operator">=</span> <span class="string">&quot;K&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAG&quot;</span><span class="operator">=</span> <span class="string">&quot;K&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GAU&quot;</span><span class="operator">=</span> <span class="string">&quot;D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAC&quot;</span><span class="operator">=</span> <span class="string">&quot;D&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GAA&quot;</span><span class="operator">=</span> <span class="string">&quot;E&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAG&quot;</span><span class="operator">=</span> <span class="string">&quot;E&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGU&quot;</span><span class="operator">=</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UGC&quot;</span><span class="operator">=</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGG&quot;</span><span class="operator">=</span> <span class="string">&quot;W&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CGU&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGA&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGC&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGG&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGA&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGG&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GGU&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGA&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGC&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGG&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGA&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAG&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAA&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">transl <span class="operator">&lt;-</span> <span class="keyword">function</span> <span class="punctuation">(</span>rna<span class="punctuation">,</span> code<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>paste0<span class="punctuation">(</span>lapply<span class="punctuation">(</span>chunks<span class="punctuation">(</span>rna<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span>code<span class="punctuation">[[</span>x<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第二種則是逆向索引，以胺基酸為名，codon 為元素，將密碼表存為 list。要注意的是，由於無法以空字符命名，所以這種儲存方法要把終止密碼子命名為其他符號，最後再把終止密碼子的符號從輸出的蛋白質序列中刪除。</p><p>簡言之，利用 lapply 遍歷所有 codon，以 grep 判斷 codon 位於 list 何處，藉此取出對應的胺基酸字符，使用 paste0 接合為蛋白質字串。最後以 gsub 配合正則表達式移除終止密碼子的符號及其後的序列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">code <span class="operator">&lt;-</span> </span><br><span class="line">  <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;F&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;L&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;I&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUA&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;M&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;V&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;S&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;P&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;T&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ACU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;A&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;Y&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;H&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;Q&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;N&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;K&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;D&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;E&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;C&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UGC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;W&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;R&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;G&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;*&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAA&quot;</span><span class="punctuation">)</span></span><br><span class="line">       <span class="punctuation">)</span></span><br><span class="line">transl <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>rna<span class="punctuation">,</span> code<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  p <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span>lapply<span class="punctuation">(</span>chunks<span class="punctuation">(</span>rna<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span><span class="built_in">names</span><span class="punctuation">(</span>code<span class="punctuation">)</span><span class="punctuation">[</span>grep<span class="punctuation">(</span>x<span class="punctuation">,</span> code<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">  p <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&quot;\\*.*?$&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span> p<span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>p<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="Biology-Translation"><a href="#Biology-Translation" class="headerlink" title="Biology: Translation"></a>Biology: Translation</h2><p>遺傳密碼的模式有很多故事可以探討，例如「為什麼遺傳密碼以三個一組為單位？」、「為什麼遺傳密碼與蛋白質非一對一關係？」、「為什麼遺傳密碼中，第三個鹼基比較無專一性？」等問題，這些問題反映了生命演化出遺傳密碼的蛛絲馬跡。這些資訊可參考書籍《生物決定論》或 Koonin &amp; Novozhilov. (2009). Origin and evolution of the genetic code: the universal enigma. IUBMB life, 61(2), 99-111.</p><p>而遺傳密碼破譯前，也有許多高明的見解和理論想解釋轉譯的模式，可以參考《創世第八天》。</p><h2 id="Python-List-comprehension"><a href="#Python-List-comprehension" class="headerlink" title="Python: List comprehension"></a>Python: List comprehension</h2><p>List comprehension 可簡化程式碼，將 for 迴圈輸出值儲存到 list 中，其結構為：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expression for item in iterable (if-else statement)]</span><br></pre></td></tr></table></figure><ul><li>expression：可為運算式或取值</li><li>item：Iterable Object 之元素</li><li>iterable：Iterable Object</li><li>if-else statement：條件判斷，即 item 符合條件才執行 expression</li></ul><p>以下列出不同類型 expression 的範例：</p><p>value extraction</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; l = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">&gt; o = [l[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(l), <span class="number">2</span>)]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><p>computation</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; n = [i*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] </span><br><span class="line">&gt; <span class="built_in">print</span> n</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>computation with if-else statement</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; n = [i*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> i &gt; <span class="number">2</span>] </span><br><span class="line">&gt; <span class="built_in">print</span> n</span><br><span class="line">[<span class="number">9</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><p>詳細介紹可參考 <a href="https://www.learncodewithmike.com/2020/01/python-comprehension.html">Python Comprehension語法應用教學</a></p><h2 id="Python-“”-join-的使用方法"><a href="#Python-“”-join-的使用方法" class="headerlink" title="Python: “”.join() 的使用方法"></a>Python: “”.join() 的使用方法</h2><p>join() 可將 list 內的各元素依照指定分隔符連接為字串，寫法為</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;sep&quot;.join(list)</span></span><br><span class="line">&gt; <span class="built_in">print</span> <span class="string">&quot;,&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">A,B,C</span><br><span class="line">&gt; <span class="built_in">print</span> <span class="string">&quot;_&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">A_B_C</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="R-strsplit-如何切割無符號分隔的字串？"><a href="#R-strsplit-如何切割無符號分隔的字串？" class="headerlink" title="R: strsplit 如何切割無符號分隔的字串？"></a>R: strsplit 如何切割無符號分隔的字串？</h2><p>strsplit 可依照指定分隔符將字串切割為一批以 list 儲存的短字串，使用方法為：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strsplit(s, sep)</span></span><br><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A_B_C_D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;_&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br></pre></td></tr></table></figure><p>倘若字串中沒有規律出現的符號（例如：mRNA 序列，”AUCGAUCGA”），可以使用正則表達式的 positive lookbehind 概念來解決。</p><p>positive lookbehind 的形式如下，意思是尋找前位字串符合 pattern 的 y。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;=pattern)y</span><br></pre></td></tr></table></figure><p>例如在以下範例中，就是把前位字符為「1」的「A」取代為「B」，而前位字符不符合條件者則不受影響</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> gsub<span class="punctuation">(</span><span class="string">&quot;(?&lt;=1)A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1A2A3A1A2A3A&quot;</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;1B2A3A1B2A3A&quot;</span></span><br></pre></td></tr></table></figure><p>在了解 positive lookbehind 的意思之後，即可解釋以下程式碼的運作原理。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;AUCGAUCGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;(?&lt;=.&#123;3&#125;)&quot;</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;AUC&quot;</span> <span class="string">&quot;GAU&quot;</span> <span class="string">&quot;CGA&quot;</span></span><br></pre></td></tr></table></figure><p>此處 「(?&lt;&#x3D;.{3})」 的涵義其實是 「(?&lt;&#x3D;.{3})””」，表示「尋找前位為字串長三個字符的空字符」， 換句話說，此程式碼先以 positive lookbehind 表達式取出預計切割位置的空字符「””」，再以 strsplit 將這些空字符當作分隔符，將輸入字串切割為一批短字串。</p><h2 id="R-為什麼要以-unlist-處理-strsplit-的輸出結果？"><a href="#R-為什麼要以-unlist-處理-strsplit-的輸出結果？" class="headerlink" title="R: 為什麼要以 unlist 處理 strsplit 的輸出結果？"></a>R: 為什麼要以 unlist 處理 strsplit 的輸出結果？</h2><p>strsplit 原始輸出為 list 形式，所以需要使用 unlist 將之轉換為 vector 以利後續處理</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> unlist<span class="punctuation">(</span>strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夏子的冒險》</title>
      <link href="/mishima-1951-natsukos-adventure/"/>
      <url>/mishima-1951-natsukos-adventure/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>二十歲的松浦夏子是個言出必行的女孩，她有著一旦下定決心便不肯輕言放棄的頑固個性，七歲那年，她受夠了菠菜，她的筷子再也不曾沾過這種蔬菜；等到十五歲時，聽聞他人評論紅色不適合她，夏子便立誓不再穿紅色系的衣服，任誰來勸說也無法動搖她的決心。</p><p>（三島由紀夫（1951），夏子的冒險。）</p><span id="more"></span><p>夏子有張典型的南方人的臉孔——烏黑的頭髮、飽滿的雙唇、挺立的鼻樑、慵懶而性感的眼神、剽悍而狂熱的氣質。儘管夏子身邊不乏追求者，她卻對那些汲汲營營於追逐金錢地位的都市青年感到乏味。她像觀察昆蟲般審視每個男人，將他們分門別類：這個只顧著怎麼爬上更高的職位，那個對教授、處長等頭銜著迷；還有些人以為只要開著跑車和送上禮物就能博得她的歡心。</p><p>上班族普遍乏味無趣，藝術家看似與眾不同卻也俗不可耐、少爺郎態度窩囊又過於天真。雖然這些男人的職業、背景、外表與人格各有不同，他們卻無一例外地缺乏強烈的熱情和迷人的神采。有次，一位名叫阿誠的青年端著一組房屋模型，向夏子描述著如果他們結婚成家，往後的日子該會有多少憧憬。</p><p>然而，他所幻想的正是夏子最唾棄的人生，被判處名為「家庭」的有期徒刑，關押在由玫瑰花、瓦屋頂和紅磚門柱所築起的囹圄之中，重複如拷問般無聊而制式的家常對話三十年，直到對磁磚的裂痕和天花板的木紋皆瞭若指掌。</p><p>因此，儘管夏子熟稔吊人胃口的技巧，也經常對追求她的男性予以無關痛癢的憐憫，卻從沒有將他們放在心上，總是無情地拒絕眾人的追求。她堅信無論跟隨哪個男人走，‧最終的下場無非淪為獨自在家打理家務的黃臉婆，或是在酒宴上陪笑的交際花。兩種命運在她眼中都一樣乏味得無藥可救。</p><blockquote><p>唉，不管跟誰走，都不可能為愛賭上性命或是冒著生命危險。男人開口閉口總在抱怨時代糟糕、社會糟糕，卻沒發現最糟糕的其實是自己的眼中毫無熱情……</p></blockquote><p>就這樣，與其把自己獻給男人，不如把生命獻給神。於是，她在一日早晨向家人宣布，她打算進修道院。夏子早已對修道院與修女的故事耳熟能詳。函館的特拉普修道院的管教嚴謹、紀律分明，修女們必須穿著層次有序的外套、聖衣與胸圍，生活的色彩只剩下黑色與白色。在那裡，她那媚人的肉體遲早會消散，只留下純淨的靈魂，日復一日地隨鐘聲起床禮拜、祝禱、彌撒。對夏子而言，再也沒有什麼比在修道院內度過單調無聊的一輩子更值得挑戰、更無路可退、更令人膽怯顫慄的體驗了。</p><p>得知這消息，她的雙親、姑姑與祖母自然是大力反對，尤其是她的父親更是百思不解，從小便不情願做禮拜的夏子為什麼突然想要進修道院，還揚言自殺威脅家人不得阻撓她。深知夏子執拗性格的家人知道說再多話也是徒勞，反而改變想法，或許修道院的苦行能讓這任性的孩子學到一些教訓，於是轉而支持夏子的決定。</p><p>儘管抱著讓孩子見見世面的想法，但放不下心的母親、祖母和姑姑還是決定帶著大包小包行李，陪同夏子宜路前往函館近郊的修道院。送行的人群不勝其數，喧嘩聲迴響在月台，引來其他旅客側目。夏子對此並不在意，因為原先對熱情絕望的她，在送行隊伍的最末端，留意到一名拎著行李箱扛著獵槍的青年，他那雙熱絡地綻放光芒的雙眼，正目瞪口呆地望著踏上火車台階的她。那雙眼牢牢烙印在夏子心中，伴她進入夢鄉，讓她面紅耳赤、動心不已……</p><blockquote><p>夏子早上喜歡躺在床上，把枕邊的小鏡子拿到臉前，和自己進行沒營養的對話。<br>「妳已經醒了？」鏡中的她說。<br>「醒了。」<br>「今天一定會有什麼好事發生喔。」<br>「是嗎，真令人期待。是什麼事呢？」<br>「不能告訴妳。」」<br>「那我們晚上睡覺前再見吧。」<br>晚上，在梳妝臺前，<br>「妳背叛了我。什麼好事也沒發生。」<br>「ㄚ這個青年如何？」<br>「那種笨蛋完全不行。」<br>「可是如果愛上那個人，妳也能得到幸福。」</p></blockquote><p>之後，夏子在轉乘的渡輪上閒晃時，又撞見月台上的青年。這次，她仔細打量著他的五官，雖然他那雙深邃的雙眼看似在眺望海面，但實際上是聚焦在一個更遙遠、沉重而龐大的目標。他眼中燃燒著野性的熱情與非比尋常的堅定意志，正是熱情的證明。</p><p>看著那名青年，夏子不禁感慨，直到她即將離開俗世的最後一天，才終於見到自己嚮往已久的目光。儘管她已下定決心，內心深處還是渴望那名青年能把她從無趣的日常生活中拯救出來。就在這時，一陣海風吹過，把夏子手中的扇子吹過欄杆，落入波濤之中。那名青年全程目睹了整個經過，試圖伸手去撿，卻徒勞無功。</p><p>「我叫井田毅。」他說，除此之外，他也知道那把扇子是夏子準備加入修道院的餞別禮物，過了今天之後，他們就再也沒機會碰面了。於是，毅邀請夏子在函館市區見面，一起度過夏子在俗世的最後一天。夏子瞞著家人溜出旅館，和毅從市內的旅社漫步到函館山，沿路經過綠意盎然的神社，穿過蒼鬱樹林，兩人邊散步邊談天。在這一路上，夏子也終於知道毅扛著獵槍隻身來到北海道的原因：他眼中燒著的熾熱火光是被復仇給點燃，而他要尋求的對象，是一頭兇殘的食人熊。</p><p>毅自小追隨父親打獵，在父親因腦溢血過世之後，他為了排遣喪父之痛，獨自一人揹著獵槍來到北海道旅行。他在愛奴人的部落寄宿時，結識了十藏一家人，以及十藏美麗的養女秋子。在愛奴部落的那段日子裡，毅聽著十藏訴說他們獵捕熊的冒險故事，也得知秋子的身世——秋子是一名棄嬰，她的雙親在遺棄她不久便遇難身亡。毅與秋子在這段期間日漸親密，兩人相約下次見面時就要結為連理。不料，毅才回到東京便收到駭人的消息：秋子和她的姊妹們上山採藥時遭食人熊襲擊，秋子逃生不及最終被殘忍分屍而死。</p><p>部落挑選了十二名資深的獵人展開獵捕，卻毫無斬獲。備受打擊的毅努力工作累積長假，一聽到北海道某座牧場被熊襲擊的傳聞，他立刻向公司請假前往北海道，他早已下定決心，無論如何都要為秋子報仇。聽完毅這番不幸的經歷，夏子深深著迷於毅那強烈而純正的動機，於是打定主意要與他同行。她急忙回到旅館，趁著親人洗澡時偷溜出門，僅留下一張字條說明自己的去向，卻隱瞞了出走的理由。</p><blockquote><p>「我果然沒有看走眼。」<br>她暗想。此人可以理直氣壯做到世間認為最無意義的事情。他可以獻身於世人最瞧不起的感情。</p></blockquote><p>儘管夏子提出如此大膽的要求，毅還是不敢妄想一名素不相識的少女願意參與自己的復仇行動。因此，他雖然與夏子約定九點出發，卻在八點半就提早離開了。不過，夏子早已看透毅的的想法，事先打聽到毅的去向。在那班夜車的車廂裡，毅因為寒冷直打哆嗦，他拉起領子縮著脖子防寒的同時，也落寞地看著對面的空位低聲自語，似乎想驅趕腦中少女的身影。就在列車即將啟程之際，一聲溫柔的嗓音打斷毅的沉思，「這個位子有人坐嗎？」。毅抬起頭，夏子就站在他面前。</p><p>在札幌，兩人與毅在當地報社工作的朋友野口會合。此時毅仍想獨自前往，於是請野口幫忙牽制夏子，好讓自己能趁著她發電報報平安的空檔溜走。不料，夏子再次識破毅的計倆，她深知毅遲早會回頭找野口商議獵熊計畫，所以硬是纏在野口身邊不放，還要求他陪著自己在札幌市區閒晃、看電影、參觀植物園、漫步在白楊林道等。</p><p>夏子這番舉動反而讓野口對她產生迷戀之情，於是將毅想支開夏子的所有計畫全盤托出。得知確切消息的夏子難耐心中的喜悅，在野口家靜候毅上門。毅一回來便撞見和野口待在一起的夏子。從毅慍怒的表情，夏子察覺他的一絲醋意，這讓她喜不自勝。於是主動將事發經過和毅解釋清楚，才化解了他心中的疑慮。在百般無奈之下，毅只得帶上夏子一同前往據說遭熊襲擊的白老牧場。</p><p>然而，當他們抵達目的地時，已經晚了一步。牧場草地被鮮血染紅，馬匹的屍首與骨骸散落在被踐踏過的土塊、淤泥與碎裂的柵欄之間。從地上的四趾足印看來，兇手正是那頭殺害秋子的食人熊。夏子盯著毅滿懷怒意的眼睛，她明白在那視線裡絲毫容不下自己的存在。</p><p>當晚，夏子和毅於牧工小屋共寢，在冒險的緊張氛圍與一次次不經意的親密接觸下，讓毅對夏子產生了強烈的慾望，不過夏子斷然拒絕了毅的求愛。對她而言，最著迷的莫過於毅那副只為復仇而存在的模樣，她暗自祈禱在殺死那頭熊之前，毅能保持這樣的生存態度，不要因她而動搖與分心。</p><p>於此同時，待在旅館的松浦一家看完夏子留下的字條後心急如焚，要報警好像操之過急，要親自尋人也豪無線索可循。收到夏子派來的電報後，她們原本打算趕赴札幌接回夏子，但細想後卻感到進退兩難。若離開旅館，他們就收不到夏子下一次的消息；可若繼續守在這，又難以將她接回，天知道這任性的孩子會在外頭遭遇哪些麻煩。</p><blockquote><p>萬事和稀泥的姑姑，半帶哭腔地吸著鼻涕說，「我一個人留下來就是了。小夏如果不回來，我就代替她進修道院贖罪。從此永遠都不出來。以後妳們想起我時，就從二樓的陽臺眺望我所在的修道院那片天空吧。」</p></blockquote><p>情急之下，她們心生一計，先用重金委託旅館經理代為接收夏子的電報，三人立刻起身趕赴札幌。儘管她們的行動慢了一步，卻透過關係得到札幌日報總編輯的協助。一行人決定就地成立搜尋夏子的總部，一五一十地向向總編輯解釋夏子逃跑的前因後果。</p><p>正巧野口也在這時回到報社，他自告奮勇地向松浦一家和總編輯編說明事發的經過。聽聞夏子竟然為了一名男子而私奔，讓她們感到十分擔憂與錯愕。即使野口再三向她們保證男子的為人，也無法化解他們的不安與疑慮。在一番激烈的討論後，她們竟做出荒謬的決定，野口有義務出面把夏子帶回來。畢竟，如果不是因為野口對夏子的私情，夏子怎麼會有機會從札幌逃走呢？</p><p>在白老的牧場，野口打聽到了夏子的下落。當他前往鄰近的 Y 牧場時，竟然碰見了獨自一人的夏子。她向野口吐露想回家的念頭，野口才知道原來這段期間曾發生一段令夏子不悅的插曲。</p><p>在前往 Y 牧場的途中，夏子與毅認識了牧場主人的女兒不二子。不二子不但樣貌出眾，更有一股與外貌不符的野性和不可思議的氣質。在牧場寄宿的幾天哩，不二子不僅主動幫毅縫補衣服，還曾摸著他的臉說要幫忙刮鬍子，種種舉動親密得有些反常。夏子既不擅長料理，也不曉得如何做針線活，眼見不二子取代自己替毅打理生活起居，她不禁感到失落和不是滋味。更令夏子惴慄不安的是，她在不二子身上，隱隱約約看到她想像中秋子的模樣。</p><blockquote><p>那個女孩名叫不二子。第一次碰面，正好就是在今天野口在河岸遇到抓魚少年的那附近。當時兩人彎過河岸一角，就發現打赤腳的女孩坐在河中岩石上。<br>女孩洗完頭髮正在晾乾。頭髮已半乾，披散在肩上。河水非常冷。於是女孩把洋裝的裙襬撩起，赤足沒有浸在水中，而是放在距離她坐的岩石約有一尺遠布滿清台的石頭上。樹梢灑落的陽光照在濡濕發亮的潔白裸足上，彷彿穿了蕾絲襪子。而且這個不可思議的女孩，正在吟唱莫名其妙的歌。</p></blockquote><p>這是夏子有生以來第一次清晰地意識到自己所欠缺的東西。跟著野口回到牧場後，夏子當著眾人的面，賭氣地對毅說想回家，還咕噥說何不讓不二子代替自己陪著毅去獵捕那頭獵熊也未嘗不可。說著說著，夏子忍不住落下了委屈的眼淚。見狀夏子突如其來的情緒潰堤，毅和野口一時之間手足無措。此時，不識趣的不二子闖了進來，她擦拭著夏子的眼淚還開起了玩笑。夏子瞪著不二子質問她是否已經愛上了毅。</p><p>不二子聽完夏子的質問不禁笑了起來，雖然她自己或許沒能拿捏好與毅之間的關係距離，可是與其跟著不怎麼喜歡的對象去獵捕野獸，她反而更有興趣去幫助站在一旁備感無奈的野口。畢竟，如果夏子真的執意跟著毅，那麼任務失敗的野口在回到報社後，不免要被痛罵一頓還可能丟失飯碗。</p><p>不久，從報社派來的電報得知，那頭殘暴的四趾熊在支笏湖現身，還造成一人重傷。毅研判那頭熊已回到根據地，短時間內應該不會再大範圍移動了。為了把握這個良機，眾人再次啟程，一行人前往位於千歲的醫院探望那名遇襲的傷患。</p><p>由於千歲是通往札幌的中繼站，所以不二子和野口也一同前往。從傷患的口述，他們得知四趾熊的活動範圍，毅打算請求支笏湖周圍的愛奴部落協助，也委託野口到札幌向當地獵友會尋求支援。於是，毅和夏子一陸深入部落，而不二子和野口則與回到札幌。</p><p>野口與不二子回到報社後，總編輯眼看夏子沒跟著回來，不知道如何向她的親屬交代，隨即對著野口大罵一頓。所幸不二子替野口說情，才讓野口免於被開除的下場。隨後，兩人也向松浦一家人解釋，她們的寶貝閨女早已深深愛上了那名青年。雖然一開始她們對於夏子的出逃感到惶恐與不安，可是在聽了毅復仇的動機以後，她們也終於理解夏子迷戀那名青年的理由。是以，與其因為阻止小倆口造成雙方的遺憾，松浦一家人覺得不如盡全力促成他們的計畫，這樣才能盡早讓夏子脫離險境。</p><p>於是，松浦一家決定拜訪札幌獵友會的分會長，說服他協助獵捕那頭四趾熊。然而，分會長回絕了她們的邀請。他認為，打獵是動物與人彼此將對方視為獵物的廝殺，直到一方的心跳停止才肯罷休。他說，毅想要追捕的，不是有血有肉的生命，而是無形的惡意；他想了結的，不是野獸搏動的心臟，而是自己仇怨的內心。</p><p>不過隨著關於那頭熊在支笏湖的古太內部落肆虐的消息傳來，分會長對於這頭獵物的興趣也越來越深，最終，他興奮地向松浦一家宣布：「決定了。我去，我去一趟。」</p><p>另一方面，毅和夏子則搭乘末班車前往支笏湖的古太內部落尋求援助，由於帶著女人，他們處處碰壁，無人願意伸出援手。經歷一番狩獵的失利和人情的冷暖，夏子不僅感到身心俱疲，還逐漸湧起失望的情緒。追捕食人熊已不復當初的新鮮感，取而代之的是更多的等待與煎熬。</p><p>兩人在古太內部落一籌莫展，只好回到蘭越拜訪秋子的父親十藏。夏子明白，既然毅帶著她同行，大概也不想再重返傷心地，讓夏子跟著他一起困在傷痛的回憶之中。儘管夏子記得毅曾說「哪怕只剩我一個人，也要殺了那頭熊。」恐怕只是誇誇其談，但是當毅不得不向人求助的時候，夏子仍私心懇盼他能再固執點，堅持那股獨自復仇的決心。</p><p>十藏領著上門拜訪的夏子與毅到佛堂前，讓他們膜拜秋子的遺像。夏子覺得秋子的容貌意外平凡，絲毫沒有像見到不二子那樣帶給她十足的不安感。不過看著怒視秋子疑照的毅，夏子後知後覺地明白，驅使著毅那股執著的，不單單是那頭殘暴的食人熊，還有這名平凡女孩的死亡，和永遠挽不回的青春回憶。</p><p>這讓她感到五味雜陳。夜裡，她悄聲對躺在一的毅力說：</p><blockquote><p>「現在你的腦中只想著秋子。我可不要當死人的替身。我是夏子，不是秋子。」……夏子像要諄諄勸諭弟弟似的，聲音變得溫柔沉靜。<br>「你知道嗎，在我們的初夜，我可沒辦法當你舊情人的替身喔。」</p></blockquote><p>翌日，十藏親自前往古太內部落，想說服他們加入獵熊的行動，卻仍一無所獲。他回來後對毅埋怨部落裡的人毫無鬥志，連自家的牲畜被熊擄走也不敢起身反抗。正當一切一籌莫展，他們倆下定決心要獨自與食人熊搏鬥時，意料外的客人駕著車來訪。除了答應幫忙的獵友會分會長，就連野口，還有夏子的媽媽、祖母和姑姑一行人居然都齊聚一堂。一問之下才得知，野口承諾要準備一則獵殺熊的報導，而松浦一家人則放不下心，非得親自見到迷倒夏子的男人是什麼德性。</p><p>在分會長的周旋下，總算說服了古太內部落的年輕人組成獵捕小組，他們推測那殘暴的四趾熊仍徘徊在部落附近，於是決定放出羊群作為誘餌，分隊長與十藏擔任前哨，負責通報食人熊的動向，其餘年輕人在村子口警戒，而夏子和毅則埋伏在羊舍屋頂，打算趁那頭熊被羊群吸引時，給予牠致命一擊。至於松浦一家和村長夫人則藏匿在村長家，以免遭受危險。</p><p>因為夏子能在最近距離看著毅專注的眼神，所以她感到前所未有的幸福。然而這種感受沒持續太久，他們便從羊隻的騷動得知那頭熊已闖入村子，並逐漸逼近松浦一家的藏身處。眼見四趾熊撞斷木柱闖進屋內，夏子失了方寸，抓著毅的臂膀哀求他出手相救。但毅早有定見，非到時機成熟不會行動。夏子自知此時沒有她插手的餘地，打算獨自前去救母親。</p><blockquote><p>「現在不准下去。」<br>「可是！」<br>「太危險了。」<br>「可是我媽——」<br>「我說不准去就是不准去！」</p></blockquote><p>毅揮拳打暈夏子，阻止她魯莽行事，同時命令其他埋伏的青年保持耐性，直到熊出現在射程範圍才准攻擊。他們盯著熊從屋內現身，沿著樹林走向被繩索綑綁的羊隻。牠扯斷繩索，扛起一隻羊，緩步隱沒在樹林，正好進入毅的視野，隨著毅的槍擊，所有人也同時開火。毅小心翼翼上前確認那頭熊已經斷氣，才向大家宣布那頭食人熊已被擊殺。</p><p>聽到槍響，分會長、十藏、野口還有剛剛躲藏起來的親屬都聚集到熊屍周圍。隨後部落人們手持火把圍繞著獵熊小組，一圈又一圈，畢竟他們從沒看過體格如此碩大的熊。屍檢時，分會長取出那顆致命的子彈，彷彿冥冥之中有安排，毅的那顆子彈正好穿過食人熊的心臟，造成致命的傷害。</p><p>終於報仇血恨的毅有些恍惚地站在熊屍旁，傳統獵人夢寐以求的頭銜與戰利品對他一點也沒有吸引力，他只想忘掉這一切，包含他兩年來對秋子的情思。當他向夏子吐露這想法時，這一刻成為他們兩人內心最親密的時光，不須祝福與稱許來點綴。</p><p>慶功宴之後，野口滿意地帶著「情侶獵熊獲得勝利榮冠」的新聞回到札幌，這則報導一砲而紅，讓他賺進大筆獎金。而夏子的家人在這場危機後，也認同毅作為女婿的資格。在眾人的祝福與送行下，夏子與毅乘著渡輪返回東京。因為睡不著，兩人來到當初相遇的甲板，望著朝陽從海面緩緩升起。</p><blockquote><p>「回到東京後，什麼時候結婚。」<br>毅把手搭在夏子的肩頭說。<br>「這個嘛，隨時都可以。」</p></blockquote><p>毅沒有因為夏子冷淡的回應而作罷，仍喋喋不休地說著回到東京的規劃。他懊惱著該怎麼弭補請假期間的工作耽誤，期盼有朝一日能赴美國工作，還為往後的開銷列了預算。畢竟，夏子也需要一套美麗的衣服，暫時沒有孩子也沒關係，他們倆人可以享受每周去看電影和跳舞等的消遣。等到他在職場上有所成就，他們遲早可以買台車、買棟房，「到時候，到時候……」</p><p>聽著就職、旅行、置產和裝潢等話題，夏子卻感到心寒，「曾經魅惑她的那雙眼去哪了呢？」她哀傷地看著毅自顧自地勾勒兩人未來的模樣，她覺得他身上某種東西似乎隨著食人熊一起死去了。再也受不了這廉價希望帶來的窒息感，「失陪一下」她離開毅回到大廳，在成排行李袋之間打轉。夏子的母親、祖母和姑姑看著夏子異常的舉動，問道：</p><blockquote><p>「妳在找什麼？」<br>「時刻表。……從青森開往函館的船是幾點出發？」</p></blockquote><p>「怎麼，你忘了什麼東西嗎？」</p><blockquote><p>她猛然轉身，用那種充滿個性、具有某種特徵的斷定口吻說，<br>「我還是決定進修道院。」<br>三人目瞪口呆，放下茶匙。唯有三個咖啡杯冒出的熱氣，在這神秘的沉默中，像青煙一樣冉冉上升……</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Sorting by Reversals (SORT)</title>
      <link href="/sorting-by-reversals/"/>
      <url>/sorting-by-reversals/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一對數列，計算兩者的最小反轉距離，並依序列出反轉數列的步驟。</p><blockquote><p>A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms (4,1,2,6,3,5) into (4,1,3,6,2,5) is encoded by [3,5] .<br>A collection of reversals sorts π into γ if the collection contains drev(π,γ) reversals, which when successively applied to π yield γ .</p></blockquote><blockquote><p>Given: Two permutations π and γ , each of length 10.<br>Return: The reversal distance drev(π,γ) , followed by a collection of reversals sorting π into γ . If multiple collections of such reversals exist, you may return any one.</p></blockquote><p>(<a href="https://rosalind.info/problems/sort/">https://rosalind.info/problems/sort/</a>)</p><span id="more"></span><p>這題的概念與 <a href="https://5uperb0y.com/reversal-distance/">Reversal Distance</a> 相同，只是需要修改程式碼以便記錄和追蹤數列反轉的步驟。首先，在生成反轉數列的同時，我用 dictionary 記錄新生成數列的來源以及被反轉的子數列的首尾位置。這裡把首位座標值加 1 是因為題目的座標系統從 1 開始）。</p><p>雖然這些資訊也可以用 list 紀錄，但使用 dictionary 可以透過 key 將資訊分門別類，在取值時會比用 list 時以座標取值明確。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        t[:i] + t[i:j][::-<span class="number">1</span>] + t[j:]: &#123;<span class="string">&quot;parent&quot;</span>: t, <span class="string">&quot;move&quot;</span>: (i + <span class="number">1</span>, j)&#125;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下這個副程式用於生成數列集合的每個元素在經過一次反轉後可能產生的所有數列。由於修改了 swap 的輸出格式，所以這副程式也要跟著調整，確保之後能取得新生成的數列、這些數列的來源以及反轉步驟等資訊。</p><p>雖然以 for 調用 dictionary 的時候，直接寫變項名稱（<code>var</code>）的效果與 <code>var.keys()</code> 一致，不過因為我常常忘記這特性，所以覺得還是清楚列出來比較好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next_steps</span>(<span class="params">current, visited</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        swap_e: details</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> current.keys()</span><br><span class="line">        <span class="keyword">for</span> swap_e, details <span class="keyword">in</span> swap(e).items()</span><br><span class="line">        <span class="keyword">if</span> swap_e <span class="keyword">not</span> <span class="keyword">in</span> visited.keys()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由於記錄了各數列的源頭與反轉方式，所以配合已檢查過的數列清單 visited，即可追蹤數列的反轉步驟。簡而言之，就是拿當前數列去查詢 visited，記錄反轉步驟，再查出該數列的源頭，查詢數列源頭的反轉步驟，直到追蹤到起始數列。</p><p>這裡我假設起始數列的資料格式為 <code>&#123;seq: -1&#125;</code>，所以只要檢查到 -1 就表示已經追蹤到起點了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_moves</span>(<span class="params">meet_point, visited</span>):</span><br><span class="line">    moves = []</span><br><span class="line">    current = visited[meet_point]</span><br><span class="line">    <span class="keyword">while</span> current != -<span class="number">1</span>:</span><br><span class="line">        moves.append(current[<span class="string">&quot;move&quot;</span>])</span><br><span class="line">        current = visited[current[<span class="string">&quot;parent&quot;</span>]]</span><br><span class="line">    <span class="keyword">return</span> moves</span><br></pre></td></tr></table></figure><p>除了變項名稱以外，我也對計算反轉距離的功能做了一些調整。首先，因應使用 dictionary 記錄數列，比較雙向搜索是否有交集時，得額外取出兩者的 keys 來比對。</p><p>其次，我轉而以交錯方式來推進搜索：利用 <code>check_forward</code> 當成開關，這變項決定這次檢查要從哪個方向開始，這樣能確保每次迴圈只會從數列前端或後端推進一步。這樣就不用像我之前寫得那樣，在每個迴圈為各方向的推進檢查兩次。</p><p>其餘的步驟與先前的寫法類似，一旦雙向搜索的進度交錯，就分別使用 get_moves 重建反轉步驟。</p><p>因為這個副程式預設用 append() 添加元素，所以對於從前端開始的檢查而言，在追蹤完所有反轉步驟後，要將輸出的 list 反轉才能得到正確的順序。結合前後兩端的反轉步驟，即得到兩數列互相轉換所需經過得最少反轉步驟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    cur_fwd, vis_fwd = &#123;s1: -<span class="number">1</span>&#125;, &#123;s1: -<span class="number">1</span>&#125;</span><br><span class="line">    cur_bwd, vis_bwd = &#123;s2: -<span class="number">1</span>&#125;, &#123;s2: -<span class="number">1</span>&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    check_forward = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> cur_fwd <span class="keyword">and</span> cur_bwd:</span><br><span class="line">        intersection = cur_fwd.keys() &amp; cur_bwd.keys()</span><br><span class="line">        <span class="keyword">if</span> intersection:</span><br><span class="line">            meet_point = intersection.pop()</span><br><span class="line">            <span class="keyword">return</span> dist, get_moves(meet_point, vis_fwd)[::-<span class="number">1</span>] + get_moves(meet_point, vis_bwd)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> check_forward:</span><br><span class="line">                cur_fwd = get_next_steps(cur_fwd, vis_fwd)</span><br><span class="line">                vis_fwd.update(cur_fwd)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_bwd = get_next_steps(cur_bwd, vis_bwd)</span><br><span class="line">                vis_bwd.update(cur_bwd)</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            check_forward = <span class="keyword">not</span> check_forward</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="and、-和-intersection-的差異"><a href="#and、-和-intersection-的差異" class="headerlink" title="and、&amp; 和 intersection 的差異"></a>and、&amp; 和 intersection 的差異</h2><p>intersection 和 &amp; 是 set 專用的操作符，兩者的功能相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&gt; b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&gt; a &amp; b</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection(b)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>然而 &amp; 只允許 set 之前的操作，intersection 則支援 set 和任何 iterable 的比較，所以有可讀性和泛用性的優勢。詳情可參考這則 <a href="https://stackoverflow.com/questions/63827915/and-intersection-difference">stackoverflow 的說明</a> 和<a href="https://docs.python.org/3.8/library/stdtypes.html#frozenset.intersection">官方文件</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection(&#123;<span class="number">3</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>and 則是邏輯判斷符，不能用來集合運算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這裡的邏輯是：a is True, then b，所以印出 b。</span></span><br><span class="line">&gt; a <span class="keyword">and</span> b</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 用這案例會更加清楚：&#123;&#125; is False，所以不會印出 b，只有呈現 &#123;&#125;</span></span><br><span class="line">&gt; &#123;&#125; <span class="keyword">and</span> b</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="其他解題想法"><a href="#其他解題想法" class="headerlink" title="其他解題想法"></a>其他解題想法</h2><p>我覺得這種需要追蹤路徑的問題，如果用 class 來設計結構與方法可能會讓程式碼變得好維護許多。另外，之前在 Reversal Distance 也有列出用遞迴的解題方式，或許有空都可以拿來改寫看看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Reversal Distance (REAR)</title>
      <link href="/reversal-distance/"/>
      <url>/reversal-distance/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 5 對長度為 10 的數列，計算將各對數列互相轉換所需的最少反轉次數。</p><blockquote><p>A reversal of a permutation creates a new permutation by inverting some interval of the permutation; (5,2,3,1,4) , (5,3,4,1,2) , and (4,1,2,3,5) are all reversals of (5,3,2,1,4) . The reversal distance between two permutations π and σ , written drev(π,σ) , is the minimum number of reversals required to transform π into σ (this assumes that π and σ have the same length).</p><p>Given: A collection of at most 5 pairs of permutations, all of which have length 10.</p><p>Return: The reversal distance between each permutation pair.</p></blockquote><p>(<a href="https://rosalind.info/problems/rear/">https://rosalind.info/problems/rear/</a>)</p><span id="more"></span><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>染色體特定片段前後翻轉的現象稱為 inversion，它是基因體重排最常見的形式。計算兩條染色體透過 inversion 互相轉換所需的最少次數，可視同求解兩數列之間的反轉距離（reversal distance）。</p><p>假設我們有一個起始數列和一個目標數列。若兩數列完全相同，則反轉距離為 0，不須進行任何反轉操作。但如果兩者不一致，可先列出起始數列經過一次反轉後可能產生的所有數列，再檢查目標數列是否出現在新生成的數列中。</p><p>如果找到目標數列，就回報所需的反轉次數；如果沒找到，就列出這些數列再次返喘後可能產生的所有數列。</p><p>重複上述過程，列出經過 n 次反轉後可能產生的所有數列，並且檢查目標數列是否出現其中，直到找到目標數列或窮盡所有可能為止。</p><p>為了實現這個算法，首先需要一個副程式，用於列出一個數列經過一次反轉後可能產生的所有數列。簡言之，在數列上任選兩個位置，用 <code>[::-1]</code> 反轉居於其間的子數列，再連結反轉數列與剩餘數列。</p><p>這些數列可以儲存在 list、tuple、或 set 等資料型別中。我選擇使用 set 是因為它能自動排除重複的數列，減少多餘的比較。其次，與 list 和 tuple 相比，判斷一個元素是否在 set 之中只需要常數時間，能減少比較的時間成本。最後，set 支援交集、聯集和差集等操作，在比較數列集合時有比較多彈性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate all possible subsequences of a tuple by reversing segments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        l (tuple): Input tuple, e.g., (1, 2).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        set: Set of tuples with reversed segments, e.g., &#123;(1, 2), (2, 1)&#125;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        l[:i] + l[i:j][::-<span class="number">1</span>] + l[j:]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除此之外，計算反轉距離還需要以下三項資訊：</p><ul><li>curr：記錄準備與目標數列比較的數列集合</li><li>visited：記錄已經檢查過的數列集合</li><li>dist：記錄當前的反轉次數</li></ul><p>具體的流程和程式碼如下：</p><ol><li>檢查目標數列是否出現在 curr 中。若有找到目標數列，則回報當前的反轉次數  dist。</li><li>若沒有找到，則依序反轉 curr 中每個數列，但要排除掉已經檢查過的數列visited。</li><li>將新生成的反轉數列納入已檢查過的數列集合 visited，以免重複比較。</li><li>將所有可能的反轉結果更新到 curr，以便下一輪比較。同時，將當前反轉次數 dist 的值加 1。</li><li>更新完畢後，回到步驟 1. 繼續搜索，直到找出目標數列（回傳 dist），或是檢查過所有可能性仍未找到目標數列（回傳 -1）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate the minimum number of reversals required to transform tuple s1 to tuple s2.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        s1 (tuple): Starting tuple.</span></span><br><span class="line"><span class="string">        s2 (tuple): Target tuple.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: Minimum number of swaps required, or -1 if transformation is not possible.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    curr, visited = &#123;s1&#125;, &#123;s1&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="keyword">if</span> s2 <span class="keyword">in</span> curr:</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_step = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> curr:</span><br><span class="line">                next_step.update(swap(e).difference(visited))</span><br><span class="line">                visited.update(next_step)</span><br><span class="line">            curr = next_step</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>這題的觀念其實不難理解，但真正的挑戰在於計算效率。隨著數列長度和反轉次數增加，算法的時間複雜度會呈指數增長。依照題目要求的數列長度測試，我的電腦大約只能處理到 4-5 次反轉，再多的反轉次數就無法在合理的時間內算出來。</p><p>想要評估計算反轉距離的成本可以考慮以下三個因素：比較成本（$c$, Cost）、可能的數列數量（$n$, Number）、檢查的深度（$d$, Depth or Distance），即 $cn^d$。為了提升計算效率，可以從這三項因素著手。</p><ul><li>降低每次比較的成本，例如以 set 取代 list。</li><li>降低可能的數列數量，例如排除已檢查過的數列或是只生成有用的數列等。</li><li>降低檢查深度，例如同時從數列的前端和後端開始檢查。</li></ul><p>這些方式都能提升計算效率，但適用的情境不盡相同。如果數列長度很短，可能的反轉結果會比較少，反轉距離也不長，那麼關鍵就在於降低每次比較的成本。反之，如果像這題一樣需要處理較長的數列，那麼重點就轉移到了控制可能的數列數量和檢查深度上。</p><p>雖然排除已檢查過的數列能起到一定作用，但問題在於反轉距離還是太長了，相較於指數增長的待檢查數列，重複數列的數量顯得微不足道。</p><p>另一種策略是在生成可能的反轉數列時，只生成有機會轉換為目標數列的數列。這方法若能有效降低 $n$ 值，便能容忍更長的反轉距離以及比較數列的長度。</p><p>然而，這想法雖然理想，但它的困難在於不容易找到正確的篩選規則來判斷一個數列是否有可能轉換為目標數列。即使找到一項不錯的規則，但也很難保證這規則不會遺漏某西可能性，導致它雖然能在有限時間內回應，卻未必是最優解。</p><p>最後一種手段則相對值觀，就是分別從數列的前後端開始搜索，這樣可以將檢查的深度減半。如題目要求，對於長度為 10 的數列，即使窮舉，最多經過 9 次反轉便能轉會為任意數列。</p><p>如前所述，反轉距離大於 4 - 5 次就達到當前計算能力的極限，從兩端同時搜索，正好能將檢查深度控制在極限以內。</p><p>雙向排查的程式碼如下所示。為了降低主程式的複雜度，我新增了副程式 get_next_steps，用於生成數列集合的每個元素在經過一次反轉後可能產生的所有數列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next_steps</span>(<span class="params">curr, visited</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates next steps by swapping elements in `curr`, excluding those in `visited`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        curr (set): Current states.</span></span><br><span class="line"><span class="string">        visited (set): States to exclude.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        set: Next possible states.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    next_steps = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> curr:</span><br><span class="line">        next_steps.update(swap(e).difference(visited))</span><br><span class="line">    <span class="keyword">return</span> next_steps</span><br></pre></td></tr></table></figure><p>其餘部分則與只從一端開始檢查的方式相似，只是要有兩組 curr 和 visited 分別存儲從前後端檢查數列的資訊。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    f_curr, f_visited, b_curr, b_visited = &#123;s1&#125;, &#123;s1&#125;, &#123;s2&#125;, &#123;s2&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> f_curr <span class="keyword">and</span> b_curr:</span><br><span class="line">        <span class="keyword">if</span> f_curr.intersection(b_curr):</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            f_curr = get_next_steps(f_curr, f_visited)</span><br><span class="line">            f_visited.update(f_curr)</span><br><span class="line">        <span class="keyword">if</span> b_curr.intersection(f_curr):</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            b_curr = get_next_steps(b_curr, b_visited)</span><br><span class="line">            b_visited.update(b_curr)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h1><p>說點題外話，這題算得上 Rosalind 平台的東巴了，我想半天解不出來，看了討論區才知道原來有那麼多人也覺得出題方在整人。儘管題目提示 “Don’t be afraid to try an ugly solution.”，但真想用暴力法解題，是絕對沒辦法在規定時間內通過測試的。</p><p>以下是我找到的另一種基於雙向搜索的解法，雖然它沒有處理起始數列與目標數列無法互相轉換的狀況，但整體想法卻清晰易懂。這方法首先將輸入的數列轉換為 set 以利比較，接著判斷兩者是否有交集。如果有，則直接回傳當前的反轉距離；反之，則為每個數列集合中的元素生成所有可能的數列，再判斷新生成的數列集合彼此是否交集。如果仍沒有交集，就遞迴呼叫這個副程式，持續搜索下一層，直到找到交集為止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2, dist=<span class="number">0</span></span>):</span><br><span class="line">   s1 = &#123;s1&#125; <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">tuple</span>) <span class="keyword">else</span> s1</span><br><span class="line">   s2 = &#123;s2&#125; <span class="keyword">if</span> <span class="built_in">isinstance</span>(t, <span class="built_in">tuple</span>) <span class="keyword">else</span> s2</span><br><span class="line">   <span class="keyword">if</span> s1.intersection(s2):</span><br><span class="line">        <span class="keyword">return</span> dist</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">        next_s1 = &#123; swap_e <span class="keyword">for</span> e <span class="keyword">in</span> s1 <span class="keyword">for</span> swap_e <span class="keyword">in</span> swap(s1) &#125;</span><br><span class="line">        next_s2 = &#123; swap_e <span class="keyword">for</span> e <span class="keyword">in</span> s2 <span class="keyword">for</span> swap_e <span class="keyword">in</span> swap(s2) &#125;</span><br><span class="line">        <span class="keyword">if</span> s1.intersection(next_s1) <span class="keyword">or</span> s2.intersection(next_s1):</span><br><span class="line">            <span class="keyword">return</span> dist + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> next_s1.intersection(next_s2):</span><br><span class="line">            <span class="keyword">return</span> dist + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> rev_dist(next_s1, next_s2, dist + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND | Longest Increasing Subsequence (LGIS)</title>
      <link href="/longest-increasing-subsequence/"/>
      <url>/longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給一正整數列，求其最長的遞增與遞減子數列。例如數列 5, 1, 4, 2, 3 的最長遞增數列為 1, 2, 3，最長遞減數列則為 5, 4, 3。</p><blockquote><p>Given: A positive integer n≤10000 followed by a permutation π of length n.</p><p>Return: A longest increasing subsequence of π , followed by a longest decreasing subsequence of π.</p></blockquote><p>(<a href="https://rosalind.info/problems/lgis/">https://rosalind.info/problems/lgis/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Synteny block 是物種基因體間基因順序彼此一致的片段。這些片段在演化過程中沒有因為重排（genome arrangement）而分離或反轉，暗示著坐落其中的基因不只位置相鄰，功能也可能彼此關聯。</p><p>由於基因體動輒包含數億對鹼基，即使比較的對象是親緣關係相近的物種，仍有可觀的計算量與複雜性。相較之下，synteny block 的數量遠少於鹼基數，卻同樣能對基因體的功能和結構提供一些線索。因此，透過比較 synteny block 來研究推演物種的演化過程也不失為一種可行的方式。</p><p>舉例來說，假設甲物種與乙物種共享 5 個 synteny blocks，並且依照它們在甲基因體的排列順序命名為 1, 2, 3, 4, 5。接著標記乙基因體上對應的 synteny blocks，便能概括兩者基因體的差異程度，或是推測基因體的結構變化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">甲：1, 2, 3, 4, 5</span><br><span class="line">乙：3, 2, 1, 4, 5  &lt;-- 可能發生一次轉置</span><br></pre></td></tr></table></figure><p>儘管以符號標記 synteny blocks 可直觀呈現基因體差異，不過隨著比較對象和內容增加，可以使用距離指標來簡化基因體差異分析。</p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/0/05/Human-mouse_synteny.jpg"><br>（人類與老鼠的染色體 synteny blocks 分布圖，<a href="https://en.wikipedia.org/wiki/Synteny%EF%BC%89">https://en.wikipedia.org/wiki/Synteny）</a></p><p>在 <a href="https://5uperb0y.com/counting-point-mutations/">“Counting Point Mutations”</a> 當中已介紹 Hamming distance 來評估發生點突變的序列間的差異。在這題則引進最長遞增&#x2F;遞減子數列的概念，透過 synteny block 的順序來定量基因體間的差異。最長遞增&#x2F;遞減子數列的長度越長，表示兩基因體越相似；長度越短，則表示可能發生較多次基因體重排等結構上的變化。</p><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>由於找最長遞增子數列的方式也能用在找最長遞減子數列，所以我將專注討論最長遞增子數列的解法。</p><p>假設數列皆如 1, 2, 3, 4,… 嚴格遞增，那麼尋找最長遞增數列並不困難。然而，對於數列元素順序凌亂的狀況，如 2, 5, 3, 1, 4, …，隨著數列長度增加，會越來越難直觀看出答案。</p><p>造成困難的主因在於，在檢查某項數字時，我們難以確定它是延續某個既有的遞增子數列，還是作為新的遞增子數列的開端。在檢查完所有數字之前，也無從得知當前檢查的數字是否為最終答案的一部份。</p><p>以數列 2, 5, 3, 1, 4 為例，2 能與 5 或 3 組成遞增子數列，但該怎麼判斷要納入何者，以組成最長的遞增子數列？又或在數列 3, 5, 1, 2, 4 的案例中，該依據什麼資訊來決定放棄包含 3, 5 的子數列，而轉為建立新的子數列 1, 2, 4？</p><p>綜上所述，可以將讓我們左右為難的因素歸納如下，</p><ol><li>當前數字大於先前數字時，不確定要忽略它還是將其延伸至既有的遞增子數列。</li><li>當前數字小於先前數字時，不確定要忽略它還是以它為起點建立新的遞增子數列。</li></ol><p>為了解決這問題，可以使用當前數列的最長遞增子數列長度為依據，來衡量納入當前數字和建立新數列的效益，假如行動能增加遞增子數列的長度則為之。</p><p>由於每次檢查都可能推翻先前的答案，所以要比對整個數列後才能得知最終結果。以數列 3, 5, 1, 2, 4 為例，由左至右檢查數字來構築最長遞增子數列：</p><table><thead><tr><th>檢查數字</th><th>當前最長遞增子數列</th><th>遞增數列長度</th><th>判斷</th><th>行為</th></tr></thead><tbody><tr><td>3</td><td>[3]</td><td>1</td><td>起始數字</td><td>納入當前數字</td></tr><tr><td>5</td><td>[3, 5]</td><td>2</td><td>5 &gt; 3，延長遞增數列</td><td>納入當前數字</td></tr><tr><td>1</td><td>[3, 5]</td><td>2</td><td>1 &lt; 5，不能延長現有遞增數列</td><td>忽略當前數字</td></tr><tr><td>2</td><td>[3, 5], [1, 2]</td><td>2</td><td>2 &gt; 1，形成新的遞增數列，與現有數列等長</td><td>建立當前數列</td></tr><tr><td>4</td><td>[1, 2, 4]</td><td>3</td><td>4 &gt; 2，延長新建立的遞增數列，長度大於 [3, 5] 與 [1, 2]</td><td>納入當前數字</td></tr></tbody></table><p>為了實現這套算法，需要紀錄以下資訊</p><ul><li><code>lis_len</code>：紀錄截至當前數列位置，最長遞增子數列的長度，用於衡量是否要納入新數字或建立新數列。</li><li><code>prev</code>：該數字在遞增子數列的前一項的位置，用於追蹤遞增子數列的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lis_len = [<span class="number">1</span>] * <span class="built_in">len</span>(l)    <span class="comment"># 因為每個數字自成數列，所以在開始計算前，遞增子數列的長度至少為 1。</span></span><br><span class="line">prev = [-<span class="number">1</span>] * <span class="built_in">len</span>(l)      <span class="comment"># 在開始計算前，還沒有遞增子數列的位置資訊，所以預設為 -1。</span></span><br></pre></td></tr></table></figure><p>假設現在檢查第 i 個數字，那麼我們需要把它與數列之前所有數字（<code>l[j]</code>, i &gt; j）比較，才能涵蓋到所有可能性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[j] <span class="keyword">and</span> lis_len[j] + <span class="number">1</span> &gt; lis_len[i]:</span><br><span class="line">            lis_len[i] = lis_len[j] + <span class="number">1</span></span><br><span class="line">            prev[i] = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>簡言之，在當前數字大於先前數字時（<code>l[i] &gt; l[j]</code>），有兩種可能的行動：</p><ul><li>將當前數字 <code>l[i]</code> 納入以 <code>l[j]</code> 結尾的遞增子數列，形成長度為 <code>lis_len[j] + 1</code> 的遞增子數列。</li><li>忽略先前的數字，不更動 <code>l[i]</code> 所屬的遞增子數列，讓長度維持 <code>lis_len[i]</code></li></ul><p>為了找到最長的遞增子數列，應該選擇能增加子數列長度的行動。換句話說，若 <code>lis_len[j] + 1 &gt; lis_len[i]</code>，那麼就該把 <code>l[i]</code> 納入以 <code>l[j]</code> 結尾的遞增子數列，並且更新 <code>lis_len[i] = lis_len[j] + 1</code>。</p><p>與此同時，也透過 <code>prev</code> 紀錄當前數字 <code>l[i]</code> 在遞增子數列的前一項的位置 <code>prev[i] = j</code>，以利在檢查全部數字之後，從輸入的數列重建出最長的遞增子數列。</p><p>透過這樣的比較，可以確保 <code>lis_len</code> 每一項都記錄了截至當前位置能獲得的最常遞增子數列長度。因此，<code>lis_len</code> 的最大值便是整個數列的最長遞增子數列長度；該值在 <code>lis_len</code> 的位置，也對應到遞增子數列最後一項的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_pos = <span class="built_in">max</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(l)), key=<span class="keyword">lambda</span> x: lis_len[x]) </span><br></pre></td></tr></table></figure><p>由於prev陣列記錄了當前位置的數字在最長遞增子數列中前一項的索引位置,因此我們需要依序讀取prev中的值l[prev[i]],並將讀取出的數列反轉,才能獲得正確的最長遞增子數列順序。</p><p>由於 <code>prev</code> 記錄了當前位置的數字在最長遞增子數列中前一項的位置，所以回溯 <code>prev</code> 得到的數列順序與正確結果相反。仍需將讀取出的數列反轉，才能得到最長遞增子數列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output = []</span><br><span class="line"><span class="keyword">while</span> final_pos != -<span class="number">1</span>:</span><br><span class="line">    output.append(l[final_pos])</span><br><span class="line">    final_pos = prev[final_pos]</span><br><span class="line"><span class="keyword">return</span> output[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>完整的功能實現如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lgis</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Longest Increasing Subsequence</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lis_len = [<span class="number">1</span>] * <span class="built_in">len</span>(l)</span><br><span class="line">    prev = [-<span class="number">1</span>] * <span class="built_in">len</span>(l)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> l[i] &gt; l[j] <span class="keyword">and</span> lis_len[j] + <span class="number">1</span> &gt; lis_len[i]:</span><br><span class="line">                lis_len[i] = lis_len[j] + <span class="number">1</span></span><br><span class="line">                prev[i] = j</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    final_pos = <span class="built_in">max</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(l)), key=<span class="keyword">lambda</span> x: lis_len[x]) </span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">while</span> final_pos != -<span class="number">1</span>:</span><br><span class="line">        output.append(l[final_pos])</span><br><span class="line">        final_pos = prev[final_pos]</span><br><span class="line">    <span class="keyword">return</span> output[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>只要將數列倒序輸入這個副程式，再反轉回傳結果，即可獲得最長遞減子數列，因此不用額外寫一個專門的副程式。由於題目提供的輸入為純文字檔，所以在執行程式前要記得將文字轉換為整數，並在輸出答案時再將整數轉換回文字以利後續排版。若省略型態轉換的步驟，則程式會依照字母排序，結果自然會與預期有所出入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rosalind_lgis</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        nums = [ <span class="built_in">int</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> f.readlines()[<span class="number">1</span>].strip().split() ]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([ <span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> lgis(nums) ]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([ <span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> lgis(nums[::-<span class="number">1</span>])[::-<span class="number">1</span>] ]))</span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>這道題的解法是動態規劃的案例。對我來說，最困難的不是熟悉動態規劃的概念，而是判斷適用動態規劃的情境，還有選擇合適的資訊存儲和判斷式。雖然與資訊科學無關（但跟生物有點關係），練習題目時，一直想起高中生物老師耳提面命的話，</p><blockquote><p>蓋棺才能論定</p></blockquote><p>每個人多少有想追求的目標與想累積的經歷，當中免不了要面對兩難的人生抉擇：接受新的職位，還是待下去？繼續打拼，還是止損停利？與他人合作，還是獨行江湖？即使擁有預知能力，可以判斷當下決策帶來的影響，也很難保證長期而言，會帶來最高的效益。</p><p>於是，我們也只能依照當下的條件，選擇最契合個人方向與渴望的行動，直到人生告一段落再也沒有任何可能性的時候，才有機會判斷哪些舉動與決策對於當初訂立的目標最有幫助。只是知道了又如何？雖然其他人可以從這些經驗得到啟發，可是當事人也沒機會用到自己一生濃縮的最佳解。</p><p>何況每個階段的追求也可能大相逕庭，處心積慮規劃了老半天，才在某個陽光明媚的早晨發現，自己渴望 B 而不是 A 的情況應該也不少見。</p><p>因此，當初生物老師在聯考後第一堂課不檢討考卷，而花了老半天講些莫名其妙的話的時候，可能不是在勉勵我們「別因挫折而氣餒，能否達成目標還說不定呢！」（對，我們班上很多人沒考好）。他也許是期望我們就用力活著，去體驗挫敗、毫無意義、徒勞無功之類說不上是好是壞的情感，不用煩惱纏繞腦中的時程、途徑、機會、指標、最佳化等有的沒的東西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND | Finding a Shared Motif (LCSM)</title>
      <link href="/finding-a-shared-motif/"/>
      <url>/finding-a-shared-motif/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一 FASTA 檔案，內含數條由 A、C、G、T 組成的字串，求這些字串共享的最長子字串。</p><blockquote><p>A common substring of a collection of strings is a substring of every member of the collection. We say that a common substring is a longest common substring if there does not exist a longer common substring. For example, “CG” is a common substring of “ACGTACGT” and “AACCGTATA”, but it is not as long as possible; in this case, “CGTA” is a longest common substring of “ACGTACGT” and “AACCGTATA”.<br>Note that the longest common substring is not necessarily unique; for a simple example, “AA” and “CC” are both longest common substrings of “AACC” and “CCAA”.</p><p>Given: A collection of k (k≤100) DNA strings of length at most 1 kbp each in FASTA format.</p><p>Return: A longest common substring of the collection. (If multiple solutions exist, you may return any single solution.)</p></blockquote><p>(<a href="https://rosalind.info/problems/lcsm/">https://rosalind.info/problems/lcsm/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>如果我們能夠透過理論計算或是資料庫數據得知某種 motif 的組成，便能按照 <a href="https://5uperb0y.com/finding-a-motif-in-dna/">Finding a motif in dna</a> 這題的要求，在一條 DNA 中尋找已知 motif 的位置。然而，並非所有研究對象都能事前得知 motif 的資訊，所以更常見的方法是透過比較多組基因體，歸納出反覆出現且序列相似的 motif。</p><p>為了簡化問題，這題只要求找出最長的 motif，因為長度愈長，motif 涉及的功能往往越多。此外，題目還假設同一種 motif 的序列完全一致，這意味著這些 motif 在演化中沒發生任何突變，暗示其功能相當重要，具有相當的穩定性。換句話說，這些 motif 可能反映了各基因體共享的核心功能。</p><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>這題相當於尋找各字串的最長共同子字串（longest common substring, LCS）。最直觀的解法在於了解「 LCS 的長度不大於最短字串的長度」，因此可以列出最短字串的所有子字串，再拿這些子字串由長至短一一與其它字串比較。第一個出現在所有字串的子字串就是題目要求的 LCS。</p><p>以下使用 python 實作這個算法，首先找到最短的子字串 <code>min_s</code>，求出它所有的子字串 <code>kmer</code>，最後由長至短檢查子字串是否出現在所有字串中，一旦符合條件，便直接回傳結果。（由於這裡是由短至長生成 <code>kmer</code>，所以後面把它倒置 <code>kmer[::-1]</code> 來改變比對的順序。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common substring from multiple strings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    min_s = <span class="built_in">min</span>(strs, key = <span class="built_in">len</span>)</span><br><span class="line">    kmer = [</span><br><span class="line">        min_s[i:i+k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_s) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_s) - k)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> mer <span class="keyword">in</span> kmer[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(mer <span class="keyword">in</span> s <span class="keyword">for</span> s <span class="keyword">in</span> strs):</span><br><span class="line">            <span class="keyword">return</span> mer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>由於題目要求輸入 FASTA 檔案，所以需要一個讀檔的副程式。FASTA 檔案是紀錄序列的通用文字格式，<code>&gt;</code> 開頭的列紀錄 DNA、RNA或蛋白質序列的名稱，直到碰到下一個 <code>&gt;</code> 符號之前的列則記錄了序列本身。為了方便在終端機用肉眼判讀，有些 FASTA 檔案中的序列會分成數列表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Read_id</span><br><span class="line">ACTGACTGATCGGATAGTAGTGATAGCGATCGATCAGCATATCGACTATCAGCTAGCTACAGCTGAGCATCGATCG</span><br><span class="line">ACGATTACGACGATCAG</span><br></pre></td></tr></table></figure><p>以下程式將 FASTA 讀進 python dictionary。凡是 <code>&gt;</code> 開頭的列，就把它當作 dictionary 的 key，而其餘的列則串接起來成為 dictionary 的 value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_fasta</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read a fasta file into a dictionary</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reads = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;&gt;&quot;</span>):</span><br><span class="line">                key = line[<span class="number">1</span>:].strip()</span><br><span class="line">                reads[key] = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reads[key] = reads[key] + line.strip()</span><br><span class="line">        <span class="keyword">return</span> reads</span><br></pre></td></tr></table></figure><p>結合讀檔與 LCS 主程式，便能滿足題目的要求了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcsm</span>(<span class="params">fasta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common nucleotide sequence from multiple sequences in a fasta file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seqs = <span class="built_in">list</span>(read_fasta(fasta).values())</span><br><span class="line">    <span class="keyword">return</span>(lcs(seqs))</span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="longest-common-substring-longest-common-subsequence"><a href="#longest-common-substring-longest-common-subsequence" class="headerlink" title="longest common substring &amp; longest common subsequence"></a>longest common substring &amp; longest common subsequence</h2><p><a href="https://en.wikipedia.org/wiki/Longest_common_substring">Longest common substring</a> 和 <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence">longest common subsequence</a> 是不同的問題：”AB” 是 “ABXC” 和 “ABOC” 的 longest common substring，”ABC” 則否；<code>[A, B, C]</code> 是 <code>[A, B, X, C]</code> 和 <code>[A, B, O, C]</code> 的 longest common subsequence，<code>[A, B]</code> 則否。</p><p>因為在生物資訊的語境裡，序列（sequence）也用於描述 DNA&#x2F;RNA&#x2F;蛋白質，而這些序列資訊往往也用字串（string）紀錄。因此，當初想這題有什麼巧妙解法時，誤入歧途去查了 longest common “subsequence” 的解法。</p><p>寫出的程式沒有返回預期結果時，問問 chatgpt 怎麼解 longest common subsequence 還覺得是不是 AI 變笨了，怎麼給你 Rosalind 題目的完整輸出入結果還嘴硬。分清楚這兩個問題後，我才明白小丑是我自己🤡。</p><p>（如果想要找到更快的算法，可以點進 Longest common substring 連結看看維基百科的解釋）</p><h2 id="所有字串的-LCS-不見得與一對字串的-LCS-一致"><a href="#所有字串的-LCS-不見得與一對字串的-LCS-一致" class="headerlink" title="所有字串的 LCS 不見得與一對字串的 LCS 一致"></a>所有字串的 LCS 不見得與一對字串的 LCS 一致</h2><p>明白小丑是我自己之後，我謄錄了一份利用動態規劃尋找兩字串 longest common substring 的方法。簡言之，這方法會一一比對兩字串每個字符，並且將最長子字串的長度紀錄在一個矩陣中。再比對過所有字符後，便能得出 LCS。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common substring from two strings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (<span class="built_in">len</span>(s2) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) + <span class="number">1</span>)]</span><br><span class="line">    max_len, end_pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s1) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> max_len &lt; dp[i][j]:</span><br><span class="line">                    max_len = dp[i][j]</span><br><span class="line">                    end_pos = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> s1[end_pos - max_len:end_pos]</span><br></pre></td></tr></table></figure><p>我原先的以為，一對字串的 LCS 會與所有字串的 LCS 相同，所以我可以像是「找出最大的數字」一樣，找出「最長的共同子字串」，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這是錯的!!!!!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcsm</span>(<span class="params">fasta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common nucleotide sequence from multiple sequences in a fasta file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seqs = <span class="built_in">list</span>(read_fasta(fasta).values())</span><br><span class="line">    m = seqs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> seqs[<span class="number">1</span>:]:</span><br><span class="line">        m = lcs(s, m)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>雖然這支程式可順利通過 ROSALIND 的測資，但我在討論區立刻看到一則反例，才乖乖寫成題解那個形式。</p><blockquote><p>I’m not sure the LCS of all the strings would necessarily be a substring of the pairwise LCS’s. For example, in this set of strings:<br>AAAAATATATAACGT AAAAACCCCCACGT ACACACCCCCACGT<br>The LCS of the first and second string will be AAAAA, the LCS of the second and third string will be CCCCC, but the LCS of all three strings will be ACGT.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND | Finding a Motif in DNA (SUBS)</title>
      <link href="/finding-a-motif-in-dna/"/>
      <url>/finding-a-motif-in-dna/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>給定字串 s 與 t，其中 t 的長度小於等於 s，求 s 與 t 一致之子序列的起始位置。</p><blockquote><p>Given: Two DNA strings s and t (each of length at most 1 kbp).</p><p>Return: All locations of t as a substring of s.</p></blockquote><p>(<a href="https://rosalind.info/problems/subs/">https://rosalind.info/problems/subs/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Motif 是指在一範圍內反覆出現且具鮮明特質的物體或概念，其指涉的對象因脈絡而異 。在分子生物中，motif 被用以形容一段為生物體共享的核酸或蛋白質序列，這些序列可能有相似的功能，且對各生物都至關重要。在網路生物學中，motif 則可用以形容一出現頻率高於隨機分布的子圖，這些子圖的出現頻率很高且有獨特的網路結構，因此能在欠缺相關生物學知識的情況被辨識出來。而在結構生物學中，motif 則代表核酸或蛋白質上呈規律結構的區段，這些區段可能由多個二級結構所構成。</p><p>雖然 motif 定義多元，但皆不脫「重複」與「特別」兩項屬性。是以，透過在核酸或蛋白質序列尋找重複序列來辨識 motif，也算在找尋某種特別的屬性。在結構生物學中，domain 是與 motif 相關的概念。Domain 也具有規律的結構和鮮明的特質，但與 motif 不同，domain 能獨立發揮某項功能。換句話說，motif 強調結構的實體，而 domain 則強調功能的實體。</p><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>此題意在尋找與 motif 相符的子字串之位置。在 Python 中，我首先建立 list 儲存子字串位置，接著以 for 迴圈依序取出長度與 motif 一致的子字串，再比對兩者的序列。若序列一致，則將子字串的起始位置儲存至 list。由於 python 計數由 0 開始，所以輸出結果還要 +1 才符合題目要求。因為最後要回傳 list，所以也能用 list comprehension 呈現。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subs</span>(<span class="params">s, t</span>):</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">i + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(s[:-<span class="built_in">len</span>(t)])</span><br><span class="line"><span class="keyword">if</span> s[i:i+<span class="built_in">len</span>(t)] == t</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最後再把結果依照題目要求印出，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(subs(s,t))))</span><br></pre></td></tr></table></figure><p>在 R 中，我採取了另一種策略：先列出所有與 motif 長度一致的子字串，再回傳序列與 motif 相同的子字串位置。因此，我先定義了能從一字串取出所有特定長度子字串的 function。接著再以 grep 搜索子字串中，與 motif 相符者的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># exemplified data</span><br><span class="line">dna &lt;- &quot;GATATATGCATATACTT&quot;</span><br><span class="line">motif &lt;- &quot;ATAT&quot;</span><br><span class="line"># Generate kmer from a string</span><br><span class="line">kmer &lt;- function (s, k) &#123;</span><br><span class="line">  char &lt;- unlist(strsplit(s, &quot;&quot;))</span><br><span class="line">  kmer &lt;- unlist(lapply(0:(nchar(s) - k), function (x) &#123;paste0(char[seq(k) + x], collapse = &quot;&quot;)&#125;))</span><br><span class="line">  return(kmer)</span><br><span class="line">&#125;</span><br><span class="line"># identify motif from kmer with grep </span><br><span class="line">find_motif &lt;- function (dna, motif) &#123;</span><br><span class="line">  mer &lt;- kmer(dna, nchar(motif))</span><br><span class="line">  return(grep(motif, mer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="1-motif-相關知識來源"><a href="#1-motif-相關知識來源" class="headerlink" title="1. motif 相關知識來源"></a>1. motif 相關知識來源</h2><p>本文關於 motif 的定義參考以下文獻與網站</p><ul><li><a href="https://www.merriam-webster.com/dictionary/motif">https://www.merriam-webster.com/dictionary/motif</a></li><li>[莊榮輝，生物化學基礎 Biochemistry Basics 2008] (<a href="http://juang.bst.ntu.edu.tw/BC2008/slides/Proteinx3a.htm">http://juang.bst.ntu.edu.tw/BC2008/slides/Proteinx3a.htm</a>)</li><li>Pizzuti, &amp; Rombo. (2018). Algorithms for Graph and Network Analysis: Clustering and Search of Motifs in Graphs. Encyclopedia of Bioinformatics and Computational Biology: ABC of Bioinformatics, 95.</li></ul><h2 id="2-R-kmer-function"><a href="#2-R-kmer-function" class="headerlink" title="2. R: kmer function"></a>2. R: kmer function</h2><p>K-mers 是指一字串所有長度為 k 的子字串，長度為 l 之字串會有 l - k + 1 個 k-mers，此概念常用於基因體學的序列比對和品質篩選的演算法。</p><p>我的 kmer function 的運作方式是先將字串分割為獨立字符，再用 lapply 依序取出 k 個字符以 paste0 合併為長度為 k 的子字串。由於僅有 l - k + 1 個 k-mers，所以 lapply 迴圈僅執行  l - k + 1 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kmer &lt;- function (s, k) &#123;</span><br><span class="line">  char &lt;- unlist(strsplit(s, &quot;&quot;))</span><br><span class="line">  kmer &lt;- unlist(lapply(0:(nchar(s) - k), function (x) &#123;paste0(char[seq(k) + x], collapse = &quot;&quot;)&#125;))</span><br><span class="line">  return(kmer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-R-grep-和-grepl"><a href="#3-R-grep-和-grepl" class="headerlink" title="3. R: grep 和 grepl"></a>3. R: grep 和 grepl</h2><p>grep 用以尋找文字向量中符合特定模式的元素之索引值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; grep(pattern = &quot;A&quot;, x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;))</span><br><span class="line">[1] 1 5</span><br></pre></td></tr></table></figure><p>grepl 用以判斷文字向量的各元素是否符合特定模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; grepl(pattern = &quot;A&quot;, x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;))</span><br><span class="line">[1]  TRUE FALSE FALSE FALSE  TRUE</span><br></pre></td></tr></table></figure><p>由於此題要求回報子字串的位置，因此使用 grep 實踐之。</p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND | Ordering Strings of Varying Length Lexicographically (LEXV)</title>
      <link href="/ordering-strings-of-varying-length-lexicographically/"/>
      <url>/ordering-strings-of-varying-length-lexicographically/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定字符序列 $\mathscr{A}$，求由這些字符組成且長度小於等於 k 的所有字串。這些字串須依照 $\mathscr{A}$ 字典序排列。</p><blockquote><p>Given: A permutation of at most 12 symbols defining an ordered alphabet $\mathscr{A}$ and a positive integer n (n≤4).</p><p>Return: All strings of length at most n formed from $\mathscr{A}$, ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)</p></blockquote><p>(<a href="https://rosalind.info/problems/lexv/">https://rosalind.info/problems/lexv/</a>)</p><span id="more"></span><p>這題是 <a href="https://5uperb0y.com/enumerating-k-mers-lexicographically/">“Enumerating k-mers lexicographically”</a> 的變體。在原始題目中，只需列出長度為 k 的所有可能字串，這些字串都能直接從長度為 k - 1 的字串延伸而來。</p><p>都是從長度為 k - 1 的字串延伸而來。是以，最終解是遞迴的直接產物，也能追溯到遞迴的基本狀況。</p><p>然而，這題則要求列出所有長度「小於等於 k」的字串，例如 $\mathscr{A}$ 為 <code>[&quot;A&quot;, &quot;B&quot;]</code> 而且 k &#x3D; 2 時，則輸出應包含 <code>[&quot;A&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;BA&quot;, &quot;BB&quot;]</code>。</p><p>雖然 “AA” 和 “AB” 是透過添加字符組成，但是 “A” 和 “B” 則否，輸出結果之前來自不同的關係。為了解決這問題，每次遞迴不只要生成指定長度的字串，還要保留每次遞迴的中繼結果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lexv</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Ordering Strings of Varying Length Lexicographically</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> elements</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> elements:</span><br><span class="line">            output.append(e)</span><br><span class="line">            output.extend([<span class="string">f&quot;<span class="subst">&#123;e&#125;</span><span class="subst">&#123;k_str&#125;</span>&quot;</span> <span class="keyword">for</span> k_str <span class="keyword">in</span> lexv(elements, k - <span class="number">1</span>) ])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND | Enumerating k-mers Lexicographically (LEXF)</title>
      <link href="/enumerating-k-mers-lexicographically/"/>
      <url>/enumerating-k-mers-lexicographically/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定字符序列 $\mathscr{A}$，求由這些字符組成且長度為 k 的所有字串。這些字串須依照 $\mathscr{A}$ 字典序排列。</p><blockquote><p>Given: A permutation of at most 12 symbols defining an ordered alphabet $\mathscr{A}$ and a positive integer n (n≤4).</p><p>Return: All strings of length at most n formed from $\mathscr{A}$ , ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)</p></blockquote><p>(<a href="https://rosalind.info/problems/lexv/">https://rosalind.info/problems/lexv/</a>)</p><span id="more"></span><p>$\mathscr{A}$ 是一個字符序列，除了規範了可用的字符外，也定義了這些字符的字典序。像是英文字母的字典序是從 A 到 Z，所以 “AA” 會排在 “AB” 前面。這題要求從 $\mathscr{A}$ 生成指定長度的所有可能字串，並確保這些字串依照字典序排序。</p><p>假設今有 $\mathscr{A}$ 為 <code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code>，而且指定長度為 3，則生成步驟為：</p><ol><li>從 $\mathscr{A}$ 依序取出字符來組成字串（”A”、”B”、”C”）</li><li>對於每個字符，追加 $\mathscr{A}$ 中的每个字符，生成長度為 2 的所有可能字串（”AA”、”AB”、”AC”、”BA”、”BB”、……”CC”）</li><li>對於長度為 2 的字串，再度追加 $\mathscr{A}$ 中的每个字符，生成長度為 3 的所有可能字串（”AAA”、”AAB”、”AAC”、”ABA”、……”CCC”）</li><li>最終將生成 $3 \times 3 \times 3 &#x3D; 27$ 個字串。</li></ol><p>由上述案例，我們可以歸納遞迴關係如下：</p><ul><li>終止條件：當 <code>k=1</code> 時，回傳 $\mathscr{A}$。</li><li>遞迴關係：對於 $\mathscr{A}$ 每個字符，生成長度為 <code>k - 1</code> 的所有可能字串，再讓字符作為這些字串的前綴。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lexf</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate all permutations of a specified length from a given set of elements.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> elements</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;e&#125;</span><span class="subst">&#123;k_str&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> elements</span><br><span class="line">            <span class="keyword">for</span> k_str <span class="keyword">in</span> lexf(elements, k - <span class="number">1</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>最後再把結果依題目要求的格式印出來。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_results</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="keyword">for</span> k_str <span class="keyword">in</span> lexf(elements, k):</span><br><span class="line">        <span class="built_in">print</span>(k_str)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Enumerating Oriented Gene Orderings (SIGN)</title>
      <link href="/enumerating-oriented-gene-orderings/"/>
      <url>/enumerating-oriented-gene-orderings/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一正整數 n，求包含數字 1 到 n 與 -1 到 -n 的所有可能數列與其總數。</p><blockquote><p>A signed permutation of length n is some ordering of the positive integers {1,2,…,n} in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, π&#x3D;(5,−3,−2,1,4) is a signed permutation of length 5</p><p>Given: A positive integer n≤6</p><p>Return: The total number of signed permutations of length n, followed by a list of all such permutations (you may list the signed permutations in any order).</p></blockquote><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Synteny blocks 是相異物種因為基因體重排而分離的同源片段。在 <a href="https://5uperb0y.com/enumerating-gene-orders/">Enumerating Gene Orders</a> 當中介紹了以數列排列模擬 synteny blocks 重排的想法，我們可以額外考慮 blocks 的方向性來改善模型的精細度。DNA 雖然由兩股去氧核酸構成，但轉錄僅發生在其中一股。</p><p>由於 synteny blocks 在演化過程中除了易位，也可能發生轉置，顛倒基因的排列和方向性，改變轉錄與基因調控等行為，從而影響個體的表徵。例如，Factor VIII Intron 22 的轉置便是血友病A的成因之一。</p><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>這題的解法近似<a href="https://5uperb0y.com/enumerating-gene-orders/">數列的排列</a>，只是透過正負號來表示 synteny blocks 的方向。因為要考慮正負符號，所以需要兩個調整。</p><ol><li>遞迴的 base case 要回傳數字與其相反數。例如輸入數列 <code>[1]</code>，要回傳 <code>[[1], [-1]]</code>。</li><li>在把數字放回排列後的數列時，也要分別加入數字和其相反數。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">slperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;permutations of a numberic list, including -/+ of each number.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [[l[<span class="number">0</span>]], [-l[<span class="number">0</span>]]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            p + [sign_e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> slperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> sign_e <span class="keyword">in</span> [e, -e]</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:lakich1993"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">lakich1993.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Lakich et al. (1993). Inversions disrupting the factor VIII gene are a common cause of severe haemophilia A. Nature genetics, 5(3), 236-241.<a href="#fnref:lakich1993" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Enumerating Gene Orders (PERM)</title>
      <link href="/enumerating-gene-orders/"/>
      <url>/enumerating-gene-orders/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一正整數 n，求包含數字 1 到 n 的所有可能數列與其總數。</p><blockquote><p>A permutation of length n is an ordering of the positive integers {1,2,…,n} . For example, π&#x3D;(5,3,2,1,4) is a permutation of length 5.</p><p>Given: A positive integer n≤7 .</p><p>Return: The total number of permutations of length n , followed by a list of all such permutations (in any order).</p></blockquote><p>(<a href="https://rosalind.info/problems/perm/">https://rosalind.info/problems/perm/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>基因體重排（genome rearrangement）泛指基因體上發生的刪除（deletion）、插入（insertion）、重複（duplication）、反轉（inversion）或易位（translocation）等現象。這些變動通常涉及數百至數百萬對鹼基，相較於點突變，它們的影響更為廣泛。</p><p>基因體重排的發生機制主要有<sup id="fnref:gu2008"><a href="#fn:gu2008" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.">gu2008</span></a></sup>：</p><ul><li>non-allelic homologous recombination (NAHR)：細胞分裂中，染色體對齊時發生錯位，導致片段重組。</li><li>non-homologous end-joining (NHEJ)：DNA 斷鍊修復時，連結了非同源的染色體。</li><li>Fork Stalling and Template Switching (FoSTeS)：DNA 複製時因故停滯時，新合成的 DNA 意外移動到其他模板進行複製。</li></ul><p>這些變化可能導致基因無效而喪失功能、彼此融合而改變功能，或是副本數變動而加強&#x2F;減弱功能，從而影響細胞結構與生理。許多疾病和癌症與基因體重排有關，例如 BRCA1 和 BRCA2 的副本數變化與乳癌發作密切相關。<sup id="fnref:ewald2009"><a href="#fn:ewald2009" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.">ewald2009</span></a></sup></p><p>基因體重排不僅是疾病基因體學的重要研究對象，也因為被視為種化的分子機制之一，而在演化生物學中占一席之地。相較於點突變，基因體重排的發生頻率較低，使得親緣關係相近的物種在染色體層級上保持一致，即使它們在局部基因序列上略有不同。</p><p>然而，親緣關係較遠的物種則可能因為基因體重排而有顯著差異。在演化過程中，這些沒有被分離到道不同區域或染色體的基因彼此聚集成 synteny block。在比較基因體學中，synteny block 提供了一種比染色體數量和大小更細緻的描述單位，有助於在不過度瑣碎的層級上討論基因體的變化。透過比較 synteny block 的繼承與變化，可以推輪物種分化的歷史。<sup id="fnref:touchman2010"><a href="#fn:touchman2010" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">touchman2010</span></a></sup></p><p>這題的設計反映了基因體重排的概念，將每個數列視為一條染色體，其中每個數字代表一個 synteny block，數字的順序則代表這些 block 在餐考基因體上出現的順序或染色體編號。透過模擬單一染色體 synteny block 的不同排列，探索可能的重排情境。</p><h1 id="解題"><a href="#解題" class="headerlink" title="解題"></a>解題</h1><p>讓我們從最簡案例來推論怎麼用遞迴解這題。假設數列只有一個數字，也就只有一種可能的排列；而兩個數字的排列也很直觀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n = 1</span></span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># n = 2</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>現在考慮數列有三個數字的情形。由於沒辦法一眼得到解答，於是我們需要更系統的解決辦法，其中一個策略是：</p><ol><li>先取出其中一個數字</li><li>排列剩下的數字</li><li>把取出的數字加回排列結果</li><li>重複取出所有數字後，便得到數列的所有可能</li></ol><p>如同以下各數列所示，我首先依序取出 1、2、3 （數列的首項），然後再排列剩餘兩個數字，再把取出的數字與排列後的數列結合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># n = 3</span></span><br><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>歸納前述方法，便能用 python 實作以下關係：</p><ul><li>若數列只有一個數字，回傳此數列</li><li>若數列不只一個數字，則依序取出各數字，排列剩餘數字，再把取出的數字加到排列的結果中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Permutations of a list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [l]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>隨後便可整理排列的結果為題目要求的格式。由於我們已經列出所有可能數列，所以直接計算數列總數即可，不用多做一次階乘計算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_permutations</span>(<span class="params">n</span>):</span><br><span class="line">    num_perms = lperm(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(num_perms))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> num_perms:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, p)))</span><br></pre></td></tr></table></figure><h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>我解這題的靈感來自 <a href="https://stackoverflow.com/questions/23116911/all-permutations-of-a-string-in-python-recursive">All Permutations of a String in Python (Recursive)</a> 這串問答，我只需要把原方法改寫為適合 list 的方式即可。不過一開始我寫成以下形式，能看出會報什麼錯誤嗎？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !!!! WRONG SOLUTION !!!!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> = [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>關鍵在於遞迴關係的初始狀態設定，這個 function 預期要回傳一個存儲所有可能數列的巢狀 list，但我在初始狀態的時候寫成 <code>return l</code>，導致遞迴調用 function 回傳了一個攤平的 list。於是 <code>p</code> 就成了整數，自然無法和 <code>[e]</code> 相連，讓程式無法運作。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:ewald2009"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">ewald2009.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.<a href="#fnref:ewald2009" rev="footnote">↩</a></span></li><li id="fn:gu2008"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">gu2008.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.<a href="#fnref:gu2008" rev="footnote">↩</a></span></li><li id="fn:touchman2010"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">touchman2010.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/</a><a href="#fnref:touchman2010" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Counting Point Mutations (HAMM)</title>
      <link href="/counting-point-mutations/"/>
      <url>/counting-point-mutations/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定兩等長字串 s 和 t，計算兩者的 Hamming distance dH(s,t)</p><blockquote><p>Given: Two DNA strings s and t of equal length (not exceeding 1 kbp).</p><p>Return: The Hamming distance dH(s,t).</p></blockquote><p>(<a href="https://rosalind.info/problems/hamm/">https://rosalind.info/problems/hamm/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>分子生物學的突變 (mutations) 是基因序列的改變。其中，點突變 (point mutations) 是指單一鹼基的變化，依照變化的模式可分為 transition（pyrimidine → pyrimidine, purine → purine）和 transversion (purine ←→ pyrimidine)。</p><p>點突變的常見原因為化學修飾或複製錯誤。例如亞硝酸 (nitrous acid) 可透過氧化脫胺將 cytosine 轉化為 uracil，導致該位置的鹼基在下一輪複製發生 transition：C≡G (initial base pair) → U≡G (after mutation) → U&#x3D;A (after replication)。</p><p>由於 Hamming distance 是兩等長字串對應位置之字符不相符的數量，一條序列要轉變為另一條序列最少需要的點突變次數可用 Hamming distance 描述，藉此得以推論源於共同祖先的兩條基因序列的最簡演化途徑。</p><ul><li>ATCG 和 AAAA 的 Hamming distance 為 3</li><li>1234 和 1233 的 Hamming distance 為 1</li><li>dog  和 god  的 Hamming distance 為 2</li></ul><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>使用迴圈依序比對兩字串對應位置的鹼基是否一致，再透過記數變項統計不相符的數量即可計算 Hamming distance</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;GAGCCTACTAACGGGAT&quot;</span></span><br><span class="line">t = <span class="string">&quot;CATCGTAATGACGGCCT&quot;</span></span><br><span class="line">hdist = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i] != t[i]:</span><br><span class="line">        hdist = hdist + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> hdist</span><br></pre></td></tr></table></figure><p>此任務亦可配合 zip 改寫為 list comprehension 形式，即合計兩字串對應位置鹼基符號不相符的數量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">sum</span>([a != b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(s, t)])</span><br></pre></td></tr></table></figure><p>簡言之，zip 可將兩 list 的元素依序取出配對形成新的 list，所以能配合 for 一次處理兩個 list 的元素。例如輸入 zip(“abc”, “def”) 會回傳 [(“a”, “d”), (“b”, “e”), (“c”, “f”)]。zip() 的介紹詳見 <a href="https://blog.gtwang.org/programming/python-iterate-through-multiple-lists-in-parallel/">Python 使用 zip 與 for 迴圈同時對多個 List 進行迭代</a></p><p>至於 List comprehension 則能以較簡潔的程式碼應用 for loop，也往往有較高的執行效率。此表達法的典型形式為 [expression for item in iterable]。例如要從字串中取出非A的序列，一般的 for loop 寫法為</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># common method</span><br><span class="line">str = []</span><br><span class="line">for i in &quot;AATCGG&quot;:</span><br><span class="line">if i != &quot;A&quot;:</span><br><span class="line">str.append(i)</span><br><span class="line">print str</span><br></pre></td></tr></table></figure><p>使用 List comprehension 可將程式碼簡化為一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># list comprehension method</span><br><span class="line">print [i for i in &quot;ATCGG&quot; if i != &quot;A&quot;]</span><br></pre></td></tr></table></figure><p>使用 list comprehension 的其他特性，可參考<a href="https://stackoverflow.com/questions/16341775/what-is-the-advantage-of-a-list-comprehension-over-a-for-loop">What is the advantage of a list comprehension over a for loop?</a> </p><p>回到 hamming distance 的計算，另一種寫法是不直接加總 True&#x2F;False，而是用判斷式把不相符時的距離加權記錄在程式中，這樣可以明確表達鹼基不符時，要計算多少距離。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_distance</span>(<span class="params">s1, s2</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;Calculating hamming distance of two strings with equal length</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>( <span class="number">1</span> <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s1, s2) <span class="keyword">if</span> c1 != c2 )</span><br></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>R 的作法則是使用 strsplit 將字串轉換為 list，再以向量運算對應位置的鹼基是否一致，最後以 sum 統計相異鹼基的數量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s &lt;- &quot;GAGCCTACTAACGGGAT&quot;</span><br><span class="line">t &lt;- &quot;CATCGTAATGACGGCCT&quot;</span><br><span class="line">sum(strsplit(s, &quot;&quot;)[[1]] != strsplit(t, &quot;&quot;)[[1]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DADA2 execution halted (Error in table: attempt to make a table with &gt;= 2^31 elements)</title>
      <link href="/dada2-execution-halted-error-in-table-attempt-to-make-a-table-with-2-31-elements/"/>
      <url>/dada2-execution-halted-error-in-table-attempt-to-make-a-table-with-2-31-elements/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文純粹是技術問題。我之前以 Qiime2 外掛的 DADA2 處理已切除轉接子的 16S rRNA 基因序列 (V4 region) 時，因為以下錯誤而中斷了執行四天的程式。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin error from dada2<span class="operator">:</span> An error was encountered <span class="keyword">while</span> running DADA2 <span class="keyword">in</span> R <span class="punctuation">(</span><span class="built_in">return</span> code <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> please inspect stdout and stderr to learn more.</span><br></pre></td></tr></table></figure><span id="more"></span><p>我檢查錯誤報告後發現以下敘述：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> table<span class="punctuation">(</span>pairdf<span class="operator">$</span>forward<span class="punctuation">,</span> pairdf<span class="operator">$</span>reverse<span class="punctuation">)</span> <span class="operator">:</span></span><br><span class="line">attempt to make a table with <span class="operator">&gt;=</span> <span class="number">2</span><span class="operator">^</span><span class="number">31</span> elements</span><br><span class="line">Calls<span class="operator">:</span> mergePairs <span class="operator">-&gt;</span> lapply <span class="operator">-&gt;</span> FUN <span class="operator">-&gt;</span> table</span><br><span class="line">Execution halted</span><br><span class="line">Running external command line application<span class="punctuation">(</span>s<span class="punctuation">)</span>. This may print messages to stdout and<span class="operator">/</span>or stderr.</span><br><span class="line">The command<span class="punctuation">(</span>s<span class="punctuation">)</span> being run are below. These commands cannot be manually re<span class="operator">-</span>run as they will depend on temporary files that no longer exist.</span><br></pre></td></tr></table></figure><p>於是根據關鍵字查詢只找到<a href="https://github.com/benjjneb/dada2/issues/641">一起相似案例</a>，但該討論串沒有提供可行的解決辦法。簡言之，提問者的資料中可能有人類序列汙染，導致獨特序列的數量超出 DADA2 演算法的上限，所以程式才異常中斷。</p><p>然而，抽檢資料卻沒發現人類序列汙染，而且使用小量資料可以順利執行，讓我難以判斷問題的癥結點。因此，我蒐集 Qiime2 論壇上常提到的出錯狀況，一一測試來確認能否解決問題。</p><p>首先，我<a href="https://forum.qiime2.org/t/dada2-error-return-code-1/7140/3">調整了線程</a>以免記憶體用罄，接著<a href="https://forum.qiime2.org/t/dada2-return-code-1/2972">檢查格式</a>確保資料完整無誤，也重新安裝以排除未知問題，但這些方法都無濟於事，所以我只好 Qiime2 論壇<a href="https://forum.qiime2.org/t/dada2-execution-halted-error-in-table-attempt-to-make-a-table-with-2-31-elements/11845">求助</a>。</p><p>開發團隊指出，這狀況可能是資料中有未清除的技術片段、定序品質太差或是存在汙染序列，使得 DADA2 在其中一步驟時，因數據量過載而中斷（這也可以解釋少量資料可以順利執行的原因）。</p><p>在我移除潛在的文庫汙染，切除末端的低品質序列後，DADA2 便能順利執行了。綜上所述，此錯誤源於數量過多的低品質&#x2F;汙染序列，在移除汙染和品質控管後，即可解決問題。</p><p>而關於除錯，我也學到了幾個經驗：</p><ul><li>仔細閱讀錯誤訊息，鎖定問題癥結點後才能有效排除障礙。胡亂猜測出錯原因無濟於事，反而浪費時間和精力。</li><li>要以錯誤訊息為關鍵字，上網找尋類似問題的解決方式；若找不到直接相關的問題，則重新檢視演算法，說不定可以找到問題來源。</li><li>把蒐集到的方法整理成表，一一測試結果。</li><li>若查詢和測試皆無果，則準備詳盡資料到專門論壇求助。</li><li>解決問題後把過程記錄下來，幫助其他人克服困難🥰</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> metagenomics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Complementing a strand of DNA (REVC)</title>
      <link href="/complementing-a-strand-of-dna/"/>
      <url>/complementing-a-strand-of-dna/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 序列，回傳其反向互補序列。</p><blockquote><p>Given: A DNA string s of length at most 1000 bp.</p><p>Return: The reverse complement sc of s.</p></blockquote><p>(<a href="https://rosalind.info/problems/revc/">https://rosalind.info/problems/revc/</a>)</p><span id="more"></span><h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>2017 年交大某生物相關研究所入學考試其中一題為：「若 DNA 其中一股序列為 ATCGATCG，求其 complementary DNA 序列為何？ (A) AUCGAUCG (B) ATCGATCG (C) TAGCTACG (D) GCTAGCTA。」<br>解題的關鍵在了解分子生物的專有名詞定義，以下是各種 DNA 序列的簡介</p><ul><li>DNA: 去氧核醣核酸</li><li>RNA: 轉錄 DNA 之產物</li><li>complementary DNA (cDNA)：反轉錄 RNA 之產物</li><li>complementary strand of DNA：DNA 兩股互為彼此的 complementary strand of DNA</li><li>reverse complement of DNA：順序反轉的 complementary strand of DNA</li></ul><p>若 DNA 在轉錄後未經加工，原則上對於 DNA 的其中一股而言有以下關係：</p><ul><li>DNA 序列 &#x3D; complementary DNA 序列</li><li>RNA 序列 &#x3D; 把 T 換成 U 的 complementary strand of DNA 序列</li><li>complementary DNA 的序列和 complementary strand of DNA 互補</li></ul><p>因此，答案為 (B) ATCGATCG，若混淆 complementary DNA 和 complementary strand of DNA 會選到完全相反的答案。</p><h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>取得反向互補序列的任務可分解為替換鹼基和反轉序列順序。</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 的字串可以像 list 一樣以索引值提取數值，因此得以 <code>str[::-1]</code> 取得反向序列，此表達式的涵義為「由字串的最後一個字符，一次一個取出所有字符」。而替換互補鹼基則要先建立密碼表（即 A to T, T to A, C to G, G to C），再參考密碼表替換字串中的字符。我使用的第一個策略是以 dictionary 儲存互補鹼基的密碼表，接著建立逐一替換輸入的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    comp = &#123;<span class="string">&quot;A&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;T&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;G&quot;</span>: <span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(comp[nt] <span class="keyword">for</span> nt <span class="keyword">in</span> dna[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>第二個方法則是使用 maketrans(old, new) 建立字符替換的密碼表，再以 translate() 依據密碼表同時替換字串中相應的字符。由於maketrans 是字串這個物件的靜態方法，所以需要在前面加字串來調用之。既然這字串跟副程式其它功能無關，就用空字串表示以免混淆，不然理論上用什麼字串都行，可參考 <a href="https://stackoverflow.com/questions/64513034/purpose-of-string-in-front-of-maketrans">Purpose of string in front of maketrans</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> dna[::-<span class="number">1</span>].translate(<span class="string">&quot;&quot;</span>.maketrans(<span class="string">&quot;ATCG&quot;</span>, <span class="string">&quot;TAGC&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下則是我最初的錯誤嘗試，原先打算連續使用 replace() 替換鹼基，但後來發現第一次迴圈的結果會被第二次會圈抵銷掉（第一次：A to T, 第二次 T to A），所以才會採用前述的方法迴避問題。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># WRONG METHOD!</span><br><span class="line">code = &#123;&quot;A&quot;: &quot;T&quot;, &quot;T&quot;: &quot;A&quot;, &quot;C&quot;: &quot;G&quot;, &quot;G&quot;: &quot;C&quot;&#125;</span><br><span class="line">rcdna = dna</span><br><span class="line">for i, j in code.items():</span><br><span class="line">    rcdna = rcdna.replace(i, j)</span><br><span class="line">print rcdna</span><br></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>相較於 python，R 無法以索引值擷取字符，所以需要將字串轉變為其他格式再處理，以下方法參考 Four ways to reverse a string in R[<a href="https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]">https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]</a></p><ol><li>利用 strsplit() 將字串分割為 list，再以 rev() 反轉 list 順序，最後使用 paste0() 將 list 合併為字串。</li><li>利用 utf8ToInt() 將字串中 utf-8 編碼的字符轉變為 UTF-32 編碼的整數向量，再以 rev() 反轉向量順序，最後用 intToUtf8() 恢復 utf-8 編碼的字符組成之字串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dna &lt;- &quot;AAAACCCGGT&quot;</span><br><span class="line"># strsplit() method</span><br><span class="line">reversed &lt;- paste0(rev(strsplit(dna, &quot;&quot;)[[1]]), collapse = &quot;&quot;)</span><br><span class="line"># utf8ToInt() method</span><br><span class="line">reversed &lt;- intToUtf8(rev(utf8ToInt(dna)))</span><br></pre></td></tr></table></figure><p>由於 gsub() 只能把多種匹配到的字符串替換為一種字符串，<br>，所以得倚重可同時替換多種指定字符的 chartr()。  chartr() 的用法接近 bash 的 tr，會將字串中的 old (舊字符) 替換為 new (新字符)，例如 chartr(“AC”, “TG”, str) 表示 A to T, C to G。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rcdna &lt;- chartr(old = &quot;ATCG&quot;, new = &quot;TAGC&quot;, reversed)</span><br><span class="line">print(rcdna)</span><br></pre></td></tr></table></figure><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>bash 的作法較 python 和 R 簡潔，讀取字串，以 rev 反轉字串順序，再以 tr 替換互補鹼基等步驟可寫成一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dna=&quot;AAAACCCGGT&quot;</span><br><span class="line">echo &quot;$dna&quot;| rev | tr ATCG TAGC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《時間機器》</title>
      <link href="/wells-1895-the-time-machine/"/>
      <url>/wells-1895-the-time-machine/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>小說<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Herbert Wells. (1895) The Time Machine，台灣由棉花田文化翻譯出版為《時間機器》　">1</span></a></sup>是以主角朋友的紀錄呈現。開頭場景類似電影《來自地球的人》，是一場舉行在主角家裡的沙龍。當一夥人正熱烈討論著時空本質時，主角現身向他們展示了正在打造的時光機器。不過要到主角衣衫襤褸，渾身是傷地出現在再次造訪的友人面前，讀者才得以讀到由敘事者轉述，主角經歷的未來冒險。</p><span id="more"></span><p>因為急煞事故，主角被拋出時間機器，來到八十萬年後的世界。雖然與目標的時間區段不符，但本著開拓者的雄心，他決定好好地了解這個世代。主角首先接觸的是身形矮小且細皮嫩肉的埃落依人。埃落依人的外觀不因性別而異，主要以蔬果為食。他們的語言單調而且智慧有限，也未見其有任何生產活動。</p><p>望著四處的大樓廢墟和文明遺址，主角推論埃落依人應該是進步到了盡頭的社會產物。隨著社會進步，人類逐漸克服生存威脅與競爭壓力。一旦沒有威脅與競爭，能力與奮鬥便無關個體生存。於是，以往視為重要特質的野心、智慧和力量等在存活下來的族群逐漸廢弛，最終演變為只懂得享樂的埃落依人。</p><p>在與埃落依人相處一段時日後，主角對他們的習性益發困惑。首先，既然埃落依人幾乎沒有生存能力，他們究竟從何獲得營生的資源？另外，生性樂觀且無害的埃落依人為何異常地害怕黑暗，也不敢接近各處的井口？</p><p>隨著奇異事件接二連三，例如沉重的時光機不翼而飛、在台座上聽到詭異笑聲、夜半瞥見似白狼的生物還有不知通往何處的古井等，主角漸漸意識到，這世界還存在另一批人。這猜想在主角於廢墟直擊一種蒼白枯槁的醜陋生物獲得驗證。</p><p>這些族群被稱為摩洛克人。主角推論，埃落依人與摩洛克人源於工業時代資方與勞方的極端分化。在上位的資本家追求雅致，在下位的勞動者掙扎求生；資本家日漸退化，勞動者益發強韌。資方與勞方因階級固化而互不通婚，逐漸形成生殖隔離，最演化為象徵高雅但不事生產的埃落依人，以及醜陋懼光卻身強力壯的摩洛克人。</p><p>起初，主角認為埃落依人與摩洛克人仍延續著工業時代資方與勞方的主從關係。然而，當主角進入地底搜索時光機，發現被啃食到一半的人肉，他才瞬間明白埃落依人恐懼的根源。</p><p>原來，埃落依人是摩洛克人的牲畜。雖然上位者最初能以資本壓迫勞方，可是隨著勞動者逐漸掌握生產工具和技術，僅存世襲財富而無實業能力的資本家便無法對抗勞動者的反撲。於是勞資的關係反轉，勞動者仍舊像工業時代一樣供應著資本家生活所需的一切，但這種關係無異於飼主對牲畜的餵養。</p><p>經歷過這番震驚後，主角還遊歷了三千萬年後太陽能耗盡而衰亡的世界才回到現代。</p><p>不過，主角的朋友對於他的冒險多持懷疑態度，再加上主角自己的印象都有些錯亂，口說無憑的奇聞軼事更難以置信了。為證明自己所述，主角再次踏上時光旅行。不過，小說卻在敘事者無期的等待中畫下句點。</p><p>我覺得小說中最令人驚嘆的景色是三千萬年後，死寂、淒涼和鬱悶的末日描寫。這段情節或許來自克耳文勳爵的推理。</p><p>克耳文勳爵假設地球曾是個熾熱而無法維持生命存在的星球，於是以鐵球冷凝的實驗推論地球約有四千多萬年歷史。隨著地球冷卻，太陽熱能也會因引力塌縮的極限而消退。最終日光燒盡，全球冷凍。</p><p>然而，依照我們現在的理解，地球面臨的未來將是相反的景況，太陽將持續膨脹，吞沒太陽系的每顆行星。</p><p>另外，威爾斯設定的光機無法回到時光機完工之前的日子。因為時光機會在時間軸上連續移動，若持續回到過去，最終勢必撞上當初打造的時光機，造成時光機毀壞。</p><p>雖然推理方式不同，不過這說法和《時間旅人》的 Ronald Mallett 博士的理論巧合地相似。這種說法解釋了為什麼至今我們還沒有看到來自未來的人，畢竟第一部時光機還沒問世。</p><p>這設定不禁令人思考，每次時間旅行，穿越時間的幅度會和距離同步嗎？畢竟地球自轉速度越來越慢，若用天來評估時間旅行的長度，很有可能穿越過去後發現自己身在太空吧？</p><p>不過，時光機或時光旅行的種種悖論或許不是《時間機器》的主軸。時光機對威爾斯而言，應該比較像當今異世界小說用以交代主角在不同世界穿梭的媒介。</p><p>相關的媒介有旅行（例如格列佛遊記）、太空探險、輪迴等，只是威爾斯使用時光機為媒介，將之作為開啟冒險的按鈕，藉此呈現出他所營造的世界。這個世界不一定要能預測未來的矛盾，也可能源於今日荒謬的局面。所謂奇異，只不過是變了樣的現在。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Herbert Wells. (1895) The Time Machine，台灣由棉花田文化翻譯出版為《時間機器》<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Counting DNA Nucleotides (DNA)</title>
      <link href="/counting-dna-nucleotides/"/>
      <url>/counting-dna-nucleotides/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 字串，依照 “A”、”C”、”G”、”T” 的順序，印出四種鹼基符號的數量。</p><blockquote><p>Given: A DNA string s of length at most 1000 nt.</p><p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols ‘A’, ‘C’, ‘G’, and ‘T’ occur in s.</p></blockquote><p>(<a href="https://rosalind.info/problems/dna/">https://rosalind.info/problems/dna/</a>)</p><span id="more"></span><p>在此例使用 dictionary 的 key 記錄鹼基符號，利用 value 記錄出現頻率，透過迴圈遍歷整個字串，每逢與 key 相同的字符即增加該 key 之 value。</p><p>儘管統計鹼基的方法很直觀，但輸出的順序要留意。題目要求以 A、C、G、T 之順序輸出鹼基出現頻率，但 python 的 <em>dictionary</em> 為無排序的雜湊表，所以值不會依照字母的順序或定義時的順序印出。為了回傳排序後的統計量，要在輸出前調整順序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    freq = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0</span>, <span class="string">&quot;T&quot;</span>: <span class="number">0</span>, <span class="string">&quot;C&quot;</span>: <span class="number">0</span>, <span class="string">&quot;G&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> nt <span class="keyword">in</span> dna:</span><br><span class="line">        freq[nt] = freq[nt] + <span class="number">1</span></span><br><span class="line">    output = <span class="string">&quot; &quot;</span>.join( <span class="built_in">str</span>(freq[nt]) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span> )</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>也可以不自己寫迴圈，套用 python 的字串方法 <em>count()</em> 來統計特定鹼基的數量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">str</span>(dna.count(nt)) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span>)</span><br></pre></td></tr></table></figure><p>shell script 要尋找字串也有許多寫法，其中一種做法是透過 grep -o 取得匹配的鹼基，再傳給 wc -l 計算列數（即字串中，指定鹼基符號的數量）。四種鹼基符號的統計值儲存於 array 並以空格間隔，以便輸出時辨識 array 各項目的數值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&quot;AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC&quot;</span></span><br><span class="line">d=()</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> A C G T;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    d+=$(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$s</span> | grep -o <span class="variable">$ch</span> | <span class="built_in">wc</span> -l) <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span>  <span class="string">&quot;<span class="variable">$&#123;d[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《不道德教育講座》</title>
      <link href="/mishima-1958-lectures-on-immoral-education/"/>
      <url>/mishima-1958-lectures-on-immoral-education/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1958年，三島由紀夫在《明星週刊》連載不道德教育講座，針對當代日本的文化、事件與風俗，提出有違常人價值觀的看法，例如「應該盡量說謊」、「要打從心底瞧不起老師」、還倡議「千萬不要遵守諾言」。</p><p>據他所述，老掉牙的說教作品無趣又矯情，與其重述時下倡導的道德教育，不如談些大逆不道的誇張故事還來得有趣。畢竟，讀者在看了這些荒謬情節之後，沒有產生群起效法的念頭，反倒被激起高尚的品德也說不定。</p><p>坦白講，讀過三島由紀夫其他詞藻華美、情節扭曲的小說之後，很難想像這些專欄文章出自同一人之手。《不道德教育講座》裡頭雖然有些看法引人深思，但也充滿反串、強詞奪理、偏見和誇飾的論述，簡直就像是穿越回二十世紀中葉的 PTT 八卦版鄉民。</p><span id="more"></span><p>舉例來說，三島由紀夫在此書鼓勵讀者盡早擺脫處男，畢竟沒性經驗的男生滿腦子猥褻想法，根本純潔不起來。他也鼓吹喝湯時要發出聲響干擾別人，因為這些奇怪規範是出自於盲從的社會羊群，「傲然的孤郎無須起而效尤」。</p><p>在〈應該由文弱陰柔當道〉當中，他諷刺日本人表面崇尚陰柔氣質，骨子裡還是被陽剛氣概所吸引。文末說道自己現在練了一身肌肉，即使收到徵兵單也無所謂畏懼，但好家在他的年紀已經收不到兵單了。這是什麼「還好我退了」的發言啊？</p><p>另一篇〈偷盜的奇妙功效〉則批評那些貪圖物質利益、手段又拙劣的小偷根本在丟盜賊的臉，鼓勵大家即使作奸犯科也要有宏大目標與卓越手段。三島由紀夫還以身作則，講了一則他巧妙偷走陌生人昂貴鋼筆的小故事，最後在那邊靠北：「呵呵，你看到這篇文章，我也不會還給你喔！」</p><p>除了這些驚世駭俗的言論與觀點，這選集還可以看到表面上是要問卦或討論什麼嚴肅議題，結果只是三島由紀夫想要曬貓：</p><blockquote><p>我是個愛貓成癡的人。因為，貓這種傢伙實在有點自私又忘恩，還有大部分的貓都只是忘恩之徒，而不會像卑劣人類會恩將仇報。</p></blockquote><blockquote><p>我立刻聯想到，人類最應該像貓看齊。因為再沒有比貓更冷淡、更無情、更韌性，並且絕不任由人類擺弄的動物了！牠恐怕也是最不容易被催眠成功的動物吧。因此，我也想要模仿貓，盡量讓自己變得冷淡、薄情、麻木不仁、自主獨立……。而且，只在想吃魚的時候，才願意發出撒嬌的喵喵聲。</p></blockquote><blockquote><p>比如，有隻貓剛從廚房偷吃了一條魚，來到簷廊下曬太陽，接著若無其事地擦抹乾淨，就是「Who knows?」的最佳體現。</p></blockquote><p>此書選錄的文章裏頭，我最喜歡的是「應當打從心底瞧不起老師」、「應當追隨流行」和「肉體的無常」這三則對教育、流行和健身的討論。</p><h2 id="應當打從心底瞧不起老師"><a href="#應當打從心底瞧不起老師" class="headerlink" title="應當打從心底瞧不起老師"></a>應當打從心底瞧不起老師</h2><p>由於尊師重道的觀念以及教師與學生間年齡、地位與知識的落差，學生面對老師時，不免產生崇敬、害怕或依靠等感受。若這層關係僅止於知識的傳授也罷，可是某些教師的控制欲可能干預了學生的價值觀與人生抉擇，蔑視了個體決定自我前途的責任與權利。</p><p>老師在知識上未必全面，在情感上脫離青春期太遠，未必能設身處地體會學生的困擾。其次，決策的後果無論利弊都得由個人承受，老師作為局外人不須擔負選擇的重量，所作所為也不見得貼近學生的需求。因此，對於人生，老師的位置似乎不適合多做什麼，他們可以傳授知識和了解學生，但各自的人生還是得放手讓學生去面對。</p><p>而學生這方，也不能期待老師有能力或義務理解自己。畢竟，無論大人或小孩，各年齡層皆有各自的煩惱，都需要費很多心力來解決。因此，不只不該依賴老師，還要有超越老師的鬥志才行。不管老師表現出輕視的態度還是關愛的態度也好，都可以盡情睥睨他們，只要盡可能從課堂中撈取知識油水就夠了。至於其他奇奇怪怪的刁難或干涉，可以當作往後人生的預習，畢竟這些老師可能是那些惡質成年人當中最容易對付的。</p><h2 id="應當追隨流行"><a href="#應當追隨流行" class="headerlink" title="應當追隨流行"></a>應當追隨流行</h2><p>流行的事物往往被貼上膚淺、易逝和俗套等標籤，三島由紀夫在這篇討論了上流階層輕視流行的現象，並且指出流行的可貴正是這些「不去思考本質」的特性。誠然，流行的事物之所以能迅速普及，正是因為其通俗易懂而沒有深度；之所以短暫亦逝也是因為其輕佻膚淺。</p><p>然而，比起引發了區域衝突甚至世界大戰的各式意識形態，這些膚淺的文化反而保留了更多人類美好的回憶片段。流行的循環性也會讓它在短暫的生命以後，以全新的樣貌出現在人們的生活中，意外地延續流行的壽命。</p><h2 id="肉體的無常"><a href="#肉體的無常" class="headerlink" title="肉體的無常"></a>肉體的無常</h2><p>由於我自己也有在健身，所以很好奇三島由紀夫對健身的看法。三島由紀夫自小體格矮小且單薄，直到在三十歲後讀到健美雜誌了解到這項運動後才開始健身。從網路上可取得的寫真照看來，在那個營養和運動科學才逐漸發展，大眾健身尚不普及的年代，其實也算練得有模有樣了。</p><p>曾想像「如果自己強壯起來，那麼或許……」的人，在慘澹的街燈下走回家，看著自己透過店面玻璃映出的單薄身影時，難免會懷疑自己到底在幹嘛吧？肉體總有一天會衰老、練壯了可還長同一副臉、何況現在也沒練很壯、蛋白質好貴、吃掉的東西怎麼全都變成熱逸散在大氣中……之類的。</p><p>然而，這些懷疑不構成輕視自己肉體的理由。相反地，當你流著汗走回家時，應該要對自己更有自信一點，因為健壯體格短暫無常的特性，反映了人類這種生物荒謬的存在。我們只有一次人生，每分每秒每次呼吸都是絕無僅有，不管活得漂亮瀟灑還是醜陋掙扎，最終同樣要塵歸塵土歸土，隨宇宙熱寂而默然。</p><p>這點跟肌肉一樣。體格是與生俱來，有的人骨架好，有的人長肉快，但所有人都需要經過刻苦訓練與飲食自律才能練出健壯的體魄。沒有人能夠永遠維持精壯，每一次臥推和深蹲都是用力活在當下的證據，都是努力延長「現在」的嘗試。</p><p>因此，三島由紀夫才說「在現代社會裡，肌肉發達不過是可憐又滑稽的東西。可也因為如此，我才會對積極鍛鍊出強健的體魄不遺餘力。」</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以前是從楯之會的維基百科條目了解三島由紀夫的生平，在還沒讀過其作時，已對其人有一堆印象。直到最近被討論串的<a href="https://www.ptt.cc/bbs/Gossiping/M.1677326783.A.D04.html">留言</a>（「 20多年前看過《潮騷》，青春純愛故事，字裡行間聞得到海的味道」）打動，才開始接觸他的作品。</p><p>由於我是從三島由紀夫的娛樂小說和散文作品入門，所以有機會認識這位作家別於外人給定標籤的一面。雖然不是每本書都看得懂，至少這本書我是看得蠻開心的。像讀〈應當打從心底瞧不起老師〉的時候，會想要是早點讀到就好了；但也有像〈肉體的無常〉那樣親身經歷才能體會的感動。最後要坦白，我其實也抄了一些講話很靠北的段落，但那屬於適合自娛的陰暗笑點，就不放上來了 :)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>軟體開發文件管理的簡單數學</title>
      <link href="/the-simple-math-of-document-management-in-software-development/"/>
      <url>/the-simple-math-of-document-management-in-software-development/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>伊藤潤二在其短篇漫畫《藏書幻影》中，描述了一位因為恐懼藏書遺失而決定將家中數十萬本書籍默記在心的書迷。不料，他記住所有藏書的內容後，卻沒有留下絲毫空間給自己的回憶與判斷力，只能終日在書堆中，眼神空洞地翻閱書頁、喃喃自語。</p><p>在軟體開發領域，我們同樣面臨對於遺忘的擔憂。需求分析、風險評估與架構決策等資訊，在開發過程中逐步累積，既是團隊經驗的傳承，也是產品應稽的依據。因此，各企業透過各式各樣的文件，紀錄程式碼以外稍縱即逝的寶貴思想與知識；對於醫療檢測產品，政府單位也提供了文件撰寫指引，詳細列出文件應具備的項目，以確保產品的安全性。</p><p>然而，市場變化與需求異動帶來的時程壓力，也使得團隊陷入開發延宕的恐慌。長期看來，文件固然能提供產品與團隊價值，但是撰寫文件往往是吃力不討好的工作，一方面它不直接改進產品功能，另一方面撰寫文件的努力不亞於軟體開發本身。因此，在迫切需要功能實現或障礙排除時，文件往往是首先被犧牲的項目。</p><p>依照我的經驗，對於如何撰寫文件的倡議，往往基於對內容的保障，未必會考量到維護齊全文件的成本。於是，團隊因為文件與開發的衝突，在棘手的情境間左右為難：要不因為害怕遺漏資訊而導致開發遲滯，又或憂懼逾期交付而造成紀錄不全。</p><p>因此，在這篇文章中，我嘗試跳脫基於儲存資訊的文件框架，加入一些專案管理的觀點，來思考解決兩者衝突的策略，從而避免過時、錯誤或不全等貶損文件價值的不利因素。</p><span id="more"></span><p>無論目標是應對稽核還是與用戶&#x2F;開發者溝通，考量到文件與軟體相輔相成的作用，宜將文件視為產品的一部份，並且在規劃專案時程時，將更新文件的成本納入考慮。</p><p>根據軟體的用途和文件的性質，每個軟體迭代所需更新的文件類型和數量也會有所不同。在個人主導的開源專案中，每次軟體發布可能只涉及 README.md 和 CHANGELOG.md 的修改；但若打算申請美國 FDA 的 IVD 認證，即使是簡單的功能升級，也需要維護近十份文件（例如需求、風險、設計、測試和架構等），而且這些文件的更新必須遵循法規程序，額外增加不少行政成本。</p><p>如果團隊能在指定時間內順利完成軟體與文件更新，則可確保兩者內容及時；反之，則必有一方與進度脫節。為了避免文件過時，我們可以列出以下不等式：</p><p>$$ n \cdot t_{doc} + T_{dev} \leq T_{iter} $$</p><ul><li>$t_{doc}$：更新一份文件所需要的時間</li><li>$n$：軟體每次迭代需要更新的文件數量</li><li>$T_{dev}$：軟體該次迭代的開發總時數</li><li>$T_{iter}$：軟體迭代週期</li></ul><p>依據此不等式，每次軟體迭代維護文件所需的時間取決於更新的成本與頻率。假設固定迭代週期與開發時數，那麼低頻率的更新可以容忍較高的更新成本，而低成本的更新可以配合高頻率的更新。</p><p>撰寫文件的成本補僅與內容相關，也涉及過程中的調查、驗收與調整的成本；若是法規文件，還涉及更多的審查、簽核和文檔管理等手續。而文件更新的頻率則取決於其精細度，內容愈是詳細且貼近軟體底層的運作，愈有可能因為局部的變動而需要更新；反之，內容愈是抽象且概括描述軟體的架構，則能承受較多次的軟體變更。</p><p>我們可以依據這項關係來評估撰寫文件的尺度與範圍。以下是一個假想專案每次軟體迭代各層級物件的更新頻率：</p><table><thead><tr><th>Component</th><th>API Change Frequency</th></tr></thead><tbody><tr><td>Function</td><td>100</td></tr><tr><td>Class</td><td>10</td></tr><tr><td>Structure</td><td>1</td></tr></tbody></table><p>假設這專案的迭代週期為 20 單位時間，開發費時 10 單位時間，每份文件更新需要 1 單位時間。那麼依據不等式，這軟體的文件最多能承受的更新頻率為 10 次。比照更新頻率表，若要避免文件過時，文件的內容最細只能寫到 Class 層級，而 function 層級就超出能力範圍外了。</p><p>$$ n &#x3D; \frac{T_{iter} - T_{dev}}{t_{doc}}$$</p><p>透過這方法，我們可以根據軟體與團隊的特性，調整文件內容的細緻程度，來配合軟體開發的進度。然而，若文件的抽象程度越高，也意味著犧牲了一定程度的細節。在這種情況下，若仍想保留足夠的細節供往後參考該怎麼做？</p><p>原則上，文件內容是否充分取決於當下的品質與隨後的更新。首先，在開發期間透過文件指引、校稿檢查表與同儕審查等方法，可以確保文件具備必要內容並且符合團隊規範；其次，即使發現撰寫當下沒發現的錯誤，之後若能及時修正，也能補充欠缺的資訊。</p><p>這意味著文件完整性與更新文件的成本呈負相關。成本愈低，則容許修改文件的頻率也愈高，文件修訂的機會越多，改善其品質的可能性也越大。換句話說，若我們想在有限的時間內，保障文件的內容及時且完整，就需要容許較高的修訂頻率。我們可以考慮改變文件撰寫的媒介或流程，來降低不等式當中的 $t_{doc}$。</p><p>不過，將彼此相關的資訊記錄在不同的媒介可能會提升文件間的耦合程度。關聯文件越多，每次修改涉及的文件數也越多，這一方面可能增加忘記更新的機率，另一方面，也會增加每次更新時要盤查的文件數量，從而增加文件更新的成本。目前我尚未對此問題得出結論，不過可以考慮使用修改成本較低的索引文件來串接關聯文件，藉此降低主要文件的更新頻率，又能透過索引文件得知要修改的其他文件。</p><p>綜上所述，在專案時程壓力下，團隊往往面臨軟體開發與文件撰寫的衝突。若能再考慮文件應該具備的內容之餘，考量更新文件的頻率和成本，則有機會設計出能配合開發節奏的文件，避免文件過時、錯誤與不全等風險。原則上，若能降低更新文件的成本，便能承受較多次文件更新，間接確保文件的品質與完整性；若更新文件的成本較高，可以考慮調整文件撰寫的尺度，降低更新頻率，以免文件跟不上軟體開發的進度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何管理常用的 Command Line 指令？</title>
      <link href="/how-to-manage-commands/"/>
      <url>/how-to-manage-commands/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img data-src="https://imgs.xkcd.com/comics/tar_2x.png" alt="xkcd:tar (https://imgs.xkcd.com/comics/tar.png)"></p><p>有些指令很常用，但使用頻率不見得高到能讓人既起來。那麼，除了使用記事本以外，還有什麼方法能有效管理這些指令呢？</p><p>本文總結一些管理指令的經驗和訣竅，並且介紹好用的開源工具供參考。</p><span id="more"></span><h2 id="怎麼管理常用但不見得能記起來的指令？"><a href="#怎麼管理常用但不見得能記起來的指令？" class="headerlink" title="怎麼管理常用但不見得能記起來的指令？"></a>怎麼管理常用但不見得能記起來的指令？</h2><p>在初學程式的時候，我除了用 word，還會用紙本筆記紀錄程式碼和常用指令。這些紀錄就擺在我的電腦桌面和電腦桌面上，以便不時參閱。雖然有時會忘記指令放在電腦還是筆記本上，可是當時的內容不多，所以也沒特別感到困擾。大學畢業後，因為微軟的校園授權過期，我索性把所有筆記都搬遷到 Goolge Doc。由於 Google Doc 能是雲端應用程式，所以可以讓文件跨裝置讀取與保管，讓我能統一管理寫作、報告還是程式碼指令等多媒體文件。</p><p>除了文書編輯軟體，我也曾跟上筆記軟體的風潮，試著用 Evernote 和 Notion 等工具。這些軟體把筆記篇幅劃分為更小的單位，加入標籤、資料夾或是資料庫系統，提升了管理筆記的彈性；而它們通常也支持多媒體輸入，也內建全域搜尋系統，改善了許多維護與使用筆記的體驗。</p><p>筆記軟體、文書編輯軟體或紙本筆記本在紀錄筆記上各有千秋，不過據我的使用經驗，它們在管理指令上有共通的問題：查閱指令離使用指令的距離太遠了。讓我們以按鍵數量來衡量查閱與使用的距離，假設要解壓縮一份 <code>tar.gz</code> 檔，前述幾種方法要按上幾次鍵？打開瀏覽器&#x2F;軟體&#x2F;文件、啟動搜尋、鍵入關鍵字、複製指令、打開終端機、貼上指令，扣除搜索的成本，最少也要六次以上。</p><p>這聽起來很像個人 kimochi 的問題，不過如果你的職業正好是個厭世的軟體工程師，那麼想點辦法稍稍拯救一下上班的心情也是個好主意吧？屏除開發或維護的流暢性，若能確保筆記與應用場合貼近，也有助於即時更新筆記的內容。</p><p>綜合以上提及的因素，指令的良好管理方式至少具有統一管理、跨平臺存儲、貼近使用場合等特性，才能提升用戶維護與使用的流暢性。以 Command Line 指令為例，筆記最直觀的存放位置是伺服器或電腦本身，讓他們能透過 Github 備份與版本控管。由於幾乎沒有多媒體需求，使用 markdown 語法紀錄的純文本能兼具可讀性與標籤的功能性，還可在各平台讀取。此外，command line 的搜尋系統普遍比文書與筆記軟體強大，也降低了分類、標籤和重新排序的成本。</p><p>最後，還需要一些程式來銜接筆記與應用的落差，例如將搜尋到的指令直接貼到 command line，就不需要重複複製貼上。</p><h2 id="有哪些好用的工具？"><a href="#有哪些好用的工具？" class="headerlink" title="有哪些好用的工具？"></a>有哪些好用的工具？</h2><p>只要在 Github 主題搜尋 <code>snippet</code> 或 <code>oneliner</code> 便能找到許多指令管理工具可以參考。以下幾款都支援指令速查與調用，而 <code>navi</code> 和 <code>pet</code> 甚至能引導用戶交互式輸入指令所需的參數。以刪除特定的 Docker image 為例，<code>navi</code> 可以做到用快捷鍵搜尋刪除 image 的指令，再用快捷鍵搜尋 image 的名稱，自動回填到刪除指令的參數位置。</p><p>這些工具都允許用戶依照其規範的格式增補指令，有些還內建的指令庫，彙整了像是 <a href="https://github.com/tldr-pages/tldr">tldr</a> 這樣被開源社群維護的簡明指令手冊。</p><ul><li><a href="https://github.com/yuki-yano/zsh-fzf-snippet">zsh-fzf-snippet</a>：基於 fzf 且適用於 zsh 的輕量級指令管理工具，支援指令速查與執行。核心功能只含一支腳本以及紀錄指令的設置檔。</li><li><a href="https://github.com/babarot/easy-oneliner">easy-oneliner</a>：同樣基於 fzf 且適用於 zsh 的輕量級指令管理工具，只是指令的記錄格式與 <code>zsh-fzf-snippet</code> 不同。</li><li><a href="https://github.com/denisidoro/navi">navi</a>：基於 Python 語言的指令管理工具，彙整了 Github 著名的指令庫，除了指令速查與執行的功能外，也會交互式引導用戶輸入指令的參數。</li><li><a href="https://github.com/knqyf263/pet">pet</a>：基於 Go 語言的指令管理工具，定位與 <code>navi</code> 類似，同樣具有指令速查與交互式參數輸入功能。</li><li><a href="https://github.com/chubin/cheat.sh">cheat.sh</a>：彙整了 Github 著名的指令庫，只支援指令速查。有線上版本，所以不需要安裝也能使用。</li></ul><h2 id="如何自己寫一套指令管理工具？"><a href="#如何自己寫一套指令管理工具？" class="headerlink" title="如何自己寫一套指令管理工具？"></a>如何自己寫一套指令管理工具？</h2><p>由於這些工具的原理單純，所以如果對它們的使用方式與格式規範不滿意，DIY 一套適合自己業務需求的輕量級工具也是可行。觀察前述幾項工具之後，我們可歸納出實踐指令速查功能需要的部件，</p><ul><li>儲存格式：儲存指令的格式和語法，理想上要能滿足用戶瀏覽與程式編譯的需求。</li><li>搜尋介面：搜尋指令與自動補全的介面，包含搜尋、瀏覽與預覽功能。</li><li>指令輸出：選中指令後的反應，例如執行、印出或是啟動其他程式等。</li></ul><p>以我模仿 <code>zsh-fzf-snippet</code> 的 <a href="https://github.com/5uperb0y/fzf-oneliner-manager">fzf-oneliner-manager</a> 為例。我採用習慣的 markdown 來記錄指令，標題 (<code>#</code>)紀錄摘要，程式碼區塊(<code>``</code>)紀錄指令，無標記段落則作為補充說明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Print line number X of a file</span><br><span class="line">`head -n &lt;num&gt; &lt;file&gt; | tail -n 1`</span><br><span class="line">https://www.linuxquestions.org/questions/programming-9/print-line-number-x-of-a-file-in-shell-273849/</span><br><span class="line"></span><br><span class="line"># Remove duplicate lines from a file </span><br><span class="line">`awk &#x27;!seen[$0]++&#x27; &lt;file&gt;`</span><br><span class="line">https://linux.cn/article-6881-1.html</span><br></pre></td></tr></table></figure><p>我採用模糊搜索工具 <a href="https://github.com/junegunn/fzf">fzf</a> 來製作搜尋指令的介面。fzf 能依照部分匹配來搜索文字，所以能免除用正則表達式搜尋字串的負擔。除此之外，也提供了一套方便的介面供用戶搜尋和瀏覽文字檔。</p><p>當使用快捷鍵觸發指令速查時，<code>fzf-oneliner-manager</code> 會將指令文件整理成 TSV 檔，其中每一列都包含一條指令的標題、指令內容與補充說明，然後分別陳列標題與補充說明給用戶，讓他們能透過關鍵字或是方向鍵瀏覽要調用的指令。</p><p>一旦指令被選中，指令內容會被截取出來，黏貼到用戶的 command Line 上，只要再按下確認，即可觸發這條指令。這項功能有賴 bash 的 <code>bind -x</code> 指令與 <code>READLINE_LINE</code>&#x2F;<code>READLINE_POINT</code> 變項。</p><p><code>bind -x</code> 能重新映射按鍵以觸發指定的腳本或副程式，此處我把 <code>Ctrl + A</code> 設定成啟動指令速查的快捷鍵。<code>READLINE_LINE</code> 是啟動 <code>bind -x</code> 時，command Line 的內容；而 <code>READLINE_POINT</code> 則是游標所處的位置。換句話說，只要將選中的指令取代既有的 <code>READLINE_LINE</code>，並且把游標挪到指令字串的末端，便能在完成速查後將指令貼到 Command line 上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">READLINE_LINE=<span class="string">&quot;<span class="variable">$&#123;selected&#125;</span>&quot;</span><span class="comment"># 用選中的指令替換 command line 既有的內容</span></span><br><span class="line">READLINE_POINT=<span class="string">&quot;<span class="variable">$&#123;#READLINE_LINE&#125;</span>&quot;</span><span class="comment"># 移動游標到指令字串的末端</span></span><br></pre></td></tr></table></figure><p>因此，有了這樣的工具，管理指令的日子看起來就像這樣：</p><ol><li>「那個解壓縮的指令好像叫 tar 蝦米碗糕的？」，啟動速查。</li><li>找到指令，按下確認執行並解決問題。</li><li>沒找到指令，上網 Google 或是求救 chatgpt。</li><li>把查到的指令補充到指令文件內以便往後搜索。</li><li>無聊時可以打開指令文件緬懷自己的青春，「啊啦啊啦，我小時候可是用 word 紀錄管理 server 的程式碼呢！」。</li></ol><h2 id="結論：即使有-AI，"><a href="#結論：即使有-AI，" class="headerlink" title="結論：即使有 AI，"></a>結論：即使有 AI，</h2><p>不過現在 chatgpt 或 bing AI 那麼方便，指令速查工具還有用嗎？</p><p>我覺得兩者的定位不大一樣。雖然當今生成式 AI 的功能已相當全面，卻仍無法免除溝通的成本。對於陌生議題，獨自構思方法可能比實際解決問題費時，所以上網搜尋、求助他人或是詢問 AI 等借重既有經驗的方法都能縮短整體工時。</p><p>然而，隨著用戶熟悉方法，溝通成本便成為額外的負擔。呼應文首那幅四格漫畫，為了解壓縮一份 <code>tar.gz</code> 檔，你要先打關鍵字、按下搜索、點選網頁、複製&#x2F;貼上、執行，若你用 chatgpt，還得等他做些寒暄和反應的時間。在這種情況下，速查工具能做為很好的捷徑，方便用戶迅速取得常用指令，保持工作的流暢性。</p><p>這也是為什麼我覺得用戶要自己維護指令集，因為這樣內容才會符合每個人各自的頻率、需求和合適的搜索關鍵字。當然，等到哪天勞工不用為系統管理或是NGS分析，AI 能自動自發把事情做完的未來時，那又另當別論。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尋找太陽系外的行星：天文學家莎拉．西格的愛與探索</title>
      <link href="/seager-2021-the-smallest-lights-in-the-universe-a-memoir/"/>
      <url>/seager-2021-the-smallest-lights-in-the-universe-a-memoir/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>莎拉．西格教授任職於麻省理工學院，她因在系外行星探測的理論與實踐上的傑出貢獻，於 2014 年獲頒麥克阿瑟獎。我第一次看到她的名字是在《五十億年的孤寂》一書中，此書訪談了第一線天文學家，介紹學界在尋找地外生命的嘗試、成功與挫敗，描繪出天文生物學的發展軌跡。書中不僅多次提到尋找地外生命的挑戰，還討論了社會支持對科研突破的影響。</p><p>全書以莎拉的訪談作結（由於書不在手，我只能大略描述），描繪了喪偶莎拉在黎明前拖著獨木舟航向一個對於她自己，或是地外生命探索而言都同樣晦暗不明的未來。</p><p>相較於《五十億年的孤寂》，這本書則是莎拉的人生回顧，讓我們得以從她的視角，看到一位科研人員如何因憧憬而投身科研，為什麼堅持下去，以及科研之外的事件如何影響個人的信念和觀點？</p><span id="more"></span><p>德雷克曾提出一條公式 (Drake Equation) 來估計銀河系內可能存在的外星文明數量，這公式將左右生命起源與演化的各種宏觀因素相乘。因此，對於每個因素的估計，都大大地影響了我們對於地外生命是否存在的信心。</p><p>系外行星的數量是公式其中一個變項。在 1960 年代，美國與瑞士的科學團隊分別宣稱透過徑向速度法發現系外行星，飛馬座 51。他們並未直接拍攝到行星公轉的影像，而是透過潛在天體對恆星運動軌跡的影響，來推測行星的存在。簡言之，行星繞行恆星時，恆星其實也繞著彼此的質心運動，導致其與地球的距離週期變化。這種距離變化引發的都普勒效應能在光譜上觀測到，成為支持行星存在的證據。</p><p>然而，學界對於這項發現的看法分歧，一方面有人質疑結果的解釋，另一方面則有人認為影響光譜的是其他天體而非行星。換句話說，在二十世紀中葉系外行星是否存在仍有許多爭議，這意味著即使生命可以輕易在一攤有機物濃湯裡萌發，除了地球外可能沒有合適的地方安放這些原料。觀測系外行星的限制在於沒有辦法直接看見它們，即使是當時最好的望遠鏡也只能捕捉到遙遠恆星甚至整個星系散發的微弱光亮。</p><p>如今，已有數千顆系外行星被發現，觀測方法也不限逕向運動法，還擴展到凌日法或重力透鏡法等手段。不過，在莎拉決定研究系外行星及其可能性的時候，這領域還處在手段闕如，連研究標的是否存在都還不明朗的階段。究竟是什麼樣的啟發和經歷，讓莎拉被系外行星的研究吸引，從而決定探索宇宙這個人類最大的未知領域？</p><p>理由得追溯到她十六歲的時候，擺脫了在派對、嗑藥、溜冰、還有嘉年華的夏季裡格格不入的日子，用打工買下的天文望遠鏡，顫抖地透過鏡片，在寒冷的天空看見木星的那一刻。此後，即使父親強力建議她就讀醫學系，莎拉始終不以為然，打算好好讀書進大學，看一輩子的星星。</p><p>隨後，莎拉於多倫多大學取得數學與物理學士學位，打算在進入哈佛大學進修前的長假走一趟獨木舟之旅。在籌備過程中，她結識了生命最重要的伴侶麥克，他們一同規劃行程、練習泛舟並且想像旅途中的景象。莎拉發現他們彼此能自在相處共享某種孤單，於是邀請麥克偕行。他們一路通過陌生的湖泊、湍流還在森林大火中死裡逃生。旅途之後，麥可隨莎拉在波士頓定居，並在莎拉離開哈佛前結婚。她是這麼描述他們的生活與關係：</p><blockquote><p>我把麥可和我想成宇宙裡的兩個天體，彼此相距遙遠，卻有一種無形的力量將我們綁在一起。我們就像是火星的兩個衛星：佛勃斯和戴摩斯，這兩顆衛星按照不同的軌道運行，彼此的關係卻異常和諧，就像希臘神祉阿瑞斯和阿芙柔黛蒂的雙胞胎兒子一樣，所以才這麼命名。</p></blockquote><p>她與麥可成婚不久後育有兩子，並獲麻省理工學院的教職。儘管職涯和生活皆有相當的進展，但她的光芒背後仍然伴隨著一些陰影，包含了對研究意義的質疑、與研究夥伴的決裂、意外告終的類地行星搜索計劃、寵物與父親的逝世。</p><p>而其中最大陰影，幾乎籠罩生命一切光明的，是她的丈夫麥可在壯年之際罹患癌症。莎拉不得不看著伴侶逐漸衰弱最終病故。麥可的離去不只是情感上的打擊，也破壞了她的生活平衡。以往麥可負責打理家務，讓莎拉能全神貫注在研究項目。如今，她不得不一肩扛起家庭重擔，還要照顧兩位年幼的孩子，又不能落後科研進展。</p><p>在這樣的壓力下，莎拉只好聘僱保母與家管協助，雖然這些幫助大幅減輕家務的負擔，卻無法撫平麥可逝世帶來的哀傷。這些困境和學術行政對身兼家務的學者的不友善態度，使得她一度想要放棄。所幸，寡婦俱樂部的朋友陪伴她度過失去丈夫後的春夏秋冬，研究單位的同仁也在她經濟最險峻的情況下大方支持她，讓她沒有放棄學術研究，熬到因研究成果卓越獲獎，獲得一筆足以支持她研究與生活的獎金。</p><p>幾年後，莎拉再度結識一位能交心的對象，查爾斯。他意外地走進了她的生活，陪伴莎拉走過生涯最低谷的日子。在書末，年過半百的查爾斯放棄繼承家族事業，與莎拉結為連理並搬入她的家。</p><p>莎拉的一生，恰好與她最著名的科研成果──蔽星板計劃──的意象契合。蔽星板是一種輔助觀測系外行星的裝置，它能遮蔽恆星光芒，讓儀器有辦法偵測到周圍行星反射出的微弱光訊號。在莎拉這輩子的追求中，喪夫無疑是巨大的黑暗，但在這片陰影邊緣，微弱的光芒仍引導她看見另一種可能性，如同她對自己踏上天文學的動機的回顧：</p><blockquote><p>當我想到星星，我幾乎可以感受到一股實質的拉力。我想只是看星星，我想要認識它們，每一顆星星，多如海沙的星星。銀河裡的數億顆恆星照亮了不可勝數的天空，而我想要沐浴在它們的光亮裡。對我來說，星星代表的不只是虛無飄渺的可能性，而是可能實現的機率。在地球上的機率對我可能不利，但你的所在之處可以改變一切。自古至今，每顆星星都代表了另一個機會，能讓我置身於另一個人類從未造訪過的地方。</p></blockquote><p>讀過幾本研究人員的回憶錄之後，我覺得莎拉．西格這本書的特色在於真實。雖然書腰文案強調了她獲得麥克阿瑟「天才獎」的不凡成就，好像在她經歷了一系列凌亂無章的現實生活和機會渺茫的大膽追求之後，終於得到應有的認可。不過實際上莎拉在接獲得獎消息時，第一個反應是她終於獲得一筆救命財，可以支應單親職業婦女的許多開銷，甚至有時間慢慢喜歡上自己不擅長的家庭瑣事上。</p><p>另外，也許是好萊塢影視、又或不明來歷的勵志著作、還是義務教育輔導課營造的印象，凡提起研究人員，總帶有獻身的意味在，好似這些人在某種神啟之後，便下定決心穿著白袍透過望遠鏡或顯微鏡窺探宏觀到至微的宇宙。然而，實際上人們從事什麼職業，又在哪個領域卓越是諸多因素綜合的結果。</p><p>相較於其他人，莎拉既有才能也早早立定志向，但她求學也曾經驗了只能透過程式碼觀測星空，與憧憬的生活有巨幅落差的時候；任教過程中遭遇的家庭與事業打擊更是讓她幾度萌生退意。科學家不是像媒體或大眾想像得那樣總是理性自若，同樣會經歷情緒崩潰與歇斯底里。</p><p>這本書沒有像其他傳記那樣仔細描述科學發現的過程，而是忠實地呈現了科學家作為人的一面，畢竟，愛恨情仇以及無數說不出的煩惱，無一例外地困擾著追尋星辰的科學家以及其他行業的人們。</p>]]></content>
      
      
      
        <tags>
            
            <tag> astrobiology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《三島由紀夫書信教室》</title>
      <link href="/mishima-1968-yukio-mishima-letter-classroom/"/>
      <url>/mishima-1968-yukio-mishima-letter-classroom/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這本書是由五個角色書信往來所構成的故事，他們分別是厭惡市儈作風的文藝青年炎丈流、故意寫英文情書來評價心儀對象的美艷寡婦冰真間子、收藏著五百條領帶和收養五隻貓的風流男士山鳶夫、對工作毫無熱誠只等著嫁人的粉領族空美津子，以及執著於奶油蛋糕和彩色電視機的丸虎一。</p><span id="more"></span><p>炎丈流與空美津子因通信來往而萌生情愫。眼見情侶倆關係日漸密切，暗戀炎丈流的空美津子找上損友山鳶夫，想寫封黑函來拆散這對情侶。不料，山鳶夫亦在彼此閒談與奚落的互動中，愛上了空美津子。於是基於一番妒意，暗中幫助炎丈流與空美津子，替他們向雙方的家長說情，促成這對情侶的婚事。</p><p>得知消息的空美津子，寫了封信大罵山鳶夫，還斷言要與之絕交。所幸，丸虎一在無意間勸和兩人，讓故事的結局兩對情侶皆成眷屬，而丸虎一也如願得到他想要的彩色電視和奶油蛋糕。</p><p>雖然作者對感情的見解有趣以及對損友關係的描述恰到好處，但這本書最大的看點還是丸虎一那充滿現代感的垃圾話，喜歡到我幾乎把他寫的每封信都抄了下來。</p><p>好比說，他因為借不到錢（向冰真間子）買彩色電視機又被對方揶揄一番，憤而威脅對方要到處宣傳她的學生英文很爛。</p><blockquote><p>要是不願意請客，我會在東京到處宣傳您英文補習班的每一個學生英文都很糟糕。</p></blockquote><p>又因看不到彩色節目，憂鬱纏身，寫了封信邀請冰真間子陪他殉情，只因對方老得無法作為戀愛與結婚對象：</p><blockquote><p>不光如此，我每看一個鐘頭節目，必定會吃掉一包奶油花生，也就是同時進行「看、寫、吃」這三件事，這樣一來，我相當於活了別人的三輩子。<br>不過，悲慘的現實卻是我只能觀看黑白節目，連一台彩色電視機都買不起。既然已經活了別人的三輩子，不如趁著青春年華好時光，在眾人的惋惜之下離開人——今晚忽然如此有感而發，倍覺空虛，於是選中了您陪我殉情。</p></blockquote><p>或是最終替朋友出氣的方式也令人拍案叫絕：</p><blockquote><p>最近收到一封冰真間子女式的信，信裡寫道「山鳶夫實在惹人厭，一想到他就讓人反胃！你遇到那個傢伙時，記得代我朝他吐口水」，可是這陣子沒機會見到您，又不好拖延真間子女士的交代，所以隨信附上一張沾有我口水的紙，請您把它放在臉上抹一抹。</p></blockquote><p>三島由紀夫說他們的通信內容「既可視為書信格式，也可當成寫作範本」。然而，當代人的情感生活往往比小說人物單純，我們觀念也相對開放，所以要用到這些信件的場合不多。諸如「力邀殉情的信」和「已非處子之身的坦白信」可能已充滿時代感。</p><p>不過，三島由紀夫在最後一章給讀者的信中，還是總結了寫信的要點：</p><blockquote><p>寫信時一定要先了解一個前提條件，那就是收信人根本不在乎寫信人的一切。這是最重要的關鍵。<br>一個洞悉世態者深知人們對其他人毫不在意，唯有攸關自身利害得失的時候才會產生興趣，儘管這是一種苦澀的人生哲學。<br>直到你深切體悟，世上的每一個人只顧朝著自私自利的目標邁進、除了極少數的例外幾乎不會在意其他人，這時你的文字才有躍然紙上的力量，能夠寫出撼動人心的書信。</p></blockquote><p>我覺得這道理無論哪個時代或哪種通訊媒介，只要人類仍是人類便依然適用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>莫莉的眼睛：《神經喚術士》的未來描寫</title>
      <link href="/how-william-gibson-depict-the-future-in-neuromancer/"/>
      <url>/how-william-gibson-depict-the-future-in-neuromancer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cyberspace 首見於威廉吉布森的著作，是指由可彼此互動的實體連結而成的網路空間，諸如物聯網、網際網路乃至生物體的訊息傳遞網路也可屬其範疇。</p><p>在《神經喚術士》(Neuromancer) 裡，吉布森為讀者描述了一個義體改造、意識研究與生化科技發達的世界。在這世界中，熱衷竊取情報與資訊的好手能透過面板將神經系統與網路連結，從而擺脫肉體束縛，讓意識遨遊在 cyberspace 之中。</p><p>顯然，故事中的 cyberspace 是至今尚未實現的概念，我們仍然仰賴鍵盤、滑鼠與螢幕等人機介面與網際網路的另一端互動。那麼，吉布森要怎麼描述意識連結到龐大而無遠弗屆的 cyberspace 時，會呈現什麼景象呢？</p><span id="more"></span><p>故事的主角凱斯因為竊取了雇主的情報而遭受私刑懲罰，雖然保住一命卻喪失了連網能力。在故事開端，神秘人物阿米提找到了凱斯，以治療其神經系統為條件，換取凱斯3以其卓越的駭客能力為他辦事。</p><p>當凱斯接受了先進醫療重獲連網能力後，他久違地再次進入 cyberspace，作者這樣描述：</p><blockquote><p>他閉上眼。<br>找到電源鈕凹凸不平的表面。<br>在他眼睛後方泛血光的黑暗中，銀色光幻視從空間邊緣翻騰湧入，入眠前的影像晃盪而過，彷彿以隨機畫面拼湊而成的電影。符號、人影、臉孔，一副模糊、破碎的視覺資訊曼陀羅。<br>拜託，他祈禱，現在──</p><p>一個灰色碟狀物，千葉天空的顏色。<br>現在──<br>灰碟開始旋轉，愈轉愈快，變成一個較淡灰色的球。漸漸膨脹──<br>接著湧動，為他而湧動；液態霓虹的摺紙戲法；他那無遠近的家、他的祖國逐漸開展，透明 3D 棋盤無間延展。東方沿海裂變管理局（Eastern Seaboard Fission Authority）那附階梯的猩紅金字塔在美國三菱銀行（Mitusbishis Bank of America）的綠色方塊後方發光，他張開內在之眼看著這座金字塔；而在非常高遠之處，他看見軍事系統的螺旋臂，他永遠無法觸及。</p><p>然後他在某處笑著，在一個白漆閣樓，遙遠的手指愛撫控制板，解脫的淚水從臉龐滑落。</p></blockquote><p>雖然術語的堆砌與連續不斷的描述可能造成閱讀的困難，然而陌生字眼和意識流般的描述正好塑造了資訊洪流湧入凱斯意識之中的感受。</p><p>因此，雖然初次閱讀時可能難以將這些詞彙轉化為清晰的形象與畫面，但這些敘述帶來的思覺負擔卻能體現出 cyberspace 的某些特質。這也是為什麼 cyberspace 也可被譯作「塞爆空間 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「塞爆」不只是音譯 (https://danjalin.blogspot.com/2008/07/blog-post_22.html)">1</span></a></sup>」，寓意著資訊流的氾濫與過載。<br>一般而言，名詞的堆砌和冗長不間段的描述會形成閱讀的阻礙，然而陌生的字眼、意識流似的描述卻在此處營造出 cyberspace 資訊洪流湧入凱斯意識中的感覺。</p><p>在 cyberspace 之外，《神經喚術士》則有許多篇幅較短而資訊較稀疏，卻絲毫不減其為未來世界帶來鮮明印象的段落。</p><p>阿米提治療了凱斯的神經系統時，也委託醫生替他更換了因嗑藥而幾近衰竭的肝臟，以免任務完成前病故途中。作者並沒有直接描述人工器官的先進或義體置換的複雜，而是透過手術後令人不快的後遺症來描述。</p><blockquote><p>「你在浪費時間，牛仔。」凱斯從外套口袋拿出一顆八角藥丸時，莫莉這麼說。<br>「怎麼說？要來一顆嗎？」他把藥丸遞給莫莉。<br>「你的新胰臟，凱斯，還有你肝臟上的插頭。阿米提讓它們繞過那些玩意兒。」她用一根勃根地指甲輕點藥丸，「你在生物化學上沒辦法享受安非他命或古柯鹼。」<br>「媽的。」他看著藥丸，然後看著她。<br>「吃啊，吃一打下去。什麼也不會發生。」<br>他吃了，真的什麼也沒有。</p></blockquote><p>我尤其喜歡書中對殺手莫莉的的眼睛的描述。莫莉與凱斯同樣受僱於阿米提，但她對阿米提的背景持有疑慮，因此與凱斯合作的過程也嘗試調查幕後真相。</p><p>當凱斯與莫莉初次見面時，他留意她的特殊之處：</p><blockquote><p>她搖頭。凱斯這才察覺那副眼鏡是以手術嵌入，封住了她的眼窩。銀色鏡片看似從顴骨上方平滑蒼白的肌膚長出來，框在蓬亂的黑髮下。</p></blockquote><p>這裡簡潔的敘述留給讀者需多想像空間，隨著劇情發展，透過凱斯對莫莉性格的逐步理解，她的外表與內在逐漸豐富。（關於這雙眼睛，可以在 google 查詢 「neuromance molly fan art」看看大家根據這些描述能畫出幾種版本的莫莉）</p><p>接著，他們有了更親密的肢體接觸：</p><blockquote><p>「沒關係，」她說，「我看得見。」剝下皮褲的聲音。她在他身旁扭動，掙脫皮褲後踢到一旁。她一腿跨過他，而他碰觸她的臉。植入鏡片意想不到地堅硬。「不要。」她說，「指印。」</p></blockquote><p>在執行任務途中，他們也談起改造後的生理感受：</p><blockquote><p>「我不哭，通常。」<br>「但妳會怎麼哭，如果有人把妳弄哭？」<br>「我吐口水。」她說，「淚腺牽到嘴裡。」”</p></blockquote><p>這種利用生活瑣事的不便與疙瘩感營造出的真實感，不僅讓未來世界更為具體，也豐富了角色的形象。</p><p>例如，在描寫凱斯透過終端與莫莉連接時，作者沒有說明意識共感的具體原理和操作方式，反而著重在莫莉與凱斯的互動：</p><blockquote><p>「目的是？」<br>「沒概念。只知道我要幫莫莉裝上播送裝置，所以你多半是要存取她的感覺中樞吧。」芬恩搔了搔下巴，「這下你可以弄清楚她的牛仔褲到底多貼身了，嗯？」</p></blockquote><blockquote><p>「感覺如何，凱斯？」他聽見字句，也感覺到她構句。她一隻手滑進口外套，一根指尖繞著溫暖絲綢下的乳頭打轉。那感覺令他屏住呼吸。她大笑，但這連結是單向的，他無法回應。</p></blockquote><p>類似的還有以下意識被數位化的描述，同樣沒有講清意識載體的外在形象，卻讓人對這項科技印象深刻。</p><blockquote><p>「你好嗎，迪西？」<br>「我死了，凱斯。在保坂裡待的時間足以想通這點。」<br>「感覺如何？」<br>「沒感覺。」<br>「困擾嗎？」<br>「困擾的是，沒東西讓我感到困擾。」<br>「怎麼說？」<br>「我有這麼一個夥伴先前在俄羅斯營區，西伯利亞，拇指凍傷了。軍醫來切掉拇指。一個月後，他整晚翻來覆去。愛羅伊，我說，你在煩什麼？該死的拇指癢死我了，他說。所以我告訴他，那抓一抓啊。麥考伊，他說，是另一隻天殺的拇指。」構體笑時顯現出來的是不一樣的東西，不是笑聲，而是從凱斯脊椎往下蔓延的一陣寒意。「幫個忙，老弟。」<br>「什麼忙，迪西？」<br>「你的這一局結束時，把這該死的東西刪除。」</p></blockquote><p>寫到這裡，驟然勾起我關於科技進展與感官變化的回憶。我的右手食指與中指間長著厚繭，所以持筆寫字時總是感到不舒服。我想這都得歸咎於以前看書時，往往不乖乖坐在桌前，而是靠在牆邊環抱雙臂，用一隻手比出剪刀姿勢夾住書脊把書頁支撐在視線處，試圖展現瀟灑氣質與俠客風範。</p><p>時至今日，我也不怎麼讀書了，倒是很常癱軟在椅上看著一則則短影片傻笑，絲毫不介意展現頹廢無為的作風。頂多偶爾因為耐不住手機重量，讓小指的第二指節有喘息的時間。</p><p>回到寫作的話題，要具體描述下一代人們裝酷耍廢或賴以為生的事物還真不容易。不過喀了嗨不起來的鬱卒、殺手罕見的眼淚、摸不著的困擾、指縫間的厚繭、小指節的痠疼感這類感受，這類根植於人類這物種的原始體驗或許能作為橋接人們想像與不存在事物的公約數吧。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「塞爆」不只是音譯 (<a href="https://danjalin.blogspot.com/2008/07/blog-post_22.html">https://danjalin.blogspot.com/2008/07/blog-post_22.html</a>)<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常見的生物資訊軟體開發文件</title>
      <link href="/a-collection-of-essential-documents-for-bioinformatis-software/"/>
      <url>/a-collection-of-essential-documents-for-bioinformatis-software/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>撰寫軟體的理想目標是讓程式碼自我解釋，使得任何受過訓練的工程師能夠僅靠程式碼本身理解其含意。然而，隨著軟體功能與部件日益複雜，我們仍須依賴額外的文件來說明程式碼的商業邏輯、運作情境與潛在限制等背景知識。</p><p>在生物資訊軟體開發領域，尤其是醫療軟體開發中，文件的詳盡程度與正確性尤為重要。為了把關產品品質與和保障用戶權益，醫療產品驗證要求產品送審時提供完整的軟體設計、需求分析和產品驗證報告。這些文件的種類繁多且規範細緻，撰寫和維護這些文件往往成為開發者的重擔。</p><p>減輕這種負擔的一種方法是讓開發人專注於與開發相關的文件，並將這些文件作為合規文件的來源。透過簡化文件類別和統一內容來源，來簡化文件撰寫和維護的流程。</p><p>因此，本文整理了常見的生物資訊軟體開發文件，闡述與開發密切相關的文件類型，並列舉優良的撰寫指南，同時對各類文件的定位差異提出個人見解。</p><span id="more"></span><h1 id="常見的生物資訊軟體開發文件清單"><a href="#常見的生物資訊軟體開發文件清單" class="headerlink" title="常見的生物資訊軟體開發文件清單"></a>常見的生物資訊軟體開發文件清單</h1><p>雖然文件內容會依專案性質與規模而有所不同，但在開發過程中通常會隨專案進展逐步納入以下幾種文件，</p><table><thead><tr><th>名稱</th><th>內容</th><th>額外受眾</th><th>指引</th></tr></thead><tbody><tr><td>Issues</td><td>紀錄 bugfix 或 feature request 等開發需求與問題</td><td>專案經理</td><td><a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Feature-Requests">Writing Good Feature Requests</a> &amp; <a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Bug-Reports">Writing Good Bug Reports</a></td></tr><tr><td>Docstring &amp; Type hints</td><td>描述程式模組的功能、參數與回傳資訊</td><td>開發者</td><td><a href="https://peps.python.org/pep-0257/">PEP 257</a> &amp; <a href="https://peps.python.org/pep-0484/">PEP 484</a></td></tr><tr><td>Code comments</td><td>程式碼的補充說明，包括任務標記和權益作法提示</td><td>開發者</td><td><a href="https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/">Best practices for writing code comments</a></td></tr><tr><td>Built-in help</td><td>軟體內建的用戶幫助訊息</td><td>用戶</td><td><a href="http://docopt.org/">docopt</a></td></tr><tr><td>Commit messages</td><td>摘要程式碼異動的內容、理由與背景</td><td>開發者</td><td><a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional commits</a></td></tr><tr><td>Pull requests</td><td>簡述為滿足需求對應的軟體異動及其理據</td><td>審查者</td><td><a href="https://www.pullrequest.com/blog/writing-a-great-pull-request-description/">Writing A Great Pull Request Description</a> &amp; <a href="https://github.blog/2015-01-21-how-to-write-the-perfect-pull-request/">How to write the perfect pull request</a></td></tr><tr><td>README</td><td>介紹專案目標、安裝使用與授權等入門資訊</td><td>用戶</td><td><a href="https://www.makeareadme.com/">Make a README</a></td></tr><tr><td>CHANGELOG</td><td>紀錄專案開發歷程與各版本更新內容</td><td>用戶</td><td><a href="https://keepachangelog.com/en/1.1.0/">Keep a CHANGELOG</a></td></tr></tbody></table><p>除了專案進展，開發文件的內容和格式也會根據團隊或任務需求而異。例如，單一腳本構成的小型專案在初期可能僅需程式碼註解和內建幫助訊息；隨著專案成熟，可以逐漸增加 README 文件來補充安裝和授權資訊，並在軟體定版後定期更新CHANGELOG。而個人開發的專案可能沒有 Pull Request 資訊；但團隊開發除了需要 pull request 把關軟體品質外，還需要 issues 管理專案排程。</p><p>表中的連結已提供詳細的文件撰寫指引，以下我將補充一些對個別文件定位的看法。</p><h1 id="README-和-CHANGELOG-的差異"><a href="#README-和-CHANGELOG-的差異" class="headerlink" title="README 和 CHANGELOG 的差異"></a>README 和 CHANGELOG 的差異</h1><p>README 呈現專案的現況，包括專案簡介、安裝和使用方法、軟體授權等必要資訊，是用戶或開發者了解專案的首要途徑。除此之外，README 還充當軟體文件的目錄，連結到用戶手冊、常見問題和開發指南等資源，供進階用戶或開發者參考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># README</span><br><span class="line"></span><br><span class="line">## Introduction</span><br><span class="line"></span><br><span class="line">## Quick start</span><br><span class="line"></span><br><span class="line">## installation</span><br></pre></td></tr></table></figure><p>CHANGELOG 則記錄專案的過往，包括軟體變更和版本號次等更新資訊，是用戶或開發者了解開發歷程的入門管道。此外，CHANGELOG 也充當專案歷程的目錄，連結到 issue 和 pull request 等資源，供進階用戶或開發者參考。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CHANGELOG</span><br><span class="line"></span><br><span class="line">## [1.1.0] - 2019-02-15</span><br><span class="line"></span><br><span class="line">### Added</span><br><span class="line"></span><br><span class="line">- Danish translation (#297).</span><br><span class="line">- Georgian translation from (#337).</span><br></pre></td></tr></table></figure><p>換言之，README 和 CHANGELOG 總結了專案的現況與過往，是用戶與開發者了解專案最基礎的媒介。因此，這兩份文件通常會擺在專案目錄的最頂層，確保所有人一眼就能找到。</p><h1 id="Commits-和-CHANGELOG-的差異"><a href="#Commits-和-CHANGELOG-的差異" class="headerlink" title="Commits 和 CHANGELOG 的差異"></a>Commits 和 CHANGELOG 的差異</h1><p>如前所述，CHANGELOG 主要記錄軟體的重要變更，這些變更可能影響軟體的功能或使用方式。典型的 CHANGELOG 會按時序編排條目來排列，並依版本和變更類型組織變更紀錄。每條記錄不僅簡要描述了變更內容，還會連接到相關的需求文檔，補充軟體變更背景資訊。</p><p>相較之下，commit messages 主要面向開發者，著重於個別程式碼的變更，而非對整體用戶的影響。標準的 commit messages 通常包括變更類型和簡要說明，其中類型方便篩選和查找相關資訊，而簡要說明則提供了變更的摘要。這些資訊讓查閱者能夠追蹤開發歷程（例如使用 <code>git log --onelines</code>），並在需要時回溯程式碼的變更。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure><p>更完整的 commit messages 則包含了變更的背景、原因或機制的詳細解釋，有時還會附上註腳標記相關的 issue 連結，補充程式碼變更的需求情境</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure><p>雖然兩者都是開發紀錄的一部分，但 CHANGELOG 著重於需求的處置，commit 則聚焦程式碼的具體變更；CHANGELOG 通常隨著軟體更新而更新，而 commit 則在提交後鮮少變更；CHANGELOG 強調變更的影響，而 commit 則更注重變更的細節。由於這兩種文件的目標受眾和內容尺度殊異，直接從 commits 生成 CHANGELOG 可能會導致不必要的冗餘資訊，從而無法達到 CHANGELOG 的設計目的。</p><h1 id="Code-comments-和-Docstring-的差異"><a href="#Code-comments-和-Docstring-的差異" class="headerlink" title="Code comments 和 Docstring 的差異"></a>Code comments 和 Docstring 的差異</h1><p>程式碼內的文字不被執行的文字片段可分為 code comments （註解）與 docstring。以 Python 為例，docstring 是記錄函數、類別或模塊的特殊屬性，它們被夾註在三重雙引號之中，用於描述功能、參數和回傳資訊等自訂資訊。透過內置的 <code>__doc__</code> 方法可以取得 docstring，使其能被語義化工具解析，用於自動化文件生成，如 docopt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def complex(real=0.0, imag=0.0):</span><br><span class="line">    &quot;&quot;&quot;Form a complex number.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    real -- the real part (default 0.0)</span><br><span class="line">    imag -- the imaginary part (default 0.0)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if imag == 0.0 and real == 0.0:</span><br><span class="line">        return complex_zero</span><br></pre></td></tr></table></figure><p>另一方面，註解也是程式碼中不執行的文字片段，可用於解釋程式碼的背景或機制。值得注意的是，註解通常無法以內置方法取得，因此較常用於標記任務（如：<code>TODO</code>）、提供權宜性解法的提示或對複雜程式碼進行補充說明，並會隨著程式碼的改進而被簡化或刪除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># TODO: remove the deprecated method</span><br><span class="line"></span><br><span class="line"># Use the name as the title if the properties did not include one (issue #1425)</span><br><span class="line"></span><br><span class="line"># Magical formula taken from a stackoverflow post at &lt;URL&gt;, reputedly related to human vision perception.</span><br></pre></td></tr></table></figure><p>總結來說，註解的內容較為多樣，可能包括臨時註記或任務提醒；而 docstring 則是程式碼正式文件的一部分，記錄了關於程式本身使用上的更多資訊。</p><h1 id="開發文件應存放何處？"><a href="#開發文件應存放何處？" class="headerlink" title="開發文件應存放何處？"></a>開發文件應存放何處？</h1><p>理想上，開發文件應具備好找、好讀和好維護等特性。這些特性可以這樣定義：</p><ul><li><strong>好找</strong>：文件應支援全域搜尋或資料庫搜尋，方便獲取重要資訊。</li><li><strong>好讀</strong>：文件應能在網頁、圖形介面或終端機中打開，並且資訊清晰簡潔。</li><li><strong>好維護</strong>：文件應集中存放於單一位置並能進行版本控制，以減少文件與開發進度不一致的風險。</li></ul><p>考量到這些原則，一些常見的文件格式可能不適合管理開發文件。例如，Office 系列文件不易進行搜尋和版本控制。將文件存放在品管系統 (ISO) 或多個資料夾中也不利於取得文件。而 HTML 和 LaTeX 等格式則包含過多無關的排版標記，使內容難以閱讀。</p><p>因此，目前最普遍的做法是使用 Markdown 進行純文本編輯，並將文件統一存放在專案目錄下。這樣不僅便於備份、版控和搜尋，還可以像程式碼一樣按照開發流程更新文件，從而將開發和文件緊密結合，降低不一致的風險。</p><p>常見的專案文件結構如下，例如 Python 的 <a href="https://github.com/psf/requests">requests</a> 專案或生物資訊領域的 <a href="https://github.com/nf-core/sarek/tree/3.4.0">nf-core</a> 等專案都採用了這樣的結構。</p><p>將 README 和 CHANGELOG 這兩種反映專案主要內容的文件放在專案根目錄，方便用戶或開發者取得這些資訊。再以單獨的目錄管理其他自訂文件，並共享多媒體資源，如圖片、影片或字體等。這種做法的好處除了方便管理外，還可以通過程式碼工具將文件編譯成網頁或 PDF 等易於閱讀與分享的格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|- README.md # 專案現況的學習途徑                   </span><br><span class="line">|- CHANGELOG.md              # 開發歷程的入門管道   </span><br><span class="line">|- docs/                        # 自訂文件</span><br><span class="line">    |- assets/                  # 共享的多媒體資源</span><br><span class="line">    |- &lt;usage/output/faq&gt;.md    # 用戶、開發者或分享用的文件</span><br><span class="line">    |- &lt;makefile&gt;               # 用以編譯文件檔為其他格式</span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>在生物資訊軟體開發的領域中，常見的文件類型可以分為三大類：程式碼本身 (Source Code)、軟體當前狀態 (README)、以及開發歷程 (CHANGELOG)。這些文件不僅涵蓋了軟體的關鍵資訊，還透過互相連結和註腳形式，串聯起相關的文件內容。這樣的做法有利於在必要時將內容改寫為合規文件的格式。最佳的文件管理方法是將其儲存在專案目錄下，採用 Markdown 格式進行純文本編輯。這不僅保證了文件的可檢索性和易讀性，還可通過 Git 進行版本控制，確保文件的維護和更新與程式碼開發流程同步，從而達到易於維護的目的。</p><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://academic.oup.com/bib/article/19/4/693/2907814">Top consideratios for creating bioinformatics software documentation</a></li><li><a href="https://understandlegacycode.com/blog/where-to-put-documentation/">Where should you put the documentation</a></li><li><a href="https://agilemodeling.com/essays/agiledocumentation.htm">Lean&#x2F;Agile Documnetation: strategies for agile teams</a></li><li><a href="https://www.ithome.com.tw/voice/95002">技術文件產能工具</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Door into Astrobiology | 天文生物學入門資源</title>
      <link href="/the-door-into-astrobiology/"/>
      <url>/the-door-into-astrobiology/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>天文生物學（Astrobiology）是研究生命在宇宙中形成、演化和分布的跨領域學科。由於至今只在地球上發現生物，所以眼下課題就是釐清形成地球生命的機制與先決條件，欲達成這目標不僅得追溯組成生物的原料來源，還需了解有哪些因素影響適居環境的構成，並從演化和地質證據推敲無機物轉變為生物的過程。</p><p>利用前述知識，研究者得以探討太陽系其他天體存在生命的可能，當今最具希望者無疑是我們的鄰居火星，不過類木行星的衛星，例如歐羅巴、泰坦，也有孕育生命的潛力。倘若能在這些迥異的環境中發現生命，它將成為地球生命的對照組，有助於釐清「生命是什麼？」這類問題，也會擴張對生命起源條件的想像。目前歐洲和美國太空總署皆有探索生命跡象的太空任務，至於迄今人類科技水準仍無法到達的遙遠恆星系統，則有賴天文觀測及光譜分析技術去尋找生命存在的間接證據。</p><p>總而言之，天文生物學不只是天文學加上生物學，它集結了宇宙學、演化學、地球科學、資訊科學、生物化學、比較行星學、分子生物學……等等無數學科，研究對象從五微米大的細胞到十萬光年長的星河，從宇宙爆發到生命誕生。因此，無論喜歡哪種尺度、身懷哪種學術專業，只要想探索生命起源的終極問題，總能在其中找到安身立命的地方。</p><p>本文整理了有關天文生物學（Astrobiology）的書籍、線上課、演講等學習資源，並依其內容劃分為通論、生命起源、搜索地外生命、科學史四類，歡迎大家留言補充。</p><span id="more"></span><h1 id="科普書籍"><a href="#科普書籍" class="headerlink" title="科普書籍"></a>科普書籍</h1><h2 id="通論"><a href="#通論" class="headerlink" title="通論"></a>通論</h2><ul><li>田村元秀 (2023) [《天文生物學超入門》] (<a href="https://www.books.com.tw/products/0010968407?sloc=main">https://www.books.com.tw/products/0010968407?sloc=main</a>) [台灣東販]</li><li>Jeffrey Bennett &amp; Seth Shostak (2016)：<a href="https://www.books.com.tw/products/CN11331116">《宇宙中的生命》</a> [機械工業]（簡）</li><li>Gerda Horneck &amp; 莊逢源 (2010)：<a href="https://www.books.com.tw/products/CN10159991">《宇宙生物學》</a> [中國宇航]（簡）</li><li>Peter D. Ward &amp; Donald Brownlee (2017)：<a href="https://www.books.com.tw/products/0010741618">《寂寞的地球：宇宙唯一有複雜生命的行星》</a> [貓頭鷹]</li><li>Michael William Ovenden (1964)：<a href="https://www.amazon.com/Universe-Science-Study-Michael-Ovenden/dp/0435550292">《宇宙中的生命》</a> [徐氏]</li></ul><h2 id="生命起源"><a href="#生命起源" class="headerlink" title="生命起源"></a>生命起源</h2><ul><li>Sir Paul Nurse (2021)：<a href="https://www.books.com.tw/products/0010909520?sloc=main">《生命之鑰》</a> [三采]</li><li>Addy Pross (2018)：<a href="https://www.books.com.tw/products/CN11604089">《生命是什麼：40億年生命史詩的開端》</a> [中信]（簡）</li><li>王立銘 (2018)：<a href="https://www.books.com.tw/products/CN11599405">《生命是什麼》</a> [人民郵電]（簡）</li><li>Freeman Dyson (2017)：<a href="https://www.sanmin.com.tw/product/index/006310600">《生命的起源》</a> [浙江大學]（簡）</li><li>Nick Lane (2016)：<a href="https://www.books.com.tw/products/0010730616">《生命之源：能量、演化與複雜生命的起源》</a> [貓頭鷹]</li><li>Erwin Schrodinger (2016)：<a href="https://www.books.com.tw/products/0010708022">《薛丁格生命物理學講義：生命是什麼？》</a>[貓頭鷹]</li><li>Christian de Duve (2011)：<a href="https://www.books.com.tw/products/0010516325">《生物決定論：人類一定會出現在地球上嗎？》</a> [左岸文化]</li><li>李杰信 (2008)：<a href="https://www.sanmin.com.tw/Product/Index/000791958">《生命的起始點：談生命起源》</a> [科學普及]（簡）</li><li>A.G.Cairns-Smith (1995)：<a href="https://www.books.com.tw/products/CN10041905">《生命起源的七條線索》</a> [中國對外翻譯]（簡）</li><li>Francis Crick (1993)：<a href="https://book.douban.com/subject/2420069/">《生命：起源和本質》</a> [科學普及]（簡）</li></ul><h2 id="尋找地外生命"><a href="#尋找地外生命" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul><li>Dara Oacute; Briain (2023)： <a href="https://www.books.com.tw/products/CN11895285">《真的有外星人嗎》</a> [中國紡織]（簡）</li><li>Ben Miller (2022)： <a href="https://www.sanmin.com.tw/product/index/010759160">《外星人來了？》</a> [中國友誼]（簡）</li><li>瀧澤美奈子 (2021)：<a href="https://www.sanmin.com.tw/product/index/010419542">《當天文學遇上生物學》</a> [機械工業]（簡）</li><li>Lewis Dartnell (2021)：<a href="https://www.sanmin.com.tw/product/index/010408023">《人人都該懂的地外生命》</a> [浙江教育]（簡）</li><li>李傑信 (2021)：<a href="http://《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》">《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》</a>[三民書局]</li><li>Jon Willis (2018)：<a href="https://www.books.com.tw/products/CN11579783">《群星都是你們的世界》</a> [中信]（簡）</li><li>Димитър Д. Съселов (2017)：<a href="https://www.books.com.tw/products/CN11465684">《超級地球上的生命》</a> [上海科學技術]（簡）</li><li>Louisa Preston (2017)：<a href="https://www.books.com.tw/products/CN11440032">《地外生命探索之旅》</a> [中國計量]（簡）</li><li>李炎 (2016)：<a href="https://www.sanmin.com.tw/product/index/006090615">《太空生物學》</a> [漢珍]</li><li>Bignami G. (2013)：<a href="https://www.books.com.tw/products/CN11062152">《我們就是火星人：尋找宇宙中的地外生命》</a> [科學]（簡）</li><li>李冰 (2011)：<a href="https://www.sanmin.com.tw/product/index/001680995">《尋找外星人》</a> [北京師大]（簡）</li><li>Donald Goldsmith &amp; Tobias Owen (1999)：<a href="https://www.amazon.co.jp/-/en/Donald-Goldsmith/dp/0201569493">《尋找宇宙生命》</a> [朗文]</li></ul><h2 id="科學史"><a href="#科學史" class="headerlink" title="科學史"></a>科學史</h2><ul><li>Sara Seager (2021)：<a href="https://www.books.com.tw/products/0010882271">《尋找太陽系外的行星：天文學家莎拉．西格的愛與探索》</a>[天下文化]</li><li>Ron Miller (2018)：<a href="https://www.books.com.tw/products/CN11600118">《外星生命簡史：人類400年地外生命探索與想象全記錄》</a> [北京聯合]（簡）</li><li>Bill Mesler &amp; H. James Cleaves II (2017)：<a href="https://www.books.com.tw/products/CN11438003">《生命的誕生——我們究竟來自哪裡》</a> [人民郵電]（簡體）</li><li>Lee Billings (2017)：<a href="https://www.books.com.tw/products/0010741343">《五十億年的孤寂：繁星間尋找生命》</a> [八旗文化]</li><li>汪洁 (2017)：<a href="https://www.sanmin.com.tw/Product/index/006841620">《億萬年的孤獨：地外文明探尋史話》</a> [北京時代華文書局]（簡）</li></ul><h1 id="線上課程"><a href="#線上課程" class="headerlink" title="線上課程"></a>線上課程</h1><h2 id="通論-1"><a href="#通論-1" class="headerlink" title="通論"></a>通論</h2><ul><li><a href="https://www.acoea.com/?utm_campaign=6647bde1-a2ee-4363-adb3-ecaa2466dff5&utm_source=so&utm_medium=mail&cid=ab330e43-978b-4e52-8b2a-7347df1555d3">“Introduction to Astrobiology”</a> [Amity University]（Centre of Excellence in Astrobiology）</li><li><a href="https://astrobiovideo.com/en/">“Online Courses in Astrobiology”</a> [ International Astronomical Unio]</li></ul><h2 id="生命起源-1"><a href="#生命起源-1" class="headerlink" title="生命起源"></a>生命起源</h2><ul><li>Bruce W. Fouke，<a href="https://www.coursera.org/learn/emergence-of-life">“Emergence of Life”</a> [The University of Illinois]（coursera）</li><li>Jack Szostak，<a href="https://www.ibiology.org/speakers/jack-szostak/">“The Origin of Life on Earth”</a>（iBiology）</li><li>Sarah Maurer &amp; Chris Kempes，<a href="https://www.complexityexplorer.org/courses/103-origins-of-life">“Origins Of Life”</a> [Santa fe institute]（Complexity Explorer）</li></ul><h2 id="尋找地外生命-1"><a href="#尋找地外生命-1" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul><li>Charles Cockell，<a href="https://www.coursera.org/learn/astrobiology">“Astrobiology and the Search for Extraterrestrial Life”</a> [The University of Edinburgh]（coursera）</li><li>Charles Cockell， <a href="https://www.youtube.com/channel/UCBTwJSnAqZZczK7stBaYq5w/playlists">“Life in the Universe – the pandemic series”</a>（Youtube）</li><li>Chris Impey，<a href="https://www.coursera.org/learn/astrobiology-exploring-other-worlds#syllabus">“Astrobiology: Exploring Other Worlds”</a> [The University of Arizona]（coursera）</li><li>David Spergel，<a href="https://www.coursera.org/learn/life-on-other-planets">“Imagining Other Earths”</a> [Princeton University]（coursera）</li><li>Lynn Rothschild，<a href="https://cosmolearning.org/courses/astrobiology-and-space-exploration">“Astrobiology and Space Exploration”</a> [Stanford University]（CosmoLearning）</li><li>Димитър Д. Съселов，<a href="https://www.edx.org/course/super-earths-and-life">“Super-Earths and Life”</a> [Harvard University]（edX）</li></ul><h1 id="演講"><a href="#演講" class="headerlink" title="演講"></a>演講</h1><h2 id="通論-2"><a href="#通論-2" class="headerlink" title="通論"></a>通論</h2><p>待補</p><h2 id="生命起源-2"><a href="#生命起源-2" class="headerlink" title="生命起源"></a>生命起源</h2><ul><li>Christoph Adami，<a href="https://www.ted.com/talks/christophe_adami_finding_life_we_can_t_imagine?language=zh-tw">〈尋找難以想像的生命〉</a>[TEDxUIUC]</li><li>Lee Cronin，<a href="https://www.ted.com/talks/lee_cronin_making_matter_come_alive?language=zh-tw">〈讓物質變活〉</a>[TEDGlobal]</li><li>Martin Hanczyc，<a href="https://www.ted.com/talks/martin_hanczyc_the_line_between_life_and_not_life?language=zh-tw">〈生命與非生命的界線〉</a>[TEDSalon London]</li><li>Nathalie Cabrol，<a href="https://www.ted.com/talks/nathalie_cabrol_how_mars_might_hold_the_secret_to_the_origin_of_life?language=zh-tw">〈探秘火星，解開地球生命之謎〉</a>[TED]</li></ul><h2 id="尋找地外生命-2"><a href="#尋找地外生命-2" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul><li>Aomawa Shields，<a href="https://www.ted.com/talks/aomawa_shields_how_we_ll_find_life_on_other_planets?language=zh-tw">〈我們如何尋找存在於另一顆行星上的生命〉</a>[TED]</li><li>Carolyn Porco，<a href="https://www.ted.com/talks/carolyn_porco_could_a_saturn_moon_harbor_life?language=zh-tw">〈土星的衛星可能有生命存在嗎？〉</a>[TED]</li><li>Dave Brain，<a href="https://www.ted.com/talks/dave_brain_what_a_planet_needs_to_sustain_life/transcript?language=zh-tw">〈行星維持生命存在的要素〉</a>[TEDxBoulder]</li><li>Freeman Dyson，<a href="https://www.ted.com/talks/freeman_dyson_says_let_s_look_for_life_in_the_outer_solar_system?language=zh-tw">〈在太陽系外圍找尋生命〉</a>[TED]</li><li>Garik Israelian，<a href="https://www.ted.com/talks/garik_israelian_what_s_inside_a_star">〈How spectroscopy could reveal alien life〉</a>[TEDGlobal]</li><li>James Green，<a href="https://www.ted.com/talks/james_green_3_moons_and_a_planet_that_could_have_alien_life?language=zh-tw">〈可能有生命存在的一個行星和三個衛星〉</a>[TED Talks Live]</li><li>Lucianne Walkowicz，<a href="https://www.ted.com/talks/lucianne_walkowicz_finding_planets_around_other_stars">〈Finding planets around other stars〉</a>[TEDGlobal]</li><li>Penelope Boston，<a href="https://www.ted.com/talks/penelope_boston?language=zh-tw">〈火星可能有生命存在〉</a>[TED]</li><li>Sara Seager，<a href="https://www.ted.com/talks/sara_seager_the_search_for_planets_beyond_our_solar_system/transcript?language=zh-tw">〈尋找太陽系外的行星〉</a>[TED]</li><li>Seth Shostak，<a href="https://www.ted.com/talks/seth_shostak_et_is_probably_out_there_get_ready?language=zh-tw">〈準備好，ET (可能) 就在那裡〉</a>[TEDxSanJoseCA]</li><li>Tabetha Boyajian，<a href="https://www.ted.com/talks/tabetha_boyajian_the_most_mysterious_star_in_the_universe?language=zh-tw">〈宇宙中最神秘的一顆星〉</a>[TED]</li><li>Димитър Д. Съселов，<a href="https://www.ted.com/talks/dimitar_sasselov_how_we_found_hundreds_of_potential_earth_like_planets/transcript?language=zh-tw">〈發現數百顆類似地球的行星〉</a>[TEDGlobal]</li></ul><h2 id="科學史-1"><a href="#科學史-1" class="headerlink" title="科學史"></a>科學史</h2><ul><li>Jill Tarter，<a href="https://www.ted.com/talks/jill_tarter_s_call_to_join_the_seti_search/transcript?language=zh-tw">〈加入SETI計劃〉</a>[TED]</li></ul><h1 id="知識普及網站"><a href="#知識普及網站" class="headerlink" title="知識普及網站"></a>知識普及網站</h1><ul><li><a href="https://www.facebook.com/Abiogenesis-262675454086715/">Abiogenesis</a></li><li><a href="https://www.facebook.com/Abiogenesis-Hall-of-Fame-138681233223461/">Abiogenesis Hall of Fame</a></li><li><a href="https://www.astrobio.net/">Astrobiology Magazine</a></li><li><a href="http://astrobiology.com/">Astrobiology Web</a></li><li><a href="https://www.facebook.com/Life-the-Origin-of-245683669160907/">Life, the Origin of</a></li><li><a href="https://www.facebook.com/Origin-of-Life-293514407692658/">Origin of Life</a></li><li><a href="https://www.zhihu.com/column/gswxzt">古生物新聞</a></li></ul><h1 id="學術機構"><a href="#學術機構" class="headerlink" title="學術機構"></a>學術機構</h1><h2 id="研究單位"><a href="#研究單位" class="headerlink" title="研究單位"></a>研究單位</h2><ul><li><a href="https://www.bmsis.org/">Blue Marble Space Institute of Science</a></li><li><a href="https://cool.gatech.edu/">Center for the Origin Of Life</a> [Georgia Institute of Technology]</li><li><a href="http://www.elsi.jp/en/">Earth-Life Science Institute</a> [Tokyo Institute of Technology]</li><li><a href="https://www.emergence-of-life.de/index.html">Emergence of Life</a></li><li><a href="https://www.originscenter.nl/">Origins Center</a> [University of Groningen]</li><li><a href="https://origins.harvard.edu/">Origins of Life Initiative</a> [Harvard University]</li><li><a href="https://www.simonsfoundation.org/life-sciences/origins-of-life/simons-collaboration-on-the-origins-of-life/">The Simons Collaboration on the Origins of Life</a> [Simons Foundation]</li></ul><h2 id="社群與學會"><a href="#社群與學會" class="headerlink" title="社群與學會"></a>社群與學會</h2><ul><li><a href="https://www.facebook.com/groups/2221810485/">Astrobiology Club</a> [Facebook club]</li><li><a href="https://astrobiologysociety.org/">Astrobiology Society of Britain</a></li><li><a href="https://saganet.ning.com/">Social Action for a Grassroots Astrobiology Network (SAGANet)</a></li><li><a href="http://issol.org/">International Society for the Study of the Origin of Life (ISSOL)</a></li><li><a href="https://www.facebook.com/groups/515811491814739/">Virtual Astrobiology Society</a> [Facebook club]</li></ul><h2 id="研討會"><a href="#研討會" class="headerlink" title="研討會"></a>研討會</h2><ul><li><a href="https://www.abgradcon.org/">Astrobiology Graduate Conference</a></li><li><a href="https://connect.agu.org/abscicon/home">Astrobiology Science Conference</a></li><li>Biennial European Astrobiology Conference</li><li><a href="https://issol.org/meetings/">International Conference on the Origin of Life</a></li><li><a href="https://www.grc.org/origins-of-life-conference/">Origins of Life Gordon Research Conference</a></li><li><a href="https://indico.physik.uni-muenchen.de/event/63/">Molecular Origins of Life</a>, Munich</li></ul><h1 id="研究中心與學術合作網路"><a href="#研究中心與學術合作網路" class="headerlink" title="研究中心與學術合作網路"></a>研究中心與學術合作網路</h1><h2 id="亞洲及大洋洲"><a href="#亞洲及大洋洲" class="headerlink" title="亞洲及大洋洲"></a>亞洲及大洋洲</h2><ul><li><a href="https://www.aca.unsw.edu.au/">Australian Centre for Astrobiology</a></li><li><a href="http://abc-nins.jp/en/">Astrobiology Center</a> (in Japan)</li><li><a href="https://astrobiologyindia.in/">Astrobiology India</a></li><li><a href="https://www.facebook.com/AstrobioPak/">Astrobiology Network of Pakistan</a></li><li><a href="https://www.acoea.com/">Centre of Excellence in Astrobiology</a> (in India)</li><li><a href="https://logos.ls.toyaku.ac.jp/~astrobiology-japan/en/">Japan Astrobiology Network</a></li></ul><h2 id="美洲"><a href="#美洲" class="headerlink" title="美洲"></a>美洲</h2><ul><li><a href="https://astrobiology.nasa.gov/">Astrobiology at NASA</a></li></ul><h2 id="歐洲"><a href="#歐洲" class="headerlink" title="歐洲"></a>歐洲</h2><ul><li><a href="http://www.eana-net.eu/">European Astrobiology Network Association (EANA)</a></li><li><a href="http://life-origins.com/">life-origins.com</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://oolen.org/">Origin of Life Early-career Network (OoLEN)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> astrobiology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜模仿 docstring 來註解 process and workflow</title>
      <link href="/nextflow-extract-docstring-from-a-module/"/>
      <url>/nextflow-extract-docstring-from-a-module/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹使用 docstring 的好處，並且探討如何在 Nextflow 使用多行註解模仿 python 的 docstring，從而改善撰寫與維護開發文件的流暢性。</p><span id="more"></span><p>python 的 docstring 是 function 的強大特性，能讓開發者在參數類別之外，補充關於 function 的用途、假設條件以及運作原理等額外資訊。透過 <code>__doc__</code> 屬性，docstring 能夠被其他程式讀取，實現開發文檔自動化等功能。</p><p>更重要的是，docstring 位於 function 內部，這讓開發者更動程式碼後，能夠輕易地同步更新文檔，減少文檔與程式碼不一致的情形。</p><p>然而，Nextflow 目前並不支援 docstring 功能。不過，我們可使用多行註解（即介於 <code>/*</code> 與 <code>*/</code> 之間的文字）來模仿 docstring 的效果。這對於協助開發者了解當前的 module（無論是 process 或 workflow）都很有幫助。</p><p>鑒於 Nextflow 的註解無法像 python docstring 那樣透過物件方法呼叫，我寫了一支小腳本來<a href="https://github.com/5uperb0y/nf-tools/tree/main/src/get_docstring">節錄這些資訊</a>。</p><p>簡言之，我將位於 module 名稱與 directive 之間的多行註解定義為 Nextflow 的 docstring，例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process &lt;name&gt; &#123;</span><br><span class="line"><span class="comment">/* your comments */</span></span><br><span class="line">directives</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">your code</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這支腳本運用正則表達式（感謝 chatgpt 幫忙想出裏頭可怕的正則表達式）來抓取 docstring，將其與 module 類型（即 workflow 或 process）和名稱一併輸出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python get_docstring.py workflow.nf</span><br><span class="line">process FASTQC</span><br><span class="line">this text is from FASTQC</span><br><span class="line">workflow VARIANT_CALLING</span><br><span class="line">this text is from VARIANT_CALLING</span><br></pre></td></tr></table></figure><p>如此一來，我們就能取得 docstring 的內容，不僅方便瀏覽 module 功能，也便於自動生成文檔。</p><p>雖然目前功能還蠻陽春的，但之後也許可以新增其他實用功能，例如支援以名稱篩遠 docstring，或是使用 groovy 開發，使之能在 Nextflow 內部調用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜如何改善用戶的命令列使用體驗</title>
      <link href="/nextflow-improve-user-experience-on-cli/"/>
      <url>/nextflow-improve-user-experience-on-cli/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 的命令列介面對開發者而言已相當全面，但對一般用戶而言，仍有可以改善的空間。本文介紹一些 Nextflow 的內建功能，可以因應不同的專案結構，改善用戶的命令列使用體驗。</p><span id="more"></span><h1 id="如何執行-Nextflow-腳本？"><a href="#如何執行-Nextflow-腳本？" class="headerlink" title="如何執行 Nextflow 腳本？"></a>如何執行 Nextflow 腳本？</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nextflow run /path/to/workflow.nf\</span><br><span class="line"> -c  /path/to/params.config\</span><br><span class="line"> -params-file /path/to/params.json\</span><br><span class="line"> [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure><p>Nextflow 的命令包含幾個關鍵選項，</p><ul><li><code>run</code>：啟動腳本的選項，用於執行特定的 Nextflow 腳本</li><li><code>-c</code>：pipeline 的設置檔案，可調整運算環境、計算資源和日誌檔等 pipeline 相關參數，也能批次導入腳本中以 <code>params</code>定義的參數</li><li><code>-params-file</code>：參數批次檔，經由 <code>-params-file</code> 導入的參數優先於 <code>-c</code> 導入的參數。</li><li><code>--something</code>：由命令列輸入的參數，可滿足特定的運算需求，具最高優先度。</li></ul><h1 id="可能的改進空間"><a href="#可能的改進空間" class="headerlink" title="可能的改進空間"></a>可能的改進空間</h1><p>Nextflow 的命令列設計對開發者而言相當全面，但從一般用戶的角度來說，仍有一些使用上的挑戰。這些挑戰中，最明顯的是腳本與設置檔的選擇問題。對於只包含單一腳本與配置檔案的專案而言，清楚的使用說明與文件標示足以確保腳本正確使用。然而，一旦涉及多個腳本與配置檔案，容易造成使用者困惑，尤其是在必須針對不同計算環境或分析場域選擇適當設置檔的情境。</p><p>其次，雖然 <code>-params-file</code> 提供了參數輸入的靈活性，允許用戶批次輸入樣本並且自訂 pipeline 的參數，但這同時也將 pipeline 的核心參數和樣本相關的參數混合在一起，有可能會造成一定程度的混淆。</p><p>再者，自定義參數檔需要以 JSON 格式輸入，可能對一些用戶不夠友善。</p><h1 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h1><h2 id="預設設置檔"><a href="#預設設置檔" class="headerlink" title="預設設置檔"></a>預設設置檔</h2><p>為了簡化設置檔的指定過程，可善用 Nextflow <a href="https://www.nextflow.io/docs/latest/config.html#configuration-file">讀取參數的機制</a>，將預設參數寫在腳本內部，或是存放在腳本同層目錄下的 <code>nextflow.config</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。">1</span></a></sup>。 如此一來，若用戶未使用 <code>-c</code> 指定，Nextflow 會自動讀取這兩個參數來源以執行腳本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workflows</span><br><span class="line">|- main.nf</span><br><span class="line">|- nextflow.config</span><br></pre></td></tr></table></figure><h2 id="管理多元設置"><a href="#管理多元設置" class="headerlink" title="管理多元設置"></a>管理多元設置</h2><p>跨平台與情境的設置檔可以透過 Nextflow 的 <a href="https://www.nextflow.io/docs/latest/config.html#config-profiles">Configuration Profile</a> 來管理，從而避免因少量參數異動而建立多個設置檔。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">profiles &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        process.executor = &#x27;docker&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    k8s &#123;</span><br><span class="line">        process.executor = &#x27;k8s&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用時，可以在命令列指定相應的 profile 切換執行環境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextflow run workflow.nf -profile <span class="string">&quot;k8s&quot;</span></span><br></pre></td></tr></table></figure><h2 id="採用表格輸入"><a href="#採用表格輸入" class="headerlink" title="採用表格輸入"></a>採用表格輸入</h2><p>為了改善輸入檔案與 pipeline 參數的管理，可以考慮使用表格形式紀錄輸入檔案的資訊，將 pipeline 相關參數另外以命令列傳入，達到區分樣本相關資訊與 pipeline 核心參數的效果。</p><p>讀入表格資料的方式可參考 <a href="https://nextflow-io.github.io/patterns/process-per-csv-record/">Process per CSV record</a>。假設有批定序資料要分析，其檔案路徑記錄在 <code>input.csv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;uuid&quot;,&quot;fq1&quot;,&quot;fq2&quot;</span><br><span class="line">&quot;smp1&quot;,&quot;/path/to/smp1_r1.fq&quot;,&quot;/path/to/smp1_r2.fq&quot;</span><br><span class="line">&quot;smp2&quot;,&quot;/path/to/smp2_r1.fq&quot;,&quot;/path/to/smp2_r2.fq&quot;</span><br></pre></td></tr></table></figure><p>則讀取方式可寫作：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input_ch = Channel.fromPath(params.input) |</span><br><span class="line">| splitCsv(<span class="attr">header:</span><span class="literal">true</span>) \</span><br><span class="line">| map &#123; row -&gt; tuple(row.uuid, file(row.fq1), file(row.fq2)) &#125;</span><br></pre></td></tr></table></figure><p>用戶便能透過 CSV 格式管理批次輸入的資料，並透過命令列指定其餘參數。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextflow run workflow.nf --input input.csv --output /path/to/output</span><br></pre></td></tr></table></figure><h2 id="使用入口腳本"><a href="#使用入口腳本" class="headerlink" title="使用入口腳本"></a>使用入口腳本</h2><p>在包含多個 pipeline 的專案中，可以在專案根目錄新增 <code>main.nf</code> 腳本。在這個入口腳本中，可以編寫一些幫助函數，協助用戶了解所有可用的 pipeline，或是讓用戶透過別名來快速呼叫特定的 pipeline，實踐各式各樣的客製功能。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (params.help) &#123;</span><br><span class="line"><span class="comment">// print help messages</span></span><br><span class="line"><span class="comment">// select pipeline to run by user-input key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣做的好處是，用戶可以用統一的名字呼叫 pipeline，不用記憶各支腳本的路徑。而且，用戶可以使用 <code>--help</code> 等參數來了解專案中各 pipeline 的用途與使用方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextflow run workflow --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>綜合以上的改進方案後，用戶可以在不深入研究專案目錄結構的情況下，了解該專案能提供的分析及其使用方式，免除指定設置檔的負擔，並且以慣用的表格來管理輸入檔案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextflow run project --workflow &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure><p>若需要額外的封裝和彈性，也能在 Nextflow 框架之外，開發一個能包裝其 API 的軟體，進一步簡化用戶的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wapper &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, mVCF)</title>
      <link href="/introduction-to-multiverse-variant-call-format/"/>
      <url>/introduction-to-multiverse-variant-call-format/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假設在很久很久以後的未來，人類有能力偵測到發生在多重宇宙各時間線的事件，也有演算法來比較事件間的異同，從而彙整出能代表多數宇宙歷史的標準時間線。利用跨宇宙與跨時間線的全史資料，往後的史家能將蒐集的歷史資料與標準時間線比較，推測事件的偶然與必然，指引未來史的發展方向。</p><p>面對龐大歷史分歧資料，這些史家或許需要適當的格式與軟體來管理之。對於這個數萬年後才會出現的新興史學與其困境，我想聊聊一些衍伸自生物資訊經驗的想像和白日夢……</p><span id="more"></span><h1 id="什麼是-mVCF？跟-VCF-有什麼不同？"><a href="#什麼是-mVCF？跟-VCF-有什麼不同？" class="headerlink" title="什麼是 mVCF？跟 VCF 有什麼不同？"></a>什麼是 mVCF？跟 VCF 有什麼不同？</h1><p>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, 以下簡稱為 mVCF) 是一種純文字檔案格式，用於紀錄觀測事件在特定宇宙內各時間線的分歧（詳細內容可參考我寫的<a href="https://github.com/5uperb0y/mVCF/blob/main/mVCF-spec.md">格式規範</a>）</p><p>mVCF 的構想源於基因體學的 <a href="https://github.com/samtools/hts-specs/blob/master/VCFv4.3.pdf">VCF</a> (Varaint Call Format)。VCF 檔案紀錄了樣本基因體與參考基因體的 DNA 鹼基差異，這些差異被稱之為變異 (variant)。因為基因變異可能與生物的疾病、性狀與演化史相關，所以可作為臨床診斷、族群遺傳乃至生態演化的研究基礎。</p><p>由於 VCF 檔為純文字檔、排版友善、容易擴充又被辨識基因變異的軟體所重用，所以 VCF 已是生物資訊領域通用的格式。去年，VCF 已經更新至 v4.3 版本，除了少數鹼基的變動、插入與刪除外，也納入倒置、跨染色體合併或是大片段缺失等結構變異的表示法。</p><p>當我在一個百無聊賴的下午，讀著 VCFv4.3 格式細則時，萌生了一個想法：既然 VCF 能用來紀錄 DNA 變異，那能否描述同為線性結構的時間？更進一步地，我能否用 VCF 檔紀錄一則關於平行宇宙、時空跳躍與蝴蝶效應的懸疑故事？於是我模仿 VCF，著手設計能像描述基因變異一樣，描述各時間線歧異事件的 mVCF。</p><p>不過，基因體與時間線的性質顯然有許多差異，所以雖然能挪用 VCF 的格式規範，不過要留意指涉對象的含意。</p><ul><li><strong>樣本</strong>：樣本是研究母體的子集，其範疇與形象因研究目的而異。在基因體學裡，樣本可以是細胞、組織乃至一盆湖水；而史學裡，可能是個人、國家乃至某種文化與風潮。</li><li><strong>鹼基&#x2F;事件</strong>：基因體的基本單位是鹼基，而歷史的基本單位則是事件。然而，相較於離散基因，時間則是連續的。因此，研究事件時更需要定義其範圍與尺度，事件間的差異也不只是字串比對，還需要梳理事件來龍去脈。</li><li><strong>建庫&#x2F;考古</strong>：基因體研究始於採樣與抽取 DNA，而史學也需要蒐集考古材料與文獻。如同 DNA 建庫的手段多元，未來也許會發展出更多考古技術，能取得其他宇宙與時間線的文物或口述記錄，讓歷史事件的輪廓更加清晰。</li><li><strong>定序&#x2F;編年</strong>：DNA 需經定序解碼鹼基的順序與種類，其結果構成<em>樣本的基因體</em>（樣本DNA的集合）；而考古材料也需要編年與考證，確認事件的順序與可信度，其結果構成<em>樣本的時間線</em>（樣本事件的集合）。</li><li><strong>參考基因體&#x2F;標準時間線</strong>：參考基因體是特定物種基因體的整合；而標準時間線則是特定實體（個人、國家或文化等）時間線的整合。兩者都匯集了多樣本的結果，涵蓋較全面的鹼基定序或事件編年資訊，可作為研究與比較的基礎。</li><li><strong>染色體&#x2F;宇宙</strong>：每條染色體都乘載了特定的基因，在 VCF 檔裡也有各自的座標；而每個宇宙都有各自的宇宙常數與物理定律，有其獨特的歷史脈絡與事件變化。</li><li><strong>變異&#x2F;異變</strong>：基因變異是樣本基因體與參考基因體的歧異，事件異變則是樣本時間線與標準時間線的歧異。</li></ul><p>釐清 mVCF 和 VCF 的概念差異之後，讓我以《高堡奇人》的假想歷史為例，說明 mVCF 紀錄歷史分歧事件的方式。</p><h1 id="如何解讀-mVCF？"><a href="#如何解讀-mVCF？" class="headerlink" title="如何解讀 mVCF？"></a>如何解讀 mVCF？</h1><p>《高堡奇人》是菲利普狄克的假想歷史著作，描述了軸心國贏得二戰後的故事。小說世界與真實歷史的分歧始於 1933 年小羅斯福總統遇刺身亡，導致美國無法脫離經濟蕭條並於歐戰爆發時仍保持孤立。</p><p>由於美國的政治態度與國力衰退，孤立無援的英國與歐陸為納粹所征服，隨後太平洋戰爭也以日軍大捷作結。分歧的歷史中，二戰遲至納粹德國與日本帝國於 1947 年征服美國並瓜分世界才告終。</p><p>以下即是小說時間線比對真實歷史的 mVCF 範例。若曾接觸生物資訊的話，應該能留意到它的形式其實與 VCF 一致，只是紀錄項目因應歷史事件的特徵而有所調整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">##fileformat=mVCFv0.1</span><br><span class="line">##fileDate=20240105</span><br><span class="line">##source=BiblioMapperv1.0.7</span><br><span class="line">##eventEncoding=CEES27</span><br><span class="line">##reference=file:///chronology/100000HumanHistory-pilot.tl</span><br><span class="line">##INFO=&lt;ID=EF,Number=A,Type=Float,Description=&quot;Alternative Event Frequency&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DP,Number=A,Type=Integer,Description=&quot;Read Depth, number of bibliography supporting alternate events&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DESCRIB,Number=R,Type=String,Description&quot;Event Description&quot;&gt;</span><br><span class="line">#COSMOSPOSIDREFALTQUALFILTERINFOFORMATMITHC</span><br><span class="line">U341933.Pρ..EF=0.5;DP=1;DESCRIB=&quot;Mayor cermak is assassination&quot;,&quot;President Roosevelt is assassinated&quot;..</span><br><span class="line">U341933.EEEEEEEEE..EF=0.5;DP=1;DESCRIB=&quot;US Great Depression&quot;,&quot;US Great Depression&quot;..</span><br><span class="line">U341945.WWWW..EF=0.5;DP=1;DESCRIB=&quot;WWII&quot;,&quot;WWII&quot;..</span><br><span class="line">U341945.P...EF=0.5;DP=1;DESCRIB=&quot;United Nations Founds&quot;..</span><br></pre></td></tr></table></figure><p>每份 mVCF 依序分為三個部分：元資訊列 (meta-information line)、標題列 (header line)、資料列 (entry line)。</p><ul><li><strong>元資訊列</strong>：以 <code>##</code> 開頭，紀錄「如何讀懂這份檔案」的資訊，例如檔案格式、產出日期、縮寫含意等。</li><li><strong>標題列</strong>：以 <code>#</code> 開頭，紀錄資料列各欄的含意</li><li><strong>資料列</strong>：紀錄分歧事件所發生的宇宙、時間、性質、證據以及描述等資訊，每一列都表示某時間點發生的分歧事件。</li></ul><p>此處先忽略看起來更繁雜的元資訊列（這部分通常是不懂時查找用的），專注在假想歷史的第一項分歧「小羅斯福刺殺事件」。</p><table><thead><tr><th>#COSMOS</th><th>POS</th><th>ID</th><th>REF</th><th>ALT</th><th>QUAL</th><th>FILTER</th><th>INFO</th><th>FORMAT</th><th>MITHC</th></tr></thead><tbody><tr><td>U34</td><td>1933</td><td>.</td><td>P</td><td>ρ</td><td>.</td><td>.</td><td>EF&#x3D;0.5;DP&#x3D;1;DESCRIB&#x3D;”Mayor cermak is assassination”,”President Roosevelt is assassinated”</td><td>.</td><td>.</td></tr></tbody></table><ul><li><code>#COSMOS</code>：發生事件的宇宙（具有特定宇宙常數與物理定律的環境），用以規範時間線描述的範圍。<code>U34</code> 是我們所處宇宙的代號。</li><li><code>POS</code>：發生事件的時間點。由於時間尺度因事件而異，所以需參照元資訊列確認所用的時間單位。此處以日歷年為單位，符合二戰歷史的事件發生頻率和時長。</li><li><code>ID</code>：特定事件的辨識碼。通常在各宇宙與時間線普遍發生的重大事件，例如地球生命起源或宇宙爆發等，會被標註辨識碼供交流與研究用。</li><li><code>REF</code>：在標準時間線預期發生的事件代碼。標準時間線是全史學家採樣可探測宇宙各時間線所拼湊的歷史，便於後續研究察覺罕見分歧事件。為了記錄方便，事件通常會以單字符碼概括。各領域有其常用的編碼系統，此處採用 CEES27 系統，<code>P</code> 為重大政治事件 (“politics”)，即芝加哥市長 Cermak 遇刺事件。</li><li><code>ALT</code>：在觀測時間線實際發生的事件代碼，可稱之「分歧事件」或「異變」，比較 <code>REF</code> 和 <code>ALT</code> 即可了解事件在各時間線的差異。在《高堡奇人》的時間線中，遇刺死亡的人不是 Cermak 是小羅斯福總統。</li><li><code>QUAL</code>：分歧事件的可信程度。受限於跨時空探測技術以及殘存的文獻紀錄，並非所有發現的事件都那麼可靠，這項數值即反映了研究人員對分歧事件是否存在的信心。</li><li><code>FILTER</code>：分歧事件是否可靠，基於文獻品質、數量以及考古證據等資訊，判斷分歧事件的可信程度是否達所設定的標準。</li><li><code>INFO</code>：其餘關於事件本身、探測技術或是可信程度的補充資訊。例如 <code>DP=1</code> (Read Depth) 表示僅有一份文件佐證分歧事件的發生，而後續的 <code>DESCRIB</code> 則提供了事件的摘要。</li><li><code>FORMAT</code>：假設我們不只採樣《高堡奇人》小說版的時間線，也納入影集版本的時間線，那麼就需要標記各自與標準時間線的分歧。此欄規範了標記各觀測時間線的格式。</li><li><code>MITHC</code>：觀測時間線的辨識碼 (the Main in The High Castle, MITHC)。每份 mVCF 皆可含有多筆觀測紀錄（或稱「樣本」），屬於該觀測的紀錄規範在 <code>FORMAT</code> 之中。每個觀測皆獨立一欄，依序置於<code>FORMAT</code> 之後。</li></ul><p>綜合這些欄位的資訊，這條紀錄可解讀為「1933年，於我們所處宇宙的時間線發生政治事件分歧，小羅斯福取代 Cermak 死於 Giuseppe Zangara 刺殺事件。這項分歧可在一半的時間線中觀測到，但僅有一份文獻支持其存在。」，而接續幾列則陳述了在假想的歷史中，經濟蕭條 (E, Economy) 與二戰 (W, War) 拖延的比預期更久，聯合國也不曾成立。</p><p>至此，我已介紹了 mVCF 的雛型，但對於怎麼取得分歧事件資料，或說如何詮釋歷史分歧的影響等問題仍有許多討論空間。以下分別陳述我認為值得研究和改善的議題。</p><h1 id="目前-mVCF-還有什麼待解或研究議題？"><a href="#目前-mVCF-還有什麼待解或研究議題？" class="headerlink" title="目前 mVCF 還有什麼待解或研究議題？"></a>目前 mVCF 還有什麼待解或研究議題？</h1><h2 id="如何編碼事件？"><a href="#如何編碼事件？" class="headerlink" title="如何編碼事件？"></a>如何編碼事件？</h2><p>構成 DNA 和蛋白質的基本單元只有 24 個分子，所以使用 26 個英文字母便足以表示。然而，構成時間線的事件彼此之間在時空尺度、內容性質、牽涉對象可能大相逕庭。好比說，國際政治是十數年間的的合縱連橫，地質年代則是百萬年的板塊遷移；個人史涉及了數十人的愛恨情仇，但戰史卻攸關數萬人的生離死別。</p><p>換句話說，定義事件基本單位的方式會因領域而異 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。">1</span></a></sup>，無法像基因體學只用一套編碼描述各物種的遺傳變化。因此，若想模仿 VCF 或 FASTA 等格式以單字符描述基本單元，需要適當的編碼系統，依照事件屬性將之分門別類，賦予簡明的代號以利用戶判讀。</p><p>舉前述的《高堡奇人》為例，書中的國際關係事件便用以下系統化約少量的英文字母方便於表中呈現，其餘細節則補充在於 <code>INFO</code> 欄位供參照。</p><table><thead><tr><th>編碼</th><th>事件類型</th><th>描述</th></tr></thead><tbody><tr><td>P</td><td>Political Changes</td><td>政權更迭或其他事件，例如政權更迭與當權者上位等</td></tr><tr><td>W</td><td>War and Conflict</td><td>戰爭或軍事衝突，例如歐戰與二戰</td></tr><tr><td>T</td><td>Technological and Scientific Breakthroughs</td><td>科學發現或科技發明，例如發明蒸汽機與發現核能</td></tr><tr><td>C</td><td>Cultural and Societal Shifts</td><td>社會變遷或文化風行，例如啟蒙思潮</td></tr><tr><td>E</td><td>Economic Shifts</td><td>經濟危機或發展，例如經濟大蕭條</td></tr><tr><td>X</td><td>Discovery and Exploration</td><td>開拓生存空間，例如發現新大陸與航路</td></tr><tr><td>D</td><td>Disasters and Catastrophes</td><td>天然或人為災難，例如西班牙大流感與南亞海嘯</td></tr></tbody></table><p>值得留意的是，編碼意味著篩選、歸納與簡化，所以不免捨棄部分資訊並引入主觀判斷。所以可預期每份 mVCF 的編碼系統都反映了記錄者的觀點，反映他們對驅動歷史的根本邏輯與關鍵動力的認知。這就像基因體學的 VCF 不只記錄了序列的差異，其實也蘊藏了識別變異的算法邏輯和假設。</p><p>是以，當我們討論 mVCF 所記錄的事件時，必須承認歷史的多元性與複雜性。歷史不僅由大事件構成，同時期也包含了眾多零星事件、個人故事或文化現象等。然而，實務上不一定要標記出所有事件的分歧，因為 mVCF 要涵蓋的事件內容可透過確定研究前提與範疇而聚焦。</p><h2 id="要記錄什麼事件？"><a href="#要記錄什麼事件？" class="headerlink" title="要記錄什麼事件？"></a>要記錄什麼事件？</h2><p>儘管目前沒有其他時間線的觀測報告，我們仍然可以從歷史策略遊戲的設計理念得到一些靈感。這些遊戲容許玩家參與特定時代，左右國家政權的發展，創造出與現實截然不同的歷史途徑<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考[维多利亚2（Victoria2）：历史的逻辑](https://necromanov.wordpress.com/2010/09/01/victoria2/)的總結">2</span></a></sup>。</p><p>以《世紀帝國》系列遊戲為例，玩家將選定特定文明，歷經黑暗、封建、城堡與帝王時代，逐步發展經濟與強化軍事，並以征服對手的文明為目標。在這種情況下，驅動事件的是勝負，遊戲機制維護的是玩家操作的合理性。</p><p>事件發展皆與取勝密切相關，例如生產村民、升級科技或建立軍隊等，玩家會因戰局的發展做出行動，而不是各項遊戲內的社會因素與事件長遠影響。 歷史在此處作為遊戲氛圍的點綴，其真實性與玩家舉動沒什麼關係，也可能出現與史實脫節的狀況。</p><p>而光榮的《三國誌》系列則展現了以人物為中心的敘事方式，讓玩家沉浸在大時代的故事中，挑戰歷史人物曾面臨的困境，實現他們曾立下的宏願。 基於這項設計，遊戲維護著歷史事件本身的獨特性。舉例來說，即使遊玩過程有別，赤壁之戰的劇本就該由曹操、劉備與孫權三方參與，才能營造出當代的氛圍。</p><p>即使是假想的劇情，也會遵循一條合適的劇本發展。由於驅動遊戲進行的是劇本，因此事件紀錄更為著重在決定劇本分歧的選擇，這些會成為往後重啟遊戲回顧的關鍵（例如嘗試失敗，就得回到存檔點再試一次）。</p><p>相比之下，由 paradox 公司出品的遊戲（例如《維多利亞》和《鋼鐵雄心》），更強調事件發生的合理性。在這種觀點下，遊戲機制維護的是事件發生的邏輯，而不是歷史事件本身。簡言之，參與事件的各方被抽象化，當各項參數合乎條件時，即可能觸發事件，然而因為國家環境與政治初始條件的影響，宏觀的歷史軌跡很可能相似，但在細節上可能會有差異。這類遊戲事件則更為複雜，紀錄的是影響參數的事件，例如革命事件可能會跟民生、外交與軍事等行為相關，從而影響民心之類的參數。</p><p>這類歷史模擬遊戲的假想時間線是三款之中較接近基因體學研究現況的，相較之下，世紀帝國系列的歷史發展更像遵循熱力學（在遊戲的情境中即是取得勝利）而隨機構成的聚合物，事件的前因後果較為鬆散；這類遊戲的假想歷史紀錄呈現明顯的歷史分岔和障壁，在特定檢查點的狀況會引領迥然不同的路線。</p><p>綜上所述，mVCF 紀錄的事件類型取決於紀錄者對歷史的看法。這些事件會與影響歷史的因素相關，從而允許我們從中歸納出歷史的必然和偶然。</p><h2 id="個案研究：星際移民史"><a href="#個案研究：星際移民史" class="headerlink" title="個案研究：星際移民史"></a>個案研究：星際移民史</h2><p>既然已經探討了事件類型與其編碼方法，不妨透過個案研究來加深理解。想像一下，如果我們打算研究某個文明在不同時間線上展開星際移民的可能性。考量跨星系移動所需的龐大能量，可從文明的利用效率來推斷其進行星際移民的可能性。在這樣的研究框架下，我們將關注那些直接影響能源應用效率和規模的關鍵事件；而相對地，社會文化或國際政治事件則較無關緊要。</p><p>為了有效編碼事件，我們可採用卡爾達肖夫指數 (<a href="https://en.wikipedia.org/wiki/Kardashev_scale">Kardashev scale</a>) 作為衡量標準，標記一個文明各時期所能利用的能量規模。假設該文明能在夠長的時間內維持可觀的能源利用，這表明該文明更有可能具備承擔星際旅行所需能源的能力；反之，這個文明也可能因為戰爭或自然災害而喪失先進的科技水準。雖然這種事件編碼方式省略了許多細節，但它依然能夠概括地呈現文明的發展軌跡。</p><p>在以下範例中，自然數代表卡爾達肖夫指數。在標準時間線中，可預期該文明將在四萬年後掌握恆星能源的應用。然而，在可觀測的眾多時間線裡，多數情況下 (99.99%) 文明會因某些事件而喪失這種能力。只有極為罕見的案例 (0.01%)，該文明的技術水準蕙突飛猛進，達到了能夠掌握並維持星系能源利用的階段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#COSMOSPOSIDREFALTQUALFILTERINFOFORMATMITHC</span><br><span class="line">U4240000.22333333333333333333333333,20..EF=0.0001,0.9999;DP=1000,1000..</span><br></pre></td></tr></table></figure><p>基於這項範例的觀察，星際交流可能非常罕見，因為在大多數時間線上都能觀察到科技衰退現象。這意味著或許存在某種過濾機制限制了文明的發展，這可以為人類文明的未來，或是解釋費米悖論指引一些研究方向。</p><h2 id="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"><a href="#什麼是異變（分歧事件），時間線的分歧又意味著什麼？" class="headerlink" title="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"></a>什麼是異變（分歧事件），時間線的分歧又意味著什麼？</h2><blockquote><p>異變或分歧事件在 mVCF 中指的是在不同時間線中發生的、與標準時間線不同的事件。這些分歧可以是小到一場戰役的結果不同，也可以是大到整個文明的興衰不同。這些分歧事件揭示了歷史的非線性和多變性，表明即使是微小的改變也可能引發巨大的連鎖反應。理解這些分歧有助於我們更深刻地認識決策的重要性以及歷史的複雜性。<br>基因變異與事件變異在性質上有顯著差異。基因變異通常局限於生物的物理屬性，而事件變異則涉及複雜的歷史語境。事件比對（類似於序列比對）涉及了事件的完整背景、因果關係和語境。例如，在科技發展史研究中，牛頓與萊布尼茲的微積分發明可能被視為同一事件，但在英德歷史研究中則被視為不同事件。這種比對可能需要更複雜的演算法或全面的人工智慧判斷。<br>在研究目的上，類似於基因變異的臨床檢驗、生態演化與族群遺傳，時間線分歧的研究可能專注於預測未來、判斷歷史驅動因素的必然性或偶然性，或是進行時間線間的比較研究。不同於基因變異影響衍生物，時間線的變異直接作用於其自身，這可能導致對歷史事件的解釋和影響分析更為複雜。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">事件異變與基因變異在本質上有顯著區別。基因變異影響的是生物體的物理特性，而事件異變則涉及更為複雜的歷史語境和因果關係。在分析事件異變時，我們需要考慮事件的整體背景、相互關聯和影響。例如，在科技發展史的研究中，牛頓和萊布尼茲各自發展的微積分可能被視為相同的事件，但在英國和德國的國家史中，則可能被視為不同的事件。這種事件比對比基因序列比對更為複雜，可能需要全面的人工智慧判斷或高度專業的人工分析。</span><br><span class="line"></span><br><span class="line">就研究目的而言，時間線分歧的分析可用於預測未來、判斷歷史驅動因素的必然性或偶然性，或進行不同時間線的比較研究。不同於基因變異影響生物體的衍生特性，時間線的變異直接作用於其自身，這可能對歷史事件的解釋和影響分析帶來更為複雜的挑戰。</span><br><span class="line">在處理事件異變時，我們需要的不僅是簡單的序列比對，而是對事件背景、動機、影響和連帶後果的全面分析。例如，科技發展史中的牛頓和萊布尼茲微積分的發明，雖然可以被視為相同的事件，但在英國和德國的國家史中，這兩件事就可能被視為不同事件。這需要比基因序列比對更複雜的演算法或全面的人工智慧判斷。</span><br><span class="line"></span><br><span class="line">比如，在臨床檢驗中，基因變異的研究可以幫助我們理解疾病的成因和治療方法。在歷史的脈絡中，分析事件的異變可以幫助我們理解特定決策或事件對歷史進程的影響。在生態演化中，基因變異的研究可以揭示生物多樣性和物種進化的機制；類似地，研究歷史事件的異變可以揭示文化和社會結構的演變。在族群遺傳學中，基因變異的研究有助於描繪人群遷徙和混合的歷史，而在mVCF的脈絡下，類似的分析可以揭示不同文化和政治力量如何塑造歷史的走向。</span><br></pre></td></tr></table></figure><p>怎麼樣才知道事件發生分歧？換句話說，在辨別分歧事件時，我們需要迥異於序列比對的手段。事件可能很類似，但他們有完全不一樣的語境，那能否視為。<br>例如牛頓發明微積分與萊布尼茲發明微積分在是否可歸類於相同事件，若</p><p>目前我還沒有比較明確的想法，但<br>在基因體學，偵測變異的原因不外乎歸納成因、<br>基因體與時間線其它差異在於：基因變異影響蛋白質與性狀，事件分歧則影響隨後的事件；基因變異作用在其衍生物，時間線發生分歧卻作用在其本身。</p><h1 id="如果還等不到來自其他時間線的招呼…"><a href="#如果還等不到來自其他時間線的招呼…" class="headerlink" title="如果還等不到來自其他時間線的招呼…"></a>如果還等不到來自其他時間線的招呼…</h1><p>最後談談發現多重宇宙與其他時間線之前，能利用 mVCF 做些什麼。</p><ul><li>文獻管理</li><li>完善格式</li></ul><blockquote><p>它可以作為一個強大的文獻管理工具，幫助研究者整理和分析涉及替代歷史或假想情境的文獻。</p></blockquote><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考<a href="https://necromanov.wordpress.com/2010/09/01/victoria2/">维多利亚2（Victoria2）：历史的逻辑</a>的總結<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假如事物遵循 80/20 法則，對我們的決策與行動有什麼影響？</title>
      <link href="/mayer-2023-the-art-of-clean-code-80-20-principle/"/>
      <url>/mayer-2023-the-art-of-clean-code-80-20-principle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>The principle says that the majority of effects come from the minority of causes.</p></blockquote><p>本文是<a href="https://www.books.com.tw/products/0010959955">《精通無瑕程式碼：工程師也能斷捨離》</a> 其中一章的心得。</p><p>80&#x2F;20 法則是指少數變項左右了多數結果，它既不是能預測結果的物理定律，也不是行事時得遵循的規範。精確來說，80&#x2F;20 法則是一項觀察，它可以讓我們思考，假設自己在乎的事情遵循這種分布，對我們的決策和努力方向有什麼影響。</p><p>雖然這原則對近代的讀者而言應該是耳熟能詳，但我覺得作者 Mayer 的解讀引人入勝。文中除了實際案例也有簡單計算來佐證為什麼基於 80&#x2F;20 法則，我們要投資成本在抉擇、必須保持專注、要關心核心的指標等等。因此，我覺得蠻值得寫一則心得來記錄。</p><span id="more"></span><h1 id="關鍵事物的影響超乎想像"><a href="#關鍵事物的影響超乎想像" class="headerlink" title="關鍵事物的影響超乎想像"></a>關鍵事物的影響超乎想像</h1><p>多數結果是建立在少數因素上，假設這項觀察或原則適用在多數情境，那麼有兩方面的暗示。 首先，在一個領域中，少數人員能佔有多數資源或成果，例如少數人發表了多數的論文，少數人賺進了多數的錢。</p><p>其次，在成就這現象的行為中，也只有關鍵的行為與成就有關。 換句話說，若目標是在某領與取得一定的成績，那麼若能夠辨識並投注心力在事物的關鍵環節，便不需要搞得筋疲力盡，也能維持一定成績。</p><p>從效益的角度來看，關鍵環節與其他環節的差異更加明顯。假設兩成的努力造就八成的結果，那麼每一成努力造就四成結果，相較之下，在非關鍵事物的投注僅造就四分之一的成果。單位投入下，關鍵事物造就的效益是非關鍵事物的十六倍。那這種比例的差異在實際情形中可能更加懸殊，例如在生物體方面，少數基因轉變主宰了大多數的變化，這些基因的影響力是其他基因的數千倍以上。</p><h1 id="選擇能反映結果並指引方向的指標"><a href="#選擇能反映結果並指引方向的指標" class="headerlink" title="選擇能反映結果並指引方向的指標"></a>選擇能反映結果並指引方向的指標</h1><p>當然，除了原則背後的機制以外，作者也解釋了要怎麼透過這些原則指引行動，讓自己在有限的資源，更有效率達成目標，從而有餘裕去完成或享受其他事情。</p><p>這涉及了 80&#x2F;20 法則的另一項暗示，除了大部分資源為少數人所佔據，多數的進展也取決於少數的行為。而辨識關鍵行為的重點則是選擇適當的指標來衡量行為效益。</p><p>舉例來說，如果目標是擁有健美體態，那麼各式各樣的飲食法與健身菜單都是潛在的選項，而體重、體脂肪、身體測量值都是衡量判斷行為對目標影響的指標。</p><p>然而，不是所有指標都能忠實反映行為的影響或指引往後的行為。好比說，他人對身材的稱讚的確能反映此人的體態，不過這些讚美反映的是過往投入成本的效益，而非當下行為的影響。此外，他人評價又受長相、穿搭或其他難以捉摸的因素，未必能從中檢討出能讓自己體態變好的方向。</p><p>另一方面，體脂與肌肉尺寸則是反映行為結果忠實的指標，但很難在每次訓練中即時回饋自己到底做了多好。相較之下，訓練量（負重乘以次數）即是其中一個能及時反應行為的指標，肌肉量與耐力提昇就能提升更多訓練量，也能從當下行為反應到成效。</p><p>以作者用語總結，假如體態是衡量成功的依據，讚美並不是衡量進展的指標，體脂和肌肉量是呈現過往投資的 lagging indicator。而我們要關注的則是能反映當下行為影響的 leading indicator，後者能指引我們做有效的努力以達成目標，也能幫助我們在出錯時檢討問題所在。</p><h1 id="透過學習減少摸索與排序指標的成本"><a href="#透過學習減少摸索與排序指標的成本" class="headerlink" title="透過學習減少摸索與排序指標的成本"></a>透過學習減少摸索與排序指標的成本</h1><p>然而，排序任務、選定指標、標記價值、學習技術也需要成本（想想看演算法課裏頭那些時間複雜度不一的排序方法），這些成本有可能攤平投資在關鍵行為與項目的效益。</p><p>因此，需要借重他人的經驗來減少摸索與排序的成本。在此書中，作者舉了寫作和寫程式兩個案例供讀者參考。對於作家而言，最重要的行為是寫作，而衡量寫作的指標則是「寫了多少句子&#x2F;幾本書&#x2F;幾個故事」；而對程式設計師而言，最重要的行為是寫程式，衡量寫程式的指標則是「寫了多少行程式碼&#x2F;提出多少修訂&#x2F;完成多少專案」</p><p>雖然這些指標看起來有點簡化，但簡化不代表單調或沒意義。相反地，越少原則表示越容易追蹤與遵循，即使是盲目地寫程式和寫作，也起碼有以下好處：</p><ul><li>你能把自己的觀點、意見、想法、風格與巧思等所有你存在過、活過、學習過的證據儲存在可交流的媒介</li><li>有了資訊，便能做為籌碼與他人交流，用以兌換經驗</li><li>即使不算精通，持續寫起碼能造就熟練，讓你能更快完成同樣或類似的任務</li><li>經驗節省的時間能反過來投資寫作和寫程式，或是物色更好的方法</li></ul><h1 id="保持專注"><a href="#保持專注" class="headerlink" title="保持專注"></a>保持專注</h1><blockquote><p>a critical strategy for moving up the Pareto curve is to stay in the game longer while participating in fewer games</p></blockquote><p>值得注意的是，前述好處的前提是專注。假設各項領域皆呈 80&#x2F;20 法則的分布，那麼投注與報酬呈指數關係。若將投注分散在不同領域，則綜合成長幅度會少於全數投資在單一領域的成長幅度。</p><p>畢竟 80&#x2F;20 法則是指多數取決於少數，若這項原則適用各領域，那麼因為分布不均，要懂得取捨；由於輕重不一，得學會排序。取捨與排序又需要經驗累積，這有賴持之以恆的專注。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>作者在這章最後有提幾項老生常的建議，我覺得最值得提醒自己的是這個：</p><blockquote><p>Don’t do things that reduce value.  These are things like smoking, eating unhealthily, sleeping little, drinking alcohol, and watching too much Netflix. Avoiding things that drag you down is one of your biggest leverage points. If you skip doing things that harm you, you’ll become healthier, happier, and more successful.  And you’ll have more time and money to enjoy the good things in life: relationships, nature, and positive experiences.</p></blockquote><p>他提到的行為是否有害見仁見智，可是不惹自己麻煩卻是很好的主意。畢竟我們不會每次能做出有效的投資，避開風險能保留更多選擇或資源以把握下次機會。</p>]]></content>
      
      
      
        <tags>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 部屬後網頁報錯 &quot;cannot get /&quot;</title>
      <link href="/hexo-cannot-get-slash-error/"/>
      <url>/hexo-cannot-get-slash-error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>新的一年好不容易提振精神來寫文章，想說先把文章的調整更新到網站上。不料，輸入完 <code>hexo clean &amp;&amp; hexo delopy</code> 之後，雖然 Github action 顯示部屬正常，但網頁卻無法瀏覽，分別顯示 “This is not the web page you are looking for” 以及 “There isn’t a GitHub Pages site here”</p><p><img data-src="https://i.stack.imgur.com/Hp57y.png" alt="This is not the web page you are looking for."></p><ul><li><a href="https://github.com/hexojs/hexo/issues/4098">404 There isn’t a GitHub Pages site here. #4098</a></li><li><a href="https://stackoverflow.com/questions/66569047/github-what-causes-gaps-in-issue-number-404-this-is-not">GitHub what causes gaps in issue #Number (404 This is Not…)</a></li></ul><p><strong>TL;DR: 如果你也碰到這情形，可能是 hexo 部屬工具不全或是，上網隨便找一篇教學，或參照以下指令把相關套件更新後再部屬看看。</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="環境設置"><a href="#環境設置" class="headerlink" title="環境設置"></a>環境設置</h1><p>忘了，只是想一寫文章啊，眼看元旦就要消失了，急著解問題沒記錄環境設置。不過這倒能衍伸出一項新年展望，下次碰到問題記得留意環境問題喔。</p><h1 id="調查過程"><a href="#調查過程" class="headerlink" title="調查過程"></a>調查過程</h1><p>使用 <code>hexo server</code> 檢查，發現網站根本起不來，只有一串的 <code>Cannot GET /</code> 掛在蒼白的網頁上。</p><p>通常，這項錯誤肇因於 <a href="https://blog.csdn.net/qq_45593330/article/details/116702792"><code>source/_posts</code> 沒有任何文章</a>，可是查看專案資料夾卻發現，所有文章都好端端留在那啊，究竟部屬的時候發生了什麼事？</p><p>回頭翻部屬訊息才注意到，哇乾，hexo 不知何故把 <code>gh-page</code> 大多數檔案移除（慘況可參考 repository 上的 <a href="https://github.com/5uperb0y/5uperb0y.github.io/commit/3929872560d5bb2db64fd0a68eb441cac377e355">commit 歷史</a>）。接下來我推測了各種可能性：</p><ul><li>token 過期等權限問題？但都能順利推上 github 了，先排除這項可能。</li><li>可能手賤刪除文章不自知？嘗試回到舊 commit 再部屬，問題依舊。</li><li>可能 <code>_config.yml</code> 的分支設錯？檢查設置檔，也確定 origin 分支了，問題依舊</li></ul><p>到了最後才懷疑套件可能安裝不全或有問題？找了這篇 <a href="https://feifacunzai.github.io/2020/06/29/Hexo-%E7%B4%80%E9%8C%84%E6%9B%B4%E6%96%B0%E9%81%8E%E7%A8%8B/">Hexo 紀錄更新過程</a>，照裡面講的步驟更新套件後再部屬後，網頁和文章都回來啦。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>人生難免碰到困難與障礙，有時並非個人不努力，而是大環境的問題。既然錯不在己，過度糾結也無濟於事，不如更新環境或給自己重新開機的機會，也許問題會迎刃而解呢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「It&#39;s MyGo!!!!!」太好看了八😭</title>
      <link href="/why-should-we-watch-bangdream-its-my-go/"/>
      <url>/why-should-we-watch-bangdream-its-my-go/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>「It’s MyGo!!!!!」太好看了八😭😭😭，這部和「放學後的昴星團」一樣，是應取代雅量與鄭伯克段於鄢，納入國民義務教育的作品。</p><span id="more"></span><p>動畫標題的含義是「迷路的孩子」，講述一個樂團解散後，曾經的成員與愛慕虛榮的轉學生在組織新樂團時，發生種種得面對各自過往創傷的故事。</p><p>在卡牌動畫裡，沒有什麼爭端是「決鬥」不能解決的；在超級機器人的世界觀，最終的命運往往要靠「合體」來決定；至於在樂團作品，上了台，「音樂」就是對一切的回應。</p><p>儘管「It’s MyGo!!!!!」靠音樂的感染力掩飾掉部分生硬的情節轉折。我覺得這部作品仍然可貴的理由在於，編劇並沒有因為主題是迷茫，就為了推動情節而向觀眾許諾一個有解的宇宙。</p><p>到了故事尾聲，角色的目標與方向不見得較開始時清晰明朗，反而還有更多不甘、愧疚、困惑與說不清的苦楚。</p><p>苦、茫與惑這些字眼從甲骨文保留到當代未曾消失，就像現實中冰會融、雨會下一樣自然，繞了一大圈仍回到原點的事情也屢見不鮮。</p><p>然而，如同動畫專輯封面所呈現，角色歷經了這麼多，雖然雨還在下，但他們已曉得撐傘。即使在熱力學主宰的世界裡，「冰塊融化後，還是會有像水一樣留下的東西」，也因為存在摩擦，邁向原點的曲折路上依然能發（不可見）光發熱。</p><p>在動畫第十集插曲MV的最後畫面，新成立樂團的五位成員在舞台上的站位，對應著團名的首字母，也象徵著仙后座的形象。找齊仙后座的五顆星，便能在茫茫星河之中，找到指引著方向的北極星。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acgn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Window 上使用 VSCode 建立 Tabletop simulator 的 Lua 腳本開發環境</title>
      <link href="/tabletop-simulator-lua-vscode-development-environment-building/"/>
      <url>/tabletop-simulator-lua-vscode-development-environment-building/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tabletop-simulator-VSCode-開發環境設定"><a href="#tabletop-simulator-VSCode-開發環境設定" class="headerlink" title="tabletop simulator VSCode 開發環境設定"></a>tabletop simulator VSCode 開發環境設定</h1><p>Tabletop Simulator 是一款多人桌遊模擬器，提供強大的 Lua 腳本支援，讓玩家可以開發自訂遊戲。</p><p>然而，遊戲內建的腳本編輯器比記事本還難用，所以如果想要編輯複雜的腳本，仍有必要使用外部編輯器。鑒於網路上的資源稀少，我想在本文分享一下建立開發環境的經驗和總結。</p><span id="more"></span><h1 id="必要軟體安裝與設定"><a href="#必要軟體安裝與設定" class="headerlink" title="必要軟體安裝與設定"></a>必要軟體安裝與設定</h1><p>首先，我們要完成必要軟體的安裝與設定。</p><ol><li>安裝 Steam 並購買 <a href="https://store.steampowered.com/app/286160/Tabletop_Simulator/">Tabletop simulator</a>。</li><li>安裝 <a href="https://code.visualstudio.com/">VSCode</a>。雖然官方推薦的 Lua 開發環境是 Atom，但 VSCode 的功能更加強大，近幾年也比較廣泛被使用（參考 <a href="https://github.blog/2022-06-08-sunsetting-atom/">Github 停止支援 ATOM IDE 的新聞</a>）。</li><li>在 VSCode 當中安裝 <a href="https://marketplace.visualstudio.com/items?itemName=rolandostar.tabletopsimulator-lua">Tabletop Simulator Lua</a> 套件。這款套件能從遊戲儲存檔擷取 Tabletop Simulator 的 Lua 腳本，讓我們直接能在 VSCode 中開發，並享有自動補全、檔案瀏覽以及其他擴充套件的功能。</li></ol><h1 id="連結遊戲與編輯器"><a href="#連結遊戲與編輯器" class="headerlink" title="連結遊戲與編輯器"></a>連結遊戲與編輯器</h1><p>接著要設定遊戲與編輯器的連結</p><ol><li>在 Steam 中啟動 Tabletop Simulator，並開啟任意一款遊戲（步驟為：<code>Create</code>、<code>Singleplayer</code>、<code>Classic/DLC/Workshop</code>、挑選遊戲）。</li><li>打開 VSCode 時，Tabletop Simulator Lua 套件會自動辨識遊戲所在的資料夾（在 Windows 預設為 <code>%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</code>），將遊戲腳本 (<code>*.lua</code>)和設置檔 (<code>.xml</code>) 從遊戲儲存檔 (<code>*.json</code>) 獨立出來，並且放置到暫存資料夾中（預設為 <code>%UserProfile%\AppData\Local\Temp\TabletopSimulator\Tabletop Simulator Lua</code>。</li><li>如果套件沒有自動更新或是想要更換其他遊戲時，可以鍵入 <code>Ctrl</code>+<code>Alt</code>+<code>L</code> 更新連結。</li></ol><h1 id="編輯遊戲腳本"><a href="#編輯遊戲腳本" class="headerlink" title="編輯遊戲腳本"></a>編輯遊戲腳本</h1><p>現在，我們已經可以在 VSCode 當中編輯遊戲腳本了。Lua 腳本是遊戲儲存檔的一部份，而遊戲儲存檔則是一個 <code>JSON</code> 檔，記錄了啟動遊戲所需的所有元素。Tabletop Simulator Lua 的功能即是從儲存檔中擷取 Lua 腳本，並且轉換為適合閱讀與編輯的格式。</p><p>編輯完成後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 儲存並重啟腳本。此時，Tabletop Simulator 會將腳本變動更新到遊戲儲存檔，讓遊戲呈現腳本所做的變動。</p><p>如果希望在編輯腳本的同時能觀察遊戲畫面，有兩種方式可以達成：</p><p>首先，將 Tabletop Simulator 設定為視窗模式（<code>Menu</code>、<code>Configuration</code>、<code>Graphics</code>、取消勾選 <code>Fullscreen</code>）。</p><ul><li>使用 Windows 視窗分割功能 （<code>Win</code> + <code>←</code>&#x2F;<code>→</code>&#x2F;<code>↑</code>），同時陳列編輯器與遊戲視窗。</li><li>下載 Windows PowerToys，這是一個功能強大的 Windows 工具集，其中包含了能將遊戲視窗固定在螢幕上的功能。(<a href="https://learn.microsoft.com/en-us/windows/powertoys/always-on-top">always on top feature</a>)</li></ul><h1 id="建立專案資料夾"><a href="#建立專案資料夾" class="headerlink" title="建立專案資料夾"></a>建立專案資料夾</h1><p>由於無法指定 Tabletop Simulator 遊戲儲存檔的存放位置，所以想要進行版本控管或專案管理時需要一些權變措施。</p><ol><li>首先，建立一個新的專案資料夾，例如命名為 <code>project/</code>。專案資料夾的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br></pre></td></tr></table></figure></li><li>再次開啟 Tabletop Simulator，選擇任意遊戲並儲存。遊戲會自動建立包含遊戲所有設定與資訊的 JSON 儲存檔 (<code>TS_Save_*.json</code>)，並附上一張遊戲截圖 (<code>TS_Save_*.jpg</code>)。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li><li>由於 Tabletop Simulator 並未提供選擇遊戲儲存檔位置的選項，我們可以先將儲存檔和截圖檔案移至專案資料夾，以便之後進行版本控管。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li><li>接下來，在 Tabletop Simulator 的資料夾內建立一個指向專案資料夾的軟連結，以確保儲存檔可以在遊戲的載入遊戲清單中被找到。由於軟連結會連結到原始檔案，因此我們可以透過軟連結對原始檔案進行修改，並將變動同步到遊戲中。（Windows 系統在 cmd 當中使用 <a href="https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/mklink">mklink 建立軟連結</a>） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- project/ -&gt; /path/to/project/</span><br></pre></td></tr></table></figure></li><li>再次開啟 VSCode 並啟動 Tabletop Simulator Lua 套件。此時 VSCode 的探索欄應該會出現 Tabletop Simulator Lua 資料夾以及由套件從遊戲儲存檔中提取出來的 Lua 腳本。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br></pre></td></tr></table></figure></li><li>將專案資料夾加入 VSCode 的工作空間：選擇 <code>File</code> → <code>Add Folder to Workspace</code>，然後選擇專案資料夾。此時，探索欄的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li><li>在專案資料夾中建立需要的檔案或資料夾，例如 <code>src/</code>（用來儲存遊戲腳本）。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br><span class="line">|- src\</span><br><span class="line">    |- script1.lua</span><br><span class="line">    |- script2.lua</span><br></pre></td></tr></table></figure></li><li>接著開啟 <code>Global.-*.lua</code>，加入以下命令以指定要導入的腳本。由於套件會自動在工作空間的資料夾尋找副檔名為 <code>.ttslua</code>和<code>.lua</code> 的檔案，所以呼叫時就不需要加入副檔名了。 <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script1&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script2&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><p>現在，已經成功設定 Tabletop Simulator 的 Lua 開發環境，也將遊戲依照專案資料夾的規劃納入版本控管，可以按照自己的習慣開發遊戲腳本了。</p><p>只是要記得在修改腳本或遊戲設定後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 以同步變動到遊戲儲存檔中，也不要忘記在新增腳本時更新導入的指令。</p><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://tts-vscode.rolandostar.com/">TTS VSCode Docs</a></li><li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/27">Require and Path</a></li><li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/21">Best way to commit the main json file?</a></li><li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/20">Get&#x2F;Send LUA scripts to&#x2F;from workspace folder</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《時空旅人之妻》的人物描繪分析</title>
      <link href="/exploring-character-depictions-in-the-time-travelers-wife/"/>
      <url>/exploring-character-depictions-in-the-time-travelers-wife/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《時空旅人之妻》細膩地刻劃出由於時空錯置所引發的複雜情緒，如悲傷、惆悵與無奈等。以主角亨利為例，在他首次覺悟到，自己竟然是唯一的時空穿越者的情節中，作者精確地捕捉並揭露了年幼亨利的失落與成年亨利的無助，以及無論在何時都無法擺脫的孤獨。</p><p>這橋段我非常喜歡，因此全文引述如下：</p><blockquote><p>這若即若離的半透明時刻。另一個我原先搞不太清楚，然後就懂了。就像現在這樣，我看著這件事情發生，希望同時成為我們兩個，希望再感受那種迷失自己的感覺，希望再一次感受第一次看到未來和現在夾雜在一起的感覺。但是我已經太習慣、太熟悉這種感覺了，所以我只能當個局外人。我想起我九歲時的驚訝，我那時突然了解：我的朋友、導師兼哥兒們，就是我。我，就只有我。這種感覺真寂寞。</p></blockquote><span id="more"></span><blockquote><p>「你就是我。」<br>「但你比較老。」<br>「可是……其他人呢？」<br>「其他的時空旅人嗎？」<br>他點點頭。<br>「我不認為還有別的時空旅人，我從來沒碰過其他人。」</p><p>有顆淚珠凝聚在他左眼眼角。當我還是個小鬼頭時，我想像有一大群時空旅人，而亨利，也就是我的老師，是一名使者，被派來訓練我；而我最後也能加入這個友好的大圈子。我到現在依然覺得自己就像個被世人遺棄的人，是某個曾經繁榮族類碩果僅存的一人。這就好像魯賓遜在海灘上發現了人類的足跡，但後來才知道那是他自己的腳印。那個我自己，那個小得像片樹葉、薄得像水的自己，哭了起來。我抱住他，抱住自己，久久不放。</p><p>後來，我們向客房服務點了熱巧克力，一邊觀賞強尼．卡森的節目。燈還亮著，亨利就睡著了。節目播完後，我盯著他看，直到他消失無蹤，回到我爸公寓的那個老房間，昏昏欲睡地站在以前那張床的床邊，然後滿心感激地倒在床上。我把電視和床頭燈關掉，一九七三年的街道噪音從打開的窗戶飄進來。我想回家。我躺在旅館硬梆梆的床上，很孤單、很寂寞，還是不明白這是怎麼一回事。</p></blockquote><p>除了情感的刻劃，角色和環境的描寫也栩栩如生。加上作者巧妙地運用時間跳躍的設定，為角色的日常生活情節添加了懸疑、推理，甚至是動作的元素，所以即便故事的主線是描述日常的愛情關係進展，卻仍然能引人入勝。</p><p>因此，我認為值得花時間去研究和學習作者的寫作技巧。例如，書中描述亨利偶然在過去碰見母親的片段，在此場景，亨利以旁觀者的角度，描述眼前母親的形象：</p><blockquote><p>我看到媽媽跟我在一起的情況：她懷孕了；他們把我從醫院抱回家了，她推著嬰兒車去公園，坐下來背樂譜，輕聲唱著歌，還微微比著手勢，對我扮鬼臉，拿玩具逗我；或是牽著我的手散步，欣賞松鼠、汽車、鴿子，以及任何會動的東西。(page 127)</p></blockquote><p>作者以行為而非外觀作為起點，透過描繪與母親共度的生活點滴，來塑造出讀者可以共鳴的人物形象。</p><p>我覺得有趣的地方在於，這段文字雖然字詞簡潔，描述亦不繁複，然而，這些行為的涵義已深深烙印在大眾的共識中，無論這些印象來源於媒體或個人經驗。因此，儘管沒有明示行為中的親情元素，讀者仍能依照自己的經驗，補全對於「慈愛」的回憶與想像。</p><p>換言之，在敘述故事時，文字不只是人物形象的代言，更是激發讀者想像力的媒介。我們如何描述人物，其實源於我們如何觀察人。當我們在腦海中塑造人物形象時，我們最關注的是什麼特質？在寫作時，我們又希望這些人物如何在故事和我們的想像中活躍？除了外貌、打扮和性格標籤外，什麼樣的行為可以讓人物顯得充滿生命力？</p><p>此外，我也摘錄了書中一些描述人物外觀的段落，試圖了解作者怎麼形容人物的外觀，並藉此佐證透過人物行為所營造的形象。</p><p>案例一，亨利描述他的母親：</p><blockquote><p>她穿著布做的外衣還有七分褲，腳上套著懶人鞋。她有一頭烏黑的秀髮、引人注目的五官、豐滿的嘴唇、大大的眼睛、俏麗的短髮；她看起來像義大利人，但其實是猶太人。我媽連去乾洗店也會擦口紅、畫眼線、塗睫毛膏、刷腮紅還有畫眉毛(page 127)</p></blockquote><p>案例二，克萊兒首次拜訪亨利家時，見到金咪（很照顧亨利的鄰居）的印象：</p><blockquote><p>亨利敲了敲一間公寓的門。有個嬌小的韓國女人馬上就把門打開，那是金咪，她穿著一件藍色絲質洋裝，還塗著大紅色的口紅，她的眉毛畫得有點左右不平衡，頭髮是黑白相間的那種灰色。她把頭髮編成辮子，然後在兩邊的耳朵旁各盤了一個髮箕。不知為什麼，她讓我想到了羅絲．高登。金咪身高大概到我肩膀，她把頭往後仰，說，「亨利，她長得太漂亮了！」(page 250)</p></blockquote><p>案例三，克萊兒瞧著亨利的父親：</p><blockquote><p>我點點頭，然後跟著她走進客廳，亨利的爸爸也在裏頭，坐在一張扶手椅上。<br>他什麼話也沒說，就只是盯著我看。亨利的爸爸高高的，瘦骨嶙峋，看起來很疲憊的樣子。他長得不太像亨利，有一頭灰白的短髮、黑眼睛、長鼻子、薄嘴唇，嘴角有一點下垂。他縮成一團坐在椅子裡，我注意到他的手，又長又優雅，就像正在打盹的貓咪躺在他的膝蓋上。(page 251)</p></blockquote><p>案例四，初次約會時，亨利對克萊兒的觀察：</p><blockquote><p>「哈囉，」我打了個招呼，克萊兒穿著一件酒紅色的絲絨洋裝，戴著珍珠項鍊，看起來就像是用約翰．葛萊姆手法所寶線出來的波提切利畫下的女子，有著灰色的大眼睛、挺直的鼻子、日本藝妓般的櫻桃小口。她的紅色秀髮及肩，遮住了她的肩膀。克萊兒實在是太蒼白了，看起來就像燭光下的蠟像。我把玫瑰花送到她的面前，「送給妳的。」(page 21)</p></blockquote><p>案例五，亨利與往後的摯友首次見面：</p><blockquote><p>電鈴聲很嚇人，我把門打開。「往上走就對了！」一個低沉的男性嗓音喊道。我慢吞吞地爬了四段樓梯。嗓音來自一個高大的金髮男性。留著舉世無雙的龐巴度髮型，叼著一根菸，穿著波蘭「團結工聯」的T桖。他看起來很面熟，但我一時想不起曾在哪裡見過他。對一個有著西班牙名「戈梅茲」的人來說，他看起來太像……波蘭人了。後來我才知道他的真名是楊．戈莫林斯基。(page 147)</p></blockquote><p>案例六，亨利與克萊兒的父親見面：</p><blockquote><p>克萊兒介紹我時，他們突然微微露出一股嫌惡之情，不過菲利普．艾布希爾是名律師，可以主宰他臉上的五官，所以在一分鐘之內就換成了一張和藹可親的笑臉。這位東道主，也就是我女朋友的爸爸，一個頭逐漸禿了的中年人，戴著飛行員眼鏡，有一副鬆弛中的運動員身材，還有一雙肥厚有力的手、打網球的人的手，雖然他很推心置腹地咧著嘴笑，但是一直用灰色的眼睛充滿驚覺地盯著我。(page 187)</p></blockquote><p>案例七，亨利去拜訪肯德瑞克博士（亨利的主治醫師）：</p><blockquote><p>我進入肯德瑞克博士的辦公室，他在某個檔案夾上記東西。我坐了下來，他還在寫。他比我想像的更年輕，大概才三十七、八歲吧。我總以為醫生都是老人家，沒辦法，這是我小時候見過無數個醫生所留下來的印象。肯德瑞克博士有一頭紅髮，臉很瘦，留著絡腮鬍，還帶著鏡片很厚的金屬框眼鏡。他看起來有點像 D. H. 勞倫斯，穿著一套很好看的炭灰色西裝，打著細長的深綠色領帶，領帶上別著虹鱒的領帶夾。這間房間瀰漫著香菸的煙霧，雖然她現在沒有抽菸，但菸灰缸都滿出來了。房間裡的一切都很現代：鋼管、米色的斜紋布、淺色的木頭。他抬頭看著我，對我微笑。(page 327)</p></blockquote><p>總結這些段落，我們可以發現，人物的介紹始於一個事件，事件讓文字聚焦在人物身上，也確定了描繪的起點。新角色透過感知（案例五）、回憶（案例一）、空間轉換（案例二、案例七）等情況自然地進入場景。</p><p>進入場景的事件也限制了最初描繪人物的方式。比如在案例五中，如果亨利是透過聽到呼喊聲才意識到戈梅茲的存在，那麼一開始，應該只能仰賴聽覺描述，隨著戈梅茲進入視線範圍，才會加入視覺描述。</p><p>在案例二中，當金咪出現在門口時，克萊兒首先注意到的是金咪的衣著（個人最明顯的特徵），然後才是對方的臉，特別是對髮型的詳細描述。而在案例三中，克萊兒是被動地注意到亨利父親的視線，所以反而是先描述對方五官的形象，然後再描寫手部的狀況。</p><p>完成初步描述後，作者的描述模式因角色而有所不同，但仍可以歸納為以下幾點：</p><ol><li>陳述引入人物的事件，然後根據事件的性質，給出人物的初步描述。</li><li>從最顯眼處描述人物的衣著、五官或身材，然後從頭到腳或從腳到頭補充細節。例如在案例六中，因為首先描述了克萊兒父親的禿頭，所以接下來才從上到下描述角色的眼睛、身材和手；而在案例二中，則是先看到金咪的口紅，所以從下到上依次描述眉毛與發型。</li><li>詳細描述能反映角色形象的外觀特徵，比如在案例一中的母親的妝容、案例二中的金咪的髮型、案例三中的亨利父親的手，以及案例五中的熟悉的面孔。</li><li>可以穿插敘述者對人物的印象或比喻等，幫助讀者想像。</li></ol><p>儘管這些內容還不全面，但我認為這樣的模式已經可以指引一些寫作方向。畢竟，人物描寫不僅僅是文筆問題，還涉及到如何選擇對象、要觀察哪些特徵、如何尋找故事性、要選擇哪些詞語等問題。因此，為了提高人物描述的能力，我可能會進行以下的練習：</p><ol><li>留意記憶中或生活中值得關注的人物。</li><li>回想這些人物因為何種事件或行為讓人印象深刻。</li><li>按照本文總結的模式進行人物描寫。</li><li>通過描寫的過程，了解自己在詞匯和觀察方面的不足。</li><li>思考這些人物描述可以放在故事的哪個環節，需要多少篇幅才合適。</li></ol><p>當然，這些指導是為了練習寫作而設計的，除了外觀和行為，人物形象還包括思想、習慣、信仰、目標、能力和恐懼等面向，而人物描述也只是故事的其中一個環節。</p><p>然而，外表和行為是最容易觀察的項目，也是反映人物態度與選擇最直接的線索。因此，從這些外顯要素著手，對於寫作新手的我來說，或許是一個非常好的出發點。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜調整工作目錄的路徑</title>
      <link href="/nextflow-change-path-to-work-directory/"/>
      <url>/nextflow-change-path-to-work-directory/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 會為分析流程的每一步建立工作目錄，再以工作目錄為中心接收資料、儲存暫存檔和匯出結果。工作目錄預設在 nextflow 腳本執行路徑下的 <code>work/</code>，可透過添加執行選項、調整參數設定、設置環境變項等三種方式自訂工作目錄的路徑。</p><span id="more"></span><h1 id="添加執行選項"><a href="#添加執行選項" class="headerlink" title="添加執行選項"></a>添加執行選項</h1><p>執行 Nextflow 腳本時，加上 <code>-w</code> 便能指定工作目錄的存放路徑與名稱，是優先度最高的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run workflow.nf -w <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure><h1 id="調整參數設定"><a href="#調整參數設定" class="headerlink" title="調整參數設定"></a>調整參數設定</h1><p>其次，也能在<a href="https://www.nextflow.io/docs/latest/config.html">設置檔內定義工作目錄</a>，再使用 <code>-c</code> 導入設置檔。（除此之外，使用 <code>-params-file</code> 導入參數或是直接將<code>workDir</code> 定義在 nextflow 腳本內都是無效的手法。）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.json</span></span><br><span class="line">workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run workflow.nf -c config.json</span><br></pre></td></tr></table></figure><p>要留意的是，雖然在設置檔內常使用 <code>params.var</code> 的方式來定義變項，但 <code>workDir</code> 不等同 <code>params.workDir</code>，因此以下兩種寫法都無法調整工作目錄的存放路徑。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">params.workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line">params <span class="punctuation">&#123;</span></span><br><span class="line">    workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="設置環境變項"><a href="#設置環境變項" class="headerlink" title="設置環境變項"></a>設置環境變項</h1><p>第三種方法則是在 nextflow 的執行環境重設環境變數，是優先度最低的方式。（Nextflow 相關的環境變項可參照 <a href="https://www.nextflow.io/docs/latest/metadata.html">Workflow introspection</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> NXF_WORK=<span class="string">&quot;/path/to/workdir/&quot;</span></span><br><span class="line">$ nextflow run workflow.nf</span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>工作目錄的內容有助於追蹤程式錯誤，為了管理方便，可透過執行指令、內製變項和環境變項來調整工作目錄的路徑。</p><p>除了工作目錄外，或許也有人想調整 <code>.nextflow</code> 等暫存目錄的位置，但根據<a href="https://github.com/nextflow-io/nextflow/issues/1747">開發者所述</a>，目前應該是無法更動。</p><blockquote><p>The <code>.nextflow</code> has to be in the launching directory to properly maintain the history of the executions.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嘗試修改 Vimium 來關閉網頁 pop-up</title>
      <link href="/modify-vimium-to-label-and-close-pop-up/"/>
      <url>/modify-vimium-to-label-and-close-pop-up/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>彈出視窗是以鍵盤瀏覽網頁的最大阻礙。這些視窗的內容不外乎會員邀請、推薦連結、蓋板廣告與網站公告等，是網站而定，通常沒辦法以 tab 來點擊，之前介紹的 Vimium 功能也沒辦法為這些視窗上的連結打標籤。由於彈出視窗並非廣告，所以下載 adblock 也無法阻擋之。所以往往只能乖乖移動滑鼠關閉之。</p><p>因為這些彈出視窗設計有別於html 內建的元素，所以有些更糟糕的案例是連關閉按鈕都沒有顯示在頁面上，強迫使用這點開網頁才能關閉之。</p><p>在得知 Vimium 點擊連結的方便之後，我嘗試修改 Vimium 的程式碼，讓他可以為原先沒辦法點擊的連結標註標籤</p><span id="more"></span><h1 id="想法與策略"><a href="#想法與策略" class="headerlink" title="想法與策略"></a>想法與策略</h1><p>Vimium 能為網頁中可點擊的元素標註標籤，讓用戶得以用這些標籤的快捷鍵點開連結，不用經手滑鼠或用tab 遍歷。其原理是透過html元素，辨識可能可點擊的元素，例如連結、按鈕等。</p><p>然而，網頁中仍能有自訂元素，這些元素的名稱和行為未必與 html 原生元素一致，所以 Vimium 只能嘗試搜索可能可點擊的元素名稱，例如 buttom 或是 link，間接推論這些元素可點擊。不過實際的網頁往往不會使用這麼直白的名稱，可能使用縮寫或是帶好來命名這些元素，導致 vimium 無法標註這些元素。</p><p>讀了<a href="https://ithelp.ithome.com.tw/articles/10091999">Vimium 介紹與支持 Plurk (噗浪)</a>之後，覺得最直觀的想法是 修改 Vimium 程式碼的判斷式，看能不能找到彈出視窗共同的特徵，例如名稱、類別或是辨識碼等，拓展 Vimium 能辨識的元素，讓程式也能夠為彈出視窗標記快捷鍵。</p><p>不過這篇文章距今已十年，Vimium 也經歷多次改版，所以可能要找一下 github page 找到辨識網頁元素的區域在何處。所幸在<a href="https://stackoverflow.com/questions/53918093/how-can-i-make-my-element-clickable-for-vimium">這篇文章</a>找到了一些參考。</p><p>我嘗試各大新聞網都失敗，只有知乎成功，因此以下會用知乎為例，說明要怎麼修改程式碼讓 Vimium 可以關閉彈出連結。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_before.png?raw=true" alt="Vimium 無法辨識知乎登入視窗的關閉符號"></p><h1 id="調查彈出視窗是否有共同的特徵"><a href="#調查彈出視窗是否有共同的特徵" class="headerlink" title="調查彈出視窗是否有共同的特徵"></a>調查彈出視窗是否有共同的特徵</h1><p>下一步是觀察彈出視窗的網頁元素的構建方式，歸納出彈出視窗的共通特徵，以便讓 Vimium 辨識。首先，在瀏覽器按 <code>F12</code> 開啟開發人員視窗來檢視網頁原始碼，接著於彈出視窗依序點擊右鍵和檢查，即可鎖定對應位置的網頁原始碼。</p><p>我檢查了幾個網站後發現，每個網頁的彈出視窗設計都不一樣，例如元素的組成、對應的滑鼠行為(e.g. hover or click)，乃至於元素的 class 與 id 也因網頁而異。這意味著，也許沒有共通的值可以辨識這些自訂元素，只能針對常用的網頁來做修改。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_check.png?raw=true"></p><h1 id="下載擴充套件程式碼"><a href="#下載擴充套件程式碼" class="headerlink" title="下載擴充套件程式碼"></a>下載擴充套件程式碼</h1><p>下載擴充套件的方式可參考<a href="https://stackoverflow.com/questions/16680682/how-to-modify-an-extension-from-the-chrome-web-store">此文</a></p><ol><li>安裝 <a href="https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin">Chrome extension source viewer</a></li><li>點開 Vimium 頁面</li><li>點擊 “Chrome extension source viewer”</li><li>點擊 “Download as zip”<br><img data-src="https://lh3.googleusercontent.com/dCvSGp9T3LZP6PLfzgxNpxlX5qxizpjKN8g9R3eNKTg98e4MfAEDc5IRVFGr5O4VtC4nq62HNKpGxkNaDLscK1VXLw=w640-h400-e365-rj-sc0x00ffffff" alt="於擴充套件頁面點擊 &quot;CRX&quot; 即可下載套件原始碼（圖：Chrome extension source viewer 頁面）"></li></ol><h1 id="修改程式碼並套用於瀏覽器"><a href="#修改程式碼並套用於瀏覽器" class="headerlink" title="修改程式碼並套用於瀏覽器"></a>修改程式碼並套用於瀏覽器</h1><p>解壓縮後，接著點開，在這段加入<br><a href="https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992">https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isClickable &amp;&amp; className &amp;&amp; className.<span class="title function_">toLowerCase</span>().<span class="title function_">includes</span>(<span class="string">&quot;zdi&quot;</span>))</span><br><span class="line">  possibleFalsePositive = isClickable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ol><li>開啟 Chrome，點選工具列的擴充功能圖示</li><li>點選「管理擴充管理」</li><li>點選「載入未封裝項目」</li><li>重新整理頁面，查看是否順利修改</li></ol><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_after.png?raw=true" alt="修改 Vimium 的程式碼後，關閉視窗的符號被標上標籤了。"></p><h1 id="困難與限制"><a href="#困難與限制" class="headerlink" title="困難與限制"></a>困難與限制</h1><p>實作之後才發現，許多網站不是用 Html 既有物件來構建彈出視窗，而是自訂許多 class 與 id，再透過 Javascript 控制。這些自定義物件的行為由 Javascript 控制，每個網頁的命名、行為與能見度都不一樣，所以 Vimium 也無法一次搞定所有可能性。</p><p>換句話說，本文陳述的嘗試只適用於常用的網站，好比說常看的新聞網或社群論壇等，不能一勞永逸地克服所有彈出視窗。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>目前，彈出視窗仍是鍵盤瀏覽網頁的最大阻礙，原因是彈出是往往是自訂元素。，諸如 Vimium 等擴充套件也不易辨識多樣的自訂元素。鍵盤的可及性受限於網頁元素的設計共識，所以政府對於無障礙網頁設計才有相關的規範與建議吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>無助於開發，但有助於身心的 VSCode 套件</title>
      <link href="/vscode-extensions-that-are-do-nothing-but-are-cool/"/>
      <url>/vscode-extensions-that-are-do-nothing-but-are-cool/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近調查 VSCode 有哪些能幫助軟體開發的工具時，發現不少有趣的擴充套件，這些套件也許不能提升開發速度，但說不定能為百無聊賴、獨自 coding 的下午增添風格與生氣。</p><span id="more"></span><h1 id="像駭客一樣寫程式"><a href="#像駭客一樣寫程式" class="headerlink" title="像駭客一樣寫程式"></a>像駭客一樣寫程式</h1><p>首先是能增加打字回饋感並且裝模作樣的套件。</p><h2 id="Power-Mode"><a href="#Power-Mode" class="headerlink" title="Power Mode"></a>Power Mode</h2><blockquote><p>This is the most necessary and MUST TO plugin EVER. Now I can feel the power of my typing. Recommended to all my friends and colleges. 1000000&#x2F;10</p></blockquote><p><img data-src="https://raw.githubusercontent.com/hoovercj/vscode-power-mode/7bbc4f68dd46da883b24011ae67516c861d09d1b/images/demo-presets-particles.gif" alt="powermode"></p><p>Power Mode 能大幅增加 coding 的回饋感，除了隨著打字噴發的特效與劇烈震動以外，在頁面右上角也會顯示連續打字次數，讓打字除了聽覺與觸覺的回饋感以外，還增加了視覺的激情與火爆。</p><p>Power Mode 的設定健全，無論特效的形式、時間、幅度、頻率或觸發條件都可調整。以震動特效為例，若覺得太過干擾，可以透過以下方式關閉，</p><ol><li><code>Ctrl</code> + <code>,</code>，開啟設置</li><li>搜尋 “Powermode &gt; Shake: Enabled”</li><li>關閉震動特效</li></ol><h2 id="VSCode-HackerTyper"><a href="#VSCode-HackerTyper" class="headerlink" title="VSCode HackerTyper"></a>VSCode HackerTyper</h2><blockquote><p> Writing Code Like a Real Hacker </p></blockquote><p><a href="https://hackertyper.net/">HackerTyper</a> 是模擬駭客寫程式的網頁。一點開網頁，映入眼簾的即典型的駭客工作環境：黑底綠字的終端畫面、等寬的程式碼字體、閃爍的文字游標等。</p><p>在這畫面中，無論敲打哪個按鍵，網頁都會印出虛構的迴圈、變數、判斷，營造出用戶正在快速寫程式的模樣。</p><p><img data-src="https://github.com/jevakallio/vscode-hacker-typer/raw/master/docs/hackertyper-video.gif" alt="VSCode HackerTyper 讓你像個駭客一樣 coding"></p><p>相較之下，VSCode HackerTyper 可以印出「真正」的程式碼。這款套件能錄製文件編輯行為，再透過用戶每次按鍵撥放來達到網頁版的效果。由於是採用自己的程式碼，所以這項套件也挺適合在現場示範時博其它人一笑的（詳見開發者親自示範如何<a href="https://www.youtube.com/watch?v=ulnC-SDBDKE">像個駭客一樣現場 demo</a>。</p><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VSCode 命令列。（接下來指令皆於命令列執行)</li><li>輸入 “HackerTyper: Record Macro”，接著開始編輯文件</li><li>編輯完文件後，輸入 “HackerTyper: Save Macro” 紀錄並命名</li><li>要展示駭客技能時，開啟文件並輸入 “HackerTyper: Play Macro”</li></ol><p><em>已知 VSCodeVim 與此套件衝突，所以要使用這工具前，得先停用 VSCodeVim 並且重啟視窗</em></p><h2 id="Cursor-smooth-setting"><a href="#Cursor-smooth-setting" class="headerlink" title="Cursor smooth setting"></a>Cursor smooth setting</h2><blockquote><p>Watching those lines of codes flow like butter along with your cursor is just another satisfying thing to watch for any programmer like the satisfying sounds of their mechanical keyboards. 😌 (Trishiraj)</p></blockquote><p>除了使用套件，VSCode 也有許多內建設置能調整編輯的視覺效果，其中我覺得最有效提升視覺舒適感的是一系列平滑設定。</p><p>好比說啟用 “Cursor Smooth Caret Animation” 之後，VSCode 會在移動過程添加殘影動畫，讓游標在字元與行列間跳動時的移動軌跡更接近肉眼習慣的模式，看起來更為滑順與流暢。</p><ol><li><code>Ctrl</code> + <code>,</code></li><li>搜尋 “smooth”</li><li>勾選 “Cursor smooth Caret Animation”</li></ol><h2 id="hacker-theme"><a href="#hacker-theme" class="headerlink" title="hacker theme"></a>hacker theme</h2><p>有了 Power Mode、HackerTyper、smooth cursor，再加上 VScode 商店許多駭客佈景主題，就能打造一座自嗨小天地，或是秀一回盛大而且浮誇的表演囉。<br><img data-src="https://github.com/thorerik/vscode-hacker-theme/raw/HEAD/media/Code_2020-08-12_01-55-19.png" alt="pro hacker theme"></p><h1 id="寫程式時不再孤獨"><a href="#寫程式時不再孤獨" class="headerlink" title="寫程式時不再孤獨"></a>寫程式時不再孤獨</h1><p>接著讓 coding 在鍵盤敲擊聲、鍵盤的觸感與閃爍的游標之外，還增添人造互動的套件。</p><h2 id="vscode-pet"><a href="#vscode-pet" class="headerlink" title="vscode-pet"></a>vscode-pet</h2><blockquote><p>Coding can be lonely sometimes but these pets always keep me company !! (Aya Lahrech)</p></blockquote><p>vscode-pets 會在 VSCode 側欄新增寵物窗格，可以在其中添加貓咪、小狗與小雞等寵物。除了看著寵物閒晃以外，也能透過點擊或擲球與他們互動。</p><p><img data-src="https://tonybaloney.github.io/vscode-pets/_images/throw-ball.gif" alt="VSCode 小動物會追著丟出的球跑，也會以表情符號回應點擊。"></p><p>若覺得預設的背景太單調，可以在設定更換背景</p><ol><li><code>Ctrl</code> + <code>,</code>，開啟設定</li><li>搜尋 “vscode-pets.theme”，設定想要的主題</li></ol><p><img data-src="https://tonybaloney.github.io/vscode-pets/_images/forest.gif" alt="除了森林，還有城堡與海灘背景"></p><h2 id="Encourage"><a href="#Encourage" class="headerlink" title="Encourage"></a>Encourage</h2><blockquote><p>There are times when writing code is drudgery. In those dark times, bathed in the soft glow of your monitor, engrossed in the rhythmic ticky tacka sound of of your keyboard, a few kind words can make a big difference. And who better to give you those kind words than your partner in crime - your editor. (Haacked)</p></blockquote><p><img data-src="https://user-images.githubusercontent.com/7860985/79793932-66320380-831f-11ea-8188-fb4a627f670a.gif" alt="Encourage 會在文件儲存時，根據程式碼正確與否給予對應的回饋。"></p><p>Encourage 是款文字互動套件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。 ">1</span></a></sup>，會根據文件儲存當下，程式碼是否語法錯誤給予對應的回饋。假如沒有錯誤，則會隨機印出鼓勵的話；反之，則會吐出吐槽或挖苦的句子。</p><p>這套件支援自訂語錄，所以可以自行添加喜歡的座右銘、名言或幹話等，</p><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟設定介面 </li><li>搜尋 “Preferences: Open User settings (JSON)”</li><li>在大括號內添加以下內容，即可新增自訂語錄： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [extensions]: Encourages</span></span><br><span class="line"><span class="attr">&quot;encourage.additionalEncouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;Wake the fuck up, Samurai. We have a city to burn 🔥🔥🔥&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Just focus, you are better than them.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Fuck yeah!!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Death to Corpos!!!💀&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Never stop fighting.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Holy FUCK!!!&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li>若只想聽到鼓勵的話，可以用空字串覆蓋預設的挖苦內容。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;encourage.discouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li></ol><p>此處我加入了一些 Cyberpunk 2077 的台詞，但你也可以調整成從飲料封膜看到的冷笑話或農民曆頁緣的生活訣竅。</p><h2 id="Hotheaded-VS-Code"><a href="#Hotheaded-VS-Code" class="headerlink" title="Hotheaded VS Code"></a>Hotheaded VS Code</h2><blockquote><p>love how it kic…, corrects me. (Venipa)</p></blockquote><p>相較於 Encourage 的文字訊息，Hotheaded VS Code 會在語法出錯時放出嫌棄的語音（而且只有嫌棄，沒有鼓勵）。雖然我個人是比較喜歡鼓勵大於責備啦，但這在業界是種獎勵也說不定。</p><p><em>聲線可以參考配音員<a href="https://www.fiverr.com/dalfaria">dalfaria 的網站試聽</a></em></p><h1 id="讓人哭笑不得"><a href="#讓人哭笑不得" class="headerlink" title="讓人哭笑不得"></a>讓人哭笑不得</h1><p>最後則是能讓自己的 IDE 與他人很不一樣的主題。此處推薦兩則 VSCode 官方推特也說讚的主題套件<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://twitter.com/code/status/928315998075215873">2</span></a></sup>。</p><h2 id="Cage-Icons"><a href="#Cage-Icons" class="headerlink" title="Cage Icons"></a>Cage Icons</h2><blockquote><p>With this I’m gonna steal the Declaration of Independence. (Kishore Newton)</p></blockquote><p>我覺得尼可拉斯凱吉是詮釋「身不由己」最出色的演員，他的表情也是迷因的重要來源。這套件會將原生圖標替換那些常在梗圖裡看到的尼可拉斯凱吉表情。<br><img data-src="https://raw.githubusercontent.com/GabeStep/cage-icons/master/example.png" alt="用膩了 Materials Icon Theme？何不試試 Cage Icons！"></p><h2 id="Hot-dog-stand"><a href="#Hot-dog-stand" class="headerlink" title="Hot dog stand"></a>Hot dog stand</h2><blockquote><p>This is AMAZING! I can hardly see anymore, recently started using a walking stick. couldn’t recommend more! (Franklin Volcic)</p></blockquote><p>Hot dog stand 套件復刻了 Win 3.1 史上最糟糕的視覺設計<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/">3</span></a></sup>。套件開發者介紹說，這套主題能在 15 秒內毀了用戶雙眼，但根據 VSCode 推特小編的說法，其實大約只需兩秒鐘……</p><p><img data-src="https://raw.githubusercontent.com/SomeKittens/VSC-HDS/master/theme.png" alt="安裝這款主題後，我只堅持了一秒鐘就移除了。"></p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>有時，認真研究點沒意義的事，其實也挺好玩的啊！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://twitter.com/code/status/928315998075215873<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜利用 `publishDir` 匯出分析檔案</title>
      <link href="/nextflow-the-mode-of-publishdir/"/>
      <url>/nextflow-the-mode-of-publishdir/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 透過 channel 媒介 process 間的檔案傳遞，讓輸出入檔案以軟連結集中到 process 的工作目錄。不過若想從工作目錄取出分析的最終結果，有賴 <code>publishDir</code> directive 的協助。</p><span id="more"></span><p><code>publishDir</code> 能匯出 process 輸出檔案到指定目錄，其語法與注意事項如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">process demoPub &#123;</span><br><span class="line">    publishDir <span class="string">&quot;/path/to/output&quot;</span></span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;example.txt&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    touch &quot;example.txt&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    demoPub()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有且僅有定義在 output channel 的檔案會匯出到指定目錄</li><li><code>publishDir</code> 應使用絕對路徑 </li><li>預設會在指定目錄建立輸出檔案的軟連結</li><li></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt -&gt; /project/work/workdir    </span><br></pre></td></tr></table></figure><h1 id="修改-publishDir-匯出檔案的方式"><a href="#修改-publishDir-匯出檔案的方式" class="headerlink" title="修改 publishDir 匯出檔案的方式"></a>修改 <code>publishDir</code> 匯出檔案的方式</h1><p>若想修改預設模式可以寫成</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">mode:</span> <span class="string">&quot;copy&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt</span><br></pre></td></tr></table></figure><p>除了 “copy”，nextflow 亦有其它匯出檔案的方式，它們分別對應了 linux 的 symbolic link, copy, 與 hard link。詳情可參考軟連結、硬連結與複製的差異，此處僅列出與使用檔案較為相關的特性。</p><table><thead><tr><th>mode</th><th>symlink</th><th>copy</th><th>link</th></tr></thead><tbody><tr><td>linux指令</td><td>symbolic link</td><td>copy</td><td>hard link</td></tr><tr><td>適用對象</td><td>檔案與目錄</td><td>檔案與目錄</td><td>檔案</td></tr><tr><td>原檔更新</td><td>隨之更新</td><td>不隨之更新</td><td>隨之更新</td></tr><tr><td>容量大小</td><td>連結大小</td><td>與原檔一致</td><td>與原檔一致</td></tr><tr><td>刪除原檔</td><td>連結遺失</td><td>不受影響</td><td>不受影響</td></tr></tbody></table><h1 id="篩選輸出的檔案"><a href="#篩選輸出的檔案" class="headerlink" title="篩選輸出的檔案"></a>篩選輸出的檔案</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.txt&quot;</span></span><br><span class="line">publishDir <span class="string">&quot;path/to/backup&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.md&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <code>pattern</code> 篩選，可以達到分流輸出檔案的目的。</p><h1 id="更動輸出名稱"><a href="#更動輸出名稱" class="headerlink" title="更動輸出名稱"></a>更動輸出名稱</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">saveAs:</span> <span class="string">&quot;new_name&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <code>saveAs</code> 重新命名，可用於重新命名、依照檔名調整輸出目錄等。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 最大的特色是以 channel 傳遞資料，process 是從前一步驟的工作目錄獲得資料，而非讀取輸出目錄的資料夾。換句話說，無論建立 output channel 還是匯出檔案到 publishDir，nextflow 都是以 process 的工作目錄為中心。由於每批次處理都會新建工作目錄，所以也確保了 process 輸出的檔案不會彼此覆寫，減少命名中間檔和管理暫存目錄的勞力（這些都由 nextflow 代勞了）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜如何為輸入的資料建立辨識碼</title>
      <link href="/nextflow-combine-data-into-a-tuple-with-key/"/>
      <url>/nextflow-combine-data-into-a-tuple-with-key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Nextflow 的框架，channel 媒介了 process 間的資料傳遞。雖然資料進出 channel 遵循先進先出 (first-in, first out, FIFO) 原則，但隨後 nextflow 會平行處理這些資料，所以 process 釋出資料的順序取決於執行速率，而不是原先輸入的順序（見下例）。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demoEmitOrder.nf</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val num</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;num&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    nums = channel.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    nums.view()</span><br><span class="line">    A(nums).view() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run demoEmitOrder.nf</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Nextflow 這項特性使得輸入彼此相依的資料時要格外留意，因為可能在定序產物品管時，發生不同樣本的順逆序列（例如：a_r1.fa 與 b_r2.fa 合併）的狀況；又或是使用 GATK 這類需要參考基因體的工具時，無法為 <code>.fasta</code> 找到對應 <code>.dict</code> 和 <code>.fai</code> 檔的情形。</p><p>因此，本文將介紹如何將想要一起輸入的檔案以及其辨識碼組合成 tuple （例如：<code>[&quot;ID&quot;, &quot;ID_r1.fastq&quot;, &quot;ID_r2.fastq&quot;]</code>），確保成對資料同進同出，還能透過辨識碼與其它資料合併。</p><span id="more"></span><h1 id="準備測試資料"><a href="#準備測試資料" class="headerlink" title="準備測試資料"></a>準備測試資料</h1><p>首先建立雙端定序產物與人體基因體序列的測試資料，用以示範成對資料和多筆資料各自要如何組合成 tuple。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> data</span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;_r&#123;1,2&#125;.fq           <span class="comment"># 示範成對資料</span></span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;.&#123;fasta,dict,fai&#125;    <span class="comment"># 示範多筆資料</span></span><br></pre></td></tr></table></figure><p>接著，在 nextflow script (<code>*.nf</code>) 定義這些資料以建立 input channel。此處這麼做是為了簡便，但其實也可以將資料路徑寫到 JSON 檔，在執行 nextflow script 時，透過 <code>-c</code> 或 <code>-params-file</code> 讀入。要留意的是，欲組合在一起的資料於 nextflow 變項的順序要一致，</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inDir = <span class="string">&quot;/path/to/data&quot;</span></span><br><span class="line">id = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">fq1 = [<span class="string">&quot;$inDir/a_r1.fq&quot;</span>, <span class="string">&quot;$inDir/b_r1.fq&quot;</span>, <span class="string">&quot;$inDir/c_r1.fq&quot;</span>]</span><br><span class="line">fq2 = [<span class="string">&quot;$inDir/a_r2.fq&quot;</span>, <span class="string">&quot;$inDir/b_r2.fq&quot;</span>, <span class="string">&quot;$inDir/c_r2.fq&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="透過-nextflow-operator"><a href="#透過-nextflow-operator" class="headerlink" title="透過 nextflow operator"></a>透過 nextflow operator</h1><p>假設已經把辨識碼與輸入資料定義成前一節的形式，而且要組合在一起的資料於 nextflow 各變項內的順序也相同，那麼可以先建立包含全數資料的 tuple，再使用 <code>transpose</code> operator 轉置。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.of([id, fq1, fq2]).transpose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/combine-data-into-a-tuple-with-key_transpose.png?raw=true" alt="`transpose` 能轉置 channel 的組成。"></p><p>由於 channel 遵循 FIFO 原則，所以使用 <code>view()</code> 瀏覽結果時，確認資料釋出與輸入順序一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure><h1 id="透過-bash-in-process"><a href="#透過-bash-in-process" class="headerlink" title="透過 bash in process"></a>透過 bash in process</h1><p>假設辨識碼為檔名的一部份，那麼也可以用 bash script 擷取字串，並在 output channel 將擷取到的辨識碼與輸入的資料組合成 <code>tuple</code>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process addID &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path fq1</span><br><span class="line">        path fq2</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        tuple env(id), path(fq1), path(fq2)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        id=\$(basename -s _r1.fq $&#123;fq1&#125;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    addID(channel.fromPath(fq1), channel.fromPath(fq2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由於經 process 處理，資料釋出順序已偏離輸入順序，紀錄的路徑也轉移到 process 的工作目錄了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r1.fq, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r2.fq]  </span><br><span class="line">[c, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r1.fq, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r2.fq]  </span><br><span class="line">[b, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r1.fq, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r2.fq]  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="透過-channel-factory-限定成對資料"><a href="#透過-channel-factory-限定成對資料" class="headerlink" title="透過 channel factory (限定成對資料)"></a>透過 channel factory (限定成對資料)</h1><p>如果辨識碼是檔名的一部份，而且資料又如雙端定序產物兩兩一組，那麼也可以使用 <code>fromFilePairs</code> 建立 <code>tuple</code>。簡言之，nextflow 會搜尋指定目錄下含有成對詞綴的檔案（此例為 <code>_r1.fq</code> 與 <code>_r2.fq</code>），擷取詞綴前的字串，將成對資料組合成帶有辨識碼的 <code>tuple</code>。</p><p>預設是組合成 <code>[&quot;id&quot;, [&quot;path 1&quot;, &quot;path 2&quot;]]</code> 形式，所以此處使用 <code>flat:true</code> 攤平巢狀結構。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromFilePairs(<span class="string">&quot;$inDir/*_r&#123;1,2&#125;.fq&quot;</span>, <span class="attr">flat:</span><span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure><h1 id="結合-channel-operator-和-groovy-closure"><a href="#結合-channel-operator-和-groovy-closure" class="headerlink" title="結合 channel operator 和 groovy closure"></a>結合 channel operator 和 groovy closure</h1><p><code>fromFilePairs</code> 僅適用成對資料，若是多筆資料則要組合 nextflow operator 和 groovy closure 來完成。</p><ol><li>以 <code>fromPath</code> 建立 channel 時，搜尋不同詞綴的檔案</li><li>以 groovy <em>getBaseName</em> 擷取檔名，再用 nextflow <code>map</code> 將檔名與檔案路徑組合成 tuple（例如：<code>a.fasta</code>→<code>［&quot;a&quot;, &quot;a.fasta&quot;]</code>）</li><li>以 <code>groupTuple</code> 組合含有相同辨識碼的 tuple（例如：<code>[&quot;a&quot;, &quot;a.fasta&quot;]</code> 與 <code>[&quot;a&quot;, &quot;a.dict&quot;]</code> 組合成 <code>[&quot;a&quot;, [&quot;a.fasta&quot;, &quot;a.dict&quot;]]</code>）</li><li>以 <code>map</code> 配合 groovy <em>flatten</em> 攤開巢狀 <code>tuple</code></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromPath([<span class="string">&quot;$inDir/*.dict&quot;</span>, <span class="string">&quot;$inDir/*.fasta&quot;</span>, <span class="string">&quot;$inDir/*.fai&quot;</span>])</span><br><span class="line">        .map&#123;it -&gt; tuple(it.getBaseName(), it)&#125;</span><br><span class="line">        .groupTuple()</span><br><span class="line">        .map&#123;it -&gt; it.flatten()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此處假設檔名等同辨識碼，若辨識碼是檔名的子字串或其它組合，那就要參考 groovy 的字串處理方式。這裡使用 groovy 是為了要在 nextflow script 完成任務，若不限此條件，那也可以新增 process，改用熟悉的腳本語言來處理字串（參考 bash script 的方法）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a, /path/to/data/a.fasta, /path/to/data/a.dict, /path/to/data/a.fai]</span><br><span class="line">[b, /path/to/data/b.fasta, /path/to/data/b.dict, /path/to/data/b.fai]</span><br><span class="line">[c, /path/to/data/c.fasta, /path/to/data/c.dict, /path/to/data/c.fai]</span><br></pre></td></tr></table></figure><h1 id="怎麼讀取資料"><a href="#怎麼讀取資料" class="headerlink" title="怎麼讀取資料"></a>怎麼讀取資料</h1><p>前述建立的 <code>tuple</code> 可用以下方式讀入 process，也可以用 <code>join</code> 組合，確保成對或多筆資料能夠在 process 同進同出。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process readInput &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        tuple val(id), path(fq1), path(fq2)</span><br><span class="line">        tuple val(id), path(fasta), path(dict), path(fai)</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fq1&#125;, $&#123;fq2&#125;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fasta&#125;, $&#123;dict&#125;, $&#123;fai&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>最後使用一張表總結將資料組合為 <code>tuple</code> 的方法。</p><table><thead><tr><th>比較項目</th><th>operator</th><th>bash in process</th><th>fromFilePairs</th><th>operator &amp; closure</th></tr></thead><tbody><tr><td>檔案數</td><td>不限</td><td>不限</td><td>兩筆</td><td>不限</td></tr><tr><td>定義</td><td>需定義檔案路徑</td><td>需定義檔案路徑</td><td>檔案存放路徑</td><td>檔案存放路徑</td></tr><tr><td>釋出順序</td><td>輸入順序</td><td>完成順序</td><td>輸入順序</td><td>輸入順序</td></tr><tr><td>檔案位置</td><td>輸入路徑</td><td>工作目錄</td><td>輸入路徑</td><td>輸入路徑</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 常用快捷鍵與個人設置</title>
      <link href="/vscode-useful-shortcuts-and-their-settings/"/>
      <url>/vscode-useful-shortcuts-and-their-settings/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>VSCode 有許多快捷鍵設置，本文記錄一些我覺得挺實用的設置</p><span id="more"></span><h1 id="開啟個人快捷鍵配置"><a href="#開啟個人快捷鍵配置" class="headerlink" title="開啟個人快捷鍵配置"></a>開啟個人快捷鍵配置</h1><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code></li><li>搜尋 “Preferences: Open Keyboard Shortcuts (JSON)”</li></ol><h1 id="調整當前子頁尺寸"><a href="#調整當前子頁尺寸" class="headerlink" title="調整當前子頁尺寸"></a>調整當前子頁尺寸</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="開啟連結"><a href="#開啟連結" class="headerlink" title="開啟連結"></a>開啟連結</h1><p>設定條件是為了避免快捷鍵彼此衝突，點連結的行為大概只有在編輯 md 檔案時發生，所以才這樣設置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+l&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;editor.action.openLink&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus &amp;&amp; editorLangId == &#x27;markdown&#x27;&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h1><p><code>Alt</code> + <code>[0-9]</code>：切換至指定分頁</p><h1 id="刷新側欄檔案目錄"><a href="#刷新側欄檔案目錄" class="headerlink" title="刷新側欄檔案目錄"></a>刷新側欄檔案目錄</h1><p><code>Ctrl</code> + <code>0</code>：開啟檔案目錄，再按一次則聚焦檔案目錄</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+F5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.explorer.fileView.focus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="游標動畫"><a href="#游標動畫" class="headerlink" title="游標動畫"></a>游標動畫</h1><p>VSCode 有一系列滑順特效動畫，能讓游標移動與視窗滑動的軌跡帶有殘引，看起來更加滑順。我自己覺得彷彿是影片從 720p 改善到 4k 的滑溜溜感。</p><ol><li><code>Ctrl</code> + <code>,</code></li><li>搜尋 “smooth”</li><li>勾選 “Cursor smooth Caret Animation”</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode: Failed to parse remote port from server output</title>
      <link href="/vscode-remote-ssh-connection-not-working-after-update/"/>
      <url>/vscode-remote-ssh-connection-not-working-after-update/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="狀況描述"><a href="#狀況描述" class="headerlink" title="狀況描述"></a>狀況描述</h2><p>原本在 Windows 都能正常用 VSCode Remote SSH 連線伺服器，但一早卻發現連線失敗。當時，VSCode 不斷要求輸入密碼卻無法登入，”OUTPUT” 頁面提示的訊息節錄如下：</p><blockquote><p>Failed to parse remote port from server output</p></blockquote><blockquote><p>Acquiring lock on &#x2F;home&#x2F;username&#x2F;.vscode-server&#x2F;bin&#x2F;some-hash-code-here&#x2F;vscode-remote-lock.username.some-hash-code-here</p></blockquote><p><em>版本資訊：windows 21H2, VSCode 1.74.2</em></p><span id="more"></span><h2 id="原因與解決辦法"><a href="#原因與解決辦法" class="headerlink" title="原因與解決辦法"></a>原因與解決辦法</h2><p>參考 <a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">VSCode remote ssh connection not working</a>，簡言之，VSCode 遠端連線前，需要在伺服器端的 <code>.vscode-server/bin</code> 安裝連線相關的工具並進行一些連線設置。假設伺服器已有這些套件，”OUTPUT” 會提示 <code>Found existing installation at (.vscode-server/bin 的路徑)</code>；若沒有這些套件，則會從官方網站下載與安裝。</p><p>若伺服器的套件和配置沒有隨本地 Vscode 更新，便可能因為連線兩端的資訊不相符而無法順利連線，此時可刪除並重新安裝這些工具與配置檔來解決問題。</p><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟指令視窗</li><li>搜尋並執行 “Remote-SSH: Kill VS Code Server on Host”，刪除 <code>vscode-server</code> 檔案與目錄</li><li>選取欲清除既有工具的伺服器</li><li>重新連線，VSCode 便會重新安裝相關軟體了</li></ol><h2 id="檢查方式"><a href="#檢查方式" class="headerlink" title="檢查方式"></a>檢查方式</h2><ol><li>開啟 command line 工具，以 <code>ping</code> 確認連線正常</li><li>使用 putty 或 mobaXtern 等工具連線伺服器，確認問題出在 VSCode </li><li>重新開機、重新安裝 Remote SSH、移除 <code>C:/Users/username/.ssh/Known_host</code> 的內容，確認問題不在本地端</li><li>按照前述步驟刪除伺服器內 <code>vscode-server</code> 的內容，重新連線</li></ol><h2 id="其他可能解法"><a href="#其他可能解法" class="headerlink" title="其他可能解法"></a>其他可能解法</h2><p>若此處提及的方式無法解決問題，可參考以下連結試試看其他人的解法。</p><ul><li><a href="https://mushding.space/2021/12/22/vscode%20remote-ssh%20%E5%95%8F%E9%A1%8C%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/">首次遠端連線且因為網路問題下載工具受阻</a> </li><li><a href="https://www.cnblogs.com/netsa/p/14857577.html">本地與伺服器的 SSH key 因為更新等緣故沒有同步</a></li><li><a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">任何可能與遠端連線配置或安裝的問題</a></li><li><a href="https://blog.csdn.net/myWorld001/article/details/119443079">伺服器上的 <code>vscode-server</code> 文件過時</a></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>IDE 及其擴充套件相當方面，可以免去不少開發環境設置的功夫。畢竟我們不會等到摸熟了 IDE 所有功能及其實踐方式才開始開發，所以功能故障算是讓了解 IDE 機制或潛在設定的好機會。在本文的案例哩，可以關閉自動更新來避免這種狀況發生。</p><ol><li><code>Ctrl</code> + <code>,</code>，開啟 Settings</li><li>搜尋 “update: Mode”</li><li>設定為 “manual” 或 “none”</li><li>重新啟動 VScode</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜資料是怎麼在 Process 間傳遞？</title>
      <link href="/nextflow-how-data-is-passed-between-processes-through-channels/"/>
      <url>/nextflow-how-data-is-passed-between-processes-through-channels/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Process 是 nextflow 管理分析流程的基本單位，可包含能在 linux shell 執行的程式碼（例如 linux command, python code）、腳本（例如自訂的 hello-world.sh）與軟體（例如 GATK 或 FastQC）。 Process 之間彼此獨立，各有各的工作目錄，也可以分別設定其執行環境（例如 docker container 或 conda environment）。</p><p>Channel 則媒介了 process 間的資料交流，若不透過 channels 串接，process 間的檔案或變項無法共享。舉凡字串、數值、檔案路徑乃至標準輸出等，皆有對應的 qualifier 讓 nextflow 知道怎麼處理得自於 channel 的各式資料。</p><span id="more"></span><p>在以下案例，我在 process A 定義了兩條字串，並透過不同途徑傳遞給 process B。</p><p>首先，string 1 被寫入檔案 (<code>str.txt</code>)，再以 path qualifier 告訴 Nextflow，把檔案路徑用軟連結 (symbolic link) 掛到 process B 的工作目錄。至於 string 2 則被定義為變項 (strAsEnv, a bash variable)，再以 env qualifier 告訴 nextflow 把變項寫到 process A 工作目錄內的 <code>.command.env</code>。</p><p>接著，分別以 strInFile 及 strAsEnv 命名由 process A 輸出 channel，傳遞給 process B 印出。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供 process B 所需的字串</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;str.txt&quot;</span>, <span class="attr">emit:</span> strInFile</span><br><span class="line">        env strAsEnv, <span class="attr">emit:</span> strAsEnv</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;string 1&quot; &gt; &quot;str.txt&quot;</span></span><br><span class="line"><span class="string">        strAsEnv=&quot;string 2&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 印出 process A 提供的字串</span></span><br><span class="line">process B &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path strInFile</span><br><span class="line">        val strAsEnv </span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;\$(cat $&#123;strInFile&#125;) is retrieved from a file passed by a queue channel&quot;</span></span><br><span class="line"><span class="string">        echo &quot;$&#123;strAsEnv&#125; is retrieved from a environment variable passed by a value channel&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 執行 process A &amp; B</span></span><br><span class="line">workflow &#123;</span><br><span class="line">    A()</span><br><span class="line">    B(A.out.strInFile, A.out.strAsEnv).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run demoChannel.nf </span><br><span class="line">Launching `demoChannel.nf` [compassionate_shannon] - revision: 319cfe997a</span><br><span class="line">executor &gt;  <span class="built_in">local</span> (2)</span><br><span class="line">[f3/e5a365] process &gt; A [100%] 1 of 1 ✔</span><br><span class="line">[b0/f79f8e] process &gt; B [100%] 1 of 1 ✔</span><br><span class="line">string 1 is retrieved from a file passed by a queue channel</span><br><span class="line">string 2 is retrieved from a environment variable passed by a value channel</span><br></pre></td></tr></table></figure><p>各 process 的工作目錄預設建立在執行路徑下的<code>work</code>，直接觀察工作目錄內的暫存檔有助於了解 path 與 env 兩種資料傳遞方式的差異<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案">1</span></a></sup>。</p><p>在 process A 的工作目錄 ([f3&#x2F;e5a365]) 裡，除了輸出的 str.txt，還有 <code>.command.env</code>。Nextflow 在執行時會將所有用 env qualifier 標記的變項定義式（即　<code>var=value</code> 這種格式）寫入 <code>.command.env</code>，以利隨後可輸出到其它 process。（可查看 <code>.command.sh</code> 查看寫入變項定義式的程式碼）</p><p>目前，只有 bash 變項才能透過 env qualifier 輸出，其它語言的變項只能透過某些方式存成檔案輸出（例如 R 的 RDS 檔）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /work/f3/e5a365e3bb7b645cf4e13cf15eb235</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">-rw-r--r-- 1 user group   18 Jan  5 22:26 .command.env      <span class="comment"># environment variables of process A</span></span><br><span class="line">-rw-r--r-- 1 user group  146 Jan  5 22:26 .command.sh       <span class="comment"># commands to execute process A</span></span><br><span class="line">-rw-r--r-- 1 user group    9 Jan  5 22:26 str.txt           <span class="comment"># output of process A</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.env</span><br><span class="line">strAsEnv=string 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.sh　 <span class="comment"># nextflow 執行 process 的腳本，只擷取跟 `.command.env` 相關的部分</span></span><br><span class="line"><span class="comment"># capture process environment</span></span><br><span class="line"><span class="built_in">set</span> +u</span><br><span class="line"><span class="built_in">echo</span> strAsEnv=<span class="variable">$&#123;strAsEnv[@]&#125;</span> &gt; .command.env</span><br></pre></td></tr></table></figure><p>而在 process B 的工作目錄可留意到 str.txt 的資料型別為 <code>l</code> (link)，檔案名稱也標示了來源。值得留意的是，如果使用 <code>cat</code> 或 <code>cp</code> 等指令通常不會有什麼問題，但如果用 <code>ls</code> 顯示檔案大小時，要注意預設顯示的是軟連結的大小，而非原檔的大小。相似的狀況也可能發生在使用 <code>find</code> 搜尋時，因為限制了搜索標的為檔案而意外地排除軟連結的情形。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/work/b0/f79f8e550a4e1af11e2b03af8b4aa4$ <span class="built_in">ls</span> -al</span><br><span class="line">lrw-r--r-- 1 user group   62 Jan  5 22:26 str.txt -&gt; /work/f3/e5a365e3bb7b645cf4e13cf15eb235/str.txt</span><br></pre></td></tr></table></figure><p>綜上所述，要怎麼利用 channel 傳遞資料端視資料型別而異。無論想傳遞表格、文檔還是變項，都可以將其寫入檔案，再以 path qualifier 讓 nextflow 依據檔案路徑在下游 process 的工作目錄建立軟連結。若想傳遞的是 bash 變項，那還可以使用 env qualifier 將變項定義式記錄在當前 process 的工作目錄供後續取用。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vimium，學習 Vim 的新途徑</title>
      <link href="/start-learning-vim-from-vimium/"/>
      <url>/start-learning-vim-from-vimium/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的一款擴充套件，它借鑒了 Vim 的鍵位設計與操作邏輯，讓用戶只需要鍵盤便能執行分頁管理、連結點擊與頁面瀏覽等操作。</p><p>由於瀏覽器終究不等同編輯器，所以 Vimium 並沒有移植 Vim 所有的功能與指令。然而，即使只納入 Vim 的部分性質，Vimium 仍顯著改善了 Chrome 的鍵盤瀏覽體驗。以點擊連結為例，Chrome 的預設作法是<a href="https://5uperb0y.com/navigate-websites-with-keyboard/">慢慢用 <code>Tab</code> 切到連結位置</a>；Vimium 則會自動標記視窗內的連結，用戶只要鍵入標記字符即可開啟連結。因為最多輸入三個字即可開啟連結，所以有時甚至比滑鼠點擊還迅速。</p><p>對於習慣鍵鼠操作卻有心學習 Vim 的用戶而言，一時要以 Vim 取代既有的工作流程，可能是繁瑣且費時的過程。若先從 Vimium 著手，在體驗鍵盤瀏覽網頁的流暢感之餘，也能讓 Vim 操作的抽象性質融入日常生活（例如：查資料與逛論壇）。待初探了 Vim 的設計緣由，再逐步精進其他操作模式，也不失為一種學習 Vim 的可行策略。</p><span id="more"></span><h1 id="能從-Vimium"><a href="#能從-Vimium" class="headerlink" title="能從 Vimium"></a>能從 Vimium</h1><p>借鑒了 Vim 鍵位設計與操作邏輯，無論是管理分頁、點擊連結或瀏覽頁面都能夠只憑鍵盤操作。</p><ul><li><strong>習慣在 normal 模式瀏覽文件的方式</strong>：</li><li><strong>理解以 home row 為核心的鍵位安排</strong>：Vim 的鍵位設計以 home row（<code>f</code> 和 <code>j</code> 那列）為核心，不用為了點選特殊控制鍵而過度伸展手指（例如：<code>Shift</code> + <code>Alt</code> + <code>F</code>），所有操作都不超過字母鍵盤，減少了手部位移的距離。</li><li><strong>學習 vim 實用功能的邏輯與效果</strong>：Vimium 移植了</li><li><strong>了解自訂快捷鍵的意義</strong>：相較於滑鼠，快捷鍵操作有更多空間能夠因應個人的需求調整。</li><li></li><li>能夠更為習慣 normal mode 的瀏覽方式j，</li><li>體會以 home row 為中心的指令鍵位安排</li><li>習慣使用垂直移動游標，例如 <code>j</code> &amp; <code>k</code></li><li>了解 Vim easymotion 跳轉的邏輯與效果</li><li>學會使用 <code>/</code> 搜尋文字</li><li>體驗指令組合的效果</li><li>依據需求自訂快捷鍵</li><li>使用書籤功能</li></ul><h1 id="學會-Vimium-只要三分鐘"><a href="#學會-Vimium-只要三分鐘" class="headerlink" title="學會 Vimium 只要三分鐘"></a>學會 Vimium 只要三分鐘</h1><blockquote><p>Press <code>f</code> to master Vimium (and navigate internet without a mouse.)</p></blockquote><p>Vimium 最大的特色是能透過「標記與跳轉」的模式開啟連結。一旦按下 <code>f</code>，Vimium 便會為視窗內所有可互動的項目（例如連結、欄位與按鈕）標註辨識碼，接著只要輸入辨識碼即可開啟連結。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="鍵入 `f` 後, Vimium 會為視窗內的可互動物件標記辨識碼，鍵入辨識碼即可開啟連結（使用 Vimium 操作 Google search)"></p><ul><li><code>L</code>：開啟「Vimium」</li><li><code>SK</code>：開啟「工具」，透過 Vimium 的連結辨識碼，免除網頁設定欄位快捷鍵的負擔</li><li><code>SA</code>：切換至「搜尋列」，可以編輯搜尋內容</li></ul><p>雖然 Vimium 有一套基於 home row 指令，Chrome 與 Windows 內建快捷鍵已能直觀地管理分頁（例如 <code>Ctrl</code> + <code>T</code>）與滑動視窗（例如方向鍵與空白鍵），要配合瀏覽網頁的需求是綽綽有餘。例如Vimium 配合特殊控制鍵，即可在不同分頁開啟連結。</p><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td>於當前分頁開啟</td><td><code>f</code>, then ID</td></tr><tr><td>於新分頁開啟</td><td><code>f</code>, then <code>Shift</code> + ID</td></tr><tr><td>於新分頁開啟並切換至新分頁</td><td><code>f</code>, then <code>Ctrl</code> + ID</td></tr></tbody></table><h1 id="以-Vim-style-瀏覽網頁"><a href="#以-Vim-style-瀏覽網頁" class="headerlink" title="以 Vim style 瀏覽網頁"></a>以 Vim style 瀏覽網頁</h1><p>鍵鼠操作以 <code>Ctrl</code>、<code>Home</code>、<code>PageUp</code> 等控制鍵，</p><h2 id="移動游標的方式"><a href="#移動游標的方式" class="headerlink" title="移動游標的方式"></a>移動游標的方式</h2><table><thead><tr><th>行為</th><th>Vimium 快捷鍵</th><th>Vim 快捷鍵</th><th>Chrome 快捷鍵</th></tr></thead><tbody><tr><td>移至頂部</td><td><code>gg</code></td><td><code>gg</code></td><td><code>Home</code></td></tr><tr><td>向上移動半個視窗</td><td><code>u</code></td><td><code>Ctrl</code> + <code>u</code></td><td>-</td></tr><tr><td>向上移動一列</td><td><code>k</code></td><td><code>k</code></td><td><code>↑</code></td></tr><tr><td>向下移動一列</td><td><code>j</code></td><td><code>j</code></td><td><code>↓</code></td></tr><tr><td>向下移動半個視窗</td><td><code>d</code></td><td><code>Ctrl</code> + <code>d</code></td><td>-</td></tr><tr><td>移至底部</td><td><code>G</code></td><td><code>G</code></td><td><code>End</code></td></tr></tbody></table><h2 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h2><p>分頁管理是網頁瀏覽的特殊需求，所以 Vimium 就沒有照搬 Vim 的快捷鍵，而是將那些負責編輯或是功能與其他移動指令相近的按紐分配給分頁管理。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_tab-operation.png?raw=true" alt="Vimium 分頁管理與頁面瀏覽的快捷鍵"><br>比對 Vimium 指令與 Chrome 快捷鍵會發現，後者需要用 <code>Ctrl</code> 和 <code>Alt</code> 等特殊控制鍵去定義。此外，觀察鍵盤位置分布可得知，Chrome 快捷鍵位置集中在兩側，似乎也是為了因應特殊控制鍵的分布以及持滑鼠的手的擺放位置。然而，瀏覽網頁時其實沒有文字輸入的需求，所以文字區塊的鍵盤等於閒置了。</p><table><thead><tr><th>行為</th><th>Vimium 指令</th><th>Chrome 快捷鍵</th></tr></thead><tbody><tr><td>開新分頁</td><td><code>t</code></td><td><code>Ctrl</code> + <code>T</code></td></tr><tr><td>關閉分頁</td><td><code>x</code></td><td><code>Ctrl</code> + <code>W</code></td></tr><tr><td>上一頁</td><td><code>H</code></td><td><code>Alt</code> + <code>←</code></td></tr><tr><td>下一頁</td><td><code>L</code></td><td><code>Alt</code> + <code>→</code></td></tr><tr><td>直達分頁</td><td><code>#g0</code></td><td><code>Ctrl</code> + <code>#</code></td></tr><tr><td>上一分頁</td><td><code>J</code></td><td><code>Alt</code> + <code>Shift</code> + <code>Tab</code></td></tr><tr><td>下一分頁</td><td><code>K</code></td><td><code>Alt</code> + <code>Tab</code></td></tr></tbody></table><h2 id="數值參數"><a href="#數值參數" class="headerlink" title="數值參數"></a>數值參數</h2><p>就目前使用下來的想法，為什麼稱呼 Vimium 的行為為「指令」，而chrome的操作為「快捷鍵」，這是因為 Vimium 移植了 Vim 的機制，視每次操作為單元指令，指令可彼此疊加與重複創造出更複雜的行為。Vim 指令的行為分為 motion, replication factor, and operator。前述提及的所有指令都可算是 motion，亦即移動游標數個單位，例如一個視窗、一列、整個頁面等。這些指令都可以再前面冠上 replication factor 來增加執行次數 <replication factor> <motion>。</p><p>而 operator 則是對文字的編輯，這包含了 c (change)、y (yank拖)、d(delete)等，<br>Vimium 保留了 Vim 重複計數 (repeat count or replication factor) 的機制，用戶只要在命令前加上數字，便能指定命令的重複執行次數。</p><ul><li><code>4t</code>：開啟四個分頁</li><li><code>3x</code>：關閉前三個分頁</li><li><code>2d</code>：下移一個視窗(半個視窗 * 2)</li><li><code>3g0</code>：直達第三個分頁</li></ul><h2 id="頁面書籤"><a href="#頁面書籤" class="headerlink" title="頁面書籤"></a>頁面書籤</h2><ol><li><code>mc</code>，建立分頁內標記，<code>c</code> 可替換為其他小寫字母</li><li><code>mC</code>，建立跨分頁標記，<code>C</code> 可替換為其他大寫字母</li><li>&#96;&#96;c&#96;，跳轉至標記的位置</li></ol><h2 id="mode-切換"><a href="#mode-切換" class="headerlink" title="mode 切換"></a>mode 切換</h2><p>其實 Vimium 也有 insert 與 visual 模式，但相當罕用，原因如下：</p><ol><li>網頁瀏覽唯一的編輯機會是調整網址</li><li>若有大量編輯需求，也是在 google doc 或 Rstudio 這種瀏覽器編輯器編輯，裏頭應該有對應的 vim 套件才對</li><li>調整網址或更新關鍵字幾乎沒有重複操作或複雜編輯的需求</li></ol><p>Vimium 的 insert 模式與其說是用於編輯文字，不如說是為了暫時脫離 Vimium 指令模式。Normal 模式的指令與快捷鍵在 Insert 模式無效，在 youtube, gmail 等內建快捷鍵相當完善的網頁時，使用 insert mode 就能用網頁預設的快捷鍵，避免衝突。</p><h1 id="設計自己專屬的快捷鍵組合"><a href="#設計自己專屬的快捷鍵組合" class="headerlink" title="設計自己專屬的快捷鍵組合"></a>設計自己專屬的快捷鍵組合</h1><p>鼓勵用戶，Vimium 支援了自訂以下項目的功能，</p><p>首先鍵入 <code>?</code> 開啟 “Vimium Help”，再點選 “Options” 進入設定面板，即能看到以下設定</p><h2 id="“Excluded-URLs-and-keys”"><a href="#“Excluded-URLs-and-keys”" class="headerlink" title="“Excluded URLs and keys”"></a>“Excluded URLs and keys”</h2><p>這設定能限定特定網域適用的 Vimium 快捷鍵，以避免其覆蓋網頁或瀏覽器預設的快捷鍵。舉例來說，Vimium 的 <code>/</code>（搜尋頁內文字）會覆蓋 Google search 的 <code>/</code>（重返搜尋列）。</p><p>如果我已經很習慣使用 <code>Ctrl</code> + <code>F</code> 來查找頁內文字或是使用 <code>/</code> 來編輯搜索關鍵字，可以透過編輯 “Patterns” 和 “Keys”，讓 Vimium 的 <code>/</code> 設定不套用在 Google search 上。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_excluded-urls.png?raw=true" alt="編輯 &quot;Excluded URLs and keys&quot; 來設定 Vimium 快捷鍵的適用範圍（Keys 預設是禁用全數快捷鍵，而 Patterns 可用正則表達式編寫規則）"></p><h2 id="“Custom-key-mapping”"><a href="#“Custom-key-mapping”" class="headerlink" title="“Custom key mapping”"></a>“Custom key mapping”</h2><p>這設定能調整預設的快捷鍵以符合用戶的使用習慣。好比說，如果不習慣 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 的操作，可以透過以下方式改成動作遊戲常用的 <code>a</code> <code>s</code> <code>w</code> <code>d</code> (<code>map &lt;key&gt; &lt;command&gt;</code>)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改以 wasd 配置移動視窗</span></span><br><span class="line">map a scrollLeft </span><br><span class="line">map s scrollDown</span><br><span class="line">map w scrollUp</span><br><span class="line">map d scrollRight</span><br></pre></td></tr></table></figure><p>進階一點也能為常用網址設置快捷鍵 (<code>map &lt;key&gt; createTab &lt;url&gt;</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 鍵入 @tl 以開啟 Google 翻譯</span></span><br><span class="line">map @tl createTab https://translate.google.com.tw/?hl=zh-TW</span><br></pre></td></tr></table></figure><h2 id="“Previous-patterns-and-Next-patterns”"><a href="#“Previous-patterns-and-Next-patterns”" class="headerlink" title="“Previous patterns and Next patterns”"></a>“Previous patterns and Next patterns”</h2><p>輸入 <code>[[</code>（上一頁）或 <code>]]</code>（下一頁）之後，Vimium 會搜尋並開啟頁面內含「上一頁」或「下一頁」的連結。這功能完全解決了 Google search 無法迅速跳轉到下一頁搜索結果的問題。然而 Vimium 預設是辨識英文和箭頭符號，所以要應用於中文網站時得自行添加搜索標的。</p><ol><li>點選 “Show Advanced Options”</li><li>編輯 “Previous patterns” 與 “Next patterns” </li><li>依照自己常用的網頁添加搜索標的（例如：Google search，上一頁&#x2F;下一頁；ptt.cc，&lt;&#x2F;&gt;；巴哈姆特，◄&#x2F;►）</li></ol><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_page-navigation.png?raw=true" alt="可以檢查常用網站的上一頁/下一頁來調整快捷鍵偵測的字串"></p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>《原子習慣》，這些訣竅也適用於學習新事物。</p><ol><li>善用 <code>f</code> 點擊連結</li><li>維持原本的瀏覽網頁</li><li>透過 <code>?</code> 查詢指令</li><li>學習使用 vim-like 指令瀏覽與管理分頁</li><li>配合習慣，自訂適合自己的快捷鍵組合</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCodeVim 常用設定</title>
      <link href="/vscode-common-settings-for-vscodevim/"/>
      <url>/vscode-common-settings-for-vscodevim/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文紀錄一些有助於在 Vscode 使用 vim 的套件與快捷鍵設定。</p><span id="more"></span><h1 id="除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？"><a href="#除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？" class="headerlink" title="除了 Esc，還有哪些鍵適合作為模式切換快捷鍵？"></a>除了 <code>Esc</code>，還有哪些鍵適合作為模式切換快捷鍵？</h1><p>Vim 被開發出來的時候，<code>Esc</code> 位於現今當代鍵盤 <code>Tab</code> 和 <code>Caps</code> 的位置。如今，<code>Esc</code> 被移到鍵盤左上角，已不若以往方便了。既然 VSCodeVim 支援重新設定快捷鍵，那麼有哪些鍵適合作為模式切換快捷鍵？</p><ol><li><code>jj</code>：位置很棒，只是打字打到 j 時，會有輕微的停頓感。缺點是編輯中文時，要頻繁切換輸入法。</li><li><code>jk</code>：一次按兩顆鍵，但因為可以一起按，沒有連續按鈕的卡頓感，只是同樣要解決換模式前得切換輸入法的問題。</li><li><code>Enter</code>*2：剛開始使用 vim 很容易忘記切回 normal 模式，既然中文輸入會頻繁輸入 enter讓文字寫入文件，enter 設定為切換模式的快捷鍵既不會干擾文字輸入也好記。只是碰到換行時會延遲等候第二次按鍵的訊號，有時還挺煩人的。</li><li><code>Shift</code> + <code>Enter</code>：雖然要兩個按鈕，但位置其實不錯按，而且不會輸入新列的卡頓感。唯一的缺點是設置稍嫌麻煩。</li></ol><h2 id="前述三種方法要修改-setting-json"><a href="#前述三種方法要修改-setting-json" class="headerlink" title="前述三種方法要修改 setting.json"></a>前述三種方法要修改 setting.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;CR&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CR&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;Esc&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Shift-Enter-的方法要改-keybindings-json"><a href="#Shift-Enter-的方法要改-keybindings-json" class="headerlink" title="Shift + Enter 的方法要改 keybindings.json"></a><code>Shift</code> + <code>Enter</code> 的方法要改 keybindings.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//https://github.com/VSCodeVim/Vim/issues/2584#issuecomment-385561286</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shift+Enter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.vim_escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="使用相對列名"><a href="#使用相對列名" class="headerlink" title="使用相對列名"></a>使用相對列名</h1><p>由於 vim 可以為指令添加數字以重複執行，所以為了計算方便，需要設置相對行號，設定方式為：</p><ol><li><code>Ctrl</code> + <code>,</code>，啟動 UI 設定</li><li>搜尋 “Line numbers” </li><li>由 “on” 改為 “relative”，預設為絕對行號</li></ol><p>然而，內建方式只能顯示絕對行號或相對行號，若要一併顯示，則要安裝 <em>Double Line Numbers</em> 套件。</p><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>X</code>，開啟擴充套件。</li><li>搜尋並安裝 <em>Double Line Numbers</em> </li><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，輸入 <code>Double Line Numbers: Relative + Absolute</code></li></ol><h1 id="怎樣設定快捷鍵"><a href="#怎樣設定快捷鍵" class="headerlink" title="怎樣設定快捷鍵"></a>怎樣設定快捷鍵</h1><p>vscode 和 vim 有些彼此衝突的快捷鍵，例如常用的 <code>Ctrl</code> + <code>F</code> 或 <code>Ctrl</code> +<code>W</code> 等。依照個人習慣，可以選擇 vim 模式要啟用那些快捷鍵</p><ol><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li><li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li><li>新增以下設置來關掉 vim的快捷鍵 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">&quot;vim.handleKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-d&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-s&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-w&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-t&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-z&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>這些是我常用的指令。</li></ol><h1 id="怎樣才不會忘記在切換模式後切為英文輸入法"><a href="#怎樣才不會忘記在切換模式後切為英文輸入法" class="headerlink" title="怎樣才不會忘記在切換模式後切為英文輸入法"></a>怎樣才不會忘記在切換模式後切為英文輸入法</h1><p>由於 Normal mode 僅能以英文輸入法下指令，假如在 Insert mode 以中文輸入法編輯文件，使用預設的 <code>Esc</code> 切換模式後，仍維持中文輸入法，還要將輸入法切回英文，才能下達指令。為了解決這問題有兩個策略：</p><h2 id="改變模式切換快捷鍵"><a href="#改變模式切換快捷鍵" class="headerlink" title="改變模式切換快捷鍵"></a>改變模式切換快捷鍵</h2><p>第一種策略是把切換模式的快捷鍵設定為 <code>jj</code>，雖然不見得比較快，但一定能避免中文輸入法讓指令無法執行的問題。由於改用英文字母作為切換快捷鍵，所以在切換模式前一定要更換輸入法，所以能確保切換後一定是英文輸入法</p><ol><li><code>Shift</code>, then <code>jj</code>，切為 Normal mode</li><li><code>i</code>，切為 Insert mode</li><li><code>Shift</code>，切為中文輸入法</li></ol><h2 id="自動切換輸入法"><a href="#自動切換輸入法" class="headerlink" title="自動切換輸入法"></a>自動切換輸入法</h2><p>另一種是呼叫自動切換輸入法的腳本，在切回 normal mode 時自動幫我們切換文字</p><ol><li>下載 (im.select.exe)[<a href="https://github.com/daipeihust/im-select]">https://github.com/daipeihust/im-select]</a> 放到任何你喜歡的路徑</li><li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li><li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li><li>新增以下設置以啟用輸入法自動切換 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe -s &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>透過這樣設置，在切回 normal mode 瞬間，就會變成英文輸入法。而進入 insert mode 時，就會回到當初離開時的輸入法。</p><h1 id="關閉括號自動補全"><a href="#關閉括號自動補全" class="headerlink" title="關閉括號自動補全"></a>關閉括號自動補全</h1><p>VSCode 內建括號與引號自動補全，然而有時這還挺雞肋的，因為在括號內打完字還要使用方向鍵移到括號外才能繼續打字，若使用 Vim 還得切模式再移動，不管哪種方式都沒省太多功夫。因此，對於一般文本編輯或編輯程式碼的需求而言，似乎可以在 setting.json 添加以下設置來關閉自動補全。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// automatical closing</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingQuotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingBrackets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h1 id="調整視窗大小的快捷鍵"><a href="#調整視窗大小的快捷鍵" class="headerlink" title="調整視窗大小的快捷鍵"></a>調整視窗大小的快捷鍵</h1><p>設定快捷鍵，就不用為了調整欄位大小，辛苦地讓游標對齊邊框了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="更新檔案瀏覽側欄"><a href="#更新檔案瀏覽側欄" class="headerlink" title="更新檔案瀏覽側欄"></a>更新檔案瀏覽側欄</h1><p>使用終端或指令新增或刪除檔案不會同步更新在檔案探索側欄，因為重新整理的按鈕太小了，所以我也設定快捷鍵輔助。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f5&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;when&quot;</span><span class="punctuation">:</span><span class="string">&quot;filesExplorerFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="超棒的學習資源和網站"><a href="#超棒的學習資源和網站" class="headerlink" title="超棒的學習資源和網站"></a>超棒的學習資源和網站</h1><ul><li><a href="https://ithelp.ithome.com.tw/articles/10291847">VsCodeVim 自動在normal mode切回英文輸入法的方法</a></li><li><a href="https://www.blog.lasai.com.tw/2020/07/05/vscode-vim-mode/">vscode vim mode</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜輸入 empty channel 會發生什麼事？</title>
      <link href="/nextflow-input-with-an-empty-channel/"/>
      <url>/nextflow-input-with-an-empty-channel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上週碰到一個離奇的 bug，有支 nextflow 腳本可以順利執行，但會無聲無息地略過其中一個 process。該腳本執行後於終端吐出的訊息類似以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run workflow.nf</span><br><span class="line">[3c/9ab742] process &gt; a1 [100%] 1 of 1 ✔</span><br><span class="line">[8e/4eg429] process &gt; a2 [100%] 1 of 1 ✔</span><br><span class="line">[-        ] process &gt; b1</span><br><span class="line">[2f/0c0b71] process &gt; c1 [100%] 1 of 1 ✔</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li><code>a1</code> 與 <code>a2</code> 輸出的 channel 經 <code>join</code> 之後輸入 <code>b1</code>，而 <code>c1</code> 則獨立於其他三個 process。</li><li>nextflow 沒有任何錯誤訊息（即終端看不到紅色的字）</li><li>nextflow 沒有為 <code>b1</code> 開啟工作目錄，所以也無從查看 <code>.command.log/err/out</code> 等與腳本執行相關的資訊</li><li>查看 <code>.nextflow.log</code> 只能找到啟動 <code>b1</code> 的訊息：<code>[main] DEBUG nextflow.processor.TaskProcessor - Starting process &gt; b1</code>，但沒有其他執行細節。</li></ul><h1 id="解決策略"><a href="#解決策略" class="headerlink" title="解決策略"></a>解決策略</h1><p>由於 nextflow 幾乎沒有給出任何提示，所以只能自己想辦法在腳本內安排中斷點印出 channel 的內容。當時的策略是先不用 <code>join</code>，而是單獨輸入 <code>a1</code> 與 <code>a2</code> 的輸出，以便用 <code>stdout</code> 和 <code>view()</code>檢查各個 channel 是否與我們預期相同。</p><p>結果問題還真的出在 channel 的合併，原來 <code>a1</code> 與 <code>a2</code> 的輸出結果沒有共同的 key，所以執行 <code>join</code> 操作後會生成一個 empty channel。</p><h1 id="Empty-channel"><a href="#Empty-channel" class="headerlink" title="Empty channel"></a>Empty channel</h1><p>在 Nextflow 裏頭，可使用 <code>channel.empty()</code>建立 empty channel，其作用相當於對 process 傳遞終止訊號（參考 <a href="https://javadoc.io/static/io.nextflow/nextflow/0.28.2/nextflow/Channel.html">Nextflow Channel Class 的說明</a>）。</p><p>舉例來說，以下這支 nextflow 腳本會依序印出同一時間輸入的數對。雖然 <code>a_ch</code> 含有四項數字，但因為 <code>b_ch</code> 其中一項為 empty channel 的終止訊號，所以這個 process 只遞交並執行了三次<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="執行腳本時，nextflow 會先以 `nextflow.processor.TaskProcessor` 啟動 process，透過 `nextflow.executor.LocalHandler` 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 `.nextflow.log`。">1</span></a></sup>。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demoEmptyChannel.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($&#123;a&#125;, $&#123;b&#125;)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>, <span class="string">&quot;a4&quot;</span>)</span><br><span class="line">    b_ch = channel.of(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>).concat(channel.empty()).concat(channel.of(<span class="string">&quot;b4&quot;</span>)) <span class="comment">// append items with concat() and channel.of()</span></span><br><span class="line">    p(a_ch, b_ch).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run demoEmptyChannel.nf</span><br><span class="line">[a8/4b2c55] process &gt; p (3) [100%] 3 of 3 ✔</span><br><span class="line">(a3, b4)</span><br><span class="line">(a2, b2)</span><br><span class="line">(a1, b1)</span><br></pre></td></tr></table></figure><h1 id="使用-ifEmpty-為輸入-channel-設定預設值"><a href="#使用-ifEmpty-為輸入-channel-設定預設值" class="headerlink" title="使用 ifEmpty 為輸入 channel 設定預設值"></a>使用 <code>ifEmpty</code> 為輸入 channel 設定預設值</h1><p>為了避免 process 被跳過或是沒有執行的狀況，<a href="https://www.nextflow.io/docs/latest/operator.html#operator-ifempty">nextflow 官方文件</a>建議以 <code>ifEmpty</code> 為 channel 設定預設值。如以下案例，由於 <code>b_ch</code> 為 empty channel，經 <code>ifEmpty</code> operator 賦予預設值，使得 process 能順利運行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demoIfEmpty.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($a, $b)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>&#125;</span><br><span class="line">workflow &#123;   </span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>)</span><br><span class="line">    <span class="comment">// &lt;defalut value&gt; if ch.isempty() else ch</span></span><br><span class="line">    b_ch = channel.empty()</span><br><span class="line">    p(a_ch, b_ch.ifEmpty(<span class="string">&quot;b_default&quot;</span>)).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run demoIfEmpty.nf</span><br><span class="line">[47/459729] process &gt; p (1) [100%] 1 of 1 ✔</span><br><span class="line">(a1, b_default)</span><br></pre></td></tr></table></figure><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 的 process 會跳過含有 empty channel 的任務，若想避免這種狀況在非預期的情形發生（例如 <code>join</code> 失敗），可使用 <code>ifEmpty</code> 為 process 的輸入 channel 設定預設值。</p><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://stackoverflow.com/questions/70888844/nextflow-how-to-fail-if-channel-is-empty-ifempty">NextFlow: How to fail if channel is empty ( .ifEmpty() )</a></li><li><a href="https://stackoverflow.com/questions/64042860/check-if-nextflow-channel-is-empty">check if nextflow channel is empty</a>)</li><li><a href="https://github.com/nextflow-io/nf-hack18/blob/master/asciidocs/07_processes.adoc">Nextflow Workshop Hackaton 2018: 07_processes</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">執行腳本時，nextflow 會先以 <code>nextflow.processor.TaskProcessor</code> 啟動 process，透過 <code>nextflow.executor.LocalHandler</code> 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 <code>.nextflow.log</code>。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網際牛仔與無障礙空間（上）：如何以鍵盤瀏覽網頁？</title>
      <link href="/navigate-websites-with-keyboard/"/>
      <url>/navigate-websites-with-keyboard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為什麼想以鍵盤瀏覽網頁？滑鼠是為簡化繁瑣的鍵入指令而生，也與圖形介面的發展相輔相成。因此，當代網頁本來就適合以滑鼠瀏覽，純靠瀏覽器有限的快捷鍵反倒綁手綁腳。</p><p>然而，有時擁有自己的風格比起事情做的有效率還重要。本文就是我對於「用鍵盤瀏覽網頁」這項風格的探索與總結。</p><blockquote><p>Style over Substance. It doesn’t matter how well you do something, as long as you look good doing it. （格調重於成效，只要你作風有形，事情幹得怎麼樣並不要緊。） </p><p style="text-align:right" > The core rulebook for Cyberpunk 2020 </p></blockquote><span id="more"></span><h1 id="「覺得酷」的學習成本有多高？"><a href="#「覺得酷」的學習成本有多高？" class="headerlink" title="「覺得酷」的學習成本有多高？"></a>「覺得酷」的學習成本有多高？</h1><p>就我的使用經驗，是否要用鍵盤瀏覽網頁是風格問題而不是效率問題。因為瀏覽網頁不像編輯文件一樣要頻繁移動游標，點擊和拖曳等行為的頻率也較低，所以沒那麼講究要降低手部位移的幅度。畢竟，有時網頁看一半，漱杯飲料或嗑片餅乾的移動幅度，都比單手改持滑鼠的移動幅度還要大。</p><p>儘管如此，我認為除了營造風格以外，善用快捷鍵能減少滑鼠在精密操作時的磨耗感，例如開啟狹窄的右鍵選單、滾動長頁面或點擊尺寸很小的按鈕，這些瑣碎操作不見得會影響瀏覽網頁的效率，但會大幅降低查找資料的心情（對，就是 kimochi 問題）。</p><p>更重要的是，體驗鍵盤瀏覽網頁的成本極低，只要學會以下三組快捷鍵，就能流暢地逛平常習慣的網頁了。本文也將以這三組快捷鍵為主軸，簡介如何利用 Windows 系統、Chrome 瀏覽器與 Vimium 套件的快捷鍵，以鍵盤瀏覽網頁。</p><ol><li>設定開啟瀏覽器的快捷鍵</li><li>學會開分頁(<code>Ctrl</code> + <code>T</code>)、關分頁 (<code>Ctrl</code> + <code>W</code>)、切換分頁 (<code>Ctrl</code> + <code>Tab</code>)</li><li>安裝 Vimium 或其他 Vim-like 瀏覽器套件</li><li>學會用 Vim-like 套件的功能點擊連結 (<code>f</code> + <code>&lt;index&gt;</code>)</li></ol><p>既然要用鍵盤瀏覽網頁，那首要的目標自然是透過鍵盤開啟瀏覽器。然而，Chrome 與 Windows 雖然有不少快捷鍵，卻似乎沒有能開啟瀏覽器的快捷鍵。幸好，Windows 支援用戶為檔案或程式建立捷徑 (Shortcut) 和設定快捷鍵 (Shortcut key)，所以能在需要時快速開啟檔案或程式，不必再移動到它們（或其捷徑）的所在目錄。</p><p>瀏覽器的捷徑可從執行檔自行建立（<strong>chrome.exe - Shortcut</strong>），或是使用安裝時自動建立的捷徑（ <strong>Google Chrome</strong>）。建立瀏覽器的捷徑之後，便能為其設定快捷鍵。</p><ol><li>右鍵點擊「捷徑」</li><li>點選「內容 (Properties)」</li><li>點選「快捷鍵」</li><li>按下自訂快捷鍵，例如 <code>Ctrl</code> + <code>Alt</code> + <code>C</code></li><li>點選「確定」套用設定</li></ol><h1 id="暢遊-Google-search"><a href="#暢遊-Google-search" class="headerlink" title="暢遊 Google search"></a>暢遊 Google search</h1><p>Chrome 完整的快捷鍵列表可參考<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hant&co=GENIE.Platform=Desktop">google 說明</a>。以下我嘗試從用戶角度，說明有哪些常用快捷鍵值得留意，而這些快捷鍵又有哪些使用的情境。</p><h2 id="如何透過搜尋引擎查找關鍵字？"><a href="#如何透過搜尋引擎查找關鍵字？" class="headerlink" title="如何透過搜尋引擎查找關鍵字？"></a>如何透過搜尋引擎查找關鍵字？</h2><p>假設今天想查詢某項資訊，可考慮以下三種方式來輸入關鍵字，再點擊 <code>Enter</code> 執行搜索：</p><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td><strong>開啟新分頁並移至新分頁的網址列</strong></td><td><code>Ctrl</code> + <code>T</code></td></tr><tr><td>移至網址列</td><td><code>Alt</code> + <code>D</code> or <code>Ctrl</code> + <code>L</code> or <code>F6</code></td></tr><tr><td>於網址列搜尋 Google</td><td><code>Ctrl</code> + <code>E</code> or <code>Ctrl</code> + <code>K</code></td></tr></tbody></table><p>由於以上方法皆透過網址列搜尋關鍵字，一旦網頁跳轉到搜索結果，該列便會轉變為網址。此時若想修正錯字或更改關鍵字，可以使用 <code>/</code> 切換到 Google search box，在該位置編輯關鍵字，就不用重新輸入一遍或編輯藏在長串網址當中的關鍵字。</p><p>跳轉到搜索結果後，便能使用以下快捷鍵滑動或跳動網頁，尋找自己需要的資訊。</p><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td>連續滑動網頁</td><td><code>↑</code> and <code>↓</code></td></tr><tr><td>向下跳數列</td><td><code>Space</code> or <code>PageDown</code></td></tr><tr><td>向上跳數列</td><td><code>Shift</code> + <code>Space</code> or <code>PageUp</code></td></tr><tr><td>移動至網頁最上端</td><td><code>Home</code></td></tr><tr><td>移動至網頁最底端</td><td><code>End</code></td></tr></tbody></table><h2 id="如何開啟特定連結？"><a href="#如何開啟特定連結？" class="headerlink" title="如何開啟特定連結？"></a>如何開啟特定連結？</h2><p>假如你已找到感興趣的結果，接下來得移動游標到連結位置才能開啟。Chrome 預設以 <code>Tab</code> 和　<code>Shift + Tab</code> 在連結間切換。</p><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td>移動至下一個連結</td><td><code>Tab</code></td></tr><tr><td>移動至上一個連結</td><td><code>Shift</code> + <code>Tab</code></td></tr></tbody></table><p>另一種方式是啟用無障礙設定裡的「使用文字游標瀏覽頁面」。在這模式裡，用戶能以 <code>←</code>、<code>↑</code>、<code>↓</code>、<code>→</code> 操作文字游標，讓網頁能像文檔一樣瀏覽。</p><ol><li><code>Alt</code> + <code>E</code> ，開啟瀏覽器設定選單</li><li><code>S</code>，選取「設定」</li><li><code>/</code>，進入搜索框</li><li>查詢「無障礙設定」</li><li>使用 <code>Tab</code> 移動到游標瀏覽功能開關</li><li><code>Enter</code>，開啟或關閉功能</li></ol><p><em>(或是以 <code>F7</code>快速切換文字游標瀏覽模式。記得關掉提醒通知，往後啟用模式才不用一再確認。）</em></p><p>當游標移動到連結位置，即可使用以下快捷鍵，決定要於哪個分頁開啟連結。</p><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td>於當前分頁開啟連結</td><td><code>Enter</code></td></tr><tr><td><strong>於新分頁開啟連結</strong></td><td><code>Ctrl</code> + <code>Enter</code></td></tr><tr><td>於新分頁開啟連結並移至新分頁</td><td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td></tr><tr><td>於新視窗開啟連結並移至新視窗</td><td><code>Shift</code> + <code>Enter</code></td></tr></tbody></table><h2 id="如果我還沒找到滿意的結果，要怎麼前往下一頁？"><a href="#如果我還沒找到滿意的結果，要怎麼前往下一頁？" class="headerlink" title="如果我還沒找到滿意的結果，要怎麼前往下一頁？"></a>如果我還沒找到滿意的結果，要怎麼前往下一頁？</h2><p>很遺憾的，目前 Chrome 或 Google Search <strong>沒有直達下一頁的快捷鍵</strong>，只能持續押著 <code>Tab</code> 直到頁面底部。那使用 <code>Shift</code> + <code>Tab</code> 從頁面底部開始找起呢？可行，但不見得比較快，因為頁面底部除了「下一頁」與「上一頁」按鈕外，還有隱私權、服務條款、活動紀錄與地理位置等連結要通過。</p><p>開啟連結是使用鍵盤瀏覽網頁的最大障礙，因為用戶必須先滑動視窗找到對應的連結，再移動游標通過一樣內容到該連結的位置。換句話說，用戶至少要跑兩次迴圈才能找到並打開連結。</p><p>既然如此，那為什麼不一開始就使用 <code>Tab</code> 來逛網頁呢？其實可以，但非常惱人。</p><p>首先，游標移動不若視窗滑動迅速。其次，連結在網頁上的順序未必與游標移動的順序一致，使得用戶無法預期瀏覽的方向。以 Google search 為例，一則搜尋條目在視覺上的結構為頁庫存檔選項、翻譯選項與連結文字。然而，游標移動的順序卻是連結文字、頁庫存檔選項、翻譯選項，導致需要連續按三次 <code>Tab</code> 才能移動到下一個連結。</p><blockquote><p><a href="https://5uperb0y.com/">https://5uperb0y.com</a> ▼ 翻譯這個網頁<br>5uperb0y’s blog</p></blockquote><p>第三，不是每個網頁都會醒目標示游標的位置，以至於用戶不僅無法確認游標移動的順序，還可能找不到游標的位置。就拿我這個網站為例，可以試試使用 <code>Tab</code> 來找到任一文章的連結，我相信按了十幾下可能都還沒辦法確認游標位置，所以也很難開啟特定連結。</p><p>在本文其他節，我會介紹能迴避這些問題的取巧手段和擴充套件。但在此處，我們先假設所有搜索都能在第一頁找到答案，並繼續了解如何透過快捷鍵管理分頁與視窗。</p><h2 id="如何管理瀏覽器分頁？"><a href="#如何管理瀏覽器分頁？" class="headerlink" title="如何管理瀏覽器分頁？"></a>如何管理瀏覽器分頁？</h2><p>如今我們已經會使用快捷鍵搜尋和瀏覽網頁，然而隨著點擊而累積的分頁又該如何管理呢？雖然列出了許多選項，但我常用的僅有粗體標示者。</p><h3 id="開啟與關閉分頁"><a href="#開啟與關閉分頁" class="headerlink" title="開啟與關閉分頁"></a>開啟與關閉分頁</h3><table><thead><tr><th>行為</th><th>shortcut</th></tr></thead><tbody><tr><td>開啟新分頁並移至新分頁</td><td><code>Ctrl</code> + <code>T</code></td></tr><tr><td><strong>關閉當前分頁</strong></td><td><code>Ctrl</code> + <code>W</code> or <code>Ctrl</code> + <code>F4</code></td></tr><tr><td>依關閉順序，重新開啟已關閉之分頁</td><td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td></tr></tbody></table><h3 id="切換與移動分頁"><a href="#切換與移動分頁" class="headerlink" title="切換與移動分頁"></a>切換與移動分頁</h3><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td>移至指定分頁</td><td><code>Ctrl</code> + <code>[1-8]</code></td></tr><tr><td>移至最後分頁</td><td><code>Ctrl</code> + <code>9</code></td></tr><tr><td><strong>移至下一分頁</strong></td><td><code>Ctrl</code> + <code>PageDown</code> or <code>Ctrl</code> + <code>Tab</code></td></tr><tr><td>移至上一分頁</td><td><code>Ctrl</code> + <code>PageUp</code> or <code>Ctrl</code> + <code>Shift</code> + <code>Tab</code></td></tr><tr><td>後挪分頁順序</td><td><code>Ctrl</code> + <code>Shift</code> + <code>PageDown</code></td></tr><tr><td>前挪分頁順序</td><td><code>Ctrl</code> + <code>Shift</code> + <code>PageUp</code></td></tr><tr><td>挪動分頁為獨立視窗</td><td><code>Shift</code> + <code>W</code></td></tr></tbody></table><h3 id="搜索或開啟曾瀏覽的網頁"><a href="#搜索或開啟曾瀏覽的網頁" class="headerlink" title="搜索或開啟曾瀏覽的網頁"></a>搜索或開啟曾瀏覽的網頁</h3><table><thead><tr><th>行為</th><th>快捷鍵</th></tr></thead><tbody><tr><td><strong>上一頁</strong></td><td><code>Alt</code> + <code>←</code></td></tr><tr><td>下一頁</td><td><code>Alt</code> + <code>→</code></td></tr><tr><td>開啟搜尋歷史</td><td><code>Ctrl</code> + <code>H</code></td></tr></tbody></table><h2 id="如何管理瀏覽器視窗？"><a href="#如何管理瀏覽器視窗？" class="headerlink" title="如何管理瀏覽器視窗？"></a>如何管理瀏覽器視窗？</h2><p>除了分頁，Chrome 亦支援以快捷鍵開啟視窗或調整視窗大小。不過這些快捷鍵我也不常用到，頂多會用無痕視窗查詢特殊關鍵字或測試 SEO 和網頁有沒有問題。值得留意的是，<code>ALT</code> + <code>Space</code> 是開啟視窗右鍵選單的快捷鍵，所以縮小或放大都有提示，不須記憶。</p><table><thead><tr><th>行為</th><th>快捷鍵</th><th>用途</th></tr></thead><tbody><tr><td>開新視窗</td><td><code>Ctrl</code> + <code>N</code></td><td>寫作時參照文件</td></tr><tr><td>開新無痕視窗</td><td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td><td>查詢關鍵字、測試網頁</td></tr><tr><td>將當前視窗縮至最小</td><td><code>ALT</code> + <code>Space</code>, then <code>N</code></td><td>操作桌面的檔案或軟體</td></tr><tr><td>將當前視窗開至最大</td><td><code>ALT</code> + <code>Space</code>, then <code>X</code></td><td>很少用</td></tr></tbody></table><p>相較於 Chrome，Windows 提供了更多調整視窗尺寸的途徑。因此有助於在寫程式或編輯文件時，雙開文件並分配視窗在螢幕上的位置，以便邊參閱資料邊修改文件。下圖是視窗間的關係，點擊 <code>Win</code> 與下圖的方向鍵，即可在不同形式的視窗間切換。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           上半視窗（點選 ↓ 會回到原始視窗）</span><br><span class="line">              ↑</span><br><span class="line">左半視窗 ←  最大視窗 → 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">左半視窗 ⇆ 原始視窗 ⇆ 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">           最小視窗          </span><br></pre></td></tr></table></figure><p>至於要在視窗間切換或取回縮小的視窗，可以使用 <code>Alt</code> + <code>Tab</code> 進入選單，再配合方向鍵選取。</p><h1 id="快捷鍵組合技"><a href="#快捷鍵組合技" class="headerlink" title="快捷鍵組合技"></a>快捷鍵組合技</h1><p>前一節介紹了 Chrome 內建的快捷鍵，但諸如好手氣、右鍵搜索、於無痕視窗開啟等功能都沒有對應的快捷鍵。因此，這一節要介紹如何組合基本的快捷鍵，實踐這些方便功能。</p><h2 id="「透過-Google-搜尋」"><a href="#「透過-Google-搜尋」" class="headerlink" title="「透過 Google 搜尋」"></a>「透過 Google 搜尋」</h2><p><strong>方法一：透過「開新分頁」</strong></p><ol><li>標示 (highlight) 欲搜索的字串</li><li><code>Ctrl</code> + <code>C</code>，複製字串</li><li><code>Ctrl</code> + <code>T</code>，開啟並移動游標至新分頁的網址列</li><li><code>Ctrl</code> + <code>V</code>，貼上字串至網址列</li><li><code>Enter</code>，執行搜尋</li></ol><p>若要在同一分頁搜尋，可以使用 <code>Ctrl</code> + <code>E</code>&#x2F;<code>K</code>&#x2F;<code>L</code> 取代 <code>Ctrl</code> + <code>T</code>。</p><p><strong>方法二：透過「右鍵選單」</strong><br>若使用 windows 電腦，可使用選單鍵開啟右鍵選單，執行相關功能。</p><ol><li>標示欲搜索的字串</li><li><code>☰</code>，透過選單鍵(menu key)開啟選單</li><li><code>S</code>，執行「透過 Google 搜尋」</li></ol><h2 id="「好手氣」"><a href="#「好手氣」" class="headerlink" title="「好手氣」"></a>「好手氣」</h2><p>Google search 首頁有個好手氣的按鈕，能直接進入第一個搜尋的網頁。我們可以使用 Google search 的無障礙連結來達到類似目的。</p><ol><li>輸入搜尋內容</li><li><code>Tab</code>，開啟無障礙輔助提示，此時應該會停在「跳至主內容」</li><li><code>Enter</code>，確認跳至「主內容」，通常會直接將游標移動到第一個連結</li><li><code>Enter</code>，進入第一個連結</li></ol><p>由於 Google 有時會在第一則搜尋條目前安插精選摘要、廣告或是錯字提醒的窗格，所以這招並非總是見效。儘管如此，仍比遍歷 Google search 的功能窗格更為便捷。</p><h2 id="「在無痕視窗中開啟連結」"><a href="#「在無痕視窗中開啟連結」" class="headerlink" title="「在無痕視窗中開啟連結」"></a>「在無痕視窗中開啟連結」</h2><p>Chrome 介紹了各種開啟連結的方式，唯獨不支援在無痕視窗開啟連結的方式，所以此處同樣要利用選單鍵的來開啟右鍵選單。</p><ol><li>移動游標至連結</li><li><code>☰</code>，透過選單鍵開啟選單</li><li><code>G</code>，執行「在無痕視窗中開啟連結」</li></ol><h2 id="「另存為圖片」"><a href="#「另存為圖片」" class="headerlink" title="「另存為圖片」"></a>「另存為圖片」</h2><p><strong>方法一：透過「另存網頁」</strong></p><ol><li>移動游標至圖片</li><li><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code>，開啟圖片於新分頁並切換至新分頁</li><li><code>Ctrl</code> + <code>S</code>，另存新檔</li><li>選取存儲目錄並存放圖片</li></ol><p><strong>方法二：透過「右鍵選單」</strong></p><ol><li>移動游標至圖片</li><li><code>☰</code>，透過選單鍵開啟選單</li><li><code>V</code>，執行「另存為圖片」</li><li>選取存儲目錄並存放圖片</li></ol><h2 id="拖曳當前分頁為獨立視窗"><a href="#拖曳當前分頁為獨立視窗" class="headerlink" title="拖曳當前分頁為獨立視窗"></a>拖曳當前分頁為獨立視窗</h2><p>Chrome 沒有相關的快捷鍵，不過我們可以透過「於新視窗開啟分頁」的快捷鍵來模擬。然而與滑鼠拖曳最大的差別在於，重啟後不會保留已填入的資料，也不會刪除舊的分頁。</p><ol><li><code>Ctrl</code> + <code>L</code> (or <code>Alt</code> + <code>D</code>)，移至網址列</li><li><code>Shift</code> + <code>Enter</code>，於新視窗開啟連結</li></ol><h1 id="以取巧的方式迴避點擊連結的障礙？"><a href="#以取巧的方式迴避點擊連結的障礙？" class="headerlink" title="以取巧的方式迴避點擊連結的障礙？"></a>以取巧的方式迴避點擊連結的障礙？</h1><p>本文前半部曾提到，點擊連結是用鍵盤瀏覽網頁最大的困難。在這一節，我嘗試用瀏覽器搜尋功能（<code>Ctrl</code>+<code>F</code>）可以迅速跳轉位置的特性，解決游標移動效率不彰的問題。</p><h2 id="如何直達特定連結？"><a href="#如何直達特定連結？" class="headerlink" title="如何直達特定連結？"></a>如何直達特定連結？</h2><p>直達特定連結有以下五個步驟：</p><ol><li>辨識：目視想要開啟的連結</li><li>編碼：觀察連結文字或網址，從中挑選獨一無二的子字串作為頁內搜尋的關鍵字。</li><li>搜尋：<code>Ctrl</code>+<code>F</code>，搜尋關鍵字以找到連結位置</li><li>跳轉：若選對關鍵字，游標會直接移動到連結。若否，則使用 <code>Enter</code> 和 <code>Shift</code> + <code>Enter</code>前後查詢連結</li><li>開啟：<code>Enter</code>，開啟連結（若想要在新分頁開啟連結，可以先　<code>Esc</code> 退出，再執行開分頁搜索的行為）</li></ol><p>為連結編碼（或說選用關鍵字）時，可挑選網域的子字串。由於網域通常會採用較獨特的名稱，所以較不容易與其它連結衝突，能避免查詢時無法一步到位。此外，Google search 會將來自相同網站的相似內容以巢狀結構編排，不會讓單一網站的內容佔滿搜尋結果。這項特性讓頁內搜索時不會一次出現很多結果，同樣提升了搜尋的精準度。</p><h2 id="如何前往下一頁？"><a href="#如何前往下一頁？" class="headerlink" title="如何前往下一頁？"></a>如何前往下一頁？</h2><p>頁內搜索的訣竅同樣能運用於前往下一頁。Google search 最下方的結果分頁有兩個潛在標的，第一個是「下一頁」本身，這個詞彙相當獨特，所以搜尋時不容易被結果條目干擾。然而它的長度較長（若以注音輸入法要按九個按鈕），所以可能要先複製字串或是用<a href="https://key.chtouch.com/cv.aspx?p=3120">window使用者造詞</a>將這些代表「下一頁」的關鍵字存為快捷鍵，減少輸入時間。（使用者造詞可以降低到只要按四個按鈕）</p><ol><li><code>Ctrl</code> + <code>F</code>，搜尋 <code>下一頁</code></li><li><code>Ctrl</code> + <code>Enter</code></li></ol><p>第二個搜索標的則是表示頁數的數字，原則上這些數字會是整個頁面最後一個數字，所以我們可以從頁面底部反向搜索這些數字來直達連結。只是 Chrome 的最後一列可能顯示用戶地址資訊，其中郵遞區號會影響查詢。目前，我還沒找到關閉這些訊息顯示的方法。</p><ol><li><code>Ctrl</code>+ <code>F</code>，搜尋任意數字</li><li><code>Shift</code> + <code>Enter</code>，往回找到最後一個搜尋結果，最差要往回查兩次才能越過郵遞區號到達頁面數字</li><li><code>Ctrl</code> + <code>Enter</code>，開啟下一頁</li></ol><p>由於不是每個網頁都有前往下一頁的對應按鈕，所以 Chrome 沒有下一頁的關鍵字也蠻合理的。不過我猜這項特性也跟搜尋引擎的理念有關。假設在關鍵字正確的情況下，Google Search 總是能推薦最佳的內容。那麼，只要用戶下對關鍵字，就能從第一個連結取得想要的結果。</p><p>若第一頁沒出現想要的結果，表示下錯關鍵字或議題太冷門，再怎麼瀏覽都很難找到想要的資訊。因此，基於對搜尋演算法的信任，下一頁的需求其實不高，這項缺陷算是變相鼓勵用戶改善搜索的效率而非瀏覽的效率。</p><h2 id="如何複製文字？"><a href="#如何複製文字？" class="headerlink" title="如何複製文字？"></a>如何複製文字？</h2><p>較費時的做法是啟用文字游標瀏覽模式，再移動游標至目標文句，再使用 <code>Shift</code> + 方向鍵選取並複製。搜尋快捷鍵則能節省游標移動的時間，</p><ol><li><code>Ctrl</code> + <code>F</code>，搜尋目標文句</li><li><code>Esc</code>，脫離頁內搜尋窗格</li><li><code>Shift</code> + 方向鍵，選取要複製的文句</li><li><code>Ctrl</code> + <code>V</code>，複製</li></ol><p>如果要複製的文字篇幅較長，這方法甚至會比滑鼠來得有效且可靠，因為使用滑鼠選取時，要同時壓著鼠鍵並滑過狹長的文字區域，這過程有如遊玩電流急急棒一樣。相較之下，使用上下鍵卻可以一次複製一整列，還不用擔心手滑取消掉選取的區域。但如果目標文句較短的話，輸入搜尋關鍵字的時間都足以重新打字一遍了，這方法便顯得沒什麼效率。</p><h1 id="使用-Vimium-解放鍵盤的潛能"><a href="#使用-Vimium-解放鍵盤的潛能" class="headerlink" title="使用 Vimium 解放鍵盤的潛能"></a>使用 Vimium 解放鍵盤的潛能</h1><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的擴充套件，借鑒了 Vim 編輯器的操作邏輯與鍵位設置，大幅改善了在 Chrome 的鍵盤瀏覽體驗。</p><h2 id="為什麼-Vim-的功能改善鍵盤瀏覽體驗？"><a href="#為什麼-Vim-的功能改善鍵盤瀏覽體驗？" class="headerlink" title="為什麼 Vim 的功能改善鍵盤瀏覽體驗？"></a>為什麼 Vim 的功能改善鍵盤瀏覽體驗？</h2><p>從鍵盤輸入電腦的訊號不外乎指令（例如開分頁、複製、下一頁)和文字（例如中文、英文與符號），由於指令數量遠大於按鈕的數量，若要確保鍵盤尺寸在雙手便於敲擊的範圍，勢必得存在兼具兩種定位的按鈕。而專為鍵盤設計的 Vim 與 Windows 與 Chrome 等仰賴鍵鼠相輔者的差異正體現在讓電腦區分鍵入訊號的方式。</p><p>鍵鼠相輔的圖形介面保留了文字鍵的獨立性，讓滑鼠與功能選單取代部分指令（例如游標移動），而且只有在一併輸入 <code>Ctrl</code>、<code>Alt</code>、<code>Home</code> 等特殊控制鍵時，這些文字鍵才會發揮指令的功能。然而，這些特殊控制鍵分布於鍵盤兩側，編輯複雜文件時，雙手往往要在滑鼠、文字鍵區與控制鍵等區域間來回移動。</p><p>與之相對，Vim 則透過切換模式來區分鍵入訊號。文字鍵在 Insert 模式用於輸入內容，在 Normal 模式則用於下達指令，所以無論要鍵入指令還是文字，所有操作都圍繞在 f 與 j 那列按鍵 (home row)，降低了操作時雙手位移的幅度。</p><p>但是，Vim 的這些特性為什麼可以改善用鍵盤瀏覽網頁的體驗？</p><p>Vim 的 Normal 模式有許多便於移動與跳轉指標的指令，這些有用的指令在鍵鼠系統裡多被滑鼠取代，導致鍵盤不足以支持瀏覽網頁的需求。然而，除了輸入關鍵字外，瀏覽網頁時其實少有編輯文字的需求，也就沒有下達指令與輸入文字的衝突。這種情況可以類比為 Vim 的 Normal 模式，如果能透過 vimium 之類的套件，移植 Vim 好用的指令到這些閒置的文字鍵，便能充分發會鍵盤的潛能。</p><h2 id="Vimium-解決了鍵盤開啟連結的麻煩"><a href="#Vimium-解決了鍵盤開啟連結的麻煩" class="headerlink" title="Vimium 解決了鍵盤開啟連結的麻煩"></a>Vimium 解決了鍵盤開啟連結的麻煩</h2><p>雖然 Vimium 還有許多功能（這些功能可透過輸入 <code>?</code> 查詢），但我覺得在改善瀏覽網頁方面，快速開啟連結是最方便也最重要的功能。</p><p>若使用 Chrome 內建的快捷鍵，必須透過遍歷或是搜尋來找到連結。當網站連結編排不友善時，遍歷的時間會延長非常多。相較之下，Vimium 引進了 Vim Easymotion 功能，用戶只要鍵入 <code>f</code>，Vimium 便會自動為連結標記關鍵字，只要輸入關鍵字就能直接開啟標註的連結。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="按下 `f` 即可自動標註連結，再按下標註的字母即可開啟連結。由於每個連結至多標註兩個字母，所以視窗內的連結都可以在輸入三個鍵以內開啟。"></p><p>學會以 Vimium 開啟連結，再配合 Windows 與 Chrome 內建直觀的快捷鍵，其實就足以查資料、逛論壇或是到社群平台串門子了。若對於效率有要求，還可以再讀 Vimium 的說明，學習以 home row 為核心的鍵盤操作。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>網頁瀏覽是少量文字編輯，加上大量查詢、瀏覽、點擊與切換等指令的循環。鍵鼠系統已能流暢地瀏覽網頁，所以是否要單用鍵盤瀏覽網頁是風格問題，我對此議題的總結如下，</p><ul><li><strong>格調重於成效</strong>：「社會組織是一部大型機器，每個人都是維繫機器運作必要的鏍絲釘。」雖然必要，但無可避免被取代。有時小小的不一樣，可以讓自己多少脫離被束縛與異化的感受。</li><li><strong>搜索取代遍歷</strong>：鍵盤操作較不直覺，但很精準，行為可以直接反映想法，不用經過滑鼠拖曳或是<code>Tab</code>切換的過程。</li><li><strong>自訂創造風格</strong>：按鍵數量有限，但可透過模式切換、特殊控制鍵、輸入順序、指令組合等方式來擴充可容納的指令。儘管擁有選項，卻不存在預設值，若想使用鍵盤就得思考和選擇，決定什麼才適合現今的自己。</li></ul><p>在實務上，只要學習 Vimium 的快搜鍵 <code>f</code> 加上瀏覽器內建按鍵（例如方向鍵），就可以應對網頁瀏覽的多數需求了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜724. Find Pivot Index</title>
      <link href="/leetcode-724-find-pivot-index/"/>
      <url>/leetcode-724-find-pivot-index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>若數列某項兩側各數字的總和相同，則該項為數列的樞紐 (pivot)。給定一整數數列，判斷其是否含樞紐項。若有，求樞紐之索引值；若無，則回傳 <code>-1</code>。</p><span id="more"></span><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote><p>Given an array of integers <code>nums</code>, calculate the pivot index of this array.<br>The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right.<br><strong>If the index is on the left edge of the array, then the left sum is <code>0</code></strong> because there are no elements to the left. This also applies to the right edge of the array.<br>Return the leftmost pivot index. If no such index exists, return <code>-1</code>.</p></blockquote><p><strong>樣例</strong></p><blockquote><p>Input: nums &#x3D; [1,7,3,6,5,6]<br>Output: 3</p></blockquote><blockquote><p>Input: nums &#x3D; [-1,-1,-1,-1,-1,0]<br>Output: 2</p></blockquote><blockquote><p>Input: nums &#x3D; [-1,-1,-1,0,1,1]<br>Output: 0</p></blockquote><p><em>留意負數項、樞紐位於數列首尾、數列只含一項或兩項的案例</em></p><p><strong>限制</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code>：留意負數項</li></ul><p><strong>知識點</strong><br>prefix sum &amp; array</p><h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此處借鑑<a href="https://leetcode.com/problems/find-pivot-index/solutions/127676/find-pivot-index/">官方解法</a>。首先計算數列的級數 (<code>S</code>)，接著依序讀過數列，並計算讀過數字之和 (<code>leftSum</code>，即當前項左側的子數列總和)。</p><p>由於已算過 <code>S</code>，所以當前項右側的子數列總和可透過 <code>S - nums[i] - leftSum</code> 得知。</p><p>若當前項左右兩側的子數列總和一致，表示當前項為樞紐，其索引值便為題解；若總和不一致，則累計 <code>leftSum</code> 的值。若遍歷數列仍未求得樞紐，即可確認此數列無樞紐，依題目要求回傳 <code>-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        S = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> leftSum == S - nums[i] - leftSum:</span><br><span class="line">                <span class="keyword">return</span>(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                leftSum += nums[i]</span><br><span class="line">        <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="曾嘗試但失敗的解法"><a href="#曾嘗試但失敗的解法" class="headerlink" title="曾嘗試但失敗的解法"></a>曾嘗試但失敗的解法</h3><p>我原先的想法是定義兩個指標，在一次迴圈中從數列兩側夾擠，同時計算 <code>leftSum</code> 和 <code>rightSum</code>。當兩指標重合，且左右數列總和一致時，指標的位置即為樞紐的索引值；反之，則表示此數列沒有樞紐。</p><p>這種方法的關鍵在於判斷何時要調動兩側的指標，所以在程式碼中間我寫了不少判斷式。然而，當數列正負數穿插的時候，判斷式便會很難寫。</p><p>舉下方的程式碼為例，碰到 <code>[-1,-1,-1,0,1,1]</code> 和 <code>[-1,-1,-1,0,1,1,0]</code> 這兩個案例時，右側指標會在循環中不斷往左側移動，直接錯過樞紐的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        leftSum = nums[l]</span><br><span class="line">        rightSum = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span>  <span class="built_in">abs</span>(leftSum) &lt; <span class="built_in">abs</span>(rightSum):</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                leftSum += nums[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                rightSum += nums[r]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftSum == rightSum:</span><br><span class="line">            <span class="keyword">return</span>(l)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="練習題目時，適合使用程式語言定義好的-function-嗎？"><a href="#練習題目時，適合使用程式語言定義好的-function-嗎？" class="headerlink" title="練習題目時，適合使用程式語言定義好的 function 嗎？"></a>練習題目時，適合使用程式語言定義好的 function 嗎？</h3><p>我覺得這算是我其中一種心態糾結，即「為了打好基礎，必須手刻所有功能」。不過追根究柢，做題的目的是透過題目學習該題相關知識。</p><p>以這題為例，<code>sum</code>並非解題的關鍵，也不是這題的核心知識，如果使用這個 function 能改善程式碼的可讀性和簡潔性，那麼我覺得使用程式語言定義好的 function 也不錯。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜1480. Running Sum of 1d Array</title>
      <link href="/leetcode-1480-running-sum-of-1d-array/"/>
      <url>/leetcode-1480-running-sum-of-1d-array/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>計算數列逐項的累積和 (runningSum)</p><span id="more"></span><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote><p>Given an array nums. We define a running sum of an array as runningSum[i] &#x3D; sum(nums[0]…nums[i]).<br>Return the running sum of nums.</p></blockquote><p><strong>樣例</strong></p><blockquote><p>Input: nums &#x3D; [1,2,3,4]<br>Output: [1,3,6,10]</p></blockquote><p><strong>限制</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul><p><strong>知識點</strong><br>prefix sum &amp; array  </p><h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題應該算是 for loop 練習，我覺得要留意 (1) indices out of range 以及 (2) len(nums) &#x3D;&#x3D; 1 的狀況。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[n] = nums[n - <span class="number">1</span>] + nums[n]</span><br><span class="line">        <span class="keyword">return</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讀後感｜生命是什麼 — 如何推論基因的尺寸？</title>
      <link href="/schrodinger-1944-what-is-life-chapter-2/"/>
      <url>/schrodinger-1944-what-is-life-chapter-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>依照<a href="./schrodinger-1944-what-is-life-chapter-1.md">第一章</a>的推理，生物及其生理過程有賴大量原子參與，來抵銷個別原子的隨機行為，以維持生存所需的宏觀秩序。</p><p>乍看之下，這項推論似乎符合當代多數的生物學觀察。畢竟個體由無數細胞組成，而細胞又由多樣的園子、分子和聚合物構築。即使是維繫生存最基本的呼吸作用，也需要大量的分子參與。這些園子的數量大小，吻合統計物理的要求，能讓物理和化學過程順利運作。</p><p>然而，在這章當中，我們可以看到維繫遺傳的關鍵因素，基因，相較於其穩定性，卻令人訝異地有著幾乎無法維持嚴格統計定律的數量。</p><span id="more"></span><h2 id="基因相當穩定"><a href="#基因相當穩定" class="headerlink" title="基因相當穩定"></a>基因相當穩定</h2><p>相較於紙張、磁碟片、或是塗鴉在牆上的紀錄，基因在保存事務上的能力相當穩定。基因的穩定型從色盲、鐮刀行貧血、乃至於哈布斯堡家族鮮明的戽斗等遺傳行疾病更為顯著，即使經過了上千年，這些性狀仍仍能忠實地在世代間傳遞，以致於當今的社會仍要為其奮鬥。</p><p>考量其穩定性，究竟需要多少原子才能讓基因維持這樣的穩定性呢？</p><h2 id="以染色體影像估算基因的最大尺寸"><a href="#以染色體影像估算基因的最大尺寸" class="headerlink" title="以染色體影像估算基因的最大尺寸"></a>以染色體影像估算基因的最大尺寸</h2><p>一種直觀的估算方法是透過細胞學的觀察為依據。果蠅唾腺細胞的染色體在分裂時會凝聚成顯微鏡可見的棒狀物，這些染色體上有深淺間格的調帶，假設這些條帶是基因的性向，那麼可以ˇ用染色惡體的體積，再除以調代的數量，那麼即可推論基因的尺寸。</p><h2 id="以遺傳圖譜估算基因的最大尺寸"><a href="#以遺傳圖譜估算基因的最大尺寸" class="headerlink" title="以遺傳圖譜估算基因的最大尺寸"></a>以遺傳圖譜估算基因的最大尺寸</h2><p>另一種迂迴但是巧妙的手法是透過遺傳方法，推論基因的數量。生物形成配子時，會先行減數分裂。減數分裂過程，同源染色體間的片段可能彼此互換，導致原先坐落相同染色體的性狀，被置換到對偶染色體上。互換會導致子代性狀的機率分布脫離孟德爾的假設，因此透過育種雜交實驗，可從子代性狀的分布推論互換的機率。</p><p>假設染色體各處發生互換的機率一致，若性狀間距越大，當中也有較多位點可能發生互換，也表示兩者互換的機率也越高（因為兩者之間有較多位置可能發生互換），反之則表示兩者互換機率愈高，則間距越大。基於這項假設，可以從性狀間的互換率，推論性狀在染色體上的相對位置與距離。</p><p>這項任務有助於在遺傳學上譜出基因的相對位置，其在推論基因尺寸的用途則在於。若我們定義基因為乘載性狀的基本單位，若一項性狀能隨互換而遷移，表示這段區域至少包含了能獨立展現性狀的基因。因此，基因的最大尺寸可由染色體的體積，除以可互換而分離的性狀數量來估計。（由於）</p><h2 id="基因具有令人訝異的穩定性"><a href="#基因具有令人訝異的穩定性" class="headerlink" title="基因具有令人訝異的穩定性"></a>基因具有令人訝異的穩定性</h2><p>無論透過何種方式推論，原子的最大體積約為 300 Å,而單一原子的尺寸約為 1 Å，這意味著基因所含的原子數頂多在數百萬個之間。透過前一章所推論的，這樣的尺寸顯然過少了。那麼究竟有什麼使得基因能以保有如此問訂的特性</p>]]></content>
      
      
      
        <tags>
            
            <tag> what is life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「天文」生物學：數量的緣故</title>
      <link href="/history-of-astrobiology-naked-eyes/"/>
      <url>/history-of-astrobiology-naked-eyes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>國中時，剛看完《星艦迷航記VIII：戰鬥巡航》的我向學校裡最接近外星生物專家的生物老師詢問是否真有外星人，他告訴我地球外還有許多星球，如果沒有其他生命也太奇怪了。</p><p>如同我的生物老師所述，對於地外生命的信心有很大一部分是建立在數量上，既然宇宙已經誕生百餘億年，當中又充滿無數星系，很難想像當中不會有其他生命存在。</p><p>然而宇宙的尺度也是經學界漫長掙扎才逐漸變得清晰，早在人類只能以肉眼觀察世界的時候，滿天繁星已不計其數，甚至至今我們對於宇宙中有多少顆適居行星仍沒有精確的估計。</p><p>天文生物學的發展不只是事實的累積，也是世代人觀念轉變的結果。</p><span id="more"></span><h2 id="肉眼"><a href="#肉眼" class="headerlink" title="肉眼"></a>肉眼</h2><p>最初人類只能以肉眼觀察這個世界，其他的天體在天空化為一個小亮點，這些亮點的意義在不同人眼裡衍伸出不同的樣貌，這些推論與想像便成為天文生物學興起前，人們對地外生命的想像基礎。</p><p>對於無法觸及的天空，德膜克利特(Democritus, 410 - 380 BC) 等原子學派 (Atomists) 哲人認為，既然原子的隨機運動組成了世間萬物，天與地應遵循相同法則，形成地球的過程沒理由不能在天外形成其他世界，是以其後繼者伊比鳩魯在給希羅多德的信 (<a href="http://www.attalus.org/old/diogenes10b.html">Letter to Herodotus</a>) 中提到，</p><blockquote><p>We must not believe that all worlds necessarily have one identical form.  Let us also beware of thinking that animals are derived from the infinite; for there is no one who can prove that the seeds from which animals are born, and plants, and all the other objects which we contemplate, have been brought from the exterior in such a world, and that this same world would not have been able to produce them of itself. （我們絕對不能假設各個世界有一致的樣貌，……，因為沒有人能證明形成動物、植物和我們眼前一切的種子無法在這樣的世界萌生。）</p></blockquote><p>伊比鳩魯的門徒 Metrodorus（400 BC） 也對地外生命的可能留下更明確的評述。</p><blockquote><p>It is unnatural in a large field to have only one stalk of wheat, and in the infinite universe only one living world.（無垠宇宙僅有一個育有生命的世界和沃野千里卻只長出一束麥子一樣不尋常。）</p></blockquote><p>相較於原子學派，亞里斯多德學派哲人認為地球是唯一的世界，所以沒有為地外生命留下空間。</p><p>亞里斯多德以朝向&#x2F;背離中心的本性解釋火、水、土和空氣四種基本元素的運動現象，所以如果世界不只一個，那麼物質便喪失了明確的運動目標，維繫世界運作的基本原理將不復存在。透過這個規謬過程，四元素說結合地心說共同否定了多重世界的觀點。</p><p>此外，天與地也在亞里斯多德體系中割裂。有別於四元素，天空是由以太組成。太陽、月亮還有其他五顆行星就在層層嵌套的天球上緩緩繞著地球旋轉，而原子學派眼裡可能存在繽紛世界的星斗只是鑲在最外層恆星天上閃爍的光點。</p><p>同片天空不同的想像與推論，形成了不同的結論。</p><p>如今我們知道，原子學派哲人的想像比較接近當今學界對世界的認知，然而這不代表他們是天文生物學還是任何現代科學的根源。囿於當時的觀察手段，無論哪派哲人的思想都沒有嚴謹事實支持，即使有許多詞彙為後世研究者共用，其中的內涵也已發生很大的變化。</p><p>但另一方面，儘管只能取得有限的線索，希臘人仍試圖靠著理性與智力解釋世界，而不是將問題簡化為鬼、神、UFO 或我不知道。</p><p>亞里斯多德的學說在中世紀時期被阿奎納 (St. Thomas Aquinas, 1225-1274) 納入神學體系，此後單一世界的想法持續主宰著歐洲人的世界觀。然而關於「數量」的爭議並沒有就此定論，亞里斯多德體系在哥白尼掀起科學革命後逐漸衰落，現代科學興起後更多的科技與觀察手段逐漸揭示宇宙的樣貌。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life in the universe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜1. Two Sum</title>
      <link href="/leetcode-1-two-sum/"/>
      <url>/leetcode-1-two-sum/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote><p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p></blockquote><p>求數列內，和為目標值的兩數之座標</p><p><strong>樣例</strong></p><blockquote><p>Input: nums &#x3D; [3,2,4], target &#x3D; 6<br>Output: [1,2]</p></blockquote><p><strong>限制</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code>：數列長度介於 2 至 104 之間</li><li><code>-109 &lt;= nums[i] &lt;= 109</code>：數列各項可能有負值</li><li><code>-109 &lt;= target &lt;= 109</code>：目標值可能為負值</li><li>Only one valid answer exists.：僅有一組解</li></ul><span id="more"></span><p><strong>知識點</strong><br>hash table</p><h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題最直觀的解法是將數列各項兩兩相加，最遲到比對所有組合後才找到題解。然而，目標值在這算法裡僅作為判斷結果的依據，沒有充分利用其提供的資訊。</p><p>為了充分利用目標值，可以各項與目標值之差為 keys，各項座標為 values，建立 hash table 存儲讀過的數字。</p><p>若現在的數字為先前出現過的數字與目標值之差，則回傳這兩數字的座標即為題解；若否，則新增現在的數字與目標值之差到 hash table 內。由於題目設計保證有唯一解，所以最遲遍歷整個數列即可找到題解。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = &#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record.keys() :</span><br><span class="line">                <span class="keyword">return</span>([record[nums[i]], i])</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                record[diff] = i</span><br></pre></td></tr></table></figure><ul><li>此以 python dict 實踐 hash table 的功能。</li><li><code>record.keys()</code> 可寫成 <code>record</code>，但標出來比較清楚</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜153. Find Minimum in Rotated Sorted Array</title>
      <link href="/leetcode-153-find-minimum-in-rotated-sorted-array/"/>
      <url>/leetcode-153-find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote><p>Given the sorted rotated<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]">1</span></a></sup> array <code>nums</code> of unique elements, return the <em>minimum element of this array</em>.</p></blockquote><p>平移一嚴格遞增數列各項 n 單位後，求此數列的最小值</p><p><strong>樣例</strong></p><blockquote><p>Input: nums &#x3D; [3,4,5,1,2]<br>Output: 1</p></blockquote><p><em>須留意幾個樣例：數列只含一項、數列只含兩項、平移後與原數列相同、最小值位於數列尾部</em></p><span id="more"></span><p><strong>限制</strong></p><ul><li><code>n == nums.length</code>：數列長度為 n</li><li><code>1 &lt;= n &lt;= 5000</code>：數列長度介於 1 至 5000 項</li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code>：數列各項介於 -5000 至 5000，因此兩項相加不至於超出整數大小的上下界</li><li>All the integers of <code>nums</code> are <strong>unique</strong>：數列各項唯一</li><li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times：數列已排序，且至多平移 n 次，最少平移 1 次</li><li>You must write an algorithm that runs in <code>O(log n)</code> time：此題有時間複雜度限制</li></ul><p><strong>知識點</strong><br>binary search</p><h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題的關鍵在於判斷最小值，並使用二分搜尋法簡化找尋最小值的步驟。</p><p>由於數列已由小到大排序，所以如果某項數值在平移後小於前一項，該項即為數列的最小值。依照這項原則，可以先定義 <code>left</code>、<code>mid</code>、<code>right</code> 三個指標，其中 <code>mid</code> 是 <code>left</code> 與 <code>right</code> 的中間值。</p><p>若 <code>nums[mid]</code> 小於其前一項，則 <code>nums[mid]</code> 為最小值，即可中斷迴圈並回傳題解。若尚未找到最小值，則可比較 <code>nums[mid]</code> 與 <code>nums[right]</code>，選定下一個搜索標的。</p><p>假設 <code>nums[right]</code> &gt; <code>nums[mid]</code>，表示數列於 <code>mid</code> 至 <code>right</code> 之間嚴格遞增，表示原數列的首尾交接處不在此區間，所以可以縮小搜索範圍到 <code>left</code> 至 <code>mid - 1</code> 之間。反之，則表示數列於 <code>left</code> 至 <code>mid</code> 之間嚴格遞增，則可縮小搜索範圍至 <code>mid + 1</code> 至 <code>right</code> 之間。</p><p>由於嚴格遞增數列一定有唯一的最小值，所以最遲在 <code>left</code> 與 <code>right</code> 指向同一座標時，會找到數列最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = right - (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>(nums[mid])</span><br></pre></td></tr></table></figure><h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="mid-的定義方式"><a href="#mid-的定義方式" class="headerlink" title="mid 的定義方式"></a><code>mid</code> 的定義方式</h3><p><code>mid</code> 亦可定義為 <code>(left + right)//2</code>，但聽同事討論，若兩數的數值極大，則有數值超出整數範圍的風險。以相減的方式撰寫則一定不會超出範圍。</p><h3 id="判斷首尾交界處的方式"><a href="#判斷首尾交界處的方式" class="headerlink" title="判斷首尾交界處的方式"></a>判斷首尾交界處的方式</h3><p>有看過同事在比較時，不比對 <code>nums[right]</code>，而是比對 <code>nums[-1]</code>，有一樣的效果。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜53. Maximum Subarray</title>
      <link href="/leetcode-53-maximum-subarray/"/>
      <url>/leetcode-53-maximum-subarray/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote><p>Given an integer array nums, find the subarray which has the largest sum and return its sum.</p></blockquote><p>給一整數數列，求其子數列級數的最大值。</p><p><strong>樣例</strong></p><blockquote><p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6</p></blockquote><span id="more"></span><p><strong>限制</strong></p><ul><li>$1$$\leq$ nums.length $\leq$$10^5$：數列長度介於 $1$ 至 $10^5$ 間</li><li>$-10^4$$\leq$ nums[i] $\leq$$10^4$：數值介於 $-10^4$ 至 $10^4$ 間</li></ul><p><strong>知識點</strong></p><ul><li>dynamic programming</li><li>Kadane’s Algorithm</li></ul><h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>這題常見的作法是 Kadane’s algorithm，我在解題時並不知道這套演算法，所以一開始是用極端情形勾勒 function 的輪廓，再透過更多樣例「擬合」出可能的解法，最後才整合為提交的答案。</p><ul><li><strong>數列僅包含一個數字</strong>：解為該項數字，表示即使只有一個數字也能回傳</li><li><strong>數列全為正值</strong>：解為數列各項之和，所以程式碼內含有累加操作</li><li><strong>數列全為負值</strong>：解為數列最大的一項數字，所以程式碼內含有暫存最大值的變項與比較數值的判斷式</li></ul><p>由此分析可知問題癥結在於，累加的級數在碰到負數時要如何處置？</p><ul><li>若級數於累加後增加，則將這些數字納入計算。例如 [2, -1, -3, 5]，由於 5 &gt; -1 + -3，所以仍有涵蓋這兩個負數的價值。</li><li>若級數於累加後減少，則跳過這些數字，從新的位置開始計算。例如 [2, -1, -4, 1]，累加新的數字無法抵銷兩個負數值，所以不如跳過。</li></ul><p>至此，我雖然對計算方式有個概念，但還是經過了一連串測試，才歸納出以下算法。依序累加數列各項，每次累加後 (1) 若累加後級數沒增加，則從當前項重新計算級數；(2) 更新當前級數的最大值。</p><p>遍歷整條數列後，當前級數的最大值即為題解。只須走一趟循環，空間用量也固定，所以時間複雜度和空間複雜度分別為 $O(n)$ 與 $O(1)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        maxVal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sums += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &lt; nums[i]:</span><br><span class="line">                sums = nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; maxVal:</span><br><span class="line">                maxVal = sums</span><br><span class="line">        <span class="keyword">return</span>(maxVal)</span><br></pre></td></tr></table></figure><p><em>當初以為要回傳子數列的位置，所以才使用 index 取值</em></p><ul><li><code>sums</code>：紀錄當前累加值</li><li><code>maxVal</code>：紀錄當前累加的最大值</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜怎麼從運行中的腳本取回參數？</title>
      <link href="/nextflow-retrieve-configuration-when-workflow-runs/"/>
      <url>/nextflow-retrieve-configuration-when-workflow-runs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在執行腳本前，Nextflow 會讀取設置檔 (configuration files) 中的參數，將之代入腳本的對應位置後再執行程式。這項特性有助於使用者管理複雜流程的輸入值與環境設定，也將具體數值從流程邏輯抽離，讓開發者專注於流程的梳理與串接。</p><p>然而，隨著流程腳本改版，設置檔的內容也可能跟著改變，是否有方法能記錄執行流程時使用的設置檔，以利往後重現分析或追蹤歷次設定？</p><p>在這篇文中，我首先介紹了 nextflow 導入參數的方式，再陳述取回參數的可行策略，並附上這些策略的最簡範例供參考。</p><span id="more"></span><h2 id="Nextflow-導入參數的方式"><a href="#Nextflow-導入參數的方式" class="headerlink" title="Nextflow 導入參數的方式"></a>Nextflow 導入參數的方式</h2><p>以下是 nextflow 導入參數的常見方式，若一參數被多種方式定義，則會以順位較小者為準。</p><table><thead><tr><th>順位</th><th>方式</th><th>範例</th></tr></thead><tbody><tr><td>1</td><td>於命令列輸入</td><td><code>nextflow run workflow.nf --something value</code></td></tr><tr><td>2</td><td>以 <code>-params-file</code> 導入</td><td><code>nextflow run workflow.nf -params-file params.json</code></td></tr><tr><td>3</td><td>以 <code>-c</code> 導入</td><td><code>nextflow run workflow.nf -c params.config</code></td></tr><tr><td>4</td><td>於 nextflow 腳本內宣告</td><td><code>params.something = value</code></td></tr></tbody></table><h2 id="使用-params-取回參數"><a href="#使用-params-取回參數" class="headerlink" title="使用 params 取回參數"></a>使用 <code>params</code> 取回參數</h2><p>其中一個方法是讀取 <code>params</code> 的內容，<code>params</code>是 nextflow 的<a href="https://www.nextflow.io/docs/latest/script.html?highlight=implicit#implicit-variables">隱變項</a>，採用 <code>[key1:value1, key2:value2,...]</code>格式存儲以不同方式導入的參數。</p><h3 id="params-json"><a href="#params-json" class="headerlink" title="params.json"></a>params.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;paramsDerivedConfig&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;provided using the -params-file option&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="params-config"><a href="#params-config" class="headerlink" title="params.config"></a>params.config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params &#123;</span><br><span class="line">    configDerivedConfig = <span class="string">&quot;specified using the -c option&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getConfig-nf"><a href="#getConfig-nf" class="headerlink" title="getConfig.nf"></a>getConfig.nf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">params.inScriptConfig = <span class="string">&quot;defined within the script itself&quot;</span></span><br><span class="line">process retrieveConfigFromParams &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$params&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run getConfig.nf --commandSpecifiedConfig <span class="string">&quot;specified on the command line&quot;</span> -params-file params.json -c params.config</span><br><span class="line">[configDerivedConfig:specified using the -c option, config-derived-config:specified using the -c option, paramsDerivedConfig:provided using the -params-file option, params-derived-config:provided using the -params-file option, commandSpecifiedConfig:specified on the <span class="built_in">command</span> line, command-specified-config:specified on the <span class="built_in">command</span> line, inScriptConfig:defined within the script itself, in-script-config:defined within the script itself]</span><br></pre></td></tr></table></figure><h2 id="從輸入路徑取回參數"><a href="#從輸入路徑取回參數" class="headerlink" title="從輸入路徑取回參數"></a>從輸入路徑取回參數</h2><p>然而，前述方法只能取回以 <code>params</code> 存儲的參數，若想取得 <code>process</code>, <code>docker</code>, <code>report</code> 等<a href="https://www.nextflow.io/docs/latest/config.html?highlight=params#config-scopes">其它設置 (configuration scope)</a>，可以讀取位於 <code>$launchDir</code> 的 <code>.nextflow.log</code>，從中獲得當初執行腳本時輸入的 <code>*.config</code> 路徑，再將設置擋複製出來。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">process getConfig &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    shell:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    str=$(grep &quot;User config file:&quot; &quot;!&#123;launchDir&#125;/.nextflow.log&quot;)</span></span><br><span class="line"><span class="string">    config=$&#123;str##*:&#125;</span></span><br><span class="line"><span class="string">    echo $&#123;config&#125;</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run getConfig.nf -c params.config</span><br><span class="line">/home/user/workflow/params.config</span><br></pre></td></tr></table></figure><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>若能從運行中的 nextflow 腳本取回輸入參數，將有助於往後重現分析或追蹤設置。目前，nextflow 有兩個隱變項能協助我們達成這項任務，</p><ul><li><code>params</code>：記錄了不同管道導入的參數，可以在 <code>*.nf</code> 檔各處呼叫以取得書入的參數和設定。</li><li><code>launchDir</code>：雖然本身與參數無關，但此變項記錄了腳本執行位置，其中的 <code>.nextflow.log</code> 記錄了 <code>*.config</code> 路徑。讀取該檔即可獲取輸入的參數和設定。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜背景執行 workflow 的方法</title>
      <link href="/nextflow-run-in-background/"/>
      <url>/nextflow-run-in-background/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般而言，若想要背景執行 linux 指令，可在指令末端添加 <code>&amp;</code>，或是透過 <code>ctrl + z</code> 配合 <code>bg %n</code> 將執行中的指令挪到背景執行。然而，nextflow 腳本卻不適用這種做法（version &gt;&#x3D; 21.10.6），指令挪到背景後會陷入停止狀態。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run workflow.nf &amp;</span><br><span class="line">[1] 533</span><br><span class="line">Launching `workflow.nf` [sick_waddington] - revision: 123b1ec198</span><br><span class="line">[2]+  Stopped                 nextflow run workflow.nf</span><br></pre></td></tr></table></figure><p>一旦陷入停止狀態，會變得異常難清，要用 <code>kill %n &amp;&amp; fg</code> 才能一次清掉（參考<a href="https://gitter.im/nextflow-io/nextflow/archives/2020/09/16">論壇的討論</a>）。</p><span id="more"></span><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>即使透過 <code>.sh</code> 來執行 nextflow 腳本也會遭遇相同的狀況。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># run_workflow.sh</span><br><span class="line">nextflow run workflow.nf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./run_workflow.sh &amp;</span><br><span class="line">N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [trusting_hamilton] - revision: 936bafe285</span><br><span class="line">[1]-  Stopped                 <span class="built_in">nohup</span> nextflow run paramInput.nf</span><br><span class="line">[2]+  Stopped                 ./run_workflow.sh</span><br></pre></td></tr></table></figure><h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>此時，若要背景執行 nextflow 腳本，可在指令或是腳本內添加 nextflow 內建的 <code>-bg</code> 選項。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run workflow.nf -<span class="built_in">bg</span></span><br><span class="line"> N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [furious_kowalevski] - revision: 936bafe285</span><br><span class="line">[8b/21d003] Submitted process &gt; sayHi</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure><p>這選項觸發的行為類似 <code>nohup</code>，能確保用戶退出 terminal 後仍能持續執行 nextflow 腳本（可參考官方<a href="https://www.nextflow.io/docs/latest/cli.html#execution-as-a-background-job">文件</a>及<a href="https://www.nextflow.io/blog/2021/5-more-tips-for-nextflow-user-on-hpc.html">部落格</a>）。</p><p>除此之外，添加 <code>-bg</code> 也會輸出 <code>.nextflow.pid</code> 檔，紀錄此指令的 pid，以便用戶追蹤 nextflow 腳本的執行狀況。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>若隨時將指令切到前台，並且用 <code>jobs</code> 查看執行狀態，也可以在指令末端補 <code>&amp;</code>。只是這樣退出 terminal 後，nextflow 腳本也跟著結束了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextflow run workflow.nf -<span class="built_in">bg</span> &gt; log.txt &amp;</span><br></pre></td></tr></table></figure><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>至於為什麼 nextflow 有這特性，我仍沒有頭緒。我試著比較添加 <code>-bg</code> 前後，<code>.nextflow.log</code> 和 <code>.command.run</code> 等檔案的內容，卻沒有發現相關差異。</p><p>另外，雖然官方說明 <code>-bg</code> 的行為類似 <code>nohup</code>，但卻無法用 <code>nohup</code> 達到同樣效果。可能還需要對 nextflow 和 linux 有更深的理解才能解釋吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 筆記｜217. Contains Duplicate</title>
      <link href="/leetcode-217-contains-duplicate/"/>
      <url>/leetcode-217-contains-duplicate/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p></blockquote><p>(給定一整數陣列，判斷其中是否含重複的數字。)</p><p>Example:</p><blockquote><p>Input: nums &#x3D; [1,2,3,1]<br>Output: true</p></blockquote><span id="more"></span><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>若 array 含重複數字，則有以下特性：</p><ul><li>數字重複出現</li><li>array 長度大於其中數字種類數</li><li>若將 array 排序，則重複的數字比鄰出現</li></ul><p>根據第一種特性，可用 hash table 存儲讀過的數字，再判斷讀入的數字是否已存在 hash table 中。此處，我以 python 的 <code>dict</code> 充作 hash table 來實踐這個想法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        occur = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> occur.keys():</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                occur[n] = n</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">由於計算時間和空間需求都隨陣列大小線性增長，所以時間與空間複雜度都是 $O(n)$</span><br><span class="line"></span><br><span class="line">除了 `<span class="built_in">dict</span>`，python 的 `<span class="built_in">set</span>` 也能體現 <span class="built_in">hash</span> table 的特性。`<span class="built_in">set</span>` 可想像為僅有 key 的 `<span class="built_in">dict</span>`，由於 `<span class="built_in">set</span>` 的元素皆獨一無二，故可將 array 轉為 `<span class="built_in">set</span>`，再比較兩者的長度。若 `<span class="built_in">set</span>` 長度小於 array，則表示 array 含重複值。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>至於先排序，再比較數值兩側是否有重複值的做法，可參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a></p><h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><ul><li><p>使用 list, dict, set 存讀過的數字有什麼差異？（參考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448">廖雪峰的官方網站：使用dict和set</a>）</p></li><li><p>python 是怎麼體現 <code>set</code> 的概念？（參考：<a href="https://stackoverflow.com/questions/3949310/how-is-set-implemented">How is set() implemented?</a>）</p></li><li><p>排序算法跟 hash table 算法相比有什麼優點？（參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a>）</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>很久很久以前，自然用什麼盛裝生命？</title>
      <link href="/how-nature-contains-life-in-early-earth/"/>
      <url>/how-nature-contains-life-in-early-earth/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1953年，在試管裡的雷鳴閃電與水氣蒸騰之後，米勒與尤里成功在模擬的早期地球環境中合成胺基酸，開啟了研究生命起源的先河。</p><p>隨著多種有機質在實驗室合成或於隕石中發現，研究人員逐漸了解生命的物質來源。然而，散落各處的有機質需要彼此接觸才有機會引發生化反應。在早期環境中，有什麼物質能夠形成容器，匯集生命形成所需的反應物？</p><span id="more"></span><p>現存生命被包覆在由磷脂組成的細胞膜內。磷脂膜的結構穩定且功能齊全，但其組成複雜，所以可能不是最早形成的容器。相較之下，脂肪酸不僅結構簡單，也能形成會膨大與分裂的囊泡。因此，脂質囊泡是構成原始細胞膜的可能選項。 </p><p>然而，脂質囊泡對酸鹼值與離子濃度敏感，可能難於多變的環境中穩定存在。是以，Jia等認為在磷脂膜或脂質囊泡形成前，其他容易形成的物質可能組成結構穩定的過渡容器，發揮匯集物質及促進反應的功能。 </p><p>為了檢驗這項假說，Jia等採取類似米勒與尤里的策略。Jia等發現，可能普遍存在早期地球的果酸可於模擬環境中形成微滴。這些微滴不僅耐受溫度、壓力和酸鹼值變動，也能吸納蛋白質和RNA等生物分子。</p><p>儘管目前無法確認生命是否透過果酸微滴形成，Jia等的研究成果仍支持了新的研究途徑：除了構成現存生命的大分子，存在早期地球的其他分子也可能形成過渡容器，在細胞膜出現前匯集生命形成所需的反應物。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jia et al. (2019). Membraneless polyester microdroplets as primordial compartments at the origins of life. <em>Proceedings of the National Academy of Sciences</em>, 116(32), 15830-15835.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> origins of life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All-Species Living Tree Project (LTP) 物種資訊的訂正和維護</title>
      <link href="/living-tree-project-database-curation/"/>
      <url>/living-tree-project-database-curation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>All-Species Living Tree Project (LTP)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="All-Species Living Tree Project (LTP)  相關文獻，Yarza & Munoz. (2014). The all-species living tree project. *In Methods in Microbiology* (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. *Systematic and applied microbiology*, 31(4), 241-250.">1</span></a></sup> 旨在維護所有已知古菌和細菌 type strain 的 16S rRNA 基因序列，並基於這些序列，建立古菌和細菌的譜系樹。</p><p>LTP 主要由四個單位參與</p><ul><li>LPSN 提供分類與命名資訊 (<a href="https://www.bacterio.net/">https://www.bacterio.net/</a>)</li><li>ARB 支援譜系樹建立與分類 (<a href="http://www.arb-home.de/">http://www.arb-home.de/</a>)</li><li>Ribocon 則負責資料庫的管理 (<a href="https://www.ribocon.com/">https://www.ribocon.com/</a>)</li><li>SILVA 則提供序列資料庫、計算資源與網頁介面 (<a href="https://www.arb-silva.de/">https://www.arb-silva.de/</a>)</li></ul><p>（自 2020 年起，LTP 的遷出 SILVA，獨立為一個網頁：<a href="https://imedea.uib-csic.es/mmg/ltp/%EF%BC%89">https://imedea.uib-csic.es/mmg/ltp/）</a></p><p>LTP 的資料常用於 16S rRNA 基因增幅序列的物種註解，而基於其收錄序列所構建的譜系樹，也能作為 Phylogenetic placement 的基礎<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. *Msystems*, 3(3), e00021-18.">2</span></a></sup>。</p><p>另外，由於 LTP與 RDP training set 都只收錄了 type strain 的序列資料，所以相較於透過序列預測建立的資料庫，LTP 的序列資料較為可靠，能避免在物種註釋時，要在分類錯誤之外面臨資料庫錯誤的問題。</p><p>儘管 LTP 已是人工維護且品質好的資料庫，但目前版本 ( LTP_01_2022) 的部分物種資訊仍有誤騰的狀況。在官方修正這些問題之前，資料庫的使用者得自己訂正這些錯誤。</p><span id="more"></span><h1 id="分類階層間少了分隔符"><a href="#分類階層間少了分隔符" class="headerlink" title="分類階層間少了分隔符"></a>分類階層間少了分隔符</h1><p>若使用 “;” 來分割這樣的字串，會得到較短的列表。</p><blockquote><p>AF251436 Ferrimicrobium acidiphilum Bacteria;ActinomycetotaAcidimicrobiia;Acidimicrobiales;Acidimicrobiaceae;Ferrimicrobium</p></blockquote><h1 id="分類名稱出現額外符號"><a href="#分類名稱出現額外符號" class="headerlink" title="分類名稱出現額外符號"></a>分類名稱出現額外符號</h1><p>文字前後出現空格、引號和句號等，可能會因字串不同而高估該分類階層的分類群數量，也可能在資料處理造成意外麻煩。</p><h2 id="額外的雙引號"><a href="#額外的雙引號" class="headerlink" title="額外的雙引號"></a>額外的雙引號</h2><blockquote><p>AY102612 Caedibacter taeniospiralis “Bacteria;Pseudomonadota;Alphaproteobacteria;Holosporales;””Caedimonadaceae””;Caedibacter </p></blockquote><h2 id="額外的句號"><a href="#額外的句號" class="headerlink" title="額外的句號"></a>額外的句號</h2><blockquote><p>LC552068 Conexivisphaera calida Archaea;Crenarchaeota;Conexivisphaeria;Conexivisphaerales;Conexivisphaeraceae;Conexivisphaera.</p></blockquote><h2 id="額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）"><a href="#額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）" class="headerlink" title="額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）"></a>額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）</h2><blockquote><p>KF863150 Hyphomonas adhaerens Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p></blockquote><h1 id="分類名稱間有額外的分隔符"><a href="#分類名稱間有額外的分隔符" class="headerlink" title="分類名稱間有額外的分隔符"></a>分類名稱間有額外的分隔符</h1><p>會導致該紀錄多一個分類階層 </p><blockquote><p>HQ223108 Thermoleophilum minutum Bacteria;Actinomycetota;;Thermoleophilia;Thermoleophilales;Thermoleophilaceae;Thermoleophilum</p></blockquote><h1 id="重複出現的分類名稱"><a href="#重複出現的分類名稱" class="headerlink" title="重複出現的分類名稱"></a>重複出現的分類名稱</h1><p>例如同樣的分類寫兩遍，或是整個條目寫了兩遍，會導致該紀錄增加多個分類階層</p><h2 id="門名重複出現"><a href="#門名重複出現" class="headerlink" title="門名重複出現"></a>門名重複出現</h2><blockquote><p>AJ288899 Bacteriovorax stolpii Bacteria;Bdellovibrionota;Bdellovibrionota;Bacteriovoracia;Bacteriovoracales;Bacteriovoracaceae;Bacteriovorax</p></blockquote><h2 id="整串分類名稱重複出現"><a href="#整串分類名稱重複出現" class="headerlink" title="整串分類名稱重複出現"></a>整串分類名稱重複出現</h2><blockquote><p>“AF082795 Hyphomonas rosenbergii Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p></blockquote><h1 id="誤植分類名稱"><a href="#誤植分類名稱" class="headerlink" title="誤植分類名稱"></a>誤植分類名稱</h1><p>在此例中，屬名 Amnimonas 被誤謄為 Aminomonas（這是另一個屬）例如因為形似而寫成其他分類名、打錯字，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p><h2 id="誤植-Aminomonas-→-Amnimonas"><a href="#誤植-Aminomonas-→-Amnimonas" class="headerlink" title="誤植 (Aminomonas → Amnimonas)"></a>誤植 (Aminomonas → Amnimonas)</h2><blockquote><p>MF682432 Amnimonas aquatica Bacteria;Pseudomonadota;Gammaproteobacteria;Moraxellales;Moraxellaceae;Aminomonas</p></blockquote><h2 id="錯字-Jatrophihabitantaless→Jatrophihabitantales"><a href="#錯字-Jatrophihabitantaless→Jatrophihabitantales" class="headerlink" title="錯字 (Jatrophihabitantaless→Jatrophihabitantales)"></a>錯字 (Jatrophihabitantaless→Jatrophihabitantales)</h2><blockquote><p>LC323105 Jatrophihabitans telluris Bacteria;Actinomycetota;Actinobacteria;Jatrophihabitantaless;Jatrophihabitantaceae;Jatrophihabitans</p></blockquote><h1 id="異名"><a href="#異名" class="headerlink" title="異名"></a>異名</h1><p>即條目間使用該分類群的不同名稱，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p><h2 id="異名-1"><a href="#異名-1" class="headerlink" title="異名"></a>異名</h2><blockquote><p>(Bdellovibrionia [synonym] → Oligoflexia [correct name])</p></blockquote><h2 id="俗名"><a href="#俗名" class="headerlink" title="俗名"></a>俗名</h2><blockquote><p>(Bdellovibrionota [not validly published] → Bdellovibrionota [correct name]) HM038000 Vampirovibrio chlorellavorus Bacteria;Bdellovibrionota;Oligoflexia;Bdellovibrionales;Bdellovibrionaceae;Vampirovibrio AJ292759 Bdellovibrio bacteriovorus Bacteria;Bdellovibrionota;Bdellovibrionia;Bdellovibrionales;Bdellovibrionaceae;Bdellovibrio</p></blockquote><h1 id="欠缺完整分類階層"><a href="#欠缺完整分類階層" class="headerlink" title="欠缺完整分類階層"></a>欠缺完整分類階層</h1><p>比其它條目少了一個分類階層 </p><blockquote><p> # Lack information at Genus level (Ulvibacterium)<br> KF303137 Aestuariibaculum scopimerae Bacteria;Bacteroidota;Flavobacteriia;Flavobacteriales;Flavobacteriaceae</p></blockquote><h1 id="檢查方式以及我們的義務"><a href="#檢查方式以及我們的義務" class="headerlink" title="檢查方式以及我們的義務"></a>檢查方式以及我們的義務</h1><p>這些問題的模式紛亂，其實不容易找到有效的偵測方法，以下枚舉幾個我曾用過的策略，</p><ul><li>以分隔符切割字串，檢查輸出字串列表當中，長度異常的條目</li><li>下載 LPSN 物種資訊，檢查未出現在 LPSN 的條目</li><li>檢查出現分號、括號、空格以外的符號的條目</li><li>利用這些方法檢查完畢後，就順道把自己的發現寄給他們，當作對資料庫維護團隊的感謝吧。</li></ul><p>最後，分享一個我原本以為是因為以下原因而產生的 typo …..</p><blockquote><p>VIFM01000001 Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis Bacteria;Myxococcota;Myxococcia;Myxococcales;Myxococcaceae;Myxococcus</p></blockquote><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_ptt.png?raw=true" alt="這難道不是因為某個老梗產生的物種名稱嗎......"></p><p>拿去 Goolge 才知道，還真的有名字這麼長的生物<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. *Genome biology and evolution*, 12(12), 2289-2302.">3</span></a></sup>，長到維基百科側欄都破圖了。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_wiki.png?raw=true" alt="名字太長了，網頁都破圖囉。"></p><p>Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis 命名自其被分離的地點，位於威爾斯安格爾西島的 Llanfair­pwll­gwyn­gyll­go­gery­chwyrn­drobwll­llan­tysilio­gogo­goch 小鎮，分離地點附近還有一間四星級飯店😮。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_map.png?raw=true" alt="分離地點附近有間四星級飯店"></p><p>註</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">All-Species Living Tree Project (LTP)  相關文獻，Yarza &amp; Munoz. (2014). The all-species living tree project. <em>In Methods in Microbiology</em> (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. <em>Systematic and applied microbiology</em>, 31(4), 241-250.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. <em>Msystems</em>, 3(3), e00021-18.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. <em>Genome biology and evolution</em>, 12(12), 2289-2302.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> metagenomics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寫論文的糟糕和美好經驗</title>
      <link href="/good-and-bad-experiences-in-journal-article-writing/"/>
      <url>/good-and-bad-experiences-in-journal-article-writing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我對論文寫作的第一印象是「寫論文很難，要花很長的時間才能完成，而且從準備到發表過程中會受到大量的批判，一路過關斬將才有機會嶄露頭角」。</p><p>所以每當開啟 word 檔開始打字的時候，都有起步的焦慮感：覺得自己還沒準備好，想要把文獻回顧完全，研究結果做到滴水不漏才有辦法動筆。</p><p>這種印象部分奠基於碩士論文寫作經驗，當時往往盯著螢幕許久沒有任何想法，最後歸因於自己文獻回顧不夠完整或是研究做得不夠完善。</p><p>我意識到阻礙我進展的是對於完美論文的期待，我期待論文能夠達到讓我感到愉悅和成就感的標準。</p><p>然而，人們總是無法在初稿時達到滿意的程度吧？而且論文需要於修改中逐漸精緻，沒辦法一蹴可幾，我的期待反過來成為我的壓力。</p><p>為了舒緩這種壓力和焦慮，我轉而把精力投注在文獻回顧或改進研究內容。雖然多做準備能暫時減緩我的焦慮和踏實感，但這只是將自己的壓力和負擔延後，之後將面對更多的時間、資源和要求的壓力。</p><span id="more"></span><h2 id="「發表論文的初衷是感謝」"><a href="#「發表論文的初衷是感謝」" class="headerlink" title="「發表論文的初衷是感謝」"></a>「發表論文的初衷是感謝」</h2><p>而我對論文的美好經驗則來自研究所的老師。我的指導教授從前曾問我：「你認為我們為什麼要投稿論文？」</p><p>從功利的角度講，Publish or Perish。發表論文是在學術界生存的根本，也是一個人能力的證據，舉凡畢業、獎學金、申請學校、公司求職、學校教職等皆可能需要論文作為能力的佐證。</p><p>然而，我的指導教授認為這些都只是其次，發表論文的初衷是感謝。</p><p>為什麼感謝？做研究總是關注著某些議題，為了解決問題，我們參考了這麼多文獻，我們正是對於前人的文獻表達感謝。</p><p>表達感謝的途徑有二，首先是引用這些文獻，彰明他們的貢獻；其次是基於這些文獻發展出我們的想法，促進對議題的理解，讓這些想法得以演化和繁衍下去。</p><p>科學是尋求解釋的活動，而我們對世界的認知並非一日造就而成的。無論是科學革命還是漸進式的科學史觀，當今的知識體系都是多人長年活動累積的結果，一項研究的鑄成往往有其思想根基和參考依據，無論是要贊同、反駁還是引發想法，都會踏過前人的足跡。</p><p>經過長期演變，論文已是紀錄和傳播科學活動成果的最有效和公認的媒介，研究和發表其實就是：我們感到疑惑，我們開始研究，我們參考了誰的想法和觀念，我們想到了一些點子和把持一些觀點。</p><p>我們想要提供一些新的解釋，我們感謝前人對於我們思想和研究的幫助，我們回饋學界這些觀念，用一種經過長期演變且公認最有效率的媒介，論文。</p><p>以感謝的角度來看待論文發表很大程度地舒緩了寫論文的恐懼和壓力，即使論文有那些功利價值，但我的指導教授還是提醒了我研究和發表理想和溫暖的一面。</p><h2 id="「一則文獻既不是最重要的也不是最不重要的」"><a href="#「一則文獻既不是最重要的也不是最不重要的」" class="headerlink" title="「一則文獻既不是最重要的也不是最不重要的」"></a>「一則文獻既不是最重要的也不是最不重要的」</h2><p>而對論文另一部份美好經驗則來自論文寫作課的老師。</p><p>有別於我的指導教授，寫作課老師從實用角度分析論文的寫作與發表，將論文寫作描述得很像 youtube 上頭 8 分鐘的 DIY 影片，好像我們在某個閒暇無事的下午，點開影片照著做就可以完成，不是什麼無法做到的事。</p><p>總結他的課程，他強調論文寫作縱使有那些功利價值，也不需要感到壓力，論文發表會被 reject 沒錯，但再換家推銷就好。</p><p>換句話說，寫作課老師讓我感受到，即使沒有達到最完美的狀況，論文還是有價值；即使還沒有準備好，也能開始動筆；即使能力還不夠，進展中就會有所成長；即使被批判，那也是很自然，因為這都是科學過程的一部分。</p><p>一則文獻既不是最重要的也不是最不重要的，科學重視的是合理而非真理，文獻呈現的是探索的過程，我們沒辦法在一則文獻中完全佐證我們的主張或對世界的看法。</p><p>錯誤與正確都是研究累積後，後世對我們的評價而已，所以不用太擔心文獻被批判等等，這本來就是科學新陳代謝的一環。</p><h2 id="正向寫作經驗的關鍵"><a href="#正向寫作經驗的關鍵" class="headerlink" title="正向寫作經驗的關鍵"></a>正向寫作經驗的關鍵</h2><ul><li><strong>寫作是 routine</strong>：寫作跟運動很像，寫作的愉悅需要一點投資，最重要的投資就是起步的意願，隨後是堅持的決心。寫作是 routine，而非儀式行為。是以，治療寫作不快或抑鬱的方法跟控制慢性病一樣，每天吃藥（寫作）。</li><li><strong>參與感</strong>：讓寫作交流可以提升寫作的回饋感，因為寫作終究是科學交流的一部份。透過研討會、一對一討論、編修等途徑，可以從中得到寫作靈感而疏通寫作瓶頸，也可以從交流中獲得參與感和社群歸屬，最終得到「意義」</li><li><strong>正面看待評論</strong>：看待拒稿和批評的認知轉換有助於降低寫作的恐懼，投稿寫作就跟賣東西一樣，一定有人買，只是看誰會買和賣什麼價碼而已。論文跟基因不一樣，別人罵你先天特徵是沒機會改變，但別人批評論文內容有改善的機會。</li><li><strong>分享的心</strong>：如果真心喜歡自己的研究，那寫作就是分享自己熱情和喜好的管道。若有類似的經驗便能體會為什麼用分享看待寫作可以增加正向寫作經驗。</li></ul><h2 id="當然還是有糟糕的經驗"><a href="#當然還是有糟糕的經驗" class="headerlink" title="當然還是有糟糕的經驗"></a>當然還是有糟糕的經驗</h2><p>儘管羅列了一堆美好經驗和建立正面想法的「要點」，寫論文還是有坐困愁城和自我質疑的時候，像是指示牴觸價值觀、結果不明又不想自欺欺人、截止日到但品質不滿意等等。</p><p>舉我的例子來說，我不太習慣被 Paul Nurse 稱之為「修正主義 (revisionist)」的科學敘事 (Nurse. (2016). Cell, 165(6), 1301-1306.)。就我理解，這是指論文敘事隱藏了科研的意外與不可控，調整文章內容以說個毫無破綻的好故事，而不是說個貼近事實的發現歷程。</p><p>最容易接觸這類修正主義的途徑可能是台灣的理科教科書。從歐幾里得、牛頓、孟德爾、波爾、拉瓦節，課本呈現的是生硬且不直觀，但和諧線性的科學史觀。理論的發展與邏輯的推演高度相符，彷彿有了前提、假設和足夠的測量，理論即順水推舟浮現，科學史跟課本都能一併翻向的新頁。</p><p>我想，為了溝通的效率，精簡內容和梳理邏輯是撰寫論文的必要過程。然而，當論文呈現與事實迥異的發現軌跡，後人要追溯某項理論的沿革時，只能走在一條虛構的途徑上，而這條途徑很可能只在想像中行得通。</p><p>等到開始寫論文，我也希望自己能夠避免這種狀況，想盡可能讓論文的敘事貼近發現的過程，保留激發研究點子的關鍵因素，討論理論與結果衝突的理由與和解方式，而不是為了結果而調整敘述過程的方向。</p><p>雖然只是一點點，但我也想要為自己認同的理念和未來做點事。不過，我後來才體會到，論文寫作還是有協商的因素存在，與合作者的協調、與計畫主持人的溝通、與編輯和審閱者的答辯等等。</p><p>我想這些合作與協商是必要的，只是折磨之處在於，若討論不是基於事實與道理，而是訴諸權威或群眾等無關論文內容的事情，那麼我有點難克服下筆時的抗拒感。</p><h2 id="但我還是想記住好的"><a href="#但我還是想記住好的" class="headerlink" title="但我還是想記住好的"></a>但我還是想記住好的</h2><p>儘管如此，我其實是喜好寫作表達想法的，我覺得將自己的主張和論證陳述清楚，嘗試去說服別人的過程仍值得投入。</p><p>畢竟寫論文也是一種發聲管道，若渴望能依照這途徑去實踐或改變什麼，那是否要做下去也非取決於經驗的好壞，而是渴望的程度。</p><p>既然如此，傾聽內心裡較良善的聲音讓自己有動力做下去，我覺得會比被糟糕回憶困住半途而廢還來得有機會幫助自己達到目標。</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextflow｜程式碼區塊的跳脫符號 (escape characters)</title>
      <link href="/nextflow-escape-characters/"/>
      <url>/nextflow-escape-characters/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹程式碼定義變項的符號與 nextflow 內建語法衝突時，有哪些選項可以解決之。</p><span id="more"></span><h2 id="Nextflow-管理程式的單位"><a href="#Nextflow-管理程式的單位" class="headerlink" title="Nextflow 管理程式的單位"></a>Nextflow 管理程式的單位</h2><p>Process 是 Nextflow 管理程式的單位，其中必然包含 script 區塊來定義想執行的程式。除了 script 區塊，還有 directives（環境設置）、inputs（輸入資料）、outputs（輸出資料）等非必要但有助流程控管的區塊。</p><p>在執行程式前，Nextflow 會解讀 script 區塊帶有 <code>$</code> 前綴的變項，代入 inputs、parameters 或 config files 的對應內容。<br>以 process fastQC 為例，nextflow 將 <code>fq</code> (input) 的內容代入 <code>$&#123;fq&#125;</code> (script) 後才執行程式，再將輸出結果透過 <code>fqc</code>(output) 傳遞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process fastQC &#123;</span><br><span class="line">    publishDir &quot;$&#123;params.outdir&#125;/qc&quot;, mode: &#x27;copy&#x27;, overwrite: true</span><br><span class="line">    input:</span><br><span class="line">        path fq</span><br><span class="line">    output:</span><br><span class="line">        path &quot;*_fastqc.&#123;zip,html&#125;&quot; into fqc</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fastqc --nogroup -q $&#123;fq&#125;</span><br><span class="line">    &quot;&quot;&quot;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程式碼與nextflow-語法衝突"><a href="#程式碼與nextflow-語法衝突" class="headerlink" title="程式碼與nextflow 語法衝突"></a>程式碼與nextflow 語法衝突</h2><p>值得留意的是，perl 或 bash 等語言也使用 <code>$</code> 標記變項（例如：<code>$i</code>、<code>$path</code>）。Nextflow 無法區分以 <code>$</code> 為前綴的變項是定義在 script 內（script 變項），還是得自於 inputs, parameters 或 config files（nextflow 變項）。</p><p>因此，如果程式碼出現以 <code>$</code> 定義或呼叫的 script 變項 ，nextflow 便有可能因為無法在 inputs、parameters 或 config files 找到對應內容而報錯。</p><p>舉以下案例來說，<code>title</code>&#x2F;<code>$title</code> 是使用 bash 定義的 script 變項。然而，nextflow 卻誤判該變項的來源，以至於找不到其內容（<code>No such variable</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># printPath.nf</span><br><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title=&quot;The current directory is,&quot;</span><br><span class="line">    echo &quot;$title \n $PWD&quot;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    printDir().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run printPath.nf</span><br><span class="line">Error executing process &gt; &#x27;printDir&#x27;</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">    No such variable: title -- Check script &#x27;printDir.nf&#x27; at line: 4</span><br></pre></td></tr></table></figure><p>對於這個問題，主要的解法是透過更換標記符號來區分 script 變項和 nextflow 變項。</p><h2 id="更換-nextflow-變項的標記符號"><a href="#更換-nextflow-變項的標記符號" class="headerlink" title="更換 nextflow 變項的標記符號"></a>更換 nextflow 變項的標記符號</h2><p>第一種方法是改以三個單引號夾註程式碼，提示 nextflow 改以 <code>！&#123;&#125;</code> 標記 nextflow 變項。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure><pre><code>title=&quot;The current directory is,&quot;echo &quot;$title \n $PWD&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="更換-跳脫-script-變項的標記符號"><a href="#更換-跳脫-script-變項的標記符號" class="headerlink" title="更換 (跳脫) script 變項的標記符號"></a>更換 (跳脫) script 變項的標記符號</h2><p>若 script 變項不多，也可以在 <code>＄</code> 前面加上反斜線(<code>\$</code>)，提示 nextflow 忽略 <code>$</code> 符號。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure><pre><code>title=&quot;The current directory is,&quot;echo &quot;\$title \n $PWD&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="更動跳脫字元"><a href="#更動跳脫字元" class="headerlink" title="更動跳脫字元"></a>更動跳脫字元</h2><p>由於 nextflow 的底層是 groovy，所以除了 script 與 nextflow 的語法衝突，也可能碰到 script 與 groovy 語法衝突的狀況。</p><p>以下兩個案例都在 script 區塊使用反斜線來編輯文字。由於反斜線是 groovy 預設的跳脫符號，所以執行這些 processes 時也可能發生編譯錯誤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sepReplace.nf</span><br><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    sepReplace().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run sepReplace.nf</span><br><span class="line">(skip)</span><br><span class="line">Command error:</span><br><span class="line">    .command.sh line3: unexpected EOF while looking for matching `&quot;&#x27;</span><br></pre></td></tr></table></figure><p>或是<a href="https://github.com/nextflow-io/nextflow/issues/67">這個案例</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># strRemove.nf</span><br><span class="line">process strRemove &#123;</span><br><span class="line">    outpur:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    echo &quot;Hello lg:en&quot; | sed &quot;s/.*lg:\(.*\).*/\1/&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    strRemove().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nextflow run strRemove.nf</span><br><span class="line">Script compilation error</span><br><span class="line">- file : /path/to/workdir/strRemove.nf</span><br><span class="line">- cause: Unexpected character: &#x27;\&#x27;&#x27; @ line 4, column 7.</span><br><span class="line">       &#x27;&#x27;&#x27;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure><p>碰到這種情形，首先要使用 <code>$/</code> 和 <code>/$</code> 夾註程式碼，提示 groovy 改以 <code>$</code> 作為跳脫符號，以區分 script 和 groovy 語法。</p><p>接著，在 script 變項的 <code>$</code> 前面再加一個 <code>$</code> (<code>$$</code>)，提示 nextflow 忽略 <code>$</code> 符號，以區分 script 和 nextflow 語法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    $/</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    /$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封裝為腳本"><a href="#封裝為腳本" class="headerlink" title="封裝為腳本"></a>封裝為腳本</h2><p>不過，如果程式碼用到大量變項，前述方法會讓程式碼顯得囉嗦又不易讀。此時，可以考慮將程式碼封裝為腳本，再從 script 區塊呼叫。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># sepReplace.sh</span><br><span class="line">str=&quot;A,B,C&quot;</span><br><span class="line">echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    $baseDir/sepReplace.sh</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為 nextflow、bash、perl 都以 <code>$</code> 標記變項，所以執行 process 時可能會無法正確辨識 script 區塊內的變項來源而報錯。可能的解決途徑如下，</p><ul><li><strong>nextflow 變項少</strong>：以三個單引號夾註程式碼，再以 <code>！&#123;&#125;</code> 標記 nextflow 變項</li><li><strong>script 變項少</strong>：以 <code>\</code> 跳脫 script 變項的 <code>$</code></li><li><strong>出現反斜線</strong>：以 <code>$/</code> 和 <code>/$</code> 夾註程式碼，再以 <code>$</code> 跳脫 script 變項的 <code>$</code></li><li><strong>程式碼龐雜</strong>：將程式碼封裝為腳本，再從 process 呼叫腳本</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nextflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何下載和安裝 RDP classifier</title>
      <link href="/how-to-download-and-install-rdp-classifier/"/>
      <url>/how-to-download-and-install-rdp-classifier/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RDP classifier 是基於 Naive Bayes 的物種分類器，常用於註解 16S rRNA 基因序列的分類資訊。除了使用內建的 RDP 資料庫以外，RDP classifier 也允許使用自訂資料庫來訓練分類器。除了內建的 RDP database，也支援以其他資料庫來訓練分類器。</p><p>目前，RDP classifier 的核心演算法已被整合到 Mothur 和 DADA2 等流程的副程式庫，所以只要有安裝這些流程軟體，即使沒有安裝 RDP classifier，也能以相同的演算法註解物種資訊。然而，若想要依據自訂或最新的資料庫註解序列，或是使用 copy number 校正等功能，仍有獨立使用 RDP classifier 的必要。</p><p>本文將介紹三種下載和安裝 RDP classifier 的方式。</p><span id="more"></span><h2 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h2><p>透過 conda 安裝的方式可參考 <a href="https://anaconda.org/bioconda/rdp_classifier">Anaconda 的教學</a>。目前，conda 與 RDP 官網提供的 classifier 皆為最新的 2.13 版。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda rdp_classifier</span><br><span class="line">conda install -c bioconda/label/cf201901 rdp_classifier</span><br></pre></td></tr></table></figure><h2 id="官方網站"><a href="#官方網站" class="headerlink" title="官方網站"></a>官方網站</h2><p>若不想要裝一堆附加的軟體或剛好 conda 沒有需要的版本，也可以直接到官網提供的<a href="https://sourceforge.net/projects/rdp-classifier/">連結</a>下載可執行檔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/rdp-classifier/rdp-class</span><br><span class="line">ifier/rdp_classifier_2.13.zip</span><br><span class="line">unzip rdp_classifier_2.13.zip</span><br><span class="line"><span class="built_in">chmod</span> u+x path/to/rdp_classifier_2.13/dist/classifier.jar</span><br></pre></td></tr></table></figure><p>由於 RDP classifier 是依賴 JAVA 的軟體，所以執行時要輸入 .jar 的絕對路徑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar &lt;<span class="built_in">command</span>&gt;  </span><br><span class="line">&lt;parameters&gt;</span><br></pre></td></tr></table></figure><p>為了簡化指令，可以創造名為 rdp_classifier 的腳本，並將腳本所在的目錄加入環境變數。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch rdp_classifier</span><br><span class="line">chmod u+x rdp_classifier</span><br><span class="line">vim rdp_classifier</span><br></pre></td></tr></table></figure><p>接著把落落長的指令放到腳本中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar $*</span><br></pre></td></tr></table></figure><p>如此一來，往後執行時就只需要輸入 rdp_classifier即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdp_classifier &lt;<span class="built_in">command</span>&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>若是 Ubuntu，則可以從套件庫安裝。只是相較於 conda，ubuntu 套件庫內的 RDP classifier 還<a href="https://packages.ubuntu.com/impish/rdp-classifier">停在 2.10 版</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get -y install rdp-classifier</span><br></pre></td></tr></table></figure><p>除了前述方法，也能夠安裝集合了 RDP 團隊包含了 classifier 在內各種開發工具的 <a href="https://github.com/rdpstaff/RDPTools">RDPTools</a>。只是 RDPTools 是透過 make 和 makefile 來編譯與安裝。由於依賴的軟體和環境設定等問題，我到現在還沒成功過，暫時無法整理出相關的筆記。</p>]]></content>
      
      
      
        <tags>
            
            <tag> metagenomics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R/Rstudio console 的指令長度限制</title>
      <link href="/r-console-upper-limit-on-the-string-length/"/>
      <url>/r-console-upper-limit-on-the-string-length/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>TL:DR：輸入 R&#x2F;Rstudio console 的指令之容量上限為 4095 bytes。若超出上限，console 會忽略超出的部分，顯示 + 提醒使用者補完剩餘指令。</p><span id="more"></span><p>今天測試定序前處理的 pipeline 時，發現總是無法順利讀檔。為了 debug，我把所有檔案的輸入路徑存為一個字串，並複製到 R console，重跑其中一個 function。結果 console 上印出一個 + 號，function 仍無法運作。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> parse_path<span class="punctuation">(</span><span class="string">&quot;....&quot;</span><span class="punctuation">)</span> <span class="comment"># 這是長度約三千多個字符的字串</span></span><br><span class="line"><span class="operator">+</span></span><br></pre></td></tr></table></figure><p>我第一個反應是檢查括弧的數量和位置是否正確，接著仔細看檔案路徑中有沒有跳脫字符。然而，怎麼檢查都沒有留意到語法錯誤，於是開始丟各種長度和內容的字串測試。</p><p>後來，我發現只要刪除部分字串，function 又可以順利執行了，所以我猜 R 的字串可能有長度上限？循著這猜想，我在網路上找到不少面臨相似問題的人，例如：</p><ul><li><a href="https://stackoverflow.com/questions/28399710/storing-long-strings-dna-sequence-in-r">storing long strings (DNA sequence) in R</a></li><li><a href="https://stackoverflow.com/questions/54974996/how-to-bypass-rstudio-console-upper-limit-on-character-string-length">How to bypass RStudio console upper limit on character string length?</a></li></ul><p>最終，我才在<a href="https://community.rstudio.com/t/does-console-impose-an-upper-limit-on-the-length-of-strings/12872">這則問題</a>找到答案：輸入的字串被刪節確實是因為其大小超出限制，但並非超出 character 存儲上限，而是超出 R&#x2F;Rstudio console 的上限。</p><p>舉例來說，我們可以用 paste0 和 rep 建立長字串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>再使用 nchar 統計字串長度。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span>seq<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>然而，若把字串印出，再完整貼到 console 裏執行。由於字串大小超出 console 上限，所以 nchar 便無法順利運作了。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span> <span class="string">&quot;ABCDEFGABCDEFGABCDEFG......&quot;</span> <span class="punctuation">)</span></span><br><span class="line"><span class="operator">+</span> </span><br></pre></td></tr></table></figure><p>當然，字串也有其容量上限，這上限應該是取決於記憶體容量。這狀況，R 會直接告訴我們容量不足，而不是顯示讓人困惑的 +。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">100000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error<span class="operator">:</span> cannot allocate vector of size <span class="number">745058.1</span> Gb</span><br></pre></td></tr></table></figure><p>有趣的是，數字再大一點時數字會以科學記號表示，不符合 rep 的輸入規範，也會顯示錯誤。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000000000000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error <span class="keyword">in</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1e+21</span><span class="punctuation">)</span> <span class="operator">:</span> invalid <span class="string">&#x27;times&#x27;</span> argument</span><br></pre></td></tr></table></figure><p>這些道理我都懂，可是，我的 pipeline 是以腳本執行啊，怎麼還會碰到這問題？經過一番苦思，發現 bug 出在我的程式邏輯上，跟本文提到的限制一點關係都沒有。</p><p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/r-console-upper-limit-on-the-string-length.png?raw=true" alt="meme, it&#39;s my fault, not R&#39;s"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《西線無戰事》</title>
      <link href="/remarque-1928-im-westen-nichts-neues/"/>
      <url>/remarque-1928-im-westen-nichts-neues/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本書並非控訴，也非懺悔。它試圖報導一個被戰爭摧毀的世代——儘管有些人得以在炮火下幸免於難。</p></blockquote><p>年輕人在追求國族主義的師長鼓吹下，即使帶有疑慮，仍在「民族」、「愛國」、「勇氣」等氛圍下從軍。然而，和崇高精神相悖的軍隊文化很快地磨耗青年人的熱情。軍隊唯一的目的是把所有人鑄成合格的士兵其中不注重思想，只在乎規矩和系統。</p><span id="more"></span><p>軍隊也是個能讓人不受限地欺壓他人的環境，無意義的操練和沒用的懲戒只因上級作威作福的想法就施加在士兵上。這種壓迫比敵國威脅或崇高精神更能促成同袍的情誼，但很諷刺地，比起敵人，這些逼迫百姓拿起武器對抗另一群百姓的軍官和政府還更加可憎。</p><p>然而，戰場上的士兵為了自保沒得選擇。即使明白對壘的敵人也是政府的棋子，卻只能忽略對方的人性，將對方想像成殺人兵器。如此一來，才能讓自己冷酷地執行任務，不被道德和倫理問題搞瘋。即使離開前線，回到生活中的士兵仍因戰爭壓力而無法想遠，僅能得顧且過，為了滿足最基本的需求而活。這些年輕人不若其他成年人和老年人，在戰爭外仍和世界有所連結，可以為其他寄託而活。</p><p>這些年輕人才和學校告別就上了戰場，對於未來仍沒有想法與目標，其過去又貧乏空白，像失根的植物，被扔進戰爭的渦流不得脫身。他們經驗裡只有砲聲、槍擊與榴彈，想像中只有恐懼和焦慮，沒有未來。</p><p>儘管一次大戰開啟了總體戰先聲，但德國境內未受到嚴重波及。儘管如此，這群年輕人在家鄉僅存的美好回憶也因戰事變得陌生。與血腥戰場脫節的居民無視士兵的慘痛經歷，用空虛的榮耀嘉許疲累的士兵，高談闊論些無謂的決策。</p><p>於是，家鄉已不再是家鄉，昔日成了陰影，永遠把步入戰場的士兵隔離在外。他們唯一能依靠的，是共歷生死的戰友。</p><p>隨著戰鬥持續，德國雖然維持帳面上的軍力，卻得動用老弱殘兵上陣。未經嚴格訓練的士兵在戰場純為砲灰，即使老兵想出力救援也無可奈何。戰爭末期，談和的傳聞日上，但士兵的焦慮只是越來越重，深怕他們會在和平的前一刻死去。</p><p>但，活著又代表什麼？老一輩的人將回到他們過往的生活，新生代的人要從廢墟中重建，可是戰爭世代的人要往哪去？在故事最後，主角的死也許是最好的結局了。陌生的家鄉，離世的同袍，茫然的未來，僅剩死亡是明朗。</p><p>最終，一個人的悲劇在政府軍方的報告中化為「西線無戰事」五個字，於歷史中遺忘。</p><p>雷馬克的手法沒有用太多華麗的詞藻，就是用一個個場景表現悲哀。戰爭、軍事、政治會搞砸自有原因，所以我猜他才會說這本書不是控訴和懺悔，而是無奈的描寫。</p><p>當今的各種國際或社會問題都沒有簡單的答案。即使想解決問題，也需要知識與道理。對此，小說家或許是最無力的，但他們的著作是讓人察覺問題的管道。我認為，作品引發的顫慄、不安、詭譎、悲憤、懷疑、宏大等感受是起身做些什麼的起點。</p><p>回到此書，我挺能體會士兵恨敵人還沒恨士官強烈的感受。另外，我相信備戰是維持和平的重要手段。不過有時看到電視政論或網路論壇討論也會想，若能了解戰爭的沉重，還有人能鼓吹戰爭或對其產生什麼幻想嗎？基於這樣想法的戰爭會把我們變成什麼模樣呢？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎麼決定合併雙端序列時允許的錯配數量？</title>
      <link href="/how-to-decide-max-mismatch-when-merging-paired-end-reads/"/>
      <url>/how-to-decide-max-mismatch-when-merging-paired-end-reads/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>illumina 的 Miseq 和 Hiseq 平台常用於定序 16S rRNA 基因特定變異區的增幅產物。因為這兩平台皆屬雙端定序 (paired-end sequencing)，所以每一條 DNA 都會獲得順向和逆向的序列（即定序結果）。在資料處理時，須比對這對序列的重疊區域，再基於重疊區域合併雙方，才能重建出代表該 DNA 的完整序列。</p><p>不管使用的軟體為 FLASH 、PEAR 還是 Usearch，合併雙端序列時都有許多參數可以設定。其中一個參數是合併時允許的錯配數量。這參數的必要性在於，即使順向和逆向序列都源於同一條 DNA，兩者的重疊區域仍會因為定序錯誤而略有差異。合併時允許少量的錯配數量能避免捨棄掉這些正確的序列。</p><p>然而，我們要怎麼知道洽當的錯配數量上限？使用預設值、反覆試誤、調查文獻都是常見的方法，不過我更想要知道能依照資料選定適用參數的策略。畢竟，如果能先推算出理論值，那麼測試時便有參考的基準，除了能縮減試誤時間，在寫論文或向他人解釋方法時也比較有依據。</p><p>因此，雖然在資料處理流程已成熟的今日，糾結參數設定可能被視為無關宏旨，我還是想以本文紀錄，自己思考這個問題的方向與看法。</p><span id="more"></span><p>首先，順逆向序列的重疊區只要有任一列發生定序錯誤便會發生錯配。由於 illumina 定序平台的逆向序列品質往往較順向序列品質低，假設不計兩序列同時出錯的狀況，重疊區的錯配數量可由逆向序列的預期鹼基錯誤數量估計。</p><p>由於 illumina 定序平台的逆向序列品質往往較順向序列低，而且重疊區任何一條序列發生定序錯誤便會造成錯配。假設不計兩序列於相同位點同時出錯的狀況，那麼重疊區的錯配數量上限，可以由逆向序列的預期鹼基錯誤數量估計：錯配數量 &lt; 逆向序列重疊區的預期鹼基錯誤數 * 2</p><p>舉例來說，若增幅和定序 16S rRNA 基因 V4 區域之後，獲得一對長度為 250 bp 的序列。由於 V4 區域大約只有 253 bp 長，所以這對序列的重疊區長達 247 bp，幾乎覆蓋了整個 V4 區域。</p><p>假設考慮最極端的狀況，即要在順向和逆向序列的每個鹼基都完全對應時，我們才肯相信合併後的序列源於同一條 DNA。那麼，在逆向序列平均品質分數為 20 的狀況下，重疊區的預期錯誤數量為 $0.99 * 247 &#x3D; 2.47$。</p><p>這意味著，即使是這對序列得自於同一條 DNA，平均而言也會出現 $2.47 * 2 &#x3D; 4.94$ 個錯配。因此至少要允許 5 個錯配，才能確保這些源於同一條 DNA 的正確序列能順利合併。</p><p>推廣來說，錯配數量上限取決於重疊區的長度與品質。隨著對重疊區長度的要求放寬，預期的鹼基錯誤數會跟著下降，允許的錯配數量也得調低，才能確保合併雙端序列的特異性和靈敏度平衡。</p><p>依照這個推論，在取得資料時，可以先思考「若這對序列沒有定序錯誤，要有多長的重疊序列，才肯相信它們得自於同一條DNA」。</p><p>接著，找到平均品質最差的那個樣本的逆向序列，計算其 3’ 端重疊區域的預期鹼基錯誤數（該段區域的定序錯誤率之和），得出數值的兩倍，應該可以當作測試雙端序列合併的參數的起始值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ngs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排遺與腸道樣本的細菌群落差異</title>
      <link href="/difference-in-bacterial-communities-between-fecal-and-intestinal-samples/"/>
      <url>/difference-in-bacterial-communities-between-fecal-and-intestinal-samples/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>哺乳動物的排遺樣本代表游離於腸道腔室的細菌（luminal microbes），黏膜樣本則反映棲居於腸道黏膜細菌（mucosal microbes）。許多研究指出，排遺樣本與黏膜樣本的細菌群落組成有別。</p><p>例如，在排序分析當中，樣本點往往依採樣部位分群。這意味著排遺樣本未必能反映腸道黏膜的細菌群落組成，而這些細菌的組成與宿主許多生理與疾病相關。</p><span id="more"></span><h1 id="上消化道與下消化道的物種和功能基因組成不一"><a href="#上消化道與下消化道的物種和功能基因組成不一" class="headerlink" title="上消化道與下消化道的物種和功能基因組成不一"></a>上消化道與下消化道的物種和功能基因組成不一</h1><p>Suzuki &amp; Nachman<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Suzuki & Nachman. (2016). Spatial heterogeneity of gut microbial composition along the gastrointestinal tract in natural populations of house mice. PloS one, 11(9), e0163720.">1</span></a></sup> 比較雌雄各半，共六隻家鼠從口腔到排遺等消化道十個部位的細菌群落。他們發現，上消化道與下消化道的物種和功能基因組成不一。此發現可為基於分類和功能資訊的 PCoA 分析佐證：來自上和下呼吸道的樣本可以明顯區分為兩群。</p><p>相較於消化道部位，飲食或個體差異對於整個消化道的變異沒有什麼影響。值得留意的是，排遺與下消化道的細菌群落相似，所以作者推論排遺樣本可以反映下消化道的細菌群落組成。</p><p>由於此研究採用的分類階層僅至於科，所以排遺與下消化道的細菌群落在屬與種的層次是否相似仍須釐清。此外，我留意到論文方法裡沒提到是否有清理黏膜上的殘渣。如果沒有清腸，仍會保留部分游離菌叢和黏膜菌叢，那麼排遺與下消化道樣本會很相似應該是可以預期的。</p><h1 id="排遺樣本的細菌多樣性低於腸道樣本"><a href="#排遺樣本的細菌多樣性低於腸道樣本" class="headerlink" title="排遺樣本的細菌多樣性低於腸道樣本"></a>排遺樣本的細菌多樣性低於腸道樣本</h1><p>Durbán et al.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Durbán et al. (2011). Assessing gut microbial diversity from feces and rectal mucosa. Microbial ecology, 61(1), 123-133.">2</span></a></sup> 提及排遺包含了因無法拓殖而游離在腸道的細菌，以及脫離黏膜的共棲菌。因此，需要比較排遺與黏膜樣本的差異，釐清排遺樣本的代表性。</p><p>此研究以人體為材料，採取了和以往研究不同的策略，即分別採集黏膜樣本和糞便樣本，並且(1) 盡可能縮短樣本採集的時間間隔，(2) 事前不清腸，降低技術誤差。</p><p>結果指出，排遺樣本的細菌多樣性低於腸道樣本。其次，排序分析亦顯示細菌群落組成因採樣位置而異，意味著排遺樣本無法忠實反映黏膜樣本的微生物相。</p><p>儘管如此，通過排遺樣本推斷腸道細菌群落暫無替代方案。因此，這類研究的用意，並非否定排遺樣本的價值，而是藉此減少這些差異造成的誤判。</p><h1 id="健康人體排遺與黏膜細菌群落有別"><a href="#健康人體排遺與黏膜細菌群落有別" class="headerlink" title="健康人體排遺與黏膜細菌群落有別"></a>健康人體排遺與黏膜細菌群落有別</h1><p>Carstens et al.<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Carstens et al. (2018). Differential clustering of fecal and mucosa‐associated microbiota in ‘healthy’individuals. Journal of Digestive Diseases, 19(12), 745-752.">3</span></a></sup> 觀察健康人的排遺與黏膜細菌群落差異：</p><ul><li>以 NMDS 排序樣本，發現黏膜樣本的組內差異較排遺樣本小 </li><li>黏膜樣本的多樣性略大於排遺樣本</li><li>個體在門分類階層的細菌族群規模在兩類樣本中不同</li></ul><p>我猜，黏膜樣本的變異小於排遺樣本是否跟飲食汙染有關？因為排遺樣本的細菌群落變化不只跟黏膜細菌的變遷有關，也可能隨飲食內容影響。若是如此，是否會造成在新生兒上觀察到的階段性變化並非共棲菌組成改變，而是因為源於飲食的細菌不再補充？</p><h1 id="野生蝙蝠的排遺與黏膜細菌群落有別"><a href="#野生蝙蝠的排遺與黏膜細菌群落有別" class="headerlink" title="野生蝙蝠的排遺與黏膜細菌群落有別"></a>野生蝙蝠的排遺與黏膜細菌群落有別</h1><p>Ingala et al.<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Ingala et al. (2018). Comparing microbiome sampling methods in a wild mammal: fecal and intestinal samples record different signals of host ecology, evolution. Frontiers in Microbiology, 9, 803.">4</span></a></sup> 的研究觀察不同種蝙蝠的糞便微生物相與腸道黏膜微生物相差異，發現野生蝙蝠的排遺與黏膜細菌群落有別，且分別反映了宿主的飲食與親緣關係。</p><p>此研究指引了黏膜樣本與排遺樣本差異的可能原因。不過，我曾思考，為何這類研究都會同時比較 weighted UniFrac 呢？假設黏膜樣本與排遺樣本的差異源於飲食，那是不是主要區別在於物種而不是相對數量？況且兩種地方的採樣方式評估的數量誤差應該都很大，是不是單用 unweighted UniFrac 比較適合？</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>相較於游離在腸腔的細菌，棲息於黏膜的細菌因為在空間和時間上與宿主更為密切，被視為與宿主的生理乃至演化有關。目前有許多研究在探討腸道細菌對宿主消化、免疫、發育與神經等系統健全的影響。</p><p>基於共棲細菌與宿主的關聯，亦有研究著重於兩者的譜系共生現象 (phylosymbiosis)，即共棲微生物組成差異能充分反映宿主間的親緣關係。此現象在演化方面，暗示了微生物與宿主歷史上互動的線索；在生態方面，則蘊藏微生物群落構建與演替機制的蛛絲馬跡。</p><p>雖然本文摘要的幾則文獻一致顯示排遺與腸道樣本有別，但因為腸道樣本不易取得，透過排遺樣本推論腸道細菌群落仍是主流。在小鼠研究中，往往要靠解剖來採集腸道樣本，但這麼一來，便無法取得個體的時間序列資料。</p><p>在人體當中，採樣的限制又更多了。常見的方法是研究割盲腸或切胃等手術後移除的組織，或是利用內視鏡採樣。儘管內視鏡採樣似乎能獲得各部位的時間序列資料，不過施術前要清腸，能影響腸道的微環境。</p><p>其次，內視鏡伸進腸道的過程絕對不好受，所以不太可能達到排遺樣本的採樣頻率。至於位於小腸的細菌群落，因為位置關係，目前各種方法都不容易採集。</p><p>因此，或許要把排遺與腸道樣本當作互補的資訊：前者採樣容易，後者採樣困難；前者採樣頻率高，後者採樣頻率低；前者資訊較攏統，後者資訊較具體；前者可用於健康檢驗與時間序列；後者可用於觀察與驗證結果。</p><p>透過比較排遺與腸道樣本差異，可釐清排遺樣本的代表性，了解研究結論的推廣性。除此之外，兩種樣本的差異，或許也反映了長期棲居與短暫停留的細菌，例如從母乳、腸道和排遺樣本的組成，也許可以推論細菌由母親直系傳遞給子代的途徑。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Suzuki &amp; Nachman. (2016). Spatial heterogeneity of gut microbial composition along the gastrointestinal tract in natural populations of house mice. PloS one, 11(9), e0163720.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Durbán et al. (2011). Assessing gut microbial diversity from feces and rectal mucosa. Microbial ecology, 61(1), 123-133.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Carstens et al. (2018). Differential clustering of fecal and mucosa‐associated microbiota in ‘healthy’individuals. Journal of Digestive Diseases, 19(12), 745-752.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Ingala et al. (2018). Comparing microbiome sampling methods in a wild mammal: fecal and intestinal samples record different signals of host ecology, evolution. Frontiers in Microbiology, 9, 803.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> microbiota </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>樹之歌</title>
      <link href="/haskell-2017-the-songs-of-trees/"/>
      <url>/haskell-2017-the-songs-of-trees/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>歌，是有序的聲音；聲音，則是波動的一種形式。若沒有變動與交互作用，也就不會產生聲音。因此，聲音也是網路的一項性質。</p><p>Haskell 以樹木為觀察對象，描述樹木與雨水、風、動植物、微生物等事物互動發出的聲響，揭示了看似孤立的樹，實則串聯萬物的生命史，形成龐雜的生命網路。</p><span id="more"></span><p>除了科普生態與植物學知識，Haskell 亦借題簡介有關的生態議題，探討人類應抱持何種倫理觀點，看待因開發造成的生態破壞。究竟要把人類視為自然的一部份，而連帶將汙染與滅絕視為無須干預的現象？還是劃清人類與自然的界線，強調人類維護自然的責任？</p><p>Haskell 認為，前者會陷入虛無主義，後者則忽略了人的自然性。因此，真正的答案，或許得回歸生物網路之中，我們需要把自己放在自然網路的脈絡思考，而不是單用人類這物種的觀念看待自己。</p><p>畢竟，塑造我們的不只是這副軀體，還有環境、共棲微生物、作物和獵物等。所有的生命過程，都是網路中的一個節點和其他節點形成持續變動的關係。透過這是腳，我們能漸漸體會何者為美，何者為值得保護的東西，什麼又代表好，從而找出人類在全球變遷中該負起何種道義責任。</p><p>這本書讀起來，像帶有自然書寫風格的抒情文，用字遣詞華麗而浪漫。在此紀錄書中一些有趣的概念。</p><ul><li><strong>雨的語言</strong>：由於各地的空氣粒子組成不同，黏附著不同懸浮粒子的雨水也就蘊含著各自的語彙和文法。</li><li><strong>植物的記憶</strong>：植物雖然不像動物以電流傳遞訊號，但也會用化學留住事件的傷痕。我想，如果延伸「疤痕是種記憶」的想法，那麼因為河流侵蝕而留下的河谷，是不是也算得上大地的記憶了？</li><li><strong>歌的來源</strong>：書中提到克丘亞族相信，樹木與河流都是會唱歌的生命，族裡傳頌的歌曲都是從它們學來的。這點與《複眼人》的瓦憂瓦憂族一致！<br>瓦奧拉尼人：瓦奧拉尼人注重群體而輕視個體，個人的自主性和能力是建立於社群中。他們認為名字是關係的產物，若脫離既有社群，就得捨棄舊有的名稱。例如他們會以植物的用途或是植物與其他生物的關係來為植物命名。因此，同一種植物可能會有不同的名稱和描述，來表示植物與不同事物的關係。</li><li><strong>細胞特化</strong>：細胞特化除了增進效率，也避免了細胞擁有過多發展性而癌化。</li><li><strong>海洋微粒</strong>：海洋微粒會增加微生物可依附的表面積，從而改變海洋微生物群落組成。</li></ul><hr><p>大衛．喬治．哈思克（2017）。樹之歌：生物學家對宇宙萬物的哲學思索（蕭寶森譯）。商周出版。（原著出版於 2017 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> ecology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏娃的時間</title>
      <link href="/yoshiura-2008-time-of-eve/"/>
      <url>/yoshiura-2008-time-of-eve/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>未來，大概日本。<br>機器人應用行之有年。<br>人形機器人才剛實用化。</p></blockquote><p>女孩小時候出了車禍成為植物人，二十年後奇蹟甦醒醒面對大不同的環境</p><span id="more"></span><p>在病榻前不離不棄的哥哥陪著她學習走路、說話重新認識世界。隨著記憶恢復，女孩卻察覺哥哥和童年印象不同，和其他人比起來多了一分淡然。有次到祭拜父母時居然發現哥哥的墓碑居然立在爸媽旁，受驚嚇的女孩不可置信地望著站在一旁的哥哥，卻毫無頭緒。</p><p>她往回家衝，瘋狂打開家中抽屜想索出蛛絲馬跡。最後她打開哥哥那不曾進過的房間，裏頭的擺設和車禍早上那天相同：2050年的電影海報、新推出的機器人玩具……。</p><p>這時她老哥在他身後，眼睛突然放出亮光，在牆上投影出一幕幕影像。</p><p>原來那天車禍奪去了爸爸媽媽和哥哥的性命，女孩的爺爺在臨終前打造了哥哥機器人，希望在自己往生後能持續照顧她。</p><p>女孩忍不住悲傷哭了起來，突然天空出現異變，被拉扯出一個大洞，巨大的宇宙生物竄出，在東京上空噴出一百兆五百億度的火焰，大氣層被點燃延燒全球。女孩毅然決然搭上巨大化的哥哥機器人和宇宙怪物進行決戰。</p><p>陸續擊潰了四大天王和最終宇宙生命後發現這些「怪物」其實是守護世界的神獸，牠們正在和看不見的敵人作戰。百億年來不甘死去的智慧生命亡魂吞食暗能量與暗物質後以量子態聚積，最終成為威脅宇宙存亡的次元惡魔。</p><p>為了守護爸爸、媽媽、哥哥與爺爺的宇宙，女孩將自己量子化將時間軸前後二十年的時空給炸毀，犧牲了過去與未來在現在全力一搏。強大的時壓消滅了次元惡魔 99.999999% 的能量，但仍然剩餘將近 $10^{5989454}$ 焦耳，女孩將之永遠放逐到過去的過去，將邪惡的力量化為創世的大霹靂。</p><p>戰鬥的最後，女孩倒臥在殘破的東京都，惆悵地望著餘暉。一眨眼，她竟因時間炸毀的關係回到了 2050 年，正站在馬路中央，迎面撞上的車上她看見了爸爸、媽媽和哥哥，卻沒看見自己。</p><h1 id="讀後感"><a href="#讀後感" class="headerlink" title="讀後感"></a>讀後感</h1><p>以上情節與動畫無關，只是看完動畫後有感而發瞎掰的。我一開始猜店長凪的老爸在過世前以自己形象打造機器人來照顧受傷的凪，結果劇情發展與我的猜想大相逕庭。既然都起了頭，便把心中預想的劇情一口氣打出來了。</p><p>這部動畫才六集，可以直接從劇場版開始看，裏頭有網路播映沒有的內容，是個輕鬆溫馨的科幻小品（大概是艾西莫夫機器人短篇集那樣的篇幅吧？雖然動畫和小說比較好像怪怪的。）</p><p>故事的開頭寫著：未來，大概日本。機器人應用行之有年，但人型機器人才剛實用化。但是劇中機器人得用投影光環以便與人區別，這不就代表機器人在外表已經跨越恐怖谷了嗎？</p><p>故事主要地點是在一家不區分人機的咖啡廳。在裏頭，主角和他同學若不是親眼看見零件或是光環也無法從對話中分辨人與機器人，這不就代表連人工智慧都通過圖靈測試了。</p><p>外表和智慧都和人類無異，而且外表可愛還會賣萌的機器人，真的是人形機器人剛實用化的時代嗎？不得不說我十分期待……</p><p>先不論科技的先進程度，《夏娃的時間》的設定還挺細緻，但都說得很隱諱，在結尾也有很多未解釋的部分，所以看得時候還是得把重點放在人機相處，不然會有種意猶未竟的感覺。</p><p>六集的主題分別是背景介紹、主僕矛盾、愛戀、認同、忌妒與羈絆。</p><p>我覺得被非法拋棄的機器人那集最好看，前面是主角和他同學滑稽地想保護壞掉的機器人不會因邏輯錯誤或是誤喝咖啡而爆炸，後面店長出來和機器人聊天才知道他雖然被拋棄卻仍懷念小主人，並想要獲得別人認同與記憶。在壞掉前一刻，店長也不顧機器人一臉機器人樣（薩米或麗莎都一副人樣，這舊機器人只有金屬殼子還踏著機械步）抱著他給他安慰。</p><p>然後第五集講到男主角討厭他家的機器人的緣故，是因為擔心他家機器人會比他還會彈鋼琴。這主題可以寫很大，不過導演把重點放在薩米和男主角的和解上而沒去討論機器人取代人類的事情（這些議題都在背景中出現呢）。</p><p>不過就算機器人很屌好了，彈鋼琴還是一項需要努力練習的技能啊！機車賽出來後腳踏車賽還是一樣熱門，阿法狗在圍棋上打敗人類最強後，下棋還是一件充滿智慧且有趣的事情啊。</p><p>周邊也做得一副欠買的樣子<br>不只美術設計，連周邊也做得一副欠買的模樣</p><p><img data-src="https://p2.bahamut.com.tw/B/2KU/37/0000827037.JPG?w=1000"><br>（圖：<a href="https://gnn.gamer.com.tw/detail.php?sn=82019%EF%BC%89">https://gnn.gamer.com.tw/detail.php?sn=82019）</a></p><p>我不懂電影製作，不過總覺這部作品的分鏡和其他動畫不大一樣呢！一些小圖示設計很漂亮，咖啡廳光看就覺得療癒。</p><p>另外，機器人上的光環是有意要和天使做連結嗎？</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讀後感｜生命是什麼 — 鴿子為什麼那麼大？</title>
      <link href="/schrodinger-1944-what-is-life-chapter-1/"/>
      <url>/schrodinger-1944-what-is-life-chapter-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>七十九年前，薛丁格在都柏林三一學院的系列演講為鴿子尺寸提供了光學以外的解釋。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》">1</span></a></sup></p><span id="more"></span><h2 id="「鴿子為什麼那麼大？」"><a href="#「鴿子為什麼那麼大？」" class="headerlink" title="「鴿子為什麼那麼大？」"></a>「鴿子為什麼那麼大？」</h2><p>這問題乍聽之下或許令人詫異，但其實許多洞見都是從這樣怪誕或荒唐的問題萌發。</p><p>日常生活中，大或小的概念是建立在比較的基礎上。在這問題中，真正的目的或許不在了解鴿子的尺寸，而是想知道事物間為何存在懸殊的尺寸差異。事物尺度與其性質的關係是物理學重要的研究方向，而肉眼可見的巨觀層次和原子尺度的微觀層次則是其中的兩個極端。統計物理解釋了這兩大體系之間的關係，為巨觀現象提供微觀尺度的解釋。因此，若以此角度出發，我們可以把問題精確地重塑為：相較於原子，為什麼鴿子那麼大呢？<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」">2</span></a></sup></p><p>確實，相較於原子，一隻鴿子的體積非常大。成鴿的平均體重為 0.5 公斤，其組織器官則由碳、氫、氧、氮、硫、磷和其它微量元素構成。假設鴿子僅由氫原子或硫原子組成，可推知一隻成鴿含有的原子數量約在 $10^26$ 到 $10^28$ 之間，這數量遠超過當今對恆星數量的估計值($3 \times 10^{23}$)<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Dokkum & Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.">3</span></a></sup>。</p><p>由於鴿子與原子的懸殊比例，鴿子既無法察覺個別原子的動靜，也不受其碰撞、震盪或旋轉影響。這表示，作用於鴿子的原理和作用於原子的原理可能有很大的差異。但這樣的尺度差異對有機體究竟有什麼意義？又為什麼非得如此，才能維持鴿子的存在？</p><h2 id="有機體的運作仰賴精確的物理和化學定律"><a href="#有機體的運作仰賴精確的物理和化學定律" class="headerlink" title="有機體的運作仰賴精確的物理和化學定律"></a>有機體的運作仰賴精確的物理和化學定律</h2><p>有機體的運作無處不仰賴事物間精確的配合。以感知和運動為例，有機體要能靈敏接收刺激，同時不失真地傳遞訊息。這些訊息得正確抵達中樞，在歷經複雜決策後，循另一條途徑輸出，以驅動目標肌肉收縮。這個過程的順利，不只需要事件層序分明，也仰賴組織構造的規律。無論是感覺&#x2F;中樞&#x2F;運動神經的緊密連結，粗肌絲與細肌絲的間隔排列，還是細胞內訊息傳遞分子的聚攏，都是完成一項行為的要件。</p><p>即使是最簡單的膝跳反射，也需要器官、組織乃至細胞間的緊密配合，更遑論思考、決策與想像等複雜行為對秩序的需求。這意味著，無論生理還是結構層面，維繫有機體的各項事件皆需要相當的精確性；而外在系統對有機體的影響，也要有與之對應的精確性才會發生作用。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」">4</span></a></sup></p><h2 id="物理和化學定律的精確性奠基於大量原子參與"><a href="#物理和化學定律的精確性奠基於大量原子參與" class="headerlink" title="物理和化學定律的精確性奠基於大量原子參與"></a>物理和化學定律的精確性奠基於大量原子參與</h2><p>然而，少量原子無法支持有機體所需的精確性。在微觀尺度，個別原子持續進行隨機的熱運動，其移動、震盪和旋轉皆無法測量與追蹤。不過隨著系統內的原子數量增加，原子狀態（例如速度、方向、電荷等）的多樣性也隨之增加。一旦數量夠多，大量原子的平均狀態，便會呈現為巨觀層次可觀察到的方向性或規律性。</p><p>以順磁性為例，石英管中的氧氣雖然會因置於磁場而磁化，可是並非所有氧分子的方向皆與磁場一致。在局部，個別分子的方向其實會隨熱運動不斷轉變，所以沒有固定一致的排列方式。儘管個別分子的方向無法預期，但隨著磁場增強，石英管內順磁性分子與逆磁性分子的數量差距會逐漸增加，使得多數的氧分子與磁場方向一致，共同產生可觀測的磁化現象。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。">5</span></a></sup></p><p>另一項案例是布朗運動與擴散現象。在微觀尺度，單一微粒會受水分子碰撞而隨機運動，其移往各方向的機率與溶液濃度無關。不過，因為溶液中高&#x2F;低濃度區域的微粒數量有別，由高往低濃度移動的微粒自然比由低往高濃度移動的微粒多，於是微粒在巨觀層次表現出隨重力沉降或隨濃度梯度擴散等現象。</p><p>反之，若組成系統的原子數越小，隨機偏差的幅度就越大。這關係可以測量精確度的極限說明。扭秤是測量作用力強度重要的工具。為了偵測到更微弱的作用力，往往會替扭秤選用更輕盈的槓桿與絲線。不過，隨著扭秤尺寸縮小，原子熱運動對扭秤的影響也隨之增加，使得原子碰撞和待測作用力造成的擺幅難以區分。在這種尺度下，單次測量的意義有限，得靠多次測量來消除隨機偏差的影響。</p><h2 id="有機體需要足夠的原子才能受益於定律的精確性"><a href="#有機體需要足夠的原子才能受益於定律的精確性" class="headerlink" title="有機體需要足夠的原子才能受益於定律的精確性"></a>有機體需要足夠的原子才能受益於定律的精確性</h2><p>綜上所述，系統在巨觀尺度的屬性是相異狀態之原子的數量分布不均所致。系統內的原子數越多，數量不均的狀況就越容易與隨機運動區別，呈現的集體現象也就越明確。原子數量與定律精確性的關係可用 $\sqrt{n}$ 法則描述。 $\sqrt{n}$ 法則是指，對一個含有 n 個原子的系統而言，物理或化學定律的誤差範圍約在 $\sqrt{n}$ 內。式子中的平方根意味著，隨著系統含有的原子增加，作用在此系統定律的相對誤差就愈低。</p><p>讓我們回到文章開頭提到的問題，為何鴿子那麼大？或說，為什麼鴿子就不能像寡糖或Omega-3一樣小？這是因為，有機體的遺傳、發育和行為等生命特徵需要足夠數量的原子，才有辦法忽視個別原子的隨機運動，表現出統計物理上的宏觀秩序。</p><p>讓我們想像一種僅由 100 個原子組成的迷你鴿子。根據 $\sqrt{n}$ 法則，發生在迷你鴿子體內的擴散、催化、接合等反應皆有 10 個原子的不確定性，即有 10% 的相對誤差。</p><p>在這尺度，影響鴿子的不再是氣流、重力和光線等巨觀現象，而是電荷、碰撞、量子穿隧等微觀現象。僅僅一個離子，就可能破壞迷你鴿子的結構；即使是少量原子刺激，都會影響鴿子的感官，以致於不能辨明關鍵的環境訊號。既然無法維繫體內運作和對外互動，這樣的生命也就不會是我們定義的「鴿子」了。</p><h2 id="古典物理無法解釋遺傳的分子機制"><a href="#古典物理無法解釋遺傳的分子機制" class="headerlink" title="古典物理無法解釋遺傳的分子機制"></a>古典物理無法解釋遺傳的分子機制</h2><p>儘管統計物理似乎為有機體的尺存給出了圓滿的解釋，但此處的議論實為楔子：依照前述討論，有機體的秩序仰賴大量原子參與。不過就當時所知，基因很可能僅由少量原子組成，那麼基因是怎麼表現出遺傳、突變與分裂等在巨觀層次可觀測到的高度秩序？薛丁格主張，這個矛盾或許可用量子力學的概念解釋。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Dokkum &amp; Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。<a href="#fnref:5" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> what is life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROSALIND｜Transcribing DNA into RNA (RNA)</title>
      <link href="/transcribing-dna-into-rna/"/>
      <url>/transcribing-dna-into-rna/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模擬 DNA 轉錄 RNA 的過程，將給定 DNA 字串中的 T 替換為 U。</p><blockquote><p>Given: A DNA string t having length at most 1000 nt.</p><p>Return: The transcribed RNA string of t.</p></blockquote><p>(<a href="https://rosalind.info/problems/rna/">https://rosalind.info/problems/rna/</a>)</p><span id="more"></span><p>此題為字符替換問題，可使用 *str.replace(old, new, max)*，將字串中的 old（舊字符串） 替換為 new（新字符串）。若指定第三個參數 max，還可設定最大替換次數。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transcribe</span>(<span class="params">dna</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;Transcribe DNA into RNA</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> dna.replace(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>)</span><br></pre></td></tr></table></figure><p>R 語言與 replace 相應的 function 為 gsub，然而 gsub 可以接受向量，批次替換字符串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dna <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAATTTT&quot;</span><span class="punctuation">)</span></span><br><span class="line">rna <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> replacement <span class="operator">=</span> <span class="string">&quot;U&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span>  dna<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>rna<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>bash 的 tr (transform) 可用於替換、刪除、修改等多種字符操作。此例使用的是其替換功能，參數設定為：$string | tr old new，意指將字串中的 old（舊字符） 替換為 new（新字符）。相較於 R 的 gsub() 和 python 的 replace()，tr 只針對字符的操作（即只能 A→T，不能 AT→CG），若要替換字符串則要使用 sed，其參數設定為：sed “s&#x2F;old&#x2F;new&#x2F;g”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transcribing DNA into RNA using tr</span></span><br><span class="line">dna=<span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Translating RNA into protein using sed</span></span><br><span class="line">dna=<span class="string">&quot;GGTGGTGGTGGT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line">protein=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span> |  sed <span class="string">&quot;s/GGU/G/g&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$protein</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> rosalind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《All You Need Is Kill》</title>
      <link href="/hiroshi-2004-all-you-need-is-kill/"/>
      <url>/hiroshi-2004-all-you-need-is-kill/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>距地球四十光年外的智慧生命為了開拓生存空間，向地球投射 Terra forming Bomb，一種行星改造奈米機器。不料，它們和地球生物共生後不斷演化，形成威脅地球人類生存的「擬態」</p><span id="more"></span><p>主角銅谷啟二在聯合防衛軍服役，在初陣中意外擊破「主機擬態」而獲得生死輪迴的能力。然而，這種穿越時空的能力實為幻覺。主機擬態在被破壞後，會以速子將訊息回傳過去，以免其他擬態重蹈覆轍；而接觸主機擬態的人類則會連帶接收這些訊息，得到猶如親歷的印象。</p><p>對於自己的遭遇，銅谷起初想要脫逃，卻徒勞無功，每每遭到擬態給殺害。為了找出脫離輪迴並存活下去的方法，他利用每次重生機會鍛鍊戰技，成為優秀的士兵。直到他在第 158 次戰鬥，碰到同樣受困於輪迴的戰鬥天才麗塔，事情才真相大白。原來，銅谷先前得以重置，是因為麗塔擊敗主機擬態的緣故。</p><p>兩人為了生存下去共同擬定了作戰計畫，成功毀掉了備份擬態和負責傳訊的天線擬態。然而，麗塔的大腦因為多次輪迴，已逐漸異變為傳訊天線。麗塔明白，遲早銅谷也會有相同的遭遇，唯有一的方法是摧毀擬態傳輸訊號的途徑，讓輪迴不再繼續，但這勢必得犧牲兩人之一。</p><p>因此，麗塔打算透過對決來決定誰能生存下去，背負著為人類繼續戰鬥的宿命。最終銅谷擊敗麗塔，也摧毀了主機擬態。由於擬態喪失了傳輸途徑，此次戰鬥之前發生的事件再沒有重來的機會。</p><p>自此，銅谷接替了麗塔戰爭英雄的地位，也承擔起麗塔曾體會的孤單、無法挽救所有人的無奈、殺死唯一知己的痛苦與折磨。</p><p>雖然這本小說的主軸包含很多心理描述，還很特別地在全書前後分別用銅谷和麗塔的視角敘事。例如麗塔重複了多次戰鬥，從最初試著救人到後來把一切交給命運；孤獨地戰鬥到後來碰到知己卻得互相殘殺的哀痛等。</p><p>最初我是為了了解輕小說筆法才讀這本書，然而我太關注主線戰鬥和行文模式，又受到一些齣戲的角色和對話內容影響（例如日本化的美國角色形象等），所以讀的時候有點難起共鳴，於是筆記中少了很多心理層面的紀錄。</p><p>然而，劇情讀起來還是挺流暢的。至於，改編版電影雖然與小說有很大的差異，但看得也很過癮。原則上，在家裡如果轉到了就會看下去（例如今天又看了一遍）。</p><hr><p>櫻坂洋（2007）。AII You Need Is Kill（fafa譯）。青文。（原著出版於 2004 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiTalk 2022：在講台上</title>
      <link href="/mitalk-6-thu-2022/"/>
      <url>/mitalk-6-thu-2022/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>兩年前，我曾以聽眾的身分報名 MiTalk，如今總算有點結果可以參加口頭報告。趁著記憶猶新，我想紀錄此次工作坊的所見所得，並且借題敘述一些尚未獨立成篇的想法。</p><p>其中一個感悟是，以報告者的身分參加會議能增加聽講的敏感度和觀察面向。當聽眾時，關注的項目往往是相關研究或新奇題材。而經歷了準備報告的過程後，即使對講題不感興趣，也會留意講者的投影片設計、敘事結構、肢體語言和危機處理。</p><p>這些是準備報告的共同課題，所以每次聽講也能從多樣的示範中學習適合自己的解決辦法。</p><span id="more"></span><h2 id="談談口頭報告的緊張感"><a href="#談談口頭報告的緊張感" class="headerlink" title="談談口頭報告的緊張感"></a>談談口頭報告的緊張感</h2><p>坦白講，因為緊張和焦慮，我幾乎無法專心在其他人的報告內容。不過，雖然這次聽講人數較多，可是我覺得報告的緊張感比以前輕微，所以想花點篇幅來整理自己做了什麼來緩解緊張情緒。</p><h3 id="剖析緊張的根源"><a href="#剖析緊張的根源" class="headerlink" title="剖析緊張的根源"></a>剖析緊張的根源</h3><p>「講得不好怎麼辦？」、「被發現不是個咖怎麼辦？」、「講錯怎麼辦？」，我覺得，這些焦慮和維護個人價值的渴望有關。當我們把行為、評價與個人價值掛勾，便會擔憂行為失當是否影響個人價值，開始想像一些可怕的圖景，讓自己在事情發生前變得緊張不安。這種擔憂會因注意到自己無法控制他人想法而加劇，導致自己的決策受他人的想法擺布，也為了滿足全數人的期待而疲憊不堪。</p><h3 id="嘗試認知轉換"><a href="#嘗試認知轉換" class="headerlink" title="嘗試認知轉換"></a>嘗試認知轉換</h3><p>既然很多心理掙扎源於認知與行動的不協調，所以改變認知的模式是有機會緩解報告的不安感。首先，可以嘗試讓口頭報告與他人評價脫鉤。我的老師常提醒我，口頭報告（或是發表期刊論文）固然有宣傳和證明自己等作用，但除了功利價值，「發表」既是對前人的感謝也是對來者的祝福。</p><p>畢竟，無論我們基於什麼目的從事科學，都需要閱讀大量文獻。當我們從前人的心血獲得發現與見解，從而滿足研究的動機以後，將結果發表出來就是最好的回饋，表達我們從過去得到什麼靈感，並發展出可以給未來的東西。因此，再微不足道的發現與努力，再笨拙的傳達方式，都無損一個人表達感謝的誠意與熱情。</p><p>其次，也可以學著讓他人評價與個人價值脫鉤。由於評價是建立在對價值的判斷，兩者的關係也因人而異。每次報告，聽眾的背景和期待都不一樣，即使是同樣的內容也可能激起不同迴響。若透過他人評價來穩固個人價值，等於把定義自我的自由讓給這些無法控制的變項。</p><p>那要如何爭取定義自我的自由呢？可行的策略是在準備報告時，先為自己設立幾個目標，避免被他人評價牽著走。這些目標反映了個人最在乎的事情，所以達成目標的過程也是自我實踐與定義的過程。例如這次我給自己設定的目標有，</p><ul><li><strong>健康</strong>：不管準備得怎麼樣都不熬夜</li><li><strong>情緒</strong>：即使當下緊張或焦慮，也要專注於當下，不要為了未來而恐慌或為過去懊悔</li><li><strong>科學</strong>：用「如果往後有更完整的資料，我也能把握機會」的心態去分析資料</li><li><strong>報告</strong>：嘗試用新的簡報版型、敘事結構和陳述方式</li></ul><p>列了目標以後，我會提醒自己，不管別人怎麼想，只要達成預先設定的目標就是我的勝利。另外，在報告前，我也透過和朋友聊天、在附近走走、穿上不同風格的衣服或與民宿老闆閒聊等策略，提醒自己具有多元面貌，不只是一個在台上報告的人。</p><p>至於犯錯、出糗或聽到批評等，我則將之聯想為 bug 和 warning。寫程式的時候，警告訊息往往用紅色字體呈現，但要注意的是字裡行間的訊息，而不是色彩給我們的原始感受。對於生活中碰到的 bug 和 warning，我試著用這樣的聯想，讓自己能跟寫程式的時候一樣勇敢按下 Run，從錯誤訊息提供的線索，找到克服困難的途徑。</p><h3 id="緩解即刻的感受"><a href="#緩解即刻的感受" class="headerlink" title="緩解即刻的感受"></a>緩解即刻的感受</h3><p>認知轉換需要時間練習，上台前即時湧起的感受仍需要一些精神勝利法或不理性的敘事結構來克服。以下列幾個我用過的手段，這些方法通常能穩定心情一段時間，讓我能更專注在準備報告。</p><ul><li><strong>「呼~」</strong>：呼吸，然後什麼都不要想，專注體會當下所有情緒感受，不做任何評價。這方式的假設是，儘管每個人擁有的時間有限，但我們能提升對生活的意識來增加經驗的厚度。由於每次情緒波動都是別於平常的經驗。因此，不管接下來發生什麼事，透過調整呼吸來品味當下的感受，都能為我們賺來生活的體驗。</li><li><strong>「反正我們都會死」</strong>：反正我們都會死，現場所有人的掙扎與聲嘶力竭都會風化在歷史，隨太陽燃盡，最後在宇宙熱寂裡靜默。所以目光放遠一點，我們在台上不是對著觀眾還是南瓜什麼的呢喃，而是面對一座座顫抖的墓碑自白。現在發生什麼事也無所謂，反正再過$10^{150}$年，我們都會分解成孤單的光子，平均散佈在宇宙中，再沒機會碰到彼此。</li><li><strong>「就這十分鐘而已」</strong>：這招從國小用到大，伴我對抗打手心、罰站、訓斥等麻煩。簡言之，就是不斷提醒自己任何感受都會消退，也提醒自己要發生的事情根本很快就過了。像報告只有十分鐘，就算支支吾吾了十分鐘也會過去，而十分鐘有多短？短到課堂間睡個覺都不夠呢。（不過應用此方法時，盡量別想像棒式之類的經驗。）</li><li><strong>「宇宙某處正在發生生死存亡的戰爭」</strong>：這是一種珍惜的心態。想像宇宙某處正在發生星系間的戰爭，下一秒銀河系可能要被當作質量兵器砸毀在其他星系群了，這或許是最後一次報告，不管怎樣都要好好地享受。即使幸免於難，對於自己能在地球上安穩穩地站著，活在重力常數為 $6.67 \times 10^{-11}m^{3}kg^{-1}s^{-2}$ 的宇宙中也是感激不盡。</li><li><strong>「輪我了」</strong>：求學過程有碰過多堂枯燥的課程，每次聽課都覺得折磨，又不能不出席。被荼毒多年，如今終於輪到我上台報仇，難得有老師待在台下機會，應該要大方講，以洩先前當學生之恨。</li><li>最後再補充一個比較積極的方法，這也是我覺得最有效的方式：想像想傾訴的對象坐在台下，然後把這場演講獻給他們。當自己總算做出點什麼時，往往忍不住想對著某些人說「你看！」吧？</li></ul><p>如果曾支持自己的人坐在台下，我會想讓他們知道，多虧了他們的關懷與支持，我才有辦法做出東西來。我覺得，這種想像讓我更能以分享與交流的心態去演講，而不會總擔憂自己做得不好而裹足不前。</p><h2 id="如何回答自己不熟悉的問題？"><a href="#如何回答自己不熟悉的問題？" class="headerlink" title="如何回答自己不熟悉的問題？"></a>如何回答自己不熟悉的問題？</h2><p>回答問題時，除了能簡要答覆自己熟悉的部分，若對問題不熟悉，也要盡可能回饋對方自己的見解，才能彼此互惠。這次 MiTalk ，我對自己回答問題的方式不太滿意，所以留意了各講者答覆不熟悉議題的策略（就是講者會停頓一下、發出「摁～」聲音或眼睛朝右上方看的那種問題），期待自己往後能預先準備，不會因為緊張而妨礙與聽眾交流的機會。</p><h3 id="Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉"><a href="#Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉" class="headerlink" title="Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉"></a>Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉</h3><ol><li>承認對 A 不熟悉</li><li>承諾可從 B 方面解釋</li><li>提出 B 方面的見解</li></ol><h3 id="Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"><a href="#Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法" class="headerlink" title="Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"></a>Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法</h3><ol><li>解釋數據的統計與數理意義</li><li>坦白目前仍在思考生物解釋</li><li>表示此問題值得探討，說明可能的探討方向</li></ol><h3 id="Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性"><a href="#Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性" class="headerlink" title="Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性"></a>Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性</h3><ol><li>坦白該部分並非專長</li><li>說明已知的資訊</li><li>承認目前專注的部分</li><li>承諾往後可能怎麼做</li></ol><h3 id="Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"><a href="#Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制" class="headerlink" title="Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"></a>Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制</h3><ol><li>承認該限制暫時無法克服</li><li>提出即使存在限制，在部分資料或條件下仍表現關注的現象</li><li>承諾未來可能怎麼解決之</li></ol><h3 id="Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"><a href="#Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節" class="headerlink" title="Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"></a>Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節</h3><ol><li>概略回答問題</li><li>承認沒有詳記所有資訊</li><li>提供參考資料給聽眾</li></ol><h3 id="Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"><a href="#Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現" class="headerlink" title="Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"></a>Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現</h3><ol><li>承認自己僅探討了感興趣的項目</li><li>依照自己理解推論該細節可能跟研究現象有何關係</li><li>感謝對方提出這方面的見解</li><li>承諾會回到實驗室思考對方的問題</li></ol><h3 id="Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"><a href="#Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究" class="headerlink" title="Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"></a>Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究</h3><p>若只回答：「自己沒有細究」會很可惜。畢竟，如果聽眾對研究題材沒興趣的話，也不會浪費時間提問了。既然講者是在場對主題最熟悉的人，即使沒做過相關研究，聽眾也會期待講者的閱歷和經驗能對延伸問題給出什麼新奇想法。因此，可以大膽依照自己的知識做有理據的猜測。</p><h2 id="After-phD-PI-or-Boss"><a href="#After-phD-PI-or-Boss" class="headerlink" title="After phD: PI or Boss?"></a>After phD: PI or Boss?</h2><p>這節主辦單位邀情王永福博士、張瑞仁博士、曾景鴻博士介紹他們的公司以及分享在博士後踏入創業之路的動機。</p><p>如果重來，會選擇創業還是當PI？<br>別人不會端著錢要你做沒意義的事情。</p><p>我覺得這個問題相當於比較產業與學術的職業特質。 先前讀過 Vincent Vanhoucke 的分析，他指出，當工程師和當研究員需要不一樣的心態。相較於工程師，研究員要面對未知是否有解的難題。很多時候，研究結果無法指向解答，只生出更多疑問。這意味著，科研的進展不代表應用的進展，投注整個生涯若能促成概念轉換已相當傑出，更多的研究只在概念上延伸微小的範圍，甚至沒有一絲漣漪地沉澱在歷史長河。</p><p>面對意義的喪失，有些人離開學界。例如，王博士即認為他仍會選擇創業，因為學術研究的回饋感較低，很常在實驗室沒日沒夜，卻對自己究竟解決了什麼重要問題感到困惑。相較之下，業界處理的是具體而且迫切的問題，每次都有明確的目標和衡量標準。此外，王博士也認為創業能獲得資金自由，從而保障研究自由，可以自己決定研究方向，不必靠計畫維繫實驗室運作。而張博士則認為只有產業才能與實務問題接軌，因為學術發現局限於文獻，規模、可行性與市場潛能都未經檢驗，若要實踐理想，仍得踏入產業界。</p><p>然而，也有些人選擇留在學界，嘗試增加與產業的連結來賦予職涯意義。例如陸永祥老師在擔任助理教授時意識到，自己雖然有許多期刊發表，但這些研究僅圍繞在自己創造出來的問題，並沒有解決這世界面臨的任何難題。因此，陸老師決定踏入產業界，在各大商業發表會中擷取靈感，了解當前社會的需求，藉此引導研究計畫開展，從而結合了研究志業與實務意義。</p><p>這幾個例子也呼應曾博士所述，創業與學術的抉擇跟個性有關，你的個性會決定你怎麼選擇職業，怎麼在職涯中追尋意義、成就與滿足。</p><h3 id="phD-的訓練對創業有幫助嗎？"><a href="#phD-的訓練對創業有幫助嗎？" class="headerlink" title="phD 的訓練對創業有幫助嗎？"></a>phD 的訓練對創業有幫助嗎？</h3><p>三位講者的共識是，phD 對專業技術與抽象思考有幫助，但對經營面的幫助有限。創業要管理的財務和人事問題比經營實驗室更為複雜，這些都不是就讀博士班容易接觸的事情。因此，張博士認為，創業與否的關鍵在商機，商機比起主題、決心和學位更重要。如果時機對了，對商機感興趣便能主動出擊。畢竟，培育 phD 和培育老闆要注重的素養有別，花費大量時間攻讀學位後，仍需要從頭累積經營經驗，此時無論商機或是能力都可能過時了。</p><p>所以三位講者建議，若有良好的機會（例如家庭背景、產業需求、新穎技術、貴人等），要抓住時機創業；若境況太差（資金不足、對產業陌生、能力不足等），需要累積點什麼，這時就讀 phD 或進入欲創業的領域，才對往後創業有幫助。換句話說，為了創業而就讀博士班不是好理由。因此，王博士也希望大家思考繼續進修的動機是什麼，並期許大家不要為了趕上別人而莽撞地決定讀博士班。</p><h3 id="為什麼選擇創業這條辛苦的路？"><a href="#為什麼選擇創業這條辛苦的路？" class="headerlink" title="為什麼選擇創業這條辛苦的路？"></a>為什麼選擇創業這條辛苦的路？</h3><p>我覺得張博士的答覆很有趣：「找不到方向或沒機會創業的人更辛苦吧？」</p><h3 id="業界研究人力和業務人力的比例為何"><a href="#業界研究人力和業務人力的比例為何" class="headerlink" title="業界研究人力和業務人力的比例為何"></a>業界研究人力和業務人力的比例為何</h3><p>曾博士提供了一個經驗法則，公司最高齡員工的年紀與業務人員的比例正相關。</p><h2 id="小型工作坊"><a href="#小型工作坊" class="headerlink" title="小型工作坊"></a>小型工作坊</h2><h3 id="Networking-and-Ecosystem"><a href="#Networking-and-Ecosystem" class="headerlink" title="Networking and Ecosystem"></a>Networking and Ecosystem</h3><p>講者：謝志豪老師 &amp; 吳育瑋老師</p><p>共現網路不等於交互作用網路，而交互關係也會隨著規律事件或突發事件而變動。謝老師的工作是利用時間序列資料，推論交互作用隨時間變化的網路。</p><p>然而，時間序列分析對採樣頻率有一定要求，一項研究至少數十到數百個樣本才夠。然而受限於經費，往往沒有辦法獲得那麼龐大的資料，所以主持人便詢問是否有克服採樣量不足的方法，而謝老師的答覆則是：「沒有，你還是得去採樣。」</p><p>這答覆挺實際的，理論強如克卜勒和牛頓也需要第谷和佛蘭斯蒂德。雖然現在分析工具很多，但沒資料仍是寸步難行。若想解決科學問題卻受經費限制，那只能拉長時間，例如謝老師創建浮游生物資料庫的期許是在「30年後」能為人所用，而不是現在就生出大量樣本，或用少數樣本配合數據模型獲得驚人結果。</p><p>因為先前摸過時間序列資料，所以我想了解不同的時間尺度怎麼影響網路推論，也想了解採樣時間不一的問題要怎麼克服。謝老師回覆，時間尺度跟關切的問題有關，不同尺度得出的交互作用網路也有別，無法彼此推論。</p><p>至於採樣時間不一的問題是目前時間序列分析的限制，常見的手段是利用內插法來推論特定時間的測量值，但不是每個狀況都適合使用內插法。因此，如果時間差異很大，採用較大的時間尺度還有可能應用此演算法。</p><p>而吳老師則簡介他在應用網路分析的心得，例如網路指標的用途不止是簡化數據，也是為了不讓分析者被資料視覺化的形式欺瞞。另外，他也推薦我們讀 Faust. (2021). Open challenges for microbial network construction and analysis. The ISME Journal, 1-8. 了解目前生物網路分析面臨的挑戰（不過謝老師補充，其實有數則問題已經被他解決了）。</p><h3 id="Probiotics"><a href="#Probiotics" class="headerlink" title="Probiotics"></a>Probiotics</h3><p>講者：徐瑋萱老師、李保宏老師、陳彥伯老師 </p><p>人體益生菌的進展分為消化、免疫、代謝與神經益生菌等世代。目前，台灣業界著重消化與免疫益生菌，但國外正積極發展第三、四代益生菌的市場。不過，益生菌的應用場合也不只人體，還可應用於寵物皮膚炎治療、牲畜疾病防治、土壤改良與環境工程（carbon sink，改善二氧化碳濃度飆升的問題）。此外，益生菌的形式亦未必要為活菌，死菌不僅較容易保存，也能避免他人竊取菌株私自培養。</p><p>在益生菌發展中，徐老師有個有趣發現：益生菌可能透過胞泌體影響其他微生物的生理過程，從而降低病原菌的毒性或生長能力。這現象的潛力在於，針對發炎性腸炎的疾病，也許不需透過菌群移植或單菌接種來改善群落結構，只要改變群落的功能就可以達到治療疾病的效果。</p><p>此外，益生菌的胞泌體還可能透過神經或其他組織運輸到其他部位，影響遠端部位的生理機能，例如遷移到腦部可能改善精神狀況或記憶相關疾病等。不過關於這些胞泌體的專一性和作用機制都仍不明朗，還需要許多研究確認之。</p><p>不過，目前益生菌的研究手段和方向受限於法規，例如基因改造技術便不得用於食品級的益生菌。而透過誘導突變再篩選菌株等菌種改良方式雖可用於食品，但無法獲取有機認證。</p><h2 id="邀請演講"><a href="#邀請演講" class="headerlink" title="邀請演講"></a>邀請演講</h2><h3 id="陳可萱老師與林宛柔老師：植物共棲真菌"><a href="#陳可萱老師與林宛柔老師：植物共棲真菌" class="headerlink" title="陳可萱老師與林宛柔老師：植物共棲真菌"></a>陳可萱老師與林宛柔老師：植物共棲真菌</h3><p>陳老師的研究主題是苔類真菌相。苔類受注目的理由除了能於極端環境生存以外，也跟苔類欠缺其他植物常見的菌根菌有關。儘管欠缺近似菌根菌的結構，苔類仍有許多共棲真菌。這些共棲真菌與苔類的關係是陳老師的研究焦點，例如判斷共棲真菌是長在死掉的植物（腐生）還是長在活的植物（共生、內生、寄生），或是了解真菌與苔類共棲於組織內或組織周圍等。</p><p>由於苔類從新生到死亡等不同生長階段的組織會出現在同一株當中（Senescence gradient，衰老梯度），所以可以做為探討真菌不同食性的研究題材。其中一種研究食性的方式是，透過C&#x2F;N穩定同位素技術，判斷真菌和植物間是否有營養交換。假如兩者有互換碳與氮，那可能兩者為共生關係；若真菌單方面擷取碳，但植物沒有獲得氮，則可能真菌寄生在植物上。</p><p>除了演化與生態應用，由於苔類與共棲生物密切相關，既然苔類能耐受極端環境，其上的生物應該也有相當的耐受性，所以苔類可能作為搜索極端環境生物的標的。其次，苔類可容納各種生物生存，所以或許可以利用這種特性，將苔類作為媒介，把生物接種到不同環境中。</p><p>相較於自營性植物共棲真菌，林老師的研究題材是水晶蘭和阿里山水晶蘭等異營性植物的共棲真菌。完全異營性植物只仰賴共棲真菌提供的營養，所以植物與真菌的關係更為密切。這種營養的依賴性可能反映在異營植物與其共棲真菌的演化歷史上。</p><p>由於水晶蘭和阿里山水晶蘭型態相近，生存環境也類似，所以林老師想探討兩植物的親緣關係，並了解共棲真菌是否跟兩種植物的分野有關。而研究結果發現，相較於水晶蘭，阿里山水晶蘭與錫杖花的親緣關係較密切。即使生存於相同環境，水晶蘭和阿里山水晶蘭的共棲真菌組成在屬的分類階層仍大不相同，暗示著水晶蘭與阿里山水晶蘭的分野可能跟共棲真菌有關。</p><h3 id="張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性"><a href="#張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性" class="headerlink" title="張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性"></a>張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性</h3><p>張博士的研究探討多樣性與群落功能性的關聯。群落的功能性是指各族群的代謝與生理功能之集合，可用生物量、呼吸率和物質消耗率等方式估計。目前已知，α diversity 和 γ diversity 與功能性正相關，但 β diversity 與功能性的關係則尚未明朗。</p><p>此研究的假說是分化生態棲位的決定性篩選會增加 β diversity，使得群落的功能多樣性隨分類組成分化而增加。相較於低功能多樣性的群落，高功能多樣性的群落更能應用環境中的不同資源，代謝共通產物也會越多。根據此假說，分化棲位的決定性群落構建過程會加強 β diversity 與功能性的正相關性。 （推理方式：deterministic heterogenize selection→niche diversification→β diversity↑→functional diversity↑→exploit resources→function effects ↑→function indices ↑）</p><p>為了探討此假說，張博士使用 Bray-Curtis dissimilarity 度量 β diversity，用 β mean pairwise taxa index (bea-MPTI) 評估決定性分化過程，以 biomass 評估功能性，來檢驗 β diversity、deterministic processes 和 functioning 三者的關聯。</p><p>我對此研究很感興趣，也有一些猜想。首先，我會想了解正相關性是否只出現在某種尺度內，例如：(1) 資源有限的情況下，群落多樣性增加應該也不會增加functioning，(2) 功能多樣性隨群落多樣性增加的幅度飽和，應該也會讓functioning 增長的趨勢停滯。其次，如果假設 niche diversification 導致功能性上升，也許使用採計親緣關係的 UniFrac 也能獲得類似的結果。</p><p>最後，在 α 和 γ diversity 和 functioning 正相關的情況下，β diversity 還能跟 functioning 呈負相關嗎？依照我的理解，α diversity 、β diversity 和 γ diversity 三者有關，當metacommunities 間 β diversity 為零，那 γ diversity 就等於 α diversity；若 metacommunities 間的 β diversity 為一，那 γ diveristy 應該是 α diversity 之和。按照這層關係，在 α diversity 固定的情況下，γ diversity 上升會伴隨 β diversity 上升，所以當 γ diversity 跟功能性正相關時，β diversity 也會跟功能性正相關。</p><p>我在想 β diversity 和 functioning 呈負相關的一個可能是，α diversity 和 β diversity 呈負相關。換句話說，若某種生態過程會使得群落間組成逐漸相似，但最大化單一棲地的多樣性，那麼就可能觀察到 β diversity 和 functioning 呈負相關。例如說在 local dispersal limitation 微弱的初級演替環境，頻繁的遷移雖然會讓各族群的組成逐漸相似 (β diversity↓)，也會增加各群落的族群數 (α diversity↑)，提升 metacommunity 的 functioning。</p><p>按照這想法推測，隨著各群落的規模觸及環境負荷極限，可能出現heterogeneous selection，例如發生 lottery competition，各群落的優勢族群取決於隨機事件，增加了 β diversity。又或發生 homogeneous selection，例如先前遷入的族群造成 priority effects，限制了後續能於各區域生存的族群多樣性，使得 β diversity 下降。在沒有更多遷入族群的情況下，這兩種情況都使得 α diversity 下降，但後者降低 γ diversity，降低 metacommunity 的 functioning，於是 β diversity 又和 functioning 正相關了。</p><h3 id="其他印象深刻的內容"><a href="#其他印象深刻的內容" class="headerlink" title="其他印象深刻的內容"></a>其他印象深刻的內容</h3><ul><li><strong>何攖寧老師</strong>：雖然獨立於培養的方法可以普查環境微生物，但為了驗證假說、生產應用和探索功能等需求，仍有培養細菌的需求。而冰河溶解、大地震、工業汙染等突發事件造成的菌群變化，更強調現地即時指引樣本微生物培養的重要性，畢竟突發事件相當罕見，時間過了就沒辦法研究了。</li><li><strong>邱名鍾博士</strong>：邱博士提到隨寄生蟲感染而上&#x2F;下調的宿主基因非常多，這些基因不僅反映了宿主受影響的生理功能和途徑，也反映了寄生蟲和宿主軍備競賽的過程。</li><li><strong>林玉儒老師</strong>：林老師講了「鬼花飄香」的故事，研究人員從已滅絕的魏氏岳槿之植物標本取得核酸，再找出產生香味的關鍵基因，將這段基因插入酵母菌生產香味分子以重現魏氏岳槿的氣味（完整故事可見科學人報導）。</li><li><strong>陳彥伯老師</strong>：「這項研究很感謝在行政院農委會任職的學妹協助，本來跟學妹約好要在台上 cue 她的，但今天學妹卻沒來。」</li><li><strong>陳立賢老師</strong>：「我們以蔥根製作的面膜並不會有蔥油餅敷在臉上的油膩感。」</li><li><strong>汪碧涵老師</strong>：「我們每次 reject，都往點數更高的期刊投。」</li><li><strong>謝志豪老師</strong>：「這裡不解釋，若對network感興趣，可以去讀書。」</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>兩年前參加 MiTalk 時，碩班研究正好碰到瓶頸。當時聽了許多老師討論他們的求學經歷，卻仍然困惑自己是否適合做研究。於是，我期許自己能透過研討會增廣見聞，在跟人討論的過程中激勵自己。如今帶著一點結果再次參加 MiTalk，算是朝當時立下的目標稍稍前進一步了。</p><p>我現在覺得不具備做好某件事的特質，不是放棄的理由。我很喜歡《原子習慣》提倡的概念，要成為怎樣的人取決於動機和行動，這實在是很 existentialism。確實，研究了未必有明確結果，報告後的回饋也不一定如預期，考到什麼學校也不保證能讀到畢業，當到計畫主持人或工廠老闆還是可能有多種麻煩要應對。</p><p>然而，這些行動無論成敗都是定義自己的過程。當你為了瞭解 metagenomics，在 compiler 輸入 print(“Hello world”) 那刻，就成了生物資訊學家；當你為了解釋群落演替，在紙上畫了數個方格模擬動物遷徙的時候，就成了理論生態學家；當你開始反思自己的研究，為了某個癥結輾轉難眠，你也已經是個學者了。</p><p>至於能在生物資訊、理論生態或是學者的路走去哪、走多遠或走出什麼道路，端看每次行動的抉擇。但我想在這個過程需要時間琢磨。因此，我現在對自己的期許是要有耐心，漸漸不再擔憂自己欠缺什麼條件，而是想辦法做到當下能做到的事情，剩下交給時間。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ecology </tag>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人際的法則 — 怎麼面對他人求助？</title>
      <link href="/templar-2017-the-rules-of-people/"/>
      <url>/templar-2017-the-rules-of-people/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>長大成人是在情感上付出努力得來的</p></blockquote><h1 id="幫助他人的前提"><a href="#幫助他人的前提" class="headerlink" title="幫助他人的前提"></a>幫助他人的前提</h1><h2 id="幫助他人前，先保護好自己"><a href="#幫助他人前，先保護好自己" class="headerlink" title="幫助他人前，先保護好自己"></a>幫助他人前，先保護好自己</h2><p>幫助他人前，要先保護好自己。人們傾向於向熟識的對象以及有類似經歷的對象求助。雖然我們往往願意傾聽並分享自己的經驗，但如果我們自己都還沒走出困境，那麼選擇幫助他人對彼此都很危險。</p><p>首先，受困的對方正專注於自己的痛苦，無法顧及我們的苦處，所以他們的情緒和行為可能在無意間傷害到我們。假如我們沒有保護好自己，那我們可能被對方的無心之過重傷，從而無法做出適當的回應。</p><p>例如在聽人訴苦的時候，如果我們自己都沒有堅定的立場，那很有可能將自己套入對方的情境，或是下意識地產生評價，而無法客觀地觀察對方的癥結點。在這種情況下，我們給出的建議也很可能無法幫到對方。</p><p>因此，在協助他人前務必要確認自己的狀況良好。若有必要，可以向求助者道歉並說明無法幫忙的理由，嘗試從其他角度支持對方。畢竟我們不會所有層面都脆弱，還是有堅強的地方，可以從此處著手協助對方。另外，量力而為。不要承諾實現不了得幫助，決定幫助他人當下需要確認自己的狀況良好，幫助他人的過程也要讓自己狀況良好。</p><p>如果許下實現不了的承諾，將面臨 (1) 自己因協助他人而困擾、(2) 他人的失望、(3) 他人要面對臨時喪失協助的損失（對方原本可以在其他方面獲得進展的）</p><h2 id="抱持同理心，取得求助者的信任"><a href="#抱持同理心，取得求助者的信任" class="headerlink" title="抱持同理心，取得求助者的信任"></a>抱持同理心，取得求助者的信任</h2><p>確認自己狀況良好後，還要了解求助者的情感需求。有時，想向他人訴苦求助，但聽完對方的分析和建議後，反而讓自己心情更差。（或是反過來，想幫助他人，但對方沒有好起來）這現象的主要原因在於，協助者沒有照顧到求助者的情感需求。由於求助相當於示弱，如果不是相當痛苦且需要他人協助，沒人願意冒著被傷害的風險暴露自己的弱點。</p><p>因此，在獲得實質幫助前，求助者往往需要協助者的承諾（言語、行動、眼神等），承諾求助者不會傷害他們的情感，承諾求助者可以暢所欲言、悲傷欲絕、憤怒抱怨而不會遺棄對方，承諾求助者能夠感受對方的苦處而不會因為一時的失態而看輕對方。</p><h1 id="尊重求助者"><a href="#尊重求助者" class="headerlink" title="尊重求助者"></a>尊重求助者</h1><h2 id="不當表達的期待與祝福，可能成為求助者的壓力"><a href="#不當表達的期待與祝福，可能成為求助者的壓力" class="headerlink" title="不當表達的期待與祝福，可能成為求助者的壓力"></a>不當表達的期待與祝福，可能成為求助者的壓力</h2><p>倘若忽略求助者的情感需求而直接提供解決辦法，就好像指責對方的情緒反應很不合理：有解決辦法→沒必要感到悲傷→求助者感到背上→求助者有毛病。因此，面對求助者時，往往要先同理對方的感受，讓他們放心地和我們一同找出解決辦法。例如，一句「你感到很受傷嗎？」或「你生氣嗎？」等關心就可以讓對方明白我們的善意，讓求助者了解協助者願意傾聽和體諒。</p><p>與這些問候相反，「別擔心」或「不用哭啦」等否定對方感受的句子，會讓人誤會協助者無法同理求助者的感受，從而把安慰理解為輕蔑（原本的意思：從希望對方擺脫擔心狀態；誤會的意思：根本不用擔心好嗎？你到底在糾結什麼？）</p><p>「和我比起來，你好很多啦」或「你看某某某不是也過得好好的？」等告訴對方處境並不像他們所認為那麼糟的句子，則會讓求助者誤會他們沒資格抱怨。（原本的意思：希望對方不用過度擔心；誤會的意思：你的情緒是大驚小怪）</p><p>「看開點」或「振作起來」等命令句子，會讓人誤會協助者在看輕他們，從而把安慰理解為不體諒（原本的意思：希望對方看開點或振作起來；誤會的意思：這種廢話我也懂，如果有用我早就做了，何必跟你講那麼多，這種安慰沒有幫助也讓人覺得你根本不在意這件事）</p><p>換句話說，倘若自己有自己的困難和價值觀，沒必要在幫助他人時傾訴（可以選在自己的抱怨時機）。幫助他人時，談話的重心就放在對方和對方的感受上。</p><blockquote><p>一旦對方知道你不會評價他，你們就可以自在地交流。對許多人而言，跟一個不會評價你的人討論某事，就是解決這件事的一種方式——不管是為了貞治解決問題還是只想找個人吐露心事。</p></blockquote><h2 id="尊重求助者的獨立意志"><a href="#尊重求助者的獨立意志" class="headerlink" title="尊重求助者的獨立意志"></a>尊重求助者的獨立意志</h2><p>然而，很多時候，求助者也許不需要幫助，只是需要讓自己的情感有所宣洩，那麼光是同理對方就可以幫助對方。尤其在情感問題方面，我們往往無法解決他人的情感問題，畢竟那並非我們的情感。情感存在於求助者的內心，往往只能由他們來清理，無法由他人代勞。</p><p>那麼求助者究竟期待協助者能做到什麼？也許求助者想要他人的同理、想要透過聊天來梳理想法、想要抒發情緒的對象、真的想要解決問題、想要透過抱怨和否定來推卸責任、想要博取關注等。</p><p>重點是求助者不需要不請自來的幫助。一旦忽略求助者的動機，開始為別人構思解決問題時，也就代表 (1) 協助者已經不再傾聽對方了。(2) 協助者透露出救星姿態，彷彿求助者沒能力解決問題（這是否定對方的舉動）。</p><p>是以，下次面對他人的求助，可以先確認對方的需求，例如問問對方「你需要幫忙嗎？還是只想說出來讓自己心情好一點？」如果對方只需要一個聽眾，那就好好克制自己想做點什麼的衝動，當自己開始傾聽就已經開始在幫助對方了。</p><h2 id="「建議」不總是面對求助的最佳解答"><a href="#「建議」不總是面對求助的最佳解答" class="headerlink" title="「建議」不總是面對求助的最佳解答"></a>「建議」不總是面對求助的最佳解答</h2><p>何況很多情況其實不適合給對方建議，因為我們能接受的線索限於對方提供的資訊，給出的建議可能過於侷限。此外，一項行為有無利害可以從時間長短、人際關係、物質損益等層次分析，而我們又無法獲得對方所有心理狀態，所以很難理解什麼建議最符合對方需求且對對方有利。</p><p>其次，我們的經驗有所侷限，沒辦法確認在對方上也能適用，倘若建議無用，很可能讓對方失望且遷怒於我方。再三，我們得尊重對方的人生經驗和努力：</p><blockquote><p>人們需要自己深思熟慮後做出決定，這樣他們才會全心全意地投入並堅定完成任務。如果你告訴對方該怎麼辦，等於是抽走對方決策過程裡的重要階段，直接到達問題的終點。實際上把問題想通想透，權衡各個選項，考慮不同的意見，這些都是非常重要的。</p></blockquote><p>尤其是注意力放在自己時，也不適合給對方建議：</p><blockquote><p>當你給別人建議時會讓你自己好受點。可是我們是要去幫助別人，在這種時候你的感受並不是最重要的。我們得試想對方會怎樣看待他人給予的建議呢？即使你認為他們確實想要接受它，但是怎麼能確定這些建議一定就符合他們的最大利益？</p></blockquote><blockquote><p>給予對方不需要或不合適的建議，其實只是在浪費心力。假設你的朋友跟一個濫情的對象在一起，你認為他們會不知道分開對彼此都好？如果你直接說出你的建議，那只是讓他們無時無刻感到自己的無能為力。這並不會幫助他們離開對方，而你只是成為另一個控制他們的人罷了。他們真正需要的是支持，不是無法落實的指示。</p></blockquote><h1 id="以對方為本的心態面對求助"><a href="#以對方為本的心態面對求助" class="headerlink" title="以對方為本的心態面對求助"></a>以對方為本的心態面對求助</h1><h2 id="幫助他人的重點在於對方，而不是自己"><a href="#幫助他人的重點在於對方，而不是自己" class="headerlink" title="幫助他人的重點在於對方，而不是自己"></a>幫助他人的重點在於對方，而不是自己</h2><p>綜上所述，當有人來尋求建議時，最應該做的是協助對方找到正確答案。透過詢問來協助對方了解困惑，透過提出不同可能來協助他們描述講不出的策略，協助他們釐清事情的走向，幫助他們了解選擇的後果，尊重他們選擇和承擔責任的尊嚴。</p><p>即使對方沒有照著自己認為最佳方案進行，也不需要太介意，因為我們已經盡力協助他們做出選擇了。我們在意對方的選擇的原因終究是我們自己，我們期待對方聽從我們的建議，而這建議對我們也有好處。</p><p>但再次回顧幫助他人的重點，幫助他人要關注的終究是對方和其感受，我們無權干涉別人的決定，也最好不要把自己的需求寄託在他人的決定。我們的需求要靠自己去爭取，對方的選擇要由對方自行承擔。協助者是事件的配角，盡其所能做到最好已然足夠。</p><h2 id="責任的區隔是種體貼和尊重"><a href="#責任的區隔是種體貼和尊重" class="headerlink" title="責任的區隔是種體貼和尊重"></a>責任的區隔是種體貼和尊重</h2><p>這種責任的區隔不是無情，而是體貼與尊重。即使對方因選擇而受挫，那仍是他們做出的選擇，他們保住了自主權。何況，我們不是對方，只有對方才完全清楚自己要的是什麼，即使他們描述不出來。</p><p>此外，這樣也能避免名為幫助的控制。很多時候，提供幫助就是讓對方欠人情，讓自己成為對方的債主，從而獲得控制對方的權力和地位。然而，有來有往才是人們相處的本質。他人拒絕幫忙有可能是要擺脫這種控制或是要維持自己的控制權。因此，當對方拒絕自己的協助時，要意識到對方的反應，了解他們對於這個協助的感受為何，不用太耿耿於懷自己。</p><blockquote><p>讓每個人都能控制自己的生活是件非常重要的事。如果你總是幫人做決定——即使出於善意——你都是在奪走別人的自主權。</p></blockquote><blockquote><p>如果你總是對已經處在極度焦慮和無助的人們提出強勢的建議，這會讓整個局勢看起來像是你在替他們做決定一樣。他們自身的感受才是最重要的，你的初衷其實無關緊要。</p></blockquote><blockquote><p>最能幫助他人的方式，是讓不想說話的人知道，你並不會強迫他們。如果有人正經歷困難，你能說得最有幫助的話是：「如果你願意聊聊你的事，我很開心；但如果你不想談，我也不會主動問。」這麼做的話，他們在你身邊時就能感到放送，因為他們知道自己不用背負更多的壓力。</p></blockquote><blockquote><p>「否認」是一種重要且寶貴的情緒緩衝。</p></blockquote><blockquote><p>你與他人任何一次互動，都會讓雙方過得更好或更糟，那些互動總會有所影響。</p></blockquote><p>協助對方做出更好的決定，尊重對方的自主權，透過中性不帶有評價的詢問來了解對方的感受、探索可能的行動選項。</p><h1 id="小訣竅"><a href="#小訣竅" class="headerlink" title="小訣竅"></a>小訣竅</h1><ul><li>當對方抱怨某人，但我不認同他的抱怨時，可以試著認同他的情緒，但對自己的立場打迷糊仗。例如：「是的，這的確會讓你很生氣。」這樣可以避免無謂的爭端，也可以讓對話繼續下去。</li><li>不要對無法改變或無能為力的事情評論，這無濟於事且令人不快。</li><li>安撫緊張的人時，不要說「別緊張」。因為對方緊張是因為在乎，是因為把事情做好相當重要，這意味著他們渴望成功而且有企圖心和動力去實踐。因此，不要把期待當成安撫，要讓他們知道我們很高興他們重視這件事，要教他們怎麼克服做事會碰到的難關，要陪伴他們讓他們得到信心。</li><li>本性難移，所以能夠改變某人的行為就很棒了。每個人都是過往經歷的產物，所以改變行為就已經是帶給他們改變自身的機會了。在無法改變本性的情況下，唯一能改變的是自己，因為他人行為產生的情緒都在自己身上，而不是他人身上，因此只能靠自己來調整情緒和認知。</li><li>「大多數時候，別人的信念是你無法改變的，你再怎麼做都是白費工夫，但這並非意味著讓某些人改變是不可能的。能讓他們改變的必須是一種沉浸式的體驗，他們必須親自感受、經歷，這些都是你無法越俎代庖的。」</li><li>理解他人是在幫助自己，每個人都由其人生經歷塑造而成，因此對方讓我方不快的舉動都有其理由。若能了解他人負面的行為，即使改變不了事實或對方本性，也能較容易改變自己的認知，讓自己舒服一點。所以為了自己去了解他人吧。</li></ul><h1 id="此書其他內容"><a href="#此書其他內容" class="headerlink" title="此書其他內容"></a>此書其他內容</h1><h2 id="評論與建議"><a href="#評論與建議" class="headerlink" title="評論與建議"></a>評論與建議</h2><p>評論與建議的原則是要讓對方知道你的認可，再提供有價值的建議。常用的訣竅是將好的方面歸功於對方，而不好的方面則歸咎於客觀因素。陳述時可以用積極的具體評論為開頭，再敘述負面的評論（待加強處），最後補上統整性的正面評論。切記，評論與建議要注重時機與氛圍，無濟於事的評論（或是對方無法改變的事情）既徒勞無功也會讓人不快，要盡量避免。</p><h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><p>感謝的關鍵在讓對方確切地知道我方在感謝什麼，清楚地告訴對方他們哪些作為讓自己感激不盡，表達對方在自己心中的位置。越具體且個性化的感謝，越能讓對方感到你的真心誠意。</p><h2 id="讚美"><a href="#讚美" class="headerlink" title="讚美"></a>讚美</h2><p>稱讚的效用包含建立信任、表達關懷與友善、鼓勵對方堅持自己擅長的事、博取支持。真誠地稱讚要發自內心，陳述的內容要具體，可以直接針對對方心裡的訴求（能力認同感或歸屬感）等稱讚，也可以稱讚對方的作為，請對方自述也是一種表達興趣的稱讚手段。</p><h2 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h2><p>贏得信任的方法是信任對方：</p><ul><li>不要私底下散播或談論對方的謠言</li><li>在外人面前要站在對方的立場</li><li>在對方需要時給予支持與同理</li><li>在不辜負他人信任的前提下，盡可能敞開心房合作</li><li>無論是否認同對方意見，都要尊重對方的觀點，不能蔑視或嘲諷對方</li><li>要認真傾聽</li><li>向對方展現他們所關心的事物</li><li>滿懷感激</li></ul><h2 id="道歉"><a href="#道歉" class="headerlink" title="道歉"></a>道歉</h2><p>「對不起」不是重點，重點是對方的想法和做法，重點是緩解雙方的不愉快，關係回到正軌。這可以透過友善的行為開端，然後好好聊聊彼此不愉快之處，討論往後怎麼避免重蹈覆轍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從碩班第一次專題課說起......</title>
      <link href="/how-i-learn-from-seminars/"/>
      <url>/how-i-learn-from-seminars/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>讀碩班前，我其實不知道 seminar 到底要幹嘛，也不知道和我有什麼關係。所以如同曖昧、戀愛等陌生概念，所有關於 seminar 的知識都是PTT教我的。</p><p>然而在完成人生中第一次正式報告後，我發現生資所碩一的專題課跟想像中有些差距：老師在有限的檢討時間內傾向於引導同學發現邏輯錯誤，或是補充報告中值得大家學習的觀念，不曾直接指正學習態度、格式錯誤或邏輯謬誤。這點和以往聽聞前輩提到的「 seminar 被老師痛電」很不一樣，上一周報告結束後沒有被批評到一文不值，所以心裡有些不踏實。</p><p>不過我內心期望的只是被電的體驗嗎？不對。我渴望的是成長，批判不是成長的唯一途徑。我要從 seminar 中學習的不是接受批評或是習於挨罵，因為這種本領已在服役期間漸漸培養起來，我想從 seminar 獲得學者的素養。</p><span id="more"></span><h2 id="seminar-是什麼？"><a href="#seminar-是什麼？" class="headerlink" title="seminar 是什麼？"></a>seminar 是什麼？</h2><p>seminar 源於拉丁文的「seminar ium」（苗床），從字根可以看出教育者的期許是讓 seminar 成為新概念的苗床，希望學生在檢視新近研究成果之外，也能互相討論激盪出新的想法。另外，對學生而言，準備報告和參與討論的過程考驗彙整資料、傳達觀念及構思問題的能力，這樣的演練有助於奠立從事學術的基礎。</p><p>但是了解  seminar  的起源和目的有什麼幫助呢？</p><p>我認為如果可以辨識出課程用意，便能聚焦在學習的成效上，而非「有沒有被電？」、「什麼時候輪到我報告？」、「報告完了是否該吃一頓大餐？」、「同學幹嘛問機掰問題」等無關緊要的指標。</p><p>因此，為了學習到更多有價值的事物，我彙整了網路上蒐集到的資料，列舉應當要從課程中培養的能力，並提出可行的練習方式，以在往後的專題課中實踐。</p><ul><li>學會閱讀研究論文及其內涵</li><li>在有限時間內清晰地表達科學概念</li><li>能即時答覆聽眾的提問</li><li>學會「聽講」這種學習或交流方式</li><li>能於聽講過程中組織問題，並清楚地向講者提問</li></ul><p>雖然要培養的能力還可以找到一大堆，但要專題課的目標可以歸納為「學習扮演研究者、策畫者、講者和聽眾」。儘管還沒有實際投入研究，但學生可以鑽研論文來學習研究者怎麼從觀察中形成問題意識，找出疑點提出假說，最後設計實驗驗證之。</p><p>除了實驗結果，科學交流也是科研的一環，有效的溝通能讓他人接受你的主張，所以研讀論文後也要試著報告給其他人聽，學會結合腹稿、逐字稿、簡報呈現流暢的演說。</p><p>而且聽講是接受新穎資訊的最快方式，如果想跟上研究前沿，勢必要從研討會中有效接收想法，並累積新觀念。因此一門課不會在報告完就結束了，課程的不同時間點，都有要投注心力的事項和可以學習的地方。</p><h2 id="聽講筆記"><a href="#聽講筆記" class="headerlink" title="聽講筆記"></a>聽講筆記</h2><p>準備這次 seminar 的過程中，我累積了一些關於閱讀論文、製作簡報及練習演說的經驗和想法，學習怎麼當個好聽眾也是很重要的議題。</p><p>聽講是快速入門研究領域的方式，但成功的報告不只是講者的工作，也需要聽眾的努力。從這幾周的專題報告中我學到一個教訓，就是儘管一開始很認真想理解內容，卻可能因為一時分神或不解而和講者的節奏脫節。</p><p>由於時間有限，講者未必有機會頻繁停下腳步回顧內容。聽眾可以透過事先預習背景知識和研究骨幹來減少聽講當下的負擔。例如在報告前細讀書面報告或是瀏覽原始論文，再整理出簡單的筆記帶到會場。如此一來，對於報告內容就有比較明確的形象，即使自己一時分心或沒跟上講者的邏輯，也能靠著預先準備的筆記重新聚焦重點。</p><p>此外，由於簡報不像課本那麼詳盡，所以如果沒在演講中把握要點，回家後要複習就只能面對生硬的論文了。因此，如果能在歷次聽講中改善自己的筆記方法，便有助於演講後整理出完整的筆記，這些筆記配合講者的投影片和書面報告，就是往後複習的利器。</p><h2 id="練習發問"><a href="#練習發問" class="headerlink" title="練習發問"></a>練習發問</h2><p>如果只是單方面聽講，那麼聽眾與講者的念頭便沒有機會在互動中產生洞見。然而，我們的專題課討論風氣不盛，這可能源於「不敢問」及「不知道要問什麼」兩項障礙。</p><p>針對「不敢問」這項障礙，我覺得可以多多思考發問的好處。發問是聽眾在演講中展現主動權的行為，能釐清聽不懂的內容、反駁被曲解的觀念、探討湧起的靈感等，</p><p>但是問了蠢問題或有失水準的問題怎麼辦？會不會很丟臉？儘管指導老師總是說世上沒有蠢問題，有問題就要發問。然而，我一直覺得指導老師只是想是要鼓勵同學發言而非描述現況。因為，每次自己問出 google 能輕易解決、過於空泛而無明確或是邏輯不通的問題時，還是覺得自己挺低能的。這些問題對於旁人一點幫助也沒有，浪費其他人提問的寶貴時間，還展示了自己的無知與隨便，所以感到很丟臉。</p><p>只是，難道因為會丟臉就不問了嗎？不對啊，變強都來不及了，哪還管什麼丟臉。將相本無種，沒有跌倒幾次怎麼會有往後的好表現？ seminar 是學習與嘗試的好機會。班上有形形色色的同學，每次發問都能和不同的人交流，嘗試不同的提問方法，如此能累積經驗，更有信心面對更大的場合。</p><p>此外，每個人對聽講的期待或是議題的關注各不相同，他人對我們提問內容的評斷既無法控制也難以得知。若提出問題的初衷是「我」感到困惑，那麼只要發問可以解決自己的困惑，那麼我認為它就是有價值問題。</p><p>畢竟，seminar 都規劃了提問的環節，充分利用這個機會來解決自己的需求，我覺得其實也沒有什麼好丟臉的。如果還是很擔心緊張，也可以課前多花時間預習，聽講時寫好筆記，提問前整理好問題，這樣就不至於給自己太大的心理壓力。</p><p>至於「不知道要問什麼」的障礙，除了預習和寫筆記以理解內容外，可以參考平常老師或其他人發問的方式，整理出可以問的問題以及這些問題的特徵，然後依樣畫葫蘆問問題，多問、多想，遲早能問出可以獲得許多回饋的問題。</p><h2 id="寫回饋單"><a href="#寫回饋單" class="headerlink" title="寫回饋單"></a>寫回饋單</h2><p>有些學校的專題課會抽同學評論報告內容的優劣，提供意見讓講者更進步。不過如果沒有要求，總覺得這個工作還是交給老師吧。</p><p>儘管如此，還是能整理一份鑑賞筆記，用來提示自己或同學徵詢時給他當參考。獨立於報告內容的筆記，鑑賞筆記用於評斷報告的科學結構、內容品質、視覺設計和口語表達的優劣，解釋這場報告優秀或低劣的原因，找出可以學習的優點，紀錄要避免的錯誤。</p><p>模仿別人怎麼評論是學習鑑賞的快速方法，可以細聽老師們的回饋，這麼做一方面提醒自己，另一方面也蒐集了評論標的，成為下次聽講時觀察的重點。整理不同的評論內容後，還可以設計出一份回饋單，不僅能節省撰寫評論的時間，這份回饋單也可以作為報告練習時蒐集意見的工具。</p><p>在上台報告前通常需要內部演練，收集他人的意見以改進報告品質。事前提醒聽眾要留意的地方或發放回饋單有助於聽眾給出針對性的意見，也方便他們紀錄內容以免忘記，讓講者更有機會獲得明確且豐富的建議。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章是我第一次參加專題課後的心得，裏頭提到的心理障礙有許多仍是我現今要面對的問題。至於，過了這麼久，我對於參加研討會或 seminar 有什麼新的想法或轉變嗎？有啊，我漸漸不再把問問題當秀場了。</p><p>以往期待自己能像某些大神一樣，能提出讓講者與聽眾都陷入深思的犀利問題。回過頭來，我發現自己用問題的品質來衡量我的水準，才追逐著所謂「好問題」，試圖證明自己是有能力的人。</p><p>然而，一旦陷入這樣的心態，就會不自覺給問題貼上有價值的、沒價值的、令人訝異的、稀鬆平常的等標籤。於是，每次心中有疑惑時，便開始思考這問題有沒有價值。聽講到最後，往往因為覺得問題很平凡，而一個也沒有提。面對這種狀況，我有時還挺懊惱的，例如之前參加微生物生態學年會便有不少精彩的演講，明明有許多共鳴與想法卻不敢發言，錯失了學習的機會。</p><p>直到我參加了許多講座與會議，聽到了從基本、艱深到與講題毫無關聯的提問，才矯正了內心對偉大問題的期待。我意識到（或回想起）：「對啊，我就是因為不懂才問問題啊！」</p><p>至於能否問個犀利的問題，我蠻喜歡在 <a href="https://www.zhihu.com/question/36980830">知乎</a> 上看到的說法</p><blockquote><p>我覺得吧，聽講座也罷，看文章也好，讀教科書也算，更重要的不是去挑刺，而是一個更有建設性的問題</p></blockquote><p>簡言之，研究或開發本身就不是件易事，要從方法學或應用條件等方向去挑毛病真的太容易了。然而，除了指出漏洞並提出可能解決方式以外，另一種延伸想法的途徑是去思考，如果對方的結論是真的，那麼要如何利用這項結論，來幫助我的研究與問題？</p><p>透過這種方式思考問題，能延伸出許多跟自己相關的議題，也比較有動機向講者請教，還能拓展關於待解問題的深刻理解或有用猜想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人類存在的意義》</title>
      <link href="/wilson-2014-the-meaning-of-human-existence/"/>
      <url>/wilson-2014-the-meaning-of-human-existence/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最早認識 E.O. Wilson 是讀 Stephen Gould 的書，Wilson 作為 Gould 反對的對象存在我的記憶中。隨後，我在小說《螞蟻》裡讀到致敬Wilson 所創造的角色—— 艾德蒙．威爾斯，才逐漸了解 Wilson 在螞蟻、演化和生物多樣性方面的成就。</p><p>而想讀這本書的動機，則是寫故事時對於意義的追求，想了解不同思想家怎麼回答人類從何而來，該往何處去等問題。不過讀完以後意識到，這本書試圖解釋的不是個人的存在焦慮，也沒有為人類這樣短暫存在的物種是否有意義給上結論。</p><p>這本書做到的，是解釋道德、愛、心等被視為人類存在重要價值怎麼演化出來。Wilson 推廣其多層次擇汰學說，主張那些人類之所以為人類的特質，是群體選擇與個體選擇的結果。（這讓我挺好奇的，就我理解 Wilson 的社會生物學應該也是基於親緣選擇學說，但在此書中，他的立場卻反駁親緣選擇學說。這也許要多讀一點演化學說的發展，以及 Wilson 近年的著作才會知道為什麼。）</p><span id="more"></span><h1 id="我們存在的理由"><a href="#我們存在的理由" class="headerlink" title="我們存在的理由"></a>我們存在的理由</h1><h2 id="意義的「意義」"><a href="#意義的「意義」" class="headerlink" title="意義的「意義」"></a>意義的「意義」</h2><p>《人類存在的意義》探討人類存在於世間的理由與地位，認為應結合人文與科學共同思索這個問題。</p><p>卷初作者便釐清意義的兩種含意：事物之所以發生的遠因與近因。近因帶有目的，例如蜘蛛結網捕蟲，蜘蛛網存在的意義就是為了獵食求生，或說神創論者相信人類是造物主規劃下的產物，人類生存的意義便是達成被賦予使命或任務。至於遠因則無關意向和動機，是事情發展至現況所經歷的一切偶然與歷史因素，沒有任何規劃與目的。</p><p>探究近因能理解事情怎麼發生，而探究遠因則能明白事情為什麼會如此。由於生物技術和優生學發展，人類已經能逐步跨出遠因的支配，依照目的性規畫自己演化的途徑，但究竟我們該翻修自己到何種程度？面對這樣的道德困境，此書著墨於人類存在的遠因——亦即人類的祖先是怎麼經歷一連串的累積而成為我們，繼而探討當我們理解這種意義後又該怎麼考量自己的處境，明瞭未來的方向。</p><h2 id="解開人類之謎"><a href="#解開人類之謎" class="headerlink" title="解開人類之謎"></a>解開人類之謎</h2><p>文明社會是人類的重要屬性，其發源於真社會性（eusociality），已知的人類外的真社會性生物僅出現在昆蟲、某些海生甲殼綱動物和生活在地下的齧齒類動物，並不超過三十種。儘管經歷數次物種爆發，真社會性一直要到近兩億年才出現，儘管如此，真社會性替生物帶來非常大的利益。不過發展真社會性需要在演化過程中出現一連串改變，首先建立巢穴，然後以此為據點覓食哺育，成員分工合作最終形成真社會性的群體，因此儘管能帶來許多好處，仍然很晚近才發展出來。</p><p>人類的真社會性可能源於飲食習慣改變為肉食，因此要更嚴謹的分工合作，繼而設立營地，因為合作與競爭發展人際關係，交流中凸顯心智的重要性，因此逐步演化出心智能力。</p><p>而解釋演化趨力的學說主流學說有兩種：「親緣選擇 （kin selection）」以及「總括生殖成就（inclusibe fitness）或是整體適存度」。前者認為個體互助源於基因相似，能從利他行為獲利，最終發展出社會行為；後者則是只要行為能確保最大基因流傳，則群體就可能發展出社會行為。然而作者主張的多層次擇汰（multilevel selection），認為自然選擇發生在個體在群體內的競爭（個體擇汰）以及群體和群體間的競爭（群體擇汰），因此人類不僅會對群體有認同感，也極其關注群體內的是是非非。</p><h2 id="演化與我們內在的衝突"><a href="#演化與我們內在的衝突" class="headerlink" title="演化與我們內在的衝突"></a>演化與我們內在的衝突</h2><p>人類的善與惡即是利他與利己的衝突，這種矛盾特徵源於基因的個體選擇和群體選擇。僅影響個體的不利基因會在群體內或群體外的人際關係中被汰除，而會影響群體（即個體互動）的基因，則會在群體與群體互動中汰除，因為無法合作協調的群體難以對抗較團結的群體。人類的利己基因能讓個體在群體內競爭中勝出，於是團體逐漸變成自私的團體，然而自私的團體在群體間競爭卻無法對抗因帶有利他基因而合作的團體。個體擇汰篩選出利己基因，群體擇汰篩選出利他基因，兩者會在演化過程中拉扯游移。</p><p>「個體擇汰」（個體和同一群體內的其他個體競爭）和和「群體擇汰」（群體與其他群體競爭）這兩種力量之間發生了衝突。後者會使同一群體的所有成員懷抱利他精神，相互合作，並產生道德意識、良知與榮譽感。簡而言之，這兩股力量之間的中途在於：在同一個群體內，自私的個體會擊敗具有利他精神的個體，但由利他主義者所組成的群體，會擊敗由自私的個體所組成的群體。說得更簡單一些：個體擇汰會助長邪惡，群體擇汰則會增強美德。</p><p>史前時期這段「多層次擇汰」的演化過程，使得人類的心中永遠充滿了矛盾與衝突，不時在這兩股極端的演化力量之間游移。我們不可能完全屈服於其中任何一種力量，因為它們都不是解決我們的社會與政治問題的理想方式。如果我們完全聽任「個體擇汰」的本能趨使，則整個社會終將瓦解。反過來說，我們如果完全臣服於「群體擇汰」的趨力，則會變成天使一般的機器人，如同一群特大號的螞蟻。（page 49）</p><h1 id="知識的統合"><a href="#知識的統合" class="headerlink" title="知識的統合"></a>知識的統合</h1><h2 id="新啟蒙時代"><a href="#新啟蒙時代" class="headerlink" title="新啟蒙時代"></a>新啟蒙時代</h2><p>雖然意在強調整合人文與科學以探索人類之所以為人類的理由，但作者卻以大量篇幅敘述人文學科的侷限，列舉科學進展飛速試圖證明科學已經到了可以解決問題的時候。</p><h2 id="人文學科的重要"><a href="#人文學科的重要" class="headerlink" title="人文學科的重要"></a>人文學科的重要</h2><p>儘管作者認為人文學科難以解釋人類的意義，但是能從倫理學的角度解決科技進步的衝擊。作者提及的道德危機是「人類是否應為了避免疾病或培養特質而編輯自己的基因」，作者支持存在保守主義（existential conservatism）主張人的生物特性是一項神聖的資產，有義務要加以保存。另外科技能被科技取代，且在傳播中會逐漸均質；但文化多樣性是獨一無二，它的演進越來越複雜越來越獨特，人文學科的第二個價值就在於它保留了人類之所以為人的特質。</p><p>總言之，作者認為人文學科不能解決我們的疑問，但它一方面作為解決道德抉擇的利器，一方面作為標本保留了文化發展獨一無二的一面。</p><h2 id="社會演化的驅力"><a href="#社會演化的驅力" class="headerlink" title="社會演化的驅力"></a>社會演化的驅力</h2><p>本章節敘述總括生殖理論和多層次擇汰的內涵，並提出前者的反證。總括生殖理論的核心觀點可以用漢彌爾頓的不等式（Hamilton inequality）表達：</p><blockquote><p>某個利他行為所造福的對象，如果他所繁衍的後代數量，超過那位利他者因該利他行為而損失的後代數量，則表現這個利他行為的基因就會增加。然而，唯有在利他者和他所造福的對象彼此的親緣關係很近的情況之下，利他者才能從自己的利他行為中受惠。至於兩者親緣接近的程度，則視他們共同擁有的基因的比例而定：兄弟姊妹是四分之一，堂（表）兄弟姊妹是八分之一，依此類推。親緣關係愈遠，比例愈低，而且下降得很快。這樣的過程後來稱為『親緣選擇』（kin selection）。(p.87)</p></blockquote><blockquote><p>……他（漢彌爾頓）認為，生活在群體中的個體會與群體中的其他成員互動。在這個過程中，牠和每一個與牠有互動關係的成員都共同參與了「親緣選擇」。這些行為的總和對牠能傳給下一代的基因數量的影響，便是牠的總括生殖成就，也就是將這些行為的好處與成本統統加起來，再用牠和每一個成員之間的親緣等級來打折所得出的數字。依照「總括生殖成就理論」，擇汰的單位在不知不覺間從『基因』變成了『個體』。(p.89)</p></blockquote><p>而作者反對的理由有：</p><ul><li>過於抽象，脫離實際觀察結果。</li><li>僅觀察少數現象做出結論，忽略生態學、譜系學、神經生物學等領域。</li><li>錯將選擇單位界定為個體。</li><li>行為的效應不一定可以加總。</li></ul><h1 id="人類之外的世界"><a href="#人類之外的世界" class="headerlink" title="人類之外的世界"></a>人類之外的世界</h1><p>（前兩節略過，閱讀無收穫）</p><h2 id="外星人的模樣"><a href="#外星人的模樣" class="headerlink" title="外星人的模樣"></a>外星人的模樣</h2><p>作者依據地球生物學知識推論能發展出文明的外星人是什麼模樣。</p><ul><li>陸生：文明發展的基礎是能源，需要乾燥的環境生火或應用其他能源。</li><li>體型大：智慧需要記憶體，而記憶體大小受限於空間大小。</li><li>視覺與聽覺溝通：化學物質的擴散太慢，不利於迅速溝通，因此文明生物需以光或波動傳訊。</li><li>觸手：任何可以製作工具的構造。</li><li>道德：由於群體擇汰和個體擇汰作用，很可能在外星趨同演化出道德觀念。</li><li>社會性：能夠合作和促使競爭，讓團體本身和其中成員具有演化優勢。</li></ul><h2 id="生物多樣性的崩壞"><a href="#生物多樣性的崩壞" class="headerlink" title="生物多樣性的崩壞"></a>生物多樣性的崩壞</h2><p>分類學的價值在於</p><ul><li>分類學家本身就是該生物的專家，是生物學知識的源頭。</li><li>生態學或其他學說需要以來自分類學的研究作為基礎，否則可能會發生誤判關鍵物種等錯誤，導致錯誤的生態改良。</li><li>發掘新物種可以擴充基因改良工具，促進生物學發展。</li></ul><h1 id="心靈的幻象"><a href="#心靈的幻象" class="headerlink" title="心靈的幻象"></a>心靈的幻象</h1><p>作者說明人性是源於「人類的心智發展過程中，得自遺傳的一些規律行為，而這些行為又使得人類的文化朝特定的方向發展，因此它是人腦中基因與文化的連結。」（p176），並舉出人們對居住地的偏好為證，還沒有居住地偏見的兒童天性愛好稀樹草原這種人類發源地的環境（African savanna hypothesis）。這些個性來自基因裡頭的預備學習（prepared learning），預備學習而來的行為因人而異，而學習傾向的多樣性在演化擇汰保留下來，導致族群普世的內在價值觀。</p><h1 id="補充心得"><a href="#補充心得" class="headerlink" title="補充心得"></a>補充心得</h1><p>我後來在《做哲學》這本書讀到蠻貼切的說法：威爾森確實為人類的信念和行為提供了一種生物學解釋，不過，了解人類「是」怎樣的存在，還不足以答覆人類「該」如何存在。</p><p>「我們從哪來？」尋找的是解釋，「我們要走向何方？」追求的則是規範。解釋擷取遺傳、社會和心理等學科的知識來釐清過去；而規範則寄託了人們的渴望、期許與畏懼來展望未來，它受限於過去，但不必與過去一致。這本書提供了解釋，也暗示遵循解釋的規範。然而，是否認同這樣的價值觀還是讀者的功課了。</p><h1 id="摘錄"><a href="#摘錄" class="headerlink" title="摘錄"></a>摘錄</h1><ul><li>人類的存在或許比我們所想像的更加簡單。沒有既定的宿命，沒有深邃難解的生命奧秘，也沒有競相要我們宣示效忠的魔鬼與神祇。我們只不過是靠著自己的努力適應環境，因而得以在這個生物世界中存活的一個獨特物種，獨立而脆弱。若欲永續存活，我們就必須敢於突破現今仍存在於社會（包括那些已經極為民主的社會）的制約，秉持獨立思考的精神與理性，好好地認識我們自己。(page 42)</li><li>「人類的所有煩惱皆起因於我們不知道自己是什麼，對於我們想要成為什麼，也沒有一致的看法」(Jean Bruller&#x2F;Vercors You Shall Know Them, page 166)</li><li>宗教在凡夫俗子的眼中是真的，在智者的眼中是假的，在統治者的眼中則是有用的。(小塞內卡, page 188)</li></ul><hr><p>愛德華．威爾森（2021）。人類存在的意義【新版】：一個生物學家對生命的思索（蕭寶森譯）。如果出版社（原著出版於 2014 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> evolution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勇往直前 1 &amp; 2</title>
      <link href="/hideaki-1988-gunbuster-and-Kazuya-2004-diebuster/"/>
      <url>/hideaki-1988-gunbuster-and-Kazuya-2004-diebuster/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>從這部《トップをねらえ!》到往後的《天元突破グレンラガン》，深深覺得熱血的科幻動畫裡頭重要的不是真實，而是無視自然定律，突破現實框架的暢快（例如引爆木星充作黑洞核心、推動地球當質量武器、低於絕對零度的冷凍射線……之類的作戰計畫）。</p><span id="more"></span><h1 id="第一部簡述"><a href="#第一部簡述" class="headerlink" title="第一部簡述"></a>第一部簡述</h1><p>一、二部的時間橫跨一萬兩千年，從第一艘超空間跳躍艦在巡航中遭襲擊開始，人類研發宇宙戰鬥人型兵器，徵招青年駕駛員建立Top部隊以對抗潛在的威脅。主角法子繼承父親遺志加入宇宙防衛部成為buster駕駛預備員，在沖繩宇宙學校被太田教練發掘，與另一位天才駕駛員天野和美共同成為Top部隊日本代表。然而法子只是個普通女孩，在眾多精銳中顯得無能，不只同儕猜忌還受自己崇拜的和美所輕視。</p><p>第三集中，田代艦長帶領以旗艦第四代戰艦exelion為首的艦隊，搭載Top部隊向宇宙深處進發，卻在LEAF64區遭遇宇宙怪物的哨兵。Top部隊首次實戰卻死傷慘重，艦長下令進行超空間跳躍回防地球。法子依賴的男友史密斯也在遭遇戰中因她的怯懦而戰死，為此自責不已的法子主動要求太田訓練她。</p><p>還沒等到歸航，艦隊在亞空間受到伏擊，艦長下令脫離亞空間以免暴露地球座標，雙方在火星軌道接戰，艦隊幾乎全滅。艦長決定和宇宙生物的頭目同歸於盡，此時法子毅然決然搭上未完成的最終兵器gunbuster主動出擊，gunbuster在有限的操縱時間內展現壓倒性的破壞力，摧毀敵軍附屬部隊，最後以軀體阻擋頭目衝鋒，瓦解宇宙生物第一波攻勢。</p><p>殘餘的艦隊才返航不久，地球方便偵測到龐大的宇宙生物群接近太陽系邊境防線，作為人類方舟的第五代戰艦完成率不及百分之十六，人類唯一的希望就是在敵軍中心引爆舊旗艦的塌縮爐，將鄰近行星捲入風暴中形成微型黑洞吞噬一切。然而擔任護衛的gunbuster二號機駕駛和美卻因所傾慕的教練卻因宇宙輻射病不久於人世而無心戰鬥，因為出征代表的是雙方無法見彼此最後一面。在法子的鼓勵下，和美才振作起來不負教練犧牲小我的大義完成任務。這次作戰消滅了敵軍九成部隊，和美在作戰後和教練結婚，而法子則在艦隊中待命準備迎向最後一戰。</p><p>人類在太陽系作戰後轉守為攻，以五代艦eltreum連帶數千艘戰艦突進敵軍巢穴，計畫以黑洞炸彈在銀河中心製造出巨大的黑洞將敵軍一網打盡。黑洞炸彈到達後受到宇宙怪物接連攻擊，人類艦隊再次重創，且炸彈的控制棒被摧毀無法啟動，法子和和美自願駕駛gunbuster進入炸彈核心——壓縮的木星當中，把機組塌縮爐充作啟動器，終於引爆炸彈，把周邊一切給吞噬殆盡。</p><p>兩人則因時間膨脹的關係，在一萬兩千年後才回航地球，迎著他們的是用燈火打出的歡迎詞。</p><h1 id="第二部簡述"><a href="#第二部簡述" class="headerlink" title="第二部簡述"></a>第二部簡述</h1><p>第二部則設定在法子與和美返回地球的十多年前，這階段科技衰退嚴重，沒有warp也沒有塌縮爐，人類被佈滿天空的宇宙怪物給封鎖在太陽系。此時地球的主要戰力是一群擁有啟動buster machine超能力的青年，主角諾諾則是一心想成為駕駛員的鄉下女孩，因為一次宇宙怪物襲擊火星的事件被帶到太空，和所崇拜的駕駛員拉路可一同行動。</p><p>前兩集只是日常，第三集進入主線，超能力者群當中有兩個雙胞胎正在開發土衛十當中潛在的機械，他們相信這力量可以帶給他們永遠的青春，因此指派其他駕駛員解決巡邏於附近的宇宙怪物，這邊衍伸出琪可和木星的故事。在挖掘出機械的前一刻，宇宙怪物大量集結湧向土衛十，在苦戰中雙胞胎成功召喚埋葬萬年的外星機械，他們一舉擊敗宇宙怪物後卻不受控制無差別地打向所有人，超能力者只剩下兩三人存活，其他都死於失控的外星機械。</p><p>當眾人陷入絕望之中時，諾諾覺醒了，原來她是第七號buster machine，能夠指揮「宇宙怪物」作戰，她及時趕到解除土衛十的危機。經過這次事件才讓人類明白，原來他們之前一直戰鬥的是萬年前人類建造出來的太陽系防衛機械群，受到超能力者的影響才轉而攻擊人類，真正帶來毀滅的是那超越人類和宇宙怪物力量的巨獸。</p><p>後來新的宇宙怪物自太陽系邊界襲來，連用行星投擲都無法擊退，對方直接超空間跳躍到地球附近，人類只好犧牲地球將之作為質量兵器與宇宙怪物同歸於盡，最終諾諾把地球推回原來軌道，和拉路可合作擊敗敵軍後消失。最後人類點燈歡迎法子和和美的歸來。</p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>這兩部的設定要在衍伸漫畫和小說當中才能補齊，當中也有有趣的東西呀：第二代宇宙戰艦是用魔王星的反物質為動力，這魔王星的反物質我第一次看到是在〈2001夜物語〉裏頭，然後電影內的細節也致敬好多東西，不過我觀影歷練不長，所以實在看不出源頭。</p><p>另外大部分人都比較推第一部，我想是因為一部比二部還要多掙扎、絕望與成長。法子與和美時代的宇宙怪物是以億萬計，且一波又一波襲向地球毫無喘息餘地；然而諾諾時代的戰鬥規模減少很多，最終魔王也只是一部的一雜兵而已。雖然諾諾被塑造成開朗認真的女孩，但是她覺醒成七號buster的過程卻顯得無力，相較之下法子從一個脆弱的女孩在生離死別、私情與大義的拉扯中成長，最終能獨當一面作戰還反過來鼓勵失意的和美姊。</p><p>但是我還是很喜歡二部的，不只是因為他畫風和風格比較接近現在，還多很多元素：例如忌妒與陰謀，那個要消失能力的男駕駛為了保持能力和雙胞胎合謀，還吃一大堆奇怪食物。另外琪可對自己能力不足以保護摯愛的人那段也很不錯。只是僅六集沒法把細節做好，就會給人一種倉促且劇情不集中的印象（其實兩部元素沒有差太多，但是一部把劇情聚焦在法子和美身上，但是二部分散在幾個不同人身上）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《戲說統計》</title>
      <link href="/lee-2017-introduction-to-statistics-and-quantitative-analysis/"/>
      <url>/lee-2017-introduction-to-statistics-and-quantitative-analysis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知乎上有段軼聞可以很好地形容我讀《戲說統計》的心境：</p><blockquote><p>以前上新東方時候聽老師講的，說以前老俞還講課的時候，特別陶醉，做完題對答案，就問“有沒有人哪道題不懂啊？”要是有人提問題的話，老俞總是深情地看一眼題目，然後放下手中的教案，說：“同學們啊，這道題讓我想起了當初創業時候的的一件事，balabalabala”短短幾分鐘的就能把全班人講的如痴如醉，然後來一句“好的，大家還有哪道題不懂嗎？（阿冰，知乎）</p></blockquote><span id="more"></span><p>讀《戲說統計》是因為我很喜歡李連江老師的另一本書。教讀者怎麼走入和走好學術這條路的書有很多，例如讀《別鬧了，費曼先生》可以立志，讀《你和你的研究》讓人不忘摘星，讀《研究生完全求生手冊》則能學習踏實做事。</p><p>然而李老師的《在學術界謀生存》卻教讀者在了解自己是個平凡人後，怎麼面對期望落差，怎麼處理生涯焦慮，怎麼不負自己的使命與期待。因此，得知他還有一本既講統計也談學術生涯的著作時，便到圖書館借來看。</p><p>在經驗分享方面，《戲說統計》的立論與《在學術界謀生存》一致，皆勸勉讀者在看清事實後仍保持積極，追求自我的價值與肯定，例如：</p><blockquote><p>人生的智慧在於準確判斷自己，欣然接納自己。(144)</p></blockquote><blockquote><p>設立現實的目標，才能建立自信。(287)</p></blockquote><blockquote><p>看過，看不懂，很好！好在哪裡？好在創造了機會。看不懂，讓人不快，不憤不啟。(292)</p></blockquote><p>這些原則跟我讀了一些書、問了一些人而且親自碰一次壁後體會的想法一樣：多做事，少幹話；爭取機會，別找藉口；把握現在，不要懊悔過去；用指標衡量進展，但不要用指標定義自我價值。</p><p>至於描述統計的內容，對學過統計學的讀者而言可能較淺。作者用了許多篇幅討論詞彙的含意，也試圖澄清專有名詞的命名邏輯。例如 variable 應譯為變量還是變項？而 variable 的三層意義，即事實與反事實之別（因果推論）、個體屬性的日新月異（縱向研究）、屬性的因人而異（橫斷研究），為什麼攸關研究設計？</p><p>這些立論初學者讀來可能恍然大悟，但要應用於實務難題時恐怕無從發揮；而有經驗者讀來或許覺得有趣，但可能會發出「早點知道這種理解方法」的喟嘆，畢竟自己已度過瓶頸，如今不需要這樣的輔助才能理解抽象概念。</p><p>此外，書中多以比喻取代公式推導來解釋統計觀念，但能否理解作者的比喻與推理則見仁見智。例如作者雖然很用心講解樣本分布、抽樣分布和誤差分布的關係，但對這些觀念已經有定見的人來說，比喻與借代反而有可能阻礙讀者理解作者想傳達的意義。</p><p>總結對《戲說統計》的看法，我會說這本書是很私人的著作，是作者盡到傳承與坦率之義務的著作。</p><p>李老師（即作者）曾寫道：「最有效的誤導方法就是培養學術明星，製造學術天才，甚至奇才」，也在這本書提到「學者要盡到承傳的天職，對學生坦誠自己求學的辛苦是本分 (012)」。《戲說統計》記錄了李老師學習統計時遭遇的難點和克服這些困難的方式，未經歷這些困難的讀者可能覺得行文囉嗦，但有共鳴的讀者或會感到助益匪淺。</p><p>畢竟讀者很多元，一本著作有這樣兩極的評價也不是什麼問題。我覺得教育講究感同身受，即使是再簡單的問題，若有一位搞不懂的學生，便需要一位能讓學生搞懂的老師。假設不存在這樣的老師，那位學生自己搞懂以後能指導曾跟他一樣迷惘的學生，不也是一樁美事嗎？</p><p>書中還有一些有意思的句子摘錄如下：</p><blockquote><p>我認為教師的功勞不是教知識，而是鼓舞學生。知識可以教，但要靠學生自己刻苦研究才能學到；能力不能教，只能靠學生自己鍛鍊提高。學生學知識，長本領，出成就，都靠學生自己。教師起什麼作用呢？教師的責任主要是影響學生。用什麼影響？就是以書本上的知識為手段，幫助學生樹立自己的學習目標，激發學生的創造精神，鼓勵學生艱苦努力，幫助學生認識自己的潛力，促使學生把自己的潛力發揮出來。（代序，車銘洲）</p></blockquote><blockquote><p>教師的主要功勞就是給學生偉大的刺激，偉大的鼓舞。教師要在課堂上把學生的學習精神、奮鬥精神鼓舞起來，教師的作用就是刺激和鼓舞，用敲鑼打鼓的方法振奮學生，讓學生努力。（代序，車銘洲）</p></blockquote><blockquote><p>… 學生造就老師。老師的成就有學生的貢獻，不是教師自己本來就那麼優秀。必須有優秀的學生，教師才能進步，這是我堅信不疑的。（代序，車銘洲）</p></blockquote><blockquote><p>教師刺激學生，學生就會跟教師研討，有研討，就能出成就。老師的智慧是學生敲出來的，學生很優秀，總是敲打教師，教師就進步了。（代序，車銘洲）</p></blockquote><blockquote><p>在方法論中，術語歸根結蒂是「約定」。約定俗成，遊戲能玩下去，溝通有效，誤會不深，就沒有必要更改術語。(008)</p></blockquote><blockquote><p>不怕了，就是學會了；敢用了，就是學通了；用對了，就是學精了。(011)</p></blockquote><blockquote><p>琢磨怎樣化繁為簡，化平淡為有趣，化有趣為智慧，也是教書的樂趣。(012)</p></blockquote><blockquote><p>英國哲學家奧斯丁說，通常情況下，我們需要的不是被告知，而是被提醒。方法論的主要作用就是提醒我們注意思維的漏洞與陷阱，(027)</p></blockquote><blockquote><p>常是相對的，變是絕對的。常是異常，無常是常。常往往是希望的目標，不是研究對象。希望常，是因為害怕變；提倡常，是因為現實中有不可阻擋的變。所以，「天不變，道亦不變」是個訴諸虛幻奢望的討好建議，不是基於事實研究的明智建言。話說回來，因為變是常態，也因為變很難把握，所以保守是明智，求變是進取。(027)</p></blockquote><blockquote><p>對人生來說，日新月異之變是唯一能直接觀察的變。人生之所以難，之所以有趣，歸根結蒂是因為人能意識到這兩種變化，試圖打通這兩種變化。我們看到種種因人而異之變，自然會想到自己日新月異之變。問題在於，這兩者之間，只在很有限的程度上相通，而且我們很難準確知道到底在什麼程度上、在哪個方面相通。(037)</p></blockquote><blockquote><p>人生的智慧與藝術，關鍵就是在正確的時候採納適當的價值觀。人生不能沒有希望，希望來自相信因人而異之變與日新月異之變相通；然而有希望必然有失望，失望來自二者經常並不相通。(037)</p></blockquote><blockquote><p>人生的關鍵是發現和發揚正態分布對自己有利的屬性，躲避和弭補正態分布對自己不利的屬性。 (139)</p></blockquote><blockquote><p>… 最難判斷的就是我們的相對位置，而平均值和標準差可以幫我們確定自己的相對位置。在這個意義上，我們關注平均值和標準差，就是希望知道自己在這個世界上的位置，也是希望改變我們的地位。人生的苦悶在於，無論我們做什麼，都既糾結於平均值，也糾結於標準差。(141)</p></blockquote><blockquote><p>年輕時要努力奮鬥，因為自己的位置是不確定的，自己的潛力是未知的。但是一定要注意，人生的舞台有很多，人的能力有多面，千萬不要覺得人生只有一條路。你在這一條路上可能平平，在另一條路上卻可能優秀。一方面要堅韌不拔，另一方面要靈活機動，才能找到你最擅長做的事。(145)</p></blockquote><blockquote><p>研究生是學者最畏懼的讀者，他們會跟老師說，你把數據庫給我，我重複做一遍，跟你學。(185)</p></blockquote><blockquote><p>無論學什麼，都分兩個功夫：一個是投入時間學，另一個是用心琢磨怎麼學。又投入時間學，又用心想，就會慢慢找出一個適合自己的方法。哪一天你找到適合自己的方法了，你就學會了。(262)</p></blockquote><p>[^*] 李連江 (2017)《戲說統計：文科生的量化方法》，中國政法大學出版社。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新生兒腸道微生物演替的文獻筆記</title>
      <link href="/succession-of-infant-gut-microbiota-literature-memos/"/>
      <url>/succession-of-infant-gut-microbiota-literature-memos/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="嬰兒共生菌相的成熟過程及其與分娩方式的關聯"><a href="#嬰兒共生菌相的成熟過程及其與分娩方式的關聯" class="headerlink" title="嬰兒共生菌相的成熟過程及其與分娩方式的關聯"></a>嬰兒共生菌相的成熟過程及其與分娩方式的關聯</h1><p>Chu et al. (2017). Maturation of the infant microbiome community structure and function across multiple body sites and in relation to mode of delivery. Nature medicine.</p><p>人類的共生菌不僅協調內分泌、免疫和代謝機能，也參與這些器官系統的發育，失衡的菌落往往和疾病相關。因此，想要理解宿主怎麼和微生物發展共生關係並保持健康或導致疾病，就需要更深入理解微生物在宿主身上的建立過程。</p><p>人體微生物計畫第一期的結果指出，成年人的身體各處有不同的微生物相。根據 Costello 在 2013 年於早產兒的研究指出，這種微生物相差異一直要到出生後三個星期才逐漸變得明顯。這項研究雖然觀察到微生物在不同身體部位的演替趨勢，但樣本過少，也只限於早產族群。此外，還忽略了影響微生物建立的外在因素。</p><p>新生兒接觸的環境決定了個體微生物的來源，而人體的免疫系統或飲食等因素則決定有哪些微生物可以順利拓殖。許多研究指出分娩方式和新生兒共生菌的類型相關，不過這些研究同樣面臨樣本數過少的問題。</p><p>另一點值得議論的是，自然產和剖腹產可能不是良好的劃分方式。原則上，自然產的新生兒會首先接觸到陰道菌群，而剖腹產的新生兒會首先接觸到皮膚菌群。但是採取剖腹產的原因可能是胎位不正、產前出血或自然產失敗，因應不同的狀況會有不同的醫療處置，這些處置也成了潛在的干擾因素。</p><p>所以為了了解健康人群的微生物建立過程，這項研究納入了更多的樣本，觀察與比較新生兒身上不同部位的微生物相隨時間的變化，並且考量前述的干擾因素，重新評估分娩方式對微生物相建立的影響。</p><h1 id="以分子技術監測人類新生兒的細菌群集演替"><a href="#以分子技術監測人類新生兒的細菌群集演替" class="headerlink" title="以分子技術監測人類新生兒的細菌群集演替"></a>以分子技術監測人類新生兒的細菌群集演替</h1><p>Favier et al. (2002) Molecular Monitoring of Succession of Bacterial Communities in Human Neonates. Applied and Environmental Microbiology. </p><p>嬰兒無菌的腸道在出生後逐漸被細菌拓殖，了解腸道微生物及影響其拓殖的因素可能提供調控微生物的機會。腸道微生物的組成深受飲食影響。當今對於嬰兒腸道微生物相的理解幾乎全數得自於基於培養方法的研究，然而腸道微生物多由難以培養的厭氧菌組成，費時的厭氧培養也限制了研究的規模。</p><p>近期，基於 16S rRNA 等分子的微生物學技術逐漸用於研究複雜的微生物生態學，但是僅有少量的研究採分子技術研究嬰兒腸道微生物。例如  Fluorescent in situ hybridization (FISH) 即用於定量分析源於不同飲食型態的嬰兒腸道微生物樣本，然而這類技術的研究範圍受限於引子的種類。</p><p>PCR 及 denaturing gradient gel electrophoresis (DGGE) 更常用於微生物生態學研究。PCR 和 DGGE 配合定序技術能夠有效地鑑識分類群，而相關技術也已被用於研究與早產兒之壞死性腸炎有關的細菌。因此，Favier et al. 使用 PCR-DGGE 探討兩名嬰兒的排遺樣本，以了解腸道細菌群集在產後十個月內的演替。</p><p>此研究探討與嬰兒飲食相關的腸道微生物相差異，但標題與文中強調的是以分子技術研究相似主題的開創性。因此，Favier et al. 首先提出困境：腸道微生物研究受限於可培養的細菌種類。</p><p>這問題顯然不是 Favier et al. 發現的，但為什麼前人沒辦法解決，此研究卻能夠克服克服？為了解釋這點，Favier et al. 提到了分子技術的發展使難養菌的研究便得可行，再比較不同分子技術的優劣，以支持研究的合理性。</p><h1 id="哺乳與餵配方奶之嬰兒的雙歧桿菌及乳桿菌多樣性區別"><a href="#哺乳與餵配方奶之嬰兒的雙歧桿菌及乳桿菌多樣性區別" class="headerlink" title="哺乳與餵配方奶之嬰兒的雙歧桿菌及乳桿菌多樣性區別"></a>哺乳與餵配方奶之嬰兒的雙歧桿菌及乳桿菌多樣性區別</h1><p>Satokari et al. (2002) Diversity of Bifidobacterium and Lactobacillus spp. in Breast-Fed and Formula-Fed Infants as Assessed by 16S rDNA Sequence Differences. Microbial Ecology in Health and Disease.</p><p>人體腸道微生物的拓殖使於出生後與生母及環境的接觸，隨後歷經數階段的演替逐漸形成複雜而穩定的成人微生物相。分娩方式、用藥、飲食等因素皆與腸道微生物的拓殖與演替有關。</p><p>早期的培養學研究發現，相較於餵食配方奶的嬰兒，Bidobacteria 是採樣自哺乳嬰兒的排遺樣本中的優勢微生物群。然而，相異研究的結果往往彼此衝突，因此與哺乳相關的微生物相差異仍無共識。 </p><p>Fluorescent in situ hybridisation、dot blot hybridisation, and 和其他以 PCR 為基礎的分子技術能更精確地辨識微生物組成差異。因此 Satokari et al. 使用 PCR 及 temperature or denaturing gradient gel electrophoresis 等技術研究腸道微生物的 16S rDNA ，比較哺乳和餵配方奶的嬰兒在離乳前後，Bifidobacterium 和 Lactobacillus 等與哺乳相關的菌群組成差異。</p><p>Satokari et al. 試圖以基於 16S rDNA 的分子技術研究嬰兒腸道微生物，解釋以培養為基礎的研究得出的衝突結果。只是作者沒有在導言中說清楚為什麼採用其他技術就能克服不同研究的矛盾，也沒有講解為什麼目前沒有相似研究的原因。畢竟各研究結果有異的原因可能是因為研究族群、材料、方法的差異，我覺得如果作者能解釋採用新技術優於統合分析等方法的理由，那這篇論文的問題脈絡便更清楚了。</p><h1 id="利用-PCA-和-T-RFLP-比較不同年齡之嬰兒排遺微生物相"><a href="#利用-PCA-和-T-RFLP-比較不同年齡之嬰兒排遺微生物相" class="headerlink" title="利用 PCA 和 T-RFLP 比較不同年齡之嬰兒排遺微生物相"></a>利用 PCA 和 T-RFLP 比較不同年齡之嬰兒排遺微生物相</h1><p>Wang et al. (2004) T-RFLP combined with principal component analysis and 16S rRNA gene sequencing: an effective strategy for comparison of fecal microbiota in infants of different ages. Journal of Microbiological Methods.</p><p>人體的腸道微生物可能參與宿主的營養代謝、病源入侵和免疫反應的過程，進而影響宿主的健康狀況。研究健康嬰兒腸道菌群的結構與動態或能幫助我們了解過敏性疾病的成因，奠立相關疾病之預防醫學的基礎。</p><p>目前嬰兒腸道微生物的生態學知識多得自於基於培養學的研究。然而，培養技術受限於難養菌的存在及定量菌群規模的困難。雖然可透過擴增和複製 16S rDNA 來補足培養學的限制，但這類技術勞力費時，不易應用於大規模樣本的對照研究。</p><p>Terminal restriction fragment length polymorphism (T-RFLP) 是環境微生物生態學常用的技術，雖然其具有高效和便捷等優點，但分析 T-RFLP 得出的大量數據相當困難。為克服詮釋數據的困難，Wang et al. 引進主成分分析來探索，腸道正處發育階段的嬰兒之排遺微生物群變化。</p><p>此文的主題、背景、問題、既有研究、難點和解決方案都交代了：以腸道微生物與疾病的關聯起頭，強調研究嬰兒腸道微生物發育的重要性。接著指出培養技術和其他替代方案之缺陷，最後提出結合 T-RFLP 和主成分分析或能克服難養菌與解釋數據的困境。</p><h1 id="健康且哺乳嬰兒的腸道微生物與免疫標記物在副食哺餵期間之轉變"><a href="#健康且哺乳嬰兒的腸道微生物與免疫標記物在副食哺餵期間之轉變" class="headerlink" title="健康且哺乳嬰兒的腸道微生物與免疫標記物在副食哺餵期間之轉變"></a>健康且哺乳嬰兒的腸道微生物與免疫標記物在副食哺餵期間之轉變</h1><p>Amarri et al. (2006) Changes of Gut Microbiota and Immune Markers During the Complementary Feeding Period in Healthy Breast-fed Infants. Journal of Pediatric Gastroenterology and Nutrition.</p><p>嬰兒無菌的腸道在出生後逐漸被細菌拓殖。雖然各研究的結果有些差異，但親餵與瓶餵的嬰兒之腸道微生物發育模式不同，哺乳嬰兒的腸道往往有較多的 bifidobacteria 和較少的 Enterobacteriaceae。在副食添加期間，哺乳的嬰兒腸道中的 enterobacteria 和 enterococci 數量漸增，隨後 Bacteroides、clostridia 和厭氧性 streptococci 也逐漸拓殖。</p><p>在離乳之後，親餵與瓶餵的嬰兒腸道的厭氧微生物逐漸演變為似於成年人腸道菌群的組成，同時兼性厭氧菌的數量也逐漸下降。目前，探討嬰兒腸道微生物演替在添加副食品和離乳期間的研究有限，少數以此為題的研究之定群規模和追蹤時數也不足。</p><p>鑒於嬰兒腸道微生物對幼兒往後健康狀況的重要性，此研究的目的是探討數種腸道微生物，以及免疫標記和腸漏指標物在嬰兒添加副食期間的轉變。</p><p>此文的寫法是依序解釋嬰兒腸道微生物的演替、哺乳相關的微生物相差異、腸道微生物與免疫的關聯等主題的研究成果，然後說明相關主題沒人做，所以自己跳下來做。我覺得這種寫法比較不有趣，因為沒有講解為什麼別人不做，也沒有講解解決問題的推理過程，讓人感覺問題之所以被解決，是增加資源而不是有什麼新的觀點。</p><h1 id="離乳期間嬰兒排遺微生物相的縱向研究"><a href="#離乳期間嬰兒排遺微生物相的縱向研究" class="headerlink" title="離乳期間嬰兒排遺微生物相的縱向研究"></a>離乳期間嬰兒排遺微生物相的縱向研究</h1><p>Magne et al. (2006) A longitudinal study of infant faecal microbiota during weaning. Federation of European Microbiological Societies.</p><p>嬰兒腸道微生物相受多種環境因素影響，其中以飲食型態最為重要。相較於餵食配方乳，餵食母乳可能助長嬰兒腸道中的 bifidobacteria 並抑制 Bacteroides、Clostridium 和 Enterobacteria 等厭氧菌的增殖。</p><p>由於腸道微生物可作為防範病原的屏障，哺乳可能保護嬰兒免於特定疾病。以痢疾和呼吸道疾病為例，相較於提早餵食副食品的嬰兒，在發展中國家中這兩項疾病在哺乳的嬰兒之盛行率較低。</p><p>儘管添加副食可能影響嬰兒排遺樣本的微生物相組成，相關的研究仍然有限。雖然曾有研究以培養方法發現 Enterococci 和 Bacteroides  的數量在已添加副食品的嬰兒（六個月大）中較高，但此研究並沒有控制各嬰兒的飲食型態，因此難以評估飲食對腸道微生物的影響。此外，由於飲食型態的轉變是漸進過程，所以也增添評估副食影響的難度。</p><p>鑒於這些困難， Magne et al. 統一研究對象的飲食內容（餵食相同的配方乳），並將嬰兒的飲食階段分為哺乳期、哺乳配合配方乳、僅餵食配方乳三個階段，使用 PCR-temporal temperature gradient gel electrophoresis 評估排遺樣本內的微生物在離乳期間的變化，以了解飲食轉變對於腸道微生物的衝擊。</p><ul><li>主題：嬰兒腸道微生物相與飲食行為轉變的關係</li><li>觀察：在開發中國家裏，哺乳嬰兒的痢疾與呼吸道疾病盛行率低於提早添加副食者</li><li>假說：飲食影響腸道微生物組成、部分微生物能防範病原入侵、哺乳能助長益菌發展）</li><li>預測：添加副食對嬰兒腸道微生物相可能有別於哺乳的影響）</li><li>缺口：既有研究沒有控制飲食型態、飲食轉變是漸進過程</li><li>解方：控制飲食內容、分期觀察</li><li>目的：透過前述解方研究腸道微生物相在飲食轉換期間的變化</li></ul><h1 id="影響嬰兒早期腸道微生物組成的因素"><a href="#影響嬰兒早期腸道微生物組成的因素" class="headerlink" title="影響嬰兒早期腸道微生物組成的因素"></a>影響嬰兒早期腸道微生物組成的因素</h1><p>Penders et al. (2006) Factors influencing the composition of the intestinal microbiota in early infancy. Pediatrics.</p><p>由於腸道微生物攸關人體健康，了解腸道微生物的組成與建立相當重要。雖然已有文獻報導分娩方式、飲食和環境等因素與腸道微生物的關聯，但這些研究多半僅聚焦特定因素，且涵蓋的樣本數有限，以至於難以符合隨機分派的研究標準。</p><p>因此，Penders et al. 在荷蘭施行了一項前瞻性研究，分析千餘名足月嬰兒的排遺樣本，以透過大規模的調查，來評估影響嬰兒早期腸道微生物組成的多種因素。</p><p>可能因為這是項探索性研究，所以論文中沒有把問題描述得很清楚。</p><ul><li>主題：影響嬰兒腸道微生物相的因素</li><li>疑難：樣本數不足以符合隨機分派的標準，以至於無法排除干擾因素的影響</li><li>策略：使用更多的樣本</li></ul><h1 id="利用即時-PCR-和北方墨點法定量嬰兒排遺內的腸道細菌"><a href="#利用即時-PCR-和北方墨點法定量嬰兒排遺內的腸道細菌" class="headerlink" title="利用即時 PCR 和北方墨點法定量嬰兒排遺內的腸道細菌"></a>利用即時 PCR 和北方墨點法定量嬰兒排遺內的腸道細菌</h1><p>Hopkins et al. (2005) Characterisation of intestinal bacteria in infant stools using real-time PCR and northern hybridisation analyses. FEMS Microbiology Ecology.</p><p>(1) 腸道細菌的拓殖受飲食、環境、抗生素施用及年齡影響。(2) 由於哺乳及益生菌在預防腸道疾病的功效，許多研究探討了哺乳與腸道微生物的關聯。(3) 即時 PCR 可以克服難養菌的限制，也能研究北方墨點法無法偵測到的少量細菌。(4) 因此 Hopkins et al. 分別使用即時 PCR 和北方墨點法，定量常見的腸道微生物並了解其與飲食型態的關聯，聚焦的菌群如下：</p><p>Bacteroides and bifidobacteria 在碳水化合物的代謝中扮演重要角色，其中常用作益生菌的 bifidobacteria 是嬰兒腸道的優勢菌群。<br>Enterococcus faecalis （一類兼性厭氧菌）是許多感染性腸炎的病原，且被認為與逐漸盛行的抗藥性有關。<br>Dissimilatory sulfate-reducing bacteria 可能與發炎性腸道疾病有關。</p><p>句子 (1) 說明研究主題，接著利用句子 (2) 的推理點出研究問題：「腸道微生物與哺乳行為的關聯是什麼？」（推理方式：哺乳與預防疾病有關　→　益生菌與預防疾病有關　→　哺乳可能透過改變腸道微生物達到預防疾病的效果　→　研究哺乳與微生物的關聯）。</p><p>Hopkins et al. 沒有明確指出研究難題（或研究立基）是什麼，但從句子 (3) 看來，應該是想表達即時 PCR 和北方墨點法可以相輔相成，克服培養學的部分限制。最後句子 (4) 解釋了選擇的研究目標和理由。</p><p>由於腸道菌與飲食的關聯是一個很大的題目，所以論文標題有「使用某某技術」的字眼限制研究範圍。不過即使如此，問題還是沒有很明確，這可能是因為早期的腸道微生物研究仍在探索階段的關係。</p><h1 id="利用-FISH-描繪餵食配方奶和母乳的嬰兒之排遺樣本微生物相"><a href="#利用-FISH-描繪餵食配方奶和母乳的嬰兒之排遺樣本微生物相" class="headerlink" title="利用 FISH 描繪餵食配方奶和母乳的嬰兒之排遺樣本微生物相"></a>利用 FISH 描繪餵食配方奶和母乳的嬰兒之排遺樣本微生物相</h1><p>Bezirtzoglou, Tsiotsias, and Welling (2011) Microbiota profile in feces of breast- and formula-fed newborns by using fluorescence in situ hybridization (FISH). Anaerobe.</p><p>(1) 由於微生物涉及宿主的營養代謝、免疫運作與致病機制，正常的微生物相攸關宿主的健康。(2) 為了瞭解微生物與宿主生理及健康的關聯，精確測量微生物的組成相當重要。(3) 既有研究受限於培養方法，僅能探討可培養的菌群，而這些菌群也可能受培養環境的選擇性影響（特異性太差或靈敏度太低）。(4) 這兩項因素導致基於培養方法的研究無法充分比較人體共棲菌群的差異。</p><p>(5) 若能更細緻地紀錄排遺樣本的微生物相，將有助於我們了解腸道疾病的病理機致，也能提升治療手段的效率和特異性。(6) 此外，增進腸道微生物變化的知識有助於我們了解健康人與患者的腸道微生物生態。(7) 然而培養方法難以反映腸道微生物在處於不同狀態的宿主的變化。</p><p>(8) 近年來，分子技術逐漸用於微生物生態學研究，這些技術使排遺微生物的研究能克服培養方法的限制。(9) Fluorescence in situ hybridization (FISH) 是其中最直接，且能辨識複雜生態系統中單一細胞的技術。(10) 因此 Bezirtzoglou, Tsiotsias, and Welling 使用 FISH 來比較餵食配方奶和母乳的嬰兒之排遺樣本微生物相，以取得培養學方法無法獲得的資訊。</p><p>句子 (1) 說明重要性，句子 (2) 提出研究問題。句子 (3)、(4) 說明研究難題和既有研究的限制，句子 (5)、(6)、(7) 解釋若不解決這些難題會有什麼後果。句子 (8) 呈現克服難題的轉機，句子 (9) 說明克服難題的策略，句子 (10) 表明研究目的。</p><p>簡而言之，此文的核心概念是：「測量微生物的方法很重要，過去的方法不好，所以我採用新方法來研究微生物。」不過雖然說明了重要性和必要性，但沒有解釋為什麼 FISH 比其他技術好。不過這也許是當代的常識，所以才沒有特別提點。</p><h1 id="人類嬰兒排遺樣本內的腸道微生相在首次引入副食後的決定因素"><a href="#人類嬰兒排遺樣本內的腸道微生相在首次引入副食後的決定因素" class="headerlink" title="人類嬰兒排遺樣本內的腸道微生相在首次引入副食後的決定因素"></a>人類嬰兒排遺樣本內的腸道微生相在首次引入副食後的決定因素</h1><p>Fallani et al. (2011) Determinants of the human infant intestinal microbiota after the introduction of first complementary foods in infant samples from five European centres. Microbiology.</p><p>(1) 早期發生在嬰兒腸道微生物的事件可能對慢性疾病的發展有長遠影響。(2) Fallani et al. 先前曾指出腸道微生物初期的拓殖深受嬰兒飲食行為、分娩方式、國籍和抗生素施用影響。(3) 在此研究中，Fallani et al. 則要檢視腸道微生物在離乳期間的變化。</p><p>(4) 離乳期間，嬰兒的腸道出現新的不可消化碳水化合物，消化系統和免疫系統也逐漸成熟。這些環境條件的變化可能影響微生物的組成。(5) 然而，目前針對嬰兒腸道微生物在離乳期間之變化的研究有限，而探討離乳前的飲食和各項臨床因素在引入副食後對腸道微生物之影響的研究也闕如。</p><p>(6) 因此，Fallani et al. 分析了來自五個歐洲國家的嬰兒在離乳前後採集的排遺樣本內的微生物，探討嬰兒腸道微生物在離乳期間的變化，並評估影響此過程的其它臨床因素。</p><p>句子 (1) 說明主題和重要性，句子 (2) 作為鋪陳，以說明研究目的（句子 (3)）。句子 (4) 預測「離乳 → 腸道環境變化 → 微生物組成改變」。句子 (5) 說明研究利基，句子 (6) 具體說明研究目的和內容。</p><h1 id="嬰兒排遺微生物相之發展及其與分娩方式、飲食及過敏疾病的關聯"><a href="#嬰兒排遺微生物相之發展及其與分娩方式、飲食及過敏疾病的關聯" class="headerlink" title="嬰兒排遺微生物相之發展及其與分娩方式、飲食及過敏疾病的關聯"></a>嬰兒排遺微生物相之發展及其與分娩方式、飲食及過敏疾病的關聯</h1><p>Galazzo et al. (2020) Development of the Microbiota and Associations With Birth Mode, Diet, and Atopic Disorders in a Longitudinal Analysis of Stool Samples, Collected From Infancy Through Early Childhood. Gastroenterology.</p><p>(1) 出生後的腸道微生物拓殖攸關免疫系統發育與成熟，許多流行病學研究指出，嬰兒腸道微生物與哮喘及過敏性疾病息息相關。(2) 儘管與過敏或哮喘相關的微生物已被辨識，但何者對疾病有正面影響，又何者有負面影響仍不明確。</p><p>(3) 這種現象可能是方法學差異、樣本數不足或沒有控制好混淆因素所致。(4) 此外，雖然橫斷研究設計普遍用於探討微生物相與疾病的關係，但難以排除反向因果關係；而縱向研究設計雖然能克服反向因果的問題，但有限的縱向研究欠缺足夠的追蹤時間，所以仍難以了解腸道微生物相的變化與病程的關係。</p><p>(5) 因此，Galazzo et al. 追蹤 440 名嬰兒周歲前的排遺樣本微生物變化 (n &#x3D; 1453)，藉由提升樣本數來排除臨床上的混淆因子，以研究腸道高度複雜且動態的微生物生態系。</p><p>句子 (1) 說明主題和研究重要性，句子 (2) 提出研究問題，句子 (3) 、(4) 解釋研究難題：「橫斷研究難以釐清因果，而縱向研究的樣本數又不夠」，句子 (5) 解釋研究策略（增加樣本數）和研究目的。</p><p>(1) 產後 13 、21、31 周，哺乳解釋了最多的腸道微生物組成變異（以 EnvFit 建模，用 r^2 度量解釋率）</p><p>(2) 產後 13 、21、31 周，腸道微生物組成因哺乳與否而異 (Permutational multivariate analysis of variance based on unweighted UniFrac)</p><p>(3) 相較於哺乳，添加副食僅在產後 31 周與腸道微生物組成相關，而且關聯性也較哺乳低。</p><p>(4) Bifidobacteria、staphylococci、streptococci 的相對數量在停止餵食母乳後顯著下降，而 Lachnospiraceae 的細菌之相對數量則上升 (Multivariate Analysis by Linear Models)</p><p>(5) 哺乳的時間長短與微生物相年齡負相關 (Multivariate Analysis by Linear Models)</p><p>【討論】依據結果 (1)、(2)、(3)，Galazzo et al. 推論唯有在離乳後，隨著母乳寡糖及其降解物質減少，才會加速腸道微生物相成熟的進程（即能代謝複雜碳水化合物的菌屬成為腸道的優勢菌屬）。</p><p>原則上，哺乳佔嬰兒飲食的比例會隨年齡增長而下降，相對地，攝取副食品的比例會逐漸上升。我最初以為微生物相的變化可能會反映飲食型態的轉變模式。然而此文及其引用的文獻卻指出，添加副食只有在離乳後才會對腸道微生物相有影響。</p><p>這個現象意味著，與哺乳相關的微生物特徵和母乳攝取量無關，亦或是離乳對腸道微生物的影響遠大於母乳攝取量的影響。（不過也可能是推論的基礎有誤，或許這些嬰兒的飲食變化是劇烈而非漸進的）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bad interpreter: No such file or directory</title>
      <link href="/bad-interpreter-no-such-file-or-directory/"/>
      <url>/bad-interpreter-no-such-file-or-directory/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Linux 執行 Perl、R 或 Python 腳本時，有幾種情況可能會跳出 “bad interpreter: No such file or directory”。</p><span id="more"></span><h1 id="打錯字"><a href="#打錯字" class="headerlink" title="打錯字"></a>打錯字</h1><p>檢查 #!&#x2F;usr&#x2F;bin&#x2F;env 有沒有拼對，如果拼錯的話也會報錯。</p><h1 id="路徑不對"><a href="#路徑不對" class="headerlink" title="路徑不對"></a>路徑不對</h1><p>即「<a href="https://www.cnblogs.com/xuxianren/p/4612440.html">執行Python “&#x2F;bin&#x2F;usr&#x2F;python: bad interpreter: No such file or directory” 錯誤</a>」中提到的問題：當腳本開頭寫成 #!&#x2F;usr&#x2F;bin&#x2F;python 時，如果沒有主動連結到安裝的 python 版本，有可能找不到。改寫成 #!&#x2F;usr&#x2F;bin&#x2F;env python，就會自動尋找 python 的路徑了。</p><h1 id="腳本的編碼格式不相容"><a href="#腳本的編碼格式不相容" class="headerlink" title="腳本的編碼格式不相容"></a>腳本的編碼格式不相容</h1><p>Windows 記事本的格式和 Linux 的腳本不同，所以會因為隱藏的字元而無法判讀，解決方法可參考「<a href="https://www.cnblogs.com/xuxianren/p/4612440.html">sh腳本異常：&#x2F;bin&#x2F;sh^M:bad interpreter: No such file or directory</a>」，在 vi 或 vim 編輯器下，以 :set fileformat&#x3D;unix 修改腳本編碼。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻殼機動隊 STAND ALONE COMPLEX</title>
      <link href="/kenji-2002-ghost-in-the-shell-stand-alone-complex/"/>
      <url>/kenji-2002-ghost-in-the-shell-stand-alone-complex/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這部由主線──笑臉男事件和支線──電子腦、義體普及引發新型社會問題組成。</p><p>主線外的小故事可以獨立看，不影響通篇劇情理解。但是支線是以公安九課的各幹部為主角(還有思考機器人，塔奇克馬)，只聚焦笑面男事件就會錯失了解個別配角的機會。例如每次調查幾乎都是佗古薩上陣，笑面男的突破線索幾乎由這個有家庭沒義體化的new comer給找出來。</p><p>不過我覺得笑面男事件結尾有點不過癮，反派顯得不夠力。前頭醞釀的巨大陰謀在夕陽西下的最後一集平淡結束，讓前一集被激起的情緒無處宣洩。</p><span id="more"></span><h1 id="電子腦和義體"><a href="#電子腦和義體" class="headerlink" title="電子腦和義體"></a>電子腦和義體</h1><p>本作最重要的設定為電子腦和義體：電子腦是把意識和網路、程式連結起來的設備。義體簡單如義肢、義眼用以取代或強化原有器官，複雜的可以直接作為意識的載體。</p><p>依照電子腦的連結對象又可分為三種情形：硬體、軟體、其他人腦(在能把意識資訊化的世界觀裡，自我意識要算廣義的軟體了)，每個情形出現異常、矛盾或是和社會價值衝突就成為個小故事的題材。</p><p>電腦有各種存取資料的結構搭配不同的演算法以解決問題。人腦雖然沒有堆疊、佇列或樹來保留學習記憶和本能，處理問題卻比電腦有創意多了。</p><p>像 26 集「公安九課 再臨」最後面笑臉男和少佐講一堆名言時，課長把電子腦和連結到外部資料庫以聽懂他們的對話。要及時理解對話，就要對那些名言佳句有印象。</p><p>印象，也就是記憶。當電子腦和資料庫連結架起，且讀取資料的時間能和人們讀取回憶一樣快時，就會產生有印象的錯覺。但假若資料庫沒辦法像人腦那樣存取，那讀取的速度就會受限於資料庫本身設計，這樣的連結頂多是不用手指划的智慧型手機。</p><p>可是每個人記憶的模式不一樣，資料庫是為通用的查詢所設計，所以連結的同時也得對資料進行處理。也許是那瞬間將資料庫依序放進電子腦，再依照個人特質進行儲存。或者，因應電子腦的出現，個人資料庫和個人網站一樣跟著普及起來。畢竟前述方法仍要花時間在預先分類資料。</p><h1 id="義體與本體感覺"><a href="#義體與本體感覺" class="headerlink" title="義體與本體感覺"></a>義體與本體感覺</h1><p>而第11集「在若林的森林」提到的電子腦自閉症，是電子腦和硬體連結不協調進一步到病症的例子。</p><p>器官移植要解決免疫系統在生理上的排他，義體又是比器官移植更劇烈的變化還須克服心理上的排他。雖然組成身體的分子每分每秒都在代換，但是結構不變我還是能認得自己。但像是換肢手術的例子，就算免疫系統接納了捐贈者的器官，受贈者心理上仍須花時間適應。</p><p>義體更是把腦以外全換為人造器官，面臨的心靈衝擊又更大，輕者只是感知遲鈍地像醉酒，重者產生自閉症、甚至變植物人完全無法協調。像少佐很小的時候就全身義體化，要隨成長更換義體，每次都要對更大的身體重新適應（難怪叫ghost in shell , 隨成長更換的外骨骼）</p><p>另外比較小的問題就是電子腦和武器做連結若不能達成人機一體的同步率，會造成使用者的不便(例如 15 集「機器們的時間」裡面的新型狙擊裝置)</p><h1 id="電子腦與自我意識"><a href="#電子腦與自我意識" class="headerlink" title="電子腦與自我意識"></a>電子腦與自我意識</h1><p>除了高同步率(即操作、讀取的效率)，電子腦也得內建系統避免人與人的界線因電子腦間的連結而消弭。畢竟讀取別人的腦和讀取自己的腦一樣便捷，還能認得出我是誰嗎？</p><p>像第 18 集「暗殺二重奏」 連結上父親記憶的兒子在舉止上越來越像父親，甚至在兒子身上產生父親的人格。第 21 集「丟棄的軌跡」巴特錯把佗古薩重傷的時的情緒當成自己的情緒變得暴躁起來。</p><p>電子腦發明前，人的意識被肉身包覆，要彼此影響只能靠有限的五官(語言、行為)，雖然意念轉換成過程有可能造成誤會，但也保護了個體的獨立性：只能用嘴巴說服、用行為證明、用金錢誘惑……只能從外在下手，而且一個人即便行為舉止受制於人，仍能保有自我思考這最後的自由。</p><p>一旦原始的防壁敞開，意識就有被人操作的危險(笑臉男就常控制別人意識幫她代言)，所以也就有個人防壁的產生。</p><p>然而，也有不設防壁的例子，讓別人不需迂迴地經過文字、圖畫、影像、聲音來理解自己的概念，例如 15 集「機器們的時間」把自己電子腦開放的導演，讓與之連結的人沉迷於其腦海裡的電影構想而無法自拔。</p><h1 id="義體、電子腦與社會"><a href="#義體、電子腦與社會" class="headerlink" title="義體、電子腦與社會"></a>義體、電子腦與社會</h1><p>至於價值觀、宗教的反對電子腦化，貧富不均導致義體分配不均……都是些老問題，癥結點往往不是出在科技本身。</p><p>像是宗教和價值觀的反對是個人理念，貧富不均則是社會體制的問題，就算沒有電子腦換成別的發明都會持續存在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物調控原理的上課筆記</title>
      <link href="/yang-2019-principles-of-biological-regulation/"/>
      <url>/yang-2019-principles-of-biological-regulation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我在上課的時候發現，把任何定義裏頭的名詞換成人生，聽起來都會很有道理。</p><span id="more"></span><blockquote><p>人生的哲學是化約、假說和驗證。</p></blockquote><blockquote><p>如果你碰到一個問題卻沒辦法解釋，但有毅力把生物系統劃分為子系統，那麼你就有機會藉由研究較單純的子系統，拼湊出整個系統的運作機制。在生物學上，我們稱這種決心叫化約。</p></blockquote><blockquote><p>小紙條放在口袋裡面，有點像錦囊妙計，問題解決不了時就拿出來看看。</p></blockquote><blockquote><p>要在不一樣的人生中看到相似性。</p></blockquote><blockquote><p>巴斯德的鵝頸瓶裏頭的肉汁到現在還是清澈的。</p></blockquote><blockquote><p>每個人都有屬於自己的宿命，人在年輕的時候，或許會走偏，或許會原地踏步，甚至繞了一大圈仍然迷惑不已，但最終終究會走回自己應走的道路上。</p></blockquote><blockquote><p>你說「生物系統這個黑盒子這麼難我怎麼可能理解」，但我們台灣人的長處就是 reverse engineering。</p></blockquote><blockquote><p>人生是由物件（components）、事件（events）、順序（pathways）與循環（circuits）組成。</p></blockquote><blockquote><p>小分子碰撞在一起會立即彈開，大分子碰撞在一起則會接觸一陣子才彈開，相處時間決定反應是否發生。</p></blockquote><blockquote><p>以前的生物化學強調記憶，現在的生物化學注重道理。</p></blockquote><blockquote><p>TCA cycle 與人生都是由拋棄與弭補構成的循環。</p></blockquote><blockquote><p>人生中很常出現 duplicate。</p></blockquote><blockquote><p>人生有兩個難題：找到該走的路（puzzle），決定該怎麼走（maze）。如果不搞清楚的話，思考的時候就會亂掉。</p></blockquote><blockquote><p>人生怎麼從高峰走向低潮是動力學問題，為什麼既有高峰也有低潮則是熱力學問題。</p></blockquote><blockquote><p>人生的轉變很難像個理想的開關，只有 All or None。</p></blockquote><blockquote><p>兩個人想要追求目標，要考慮先形成 complex 再 binding，還是先 binding 再建立 cooperativity？</p></blockquote><blockquote><p>台灣做的味精大多是用發酵作的。</p></blockquote><p>如今，我已經忘記當初是用人生來替換哪些字眼，但還是記得該怎麼活下去的訣竅唷。</p>]]></content>
      
      
      
        <tags>
            
            <tag> philosophy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《少棒的基礎》</title>
      <link href="/nishi-2015-junior-baseball-coaching-book/"/>
      <url>/nishi-2015-junior-baseball-coaching-book/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>相較於影片，要以圖文解釋複雜動作有許多限制，所以此書的重點不在於老生常談的技術內容，而是引進刻意練習的帶隊觀念。</p><p>訓練的目的是在比賽中獲勝。而比賽取勝則是我方投、打、傳、接等基本技巧，以及戰術、補位和佈陣等團體默契勝過對方。</p><p>流於形式的訓練無法讓技術進步，惟有發現真正的不足，思考進步方法並付諸實行，才是訓練的根本意義。</p><span id="more"></span><h1 id="以提升實力為目標進行訓練"><a href="#以提升實力為目標進行訓練" class="headerlink" title="以提升實力為目標進行訓練"></a>以提升實力為目標進行訓練</h1><p>訓練的目的是讓球技進步並在比賽中展現成果。和比賽相比，訓練佔了球員大部分的時間，為了讓訓練契合進步這個目的，訓練必須有效率，讓有限的時間更加充實。</p><p>想要進步的衝動源於有所不足的自覺，但進步的關鍵在於思考。球員必須思考練習的目的，從中察覺自己的弱點，並時刻檢討是否因練習而進步。</p><p>若否，則要找出原因，而非一味加重練習量。先了解自己的不足並專項特訓才有機會克服弱點，逐步達到原先辦不到的事。</p><p>此外，雖然球員可以在比賽中累積經驗，但不能僅憑密集的賽事提升能力，因為比賽多屬成果驗收，欠缺讓球員進步的時間。</p><h1 id="技術有意識可控制和不可控制的部分"><a href="#技術有意識可控制和不可控制的部分" class="headerlink" title="技術有意識可控制和不可控制的部分"></a>技術有意識可控制和不可控制的部分</h1><p>每個球員都有個性，優於無意識的習慣難以改變，所以明確的建言很危險。若球員無法體會教練的指導，過於明確的指示會使球員只注意到建言的表面，而忽略沒提到的重點。</p><p>此外，當球員專注於達到教練的標準時，也會為了矯正無法改變的錯誤而顧此失彼。</p><p>是以，指導球員時要採用類比或感性的詞彙，讓球員理解技術的意象而非規範。至於較明確的技術，可以在不影響個性的前提下，從可以意識的部分開始改進。</p><p>（可以參考《魔球》這段話：「這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。(p. 226)」）</p><h1 id="養成球員自我思考的習慣"><a href="#養成球員自我思考的習慣" class="headerlink" title="養成球員自我思考的習慣"></a>養成球員自我思考的習慣</h1><p>團隊意識、自主思考是運動的重要資產。</p><p>運動是自主思考並採取行動的活動，所以別等待指示。比賽時雖然有教練和隊友提點，球員仍要主動思考下一步並提前準備，以期反應時間縮短。</p><p>能力可及便自主行動，不可及就勇於發問，別讓問題懸著，重點是要充分表達自己的想法。賽場上要彼此協調互相指揮，在訓練時判斷錯誤也不要緊，重點是養成表達意見的習慣。</p><p>培養比賽默契的方法是建立共識，例如討論一份補位方法、暫停時機，並且在賽場上互相提醒，大喊、比手勢等等。</p><p>最後，沒有進步也會有收穫。身為教練，不該為辦不到的事情責備球員，但是要追究能力可及卻不願努力的事。</p><h1 id="高掛球鞋後讀"><a href="#高掛球鞋後讀" class="headerlink" title="高掛球鞋後讀"></a>高掛球鞋後讀</h1><p>大學花太多時間在打壘球，畢業時感到無盡的空虛，那段光陰似乎對人生一點幫助也沒有，還增添不少苦澀。所以我總跟朋友講：「早知道就進實驗室，去打工、找實習，做啥不好。」</p><p>重新翻這本書，也只是想說服自己有從打球學點有用的東西。但是，棒壘球要怎麼搭上我現在的職業呢？我後來發現《少棒的基礎》提倡的帶隊觀念和刻意練習的精神相符，都主張進步需要訓練和回饋並重。</p><p>所以，也許可以說我從打球體會了刻意練習吧？另外，因為屢戰屢敗又沒什麼人和資源，也漸漸習慣從爛咖的角度思考要怎麼克服障礙，例如學會厚臉皮鑽漏洞之類的非典型途徑。</p><p>可是這些東西得靠打球才學得到嗎？我想不是。因此，與其苦惱過去有什麼價值，不如積極規劃往後的人生。若真想探討所作所為的意義，那麼打球只是成為我自己的必要條件而已。</p><p>好吧，現在已經沒有球員可以訓練，我得學著成為自己的教練。</p><h1 id="留言"><a href="#留言" class="headerlink" title="留言"></a>留言</h1><blockquote><p>Stanley Huang，2020年2月2日 晚上8:46<br>同意這句<br>這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。<br>或許也可以說，差勁的打者反而知道大家問題可能出在哪，所以更能對球員的問題感同身受</p></blockquote><p>超級boy，2020年2月3日 下午2:17</p><p>應該說，教學時若要求球員的動作與教練一致，那球員很有可能為了達到標準而顧此失彼。由於差勁的打者不會逼你學他們，所以能避開這項教學錯誤。</p><p>至於能否對球員的問題感同身受，我覺得跟球技無關，而是跟教練的背景有關。所以不同類型的教練能幫助到不同類型的球員。</p>]]></content>
      
      
      
        <tags>
            
            <tag> zatsugaku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寫科普又不能當飯吃，為什麼還要寫？</title>
      <link href="/why-do-people-write-scientific-articles/"/>
      <url>/why-do-people-write-scientific-articles/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文是 Mitalk 4 講座「科普如何當飯吃？」的聽講心得，陳俊堯老師在演講一開始先回答了這問題，再一一告訴我們，如果無法靠寫科普賺錢營生，那麼從事研究的學生、老師和學者們，到底有什麼理由勞心費神去寫科普文？</p><blockquote><p>科普如何當飯吃？做夢吧，科普怎麼可能當飯吃。</p></blockquote><span id="more"></span><h2 id="科普不能當飯吃，為什麼還要寫科普？"><a href="#科普不能當飯吃，為什麼還要寫科普？" class="headerlink" title="科普不能當飯吃，為什麼還要寫科普？"></a>科普不能當飯吃，為什麼還要寫科普？</h2><h3 id="即使無法靠科普吃飯，也能藉由撰寫科普成長"><a href="#即使無法靠科普吃飯，也能藉由撰寫科普成長" class="headerlink" title="即使無法靠科普吃飯，也能藉由撰寫科普成長"></a>即使無法靠科普吃飯，也能藉由撰寫科普成長</h3><p>老師提到，他的著作《細菌好朋友》雖然囊括許多獎項，但半年的銷量折算為利潤後僅得兩萬餘元。既然連成功的出版品都無法為作者帶來財富，那研究生為什麼要勞費心力撰寫更冷門的科普文章？</p><p>儘管老師提及科普能促進跨領域對話、增進國民素養或支援科學教育，但先不論寫科普的外部效益，書寫本身就是一種有效的學習方式。</p><p>很多時候我們不是懂了才開始寫作，而是從蒐集資料、提煉知識和撰寫文章的過程中，逐漸了解想要傳達的事物。具體的文字能協助我們察覺思路不嚴謹之處，而寫作瓶頸則讓我們意識到知識的空缺。因此，即使我們無法憑藉科普營生，也能從撰寫中成長。</p><h3 id="研究員也能為自己的愛好發聲"><a href="#研究員也能為自己的愛好發聲" class="headerlink" title="研究員也能為自己的愛好發聲"></a>研究員也能為自己的愛好發聲</h3><p>但是，當今有許多科普網站和知識型 Youtuber 向大眾導讀論文和破解迷思，那麼研究員還有必要跳進來寫科普嗎？若想要自我成長，為什麼不寫在筆記本上就好了？</p><p>首先，學術需要政府與社會支持，研究員不能總是期待他人為研究議題發聲。以新視野號任務為例，由於美國政府的漠視，探索冥王星始終不是太空任務的優先目標，即使獲准執行，其預算也接連被削減。</p><p>為此，志在研究冥王星的 Alan Stern 只得想盡辦法遊說國會，並發起請願以尋求大眾支持。最終，新視野號任務總算排進了正式的探索行程中。雖然不能把任務的成功完全歸功於科普，但這項案例告訴我們：若研究員能為了自己的好奇心而發聲，嘗試去說服他人，那麼確實有機會將個人的願望推廣為大眾的願望。</p><p>在說服大眾方面，科普文章是性價比很高的工具。儘管影視寓教於樂，但研究員恐無暇製作。相較之下，寫作的成本低廉還能傳遞最多資訊。內容確實且題材多樣的文字材料，可作為其他科普媒介發展的基礎，擴張文章的影響力。</p><h3 id="不輕易將話語權讓給不懷好意的人"><a href="#不輕易將話語權讓給不懷好意的人" class="headerlink" title="不輕易將話語權讓給不懷好意的人"></a>不輕易將話語權讓給不懷好意的人</h3><p>教育家不是唯一對科普感興趣的人，還有濾水器廠商、智慧設計學家、政客等不懷好意的人也等著扭曲科學事實以支持他們的主張。因此，即使認為教育普羅大眾沒什麼益處，研究員也是較有立場和專業去維護科學的理性客觀價值。</p><p>相關案例在同婚公投期間層出不窮。護家盟為了表達反同立場，除了引用爭議性研究以外，還任意曲解其他學者經過長年研究和同儕審查得出的嚴謹結果。即使是研究人員本身，也會受到政治立場影響，做出有瑕疵的研究。</p><p>鑒於這些情形，研究員就算不為積極的理由寫作，也有動機為消極的理由發聲，以免研究成果為人利用，最後損及大眾對科學的信任。</p><h3 id="科普文章是經驗交流的管道"><a href="#科普文章是經驗交流的管道" class="headerlink" title="科普文章是經驗交流的管道"></a>科普文章是經驗交流的管道</h3><p>最後，撰寫科普也能協力國內的科學教育發展。儘管推動雙語教學的風氣日盛，中文始終是最便捷的語言。但除了有限的翻譯書籍和科普網站，國高中生欠缺可靠的中文資料，架構完整而且內容正確的中文科普文章可以填補這個空缺。</p><p>我認為，即使是研究生也能受益於科普寫作。相較於國外林立的論壇，台灣的網路學術經驗交流很封閉，許多技術細節和科研心得埋藏在碩博士論文、實驗室內網或私密社群裡，以至於解決問題的經驗無法共享和傳承。</p><p>可是，國外既有成熟的討論區，為何執意要促進我們自己的交流風氣？首先，多數人的中文優於英文，故以中文撰寫文章較能準確表達觀念。再則，即使面對同樣問題，解決辦法與說明方式也因人而異，多元的內容能惠及不同程度和背景的群眾。</p><p>是以，撰寫科普文章不僅能彙整思路和鞏固知識，也能保留思考的成果，幫助他人解決困難。由於互助的效益會隨參與人數增加，所以即使費時耗力也值得投資。</p><h2 id="那麼該如何撰寫科普文章呢？"><a href="#那麼該如何撰寫科普文章呢？" class="headerlink" title="那麼該如何撰寫科普文章呢？"></a>那麼該如何撰寫科普文章呢？</h2><h3 id="科普、課本和論文的差異在於受眾"><a href="#科普、課本和論文的差異在於受眾" class="headerlink" title="科普、課本和論文的差異在於受眾"></a>科普、課本和論文的差異在於受眾</h3><p>由於科普、課本和論文的目的皆為有效傳達訊息，優良的著作皆具有趣、簡潔和明瞭等特性。然而，三種文體的受眾不一，所以各自側重不同特性。論文的讀者是學者，所以旁徵博引、言簡意賅；課本的讀者是學生，因此體系完整、內容詳盡。</p><p>至於科普的讀者，則是任何有興趣的大眾。是以，科普雖然像論文一樣報導新知，卻不能吝於用字；科普也跟課本一樣具有理解新知所需的背景知識，卻不應填塞無關的資訊。除了話不能省和料不能多，科普文章要能製造驚奇以取悅讀者。</p><h3 id="撰寫科普的第一步是選定讀者"><a href="#撰寫科普的第一步是選定讀者" class="headerlink" title="撰寫科普的第一步是選定讀者"></a>撰寫科普的第一步是選定讀者</h3><p>讀者的年齡、背景和興趣攸關選材、用字和敘事風格。因此，撰寫科普文章的第一步是選定讀者，接著推測讀者想讀的內容，尋找具有衝擊性的主題。至於該怎麼寫，可以參考老師提出的「派大星貓一拳結構」。</p><p>每一篇科普都是一場冒險，文章開頭要建立現實與科學之間的橋樑，吸引讀者踏入作者營造的奇妙世界。例如，想要介紹趨化性 (chemotaxis)，可以從「撲鼻而來的雞排味」寫起，利用與主題相關的生活經驗，讓讀者對內容有具體的概念，也讓他們了解自己與主題的關係。</p><p>好的故事需要鋪陳，重要觀念也有其前提，所以破題之後先別切入重點，要交代問題和背景知識。例如經典的回馬槍結構：提問以後，先順應大眾的常識推論，接著點出先前敘述的矛盾，讓讀者在觀念衝突之下，迫不及待想要知道答案。</p><p>鋪陳以後迎來故事的高潮，要把想傳達的科學概念清楚明瞭地寫出來。最後則要總結文章，再次連結主題和生活經驗，把讀者送回現實。而更多寫作結構的細節，老師推薦我們讀讀《怎樣談科學》。</p><h3 id="撰寫科普的訣竅"><a href="#撰寫科普的訣竅" class="headerlink" title="撰寫科普的訣竅"></a>撰寫科普的訣竅</h3><p>寫作時請留意，科普讀者只是還沒學到相關知識，而不是欠缺理解能力。因此，要簡化內容，但不要藐視讀者（例如對著國小學生用）。</p><p>其次，儘管寫作時要交代背景知識，並且陳述推理的過程，但用字仍要力求簡練，以免花俏或冗贅的字眼模糊焦點。老師強調「話不能省」是指邏輯不要跳躍，而不是用繁複的文字困擾讀者。</p><p>最後，撰寫文章是學習的過程，所以開始動筆時對主題沒有完整的理解仍可以接受。然而在交付文章之前，要再三確認自己已經搞懂，以免寫出似是而非的奇怪內容。</p><h2 id="該如何練習寫科普？"><a href="#該如何練習寫科普？" class="headerlink" title="該如何練習寫科普？"></a>該如何練習寫科普？</h2><h3 id="所謂寫作，就是空出時間寫作"><a href="#所謂寫作，就是空出時間寫作" class="headerlink" title="所謂寫作，就是空出時間寫作"></a>所謂寫作，就是空出時間寫作</h3><p>所謂寫作，就是空出時間寫作。他人整理的訣竅得在練習中實踐，障礙和困難也只有在實作中才能體會。而且，文章完成後才有被閱讀和被修改的機會，因此，老師在建議大家，聽完演講以後趕快找一則論文試試看。</p><h3 id="以改寫培養寫作能力"><a href="#以改寫培養寫作能力" class="headerlink" title="以改寫培養寫作能力"></a>以改寫培養寫作能力</h3><p>如果真的不知道怎麼寫，可以從改寫起步。首先熟讀感興趣的論文，再擷取核心觀念以中文重述（若想要省事也可以直接從摘要開始改寫）。</p><p>接著，思考想傳達給讀者的訊息，開始移除不必要的內容。例如在介紹飲食跟腸道微生物關係的文章裡，不需要用大半篇幅解釋 PCA ，重點是讓讀者明白吃肉的人吃素的人，腸道裡的微生物有什麼差異。</p><p>由於術語、抽象詞和簡稱會造成困惑，所以可以用代稱、範例和比喻等技巧減輕讀者的負擔。例如以下這段截自維基百科的句子便含有許多難解的詞彙：</p><blockquote><p><strong>枯草桿菌（學名：Bacillus subtilis）</strong>，是<strong>芽孢桿菌屬</strong>的一種細菌，為<strong>革蘭氏陽性</strong>的好氣性菌，普遍存在於土壤及植物體表，在人體亦可發現在腸道內共生的枯草桿菌。型態上的主要特徵是菌體表面生有<strong>鞭毛</strong>，體內形成的<strong>內生孢子</strong>可抵抗惡劣的外在環境而存活。</p></blockquote><p>可以改寫為：</p><blockquote><p>人的肚子裡住著一群長條狀的細菌，叫做 Bacillus subtilis ——就叫它 B 細菌吧。 B 細菌身上有條尾巴，所以可以在肚子裡游來游去。</p></blockquote><p>在改寫版本裡，用「肚子裡住著」來解釋「共生」（比喻），用 B 細菌替代 Bacillus subtilis 減輕讀者對英文的恐懼（代稱）卻不損害本意。最後以游泳為例，說明鞭毛的功能（範例）。此處用尾巴比喻鞭毛可能造成誤解，所以可以補充鞭毛的照片給讀者正確的印象。</p><p>改寫後，能用「因為」、「所以」、「但是」等連接詞完善文章的架構，讓讀者了解此段的用意和前後文關係。而且要顧及讀者的注意力和記憶力，適時總結內容或插入圖片以調整閱讀節奏。</p><p>綜上所述，透過改寫培養寫作能力的流程就是：閱讀文獻、決定要旨、篩選內容、改寫文句、理清句子關係、安插小結與圖片。接下來就能分享成品給其他人看，再從回饋中改進自己不足之處了。</p><h3 id="可以在哪裡寫科普？"><a href="#可以在哪裡寫科普？" class="headerlink" title="可以在哪裡寫科普？"></a>可以在哪裡寫科普？</h3><p>寫文章難，找到讀者更難，讀者願意給意見則難上加難。儘管讀者的回饋可以促使作者成長，但寫作初期不容易找到知音，此時可以投稿科學月刊、泛科學和科普寫作網路平台等媒體，在與編輯來往的過程中學習。（即使被退稿，也能了解自己與已出版著作的差異。）</p><p>除此之外，社群網站也是分享文章的管道。許多組織都會利用社群網站傳遞消息，所以作者也能利用臉書或推特宣傳作品。然而社群媒體適合宣傳，卻不適合保存知識。簡言之，這些網站的內部檢索不友善，對搜尋引擎的支援也不佳，所以不易取用裡頭的資訊。</p><p>所以，我認為在個人網頁寫作然後用社群網站推廣，是兼顧知識保存和即時交流的好方法（也可以利用 medium 這樣結合寫文和社交的平台）。而這種方式也非新鮮事，因為在軟體工程的圈子裡，透過撰寫技術文章來自我提升已是常態。</p><p>當然，寫作除了養成能力以外，也是建立個人知識品牌的手段。想知道在熟練科普寫作以後，要怎麼拓展自己發言的份量，老師推薦我們讀《知識內容寫作課》。</p><h3 id="科普不是終點"><a href="#科普不是終點" class="headerlink" title="科普不是終點"></a>科普不是終點</h3><p>演講後，有同學請教老師怎麼避免想要解釋的衝動。的確，為了達到普及的效果，科普不免要犧牲文章的精確性，所以身為作者，有時難以克制更正內容的渴望。然而，溝通的效率不在於作者說了什麼，而在於讀者接收了多少。如果詳實的說明阻礙交流，那麼科普便喪失其意義了。</p><p>不過即使有意掌握文章的深度，初學者該怎麼判斷什麼應該寫進文章呢？老師指出，最好的方式就是在讀者的回饋中養成品味，所以再次強調，寫作的訣竅是練習。</p><p>更重要的，科普不是終點，科普的目標在於承先啟後。讀者終究要放下科普，拿起課本或期刊論文，踏入嚴肅而且冷漠的科學世界。科普作者的職責是為自己的言論負責，在告訴讀者瑰麗想像的同時，也要說明當前研究的限制。因此，只要留下足夠的參考資訊，讀者就能在往後的學習中，逐漸了解當初作者想方設法要告訴他們的，是科學的哪一面。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>即使無法以科普謀生，也值得為了提升能力、宣揚理念與捍衛自己的研究寫作。科普的特性是寫實、有趣和淺顯，寫作前可鎖定讀者以安排內容深淺和用字風格。科普文章也像故事，需要破題和鋪陳，欲傳達的知識若在故事的高潮細述，有助於讓讀者在讀畢後回味無窮。</p><p>行文時要留意，內容簡化不代表裝可愛，用字盡可能周詳而不冗贅，抱著分享而非炫耀的心態。吸引讀者之後，若能保持他們的注意力，移除無關或令人困惑的內容，可以大幅增加文章的可讀性。完成作品後可以投稿或刊登在自己的網站上，利己也利人。</p><p>若擔心簡化的內容會誤導讀者，可以用註記或參考資訊補充說明。畢竟科普的目的是引領讀者踏入科學世界，只要留下足夠的延伸資訊，讀者終究能從比喻中習得事實。</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MiTalk 2020：講廳的一隅</title>
      <link href="/mitalk-4-ntu-2020/"/>
      <url>/mitalk-4-ntu-2020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>既然我不是微生物學家，也沒成果可以投稿，而且也沒人逼我報名，為什麼我想參加 MiTalk 年輕科學家工作坊？</p><span id="more"></span><h1 id="MiTalk-2020：講廳的一隅"><a href="#MiTalk-2020：講廳的一隅" class="headerlink" title="MiTalk 2020：講廳的一隅"></a>MiTalk 2020：講廳的一隅</h1><h2 id="「我覺得自己只是在玩科學家家酒……」"><a href="#「我覺得自己只是在玩科學家家酒……」" class="headerlink" title="「我覺得自己只是在玩科學家家酒……」"></a>「我覺得自己只是在玩科學家家酒……」</h2><p>就讀碩班以來，我一直閉門造車和土法煉鋼。由於想探討的議題和指導教授的專業不同，我們只能邊做邊學，想辦法把關研究的合理性。然而，如果我沒能看出分析方法或試驗設計的破綻，也沒有得到專家或同儕背書，那麼我以為有意義的結果，不就只是堆砌的數據嗎？</p><p>儘管每學期邀請其他老師檢視研究內容，但只討論了研究方向，沒有深究細節，所以我對自己的研究還是沒有把握。而我學長和班上同學的論文題目各異，請教他們雖然能得到解決問題的靈感，但解決辦法是否合宜，彼此也莫衷一是。</p><p>此外，所上的氛圍也加深了我的不踏實感。我總覺得自己和在沙堆裡玩家家酒的小孩沒兩樣，只是裝模作樣操著名為科學方法的套路，把泥巴當飯糰想像自己吃得津津有味，卻從沒有把它當真的意思。</p><h2 id="「經過-peer-review-的研究才是完整的科學」"><a href="#「經過-peer-review-的研究才是完整的科學」" class="headerlink" title="「經過 peer review 的研究才是完整的科學」"></a>「經過 peer review 的研究才是完整的科學」</h2><p>儘管如此，環境問題不該是阻礙研究的藉口。除了系上的老師，學校裡還有數百位教授可以請教；即使是其他地區，也能透過網路或電話交流。而且，每年有那麼多研討會可以參加，想當面溝通根本不成問題。</p><p>蔡東湖老師說過：「經過 peer review 的研究才是完整的科學」，而我也認為苦思之後的想法若能經過同儕審視，可以增加自己對研究的信心（亦即更有把握說出「我沒做錯」還是「我做錯了」）。</p><p>因此，如果我有解決問題的決心，就不該把自己侷限在所上，應該窮盡可行的方法，繼而在真正的研究圈子尋求認可和批判。</p><h2 id="「我們歡迎正在從事微生物生態研究，或對微生物生態學有興趣的同好加入」"><a href="#「我們歡迎正在從事微生物生態研究，或對微生物生態學有興趣的同好加入」" class="headerlink" title="「我們歡迎正在從事微生物生態研究，或對微生物生態學有興趣的同好加入」"></a>「我們歡迎正在從事微生物生態研究，或對微生物生態學有興趣的同好加入」</h2><p>針對資料處理和統計推論等技術問題，我首先請指導教授介紹專家，再到論壇貼文詢問有經驗的人。為了獲得同學或其他老師的回饋，我試著在書報討論或課堂報告裡偷渡自己的研究內容，如此一來，平常沒空理我的人也不得不擠出意見。</p><p>最近，我開始在部落格記錄研究想法和分析心得。我盤算此舉既可累積碩士論文的素材，亦能讓研究為他人檢視，增加錯誤被糾正的機會。</p><p>由於還沒有完整結果可以投稿研討會，所以我先報名今年的 MiTalk 工作坊。既然我才接觸微生物學，官方網站的簡介也寫著「歡迎正在從事微生物生態研究，或對微生物生態學有興趣的同好加入」，所以我推測即使問出可笑問題應該是可以被原諒的。</p><p>儘管沒有投稿，我仍希望能在討論中，了解同儕如何思考問題和找尋答案，逐步建立自己判斷對錯的能力和信心，擺脫目前玩家家酒的窘境。這次的工作坊有好幾個交流的機會，像是邀請演講（發問）、海報（私下討論）、主題討論（討論）。如同主辦人楊姍樺老師所述，參加研討會或工作坊的目的是結善緣。</p><p>即使是學有所成的教授們也會利用這些機會和其他老師互通有無，所以學生更應該克服自己害羞的個性，盡可能參與每個討論環節，逐漸習慣科學交流的生態。</p><h1 id="邀請演講"><a href="#邀請演講" class="headerlink" title="邀請演講"></a>邀請演講</h1><h2 id="微生物群集組成在富含甲烷之沉積物內的空間變化（塗子萱老師）"><a href="#微生物群集組成在富含甲烷之沉積物內的空間變化（塗子萱老師）" class="headerlink" title="微生物群集組成在富含甲烷之沉積物內的空間變化（塗子萱老師）"></a>微生物群集組成在富含甲烷之沉積物內的空間變化（塗子萱老師）</h2><p>在海底沉積層，隨著深度增加，氧氣濃度漸減，而甲烷濃度遞增。塗老師利用德國廠商來台鑽探天然氣的機會，採集了台灣西南方兩個板塊交界帶的海底沉積樣本，研究微生物群集在不同地點和深度的組成差異。</p><p>由於此研究採以核酸為基礎的標的基因分析，所以無法確保蒐集到的資料是否為活躍的菌群（畢竟無論死活都採集得到 DNA）。在沉積環境中，越深處應該堆積了越多生物遺骸。所以有老師問，不同深度觀察到的微生物相差異是不是有可能受到這個現象影響。</p><p>另外，塗老師團隊使用的是 V4 區域來研究沉積層的微生物，不過這種環境也許有不少古菌，所以也有老師問 V4 區域引子能否有效覆蓋到研究標的。</p><p>雖然我目前只有做分析，但是要判斷結果的合理性仍須深入了解樣本採集流程，所以我覺得這幾個問題都蠻有參考價值的。</p><h2 id="混營浮游生物食物網的生物元素比取決於個體體型、光照強度和無機鹽供應（何珮綺博士）"><a href="#混營浮游生物食物網的生物元素比取決於個體體型、光照強度和無機鹽供應（何珮綺博士）" class="headerlink" title="混營浮游生物食物網的生物元素比取決於個體體型、光照強度和無機鹽供應（何珮綺博士）"></a>混營浮游生物食物網的生物元素比取決於個體體型、光照強度和無機鹽供應（何珮綺博士）</h2><p>碳、氮和磷等生命基礎元素的比例與體內主要化學方式相關。例如光合作用傾向於固碳，會提升碳氮比；而呼吸作用則會流失碳，於是降低碳氮比。換句話說，自營生物有較高碳氮比，而異營生物有較低碳氮比。</p><p>何博士的研究對象是混營的浮游生物，這類生物除了行光合作用，也能吸收營養鹽或捕食其他生物獲取能量。然而，這三種營養策略的相對效率因體型而異，所以體型不同的浮游生物可能採取不同的營養策略。</p><p>光合作用的效率取決於細胞的截面積 (πr^2)，而吸收營養鹽的效率取決於細胞的表面積 (4 πr^2)。兩者皆為冪增長，但吸收營養鹽的效率應該會在體型大到一定程度的時候超越光合作用的效率。</p><p>假設環境中存在所有大小的浮游生物，每種的數量都一樣多，而且體型大者能吃體型小者。那麼體型越大，能吃的生物就越多，所以捕食的效率是線性增長。</p><p>基於這些假說，可以預測體型大的生物多採異營方式（捕食和吸收），而體型小的生物則採自營方式（光合作用）。體型大者的碳氮比會隨體型下降，而體型小者的碳氮比則會隨體型上升，而營養策略的分界則視光合作用效率隨體型增長的程度不同。</p><p>雖然有老師指出藻類應該不太會捕食其它生物，但我還是覺得這項研究還是很有趣。我心目中最理想的研究方式就是以理論計算得出洞見，再用成本很低而且直觀的實驗支持，這樣應該比較適合我們這種小國家的科研發展吧？</p><h2 id="黏膜微生物-連結環境與生物體的橋樑-王亮鈞老師"><a href="#黏膜微生物-連結環境與生物體的橋樑-王亮鈞老師" class="headerlink" title="黏膜微生物 - 連結環境與生物體的橋樑 (王亮鈞老師)"></a>黏膜微生物 - 連結環境與生物體的橋樑 (王亮鈞老師)</h2><p>以往魚類致病菌的研究方式是，把病源菌添加到水體中，觀察魚類的生理狀況。假如相對於控制組，添加致病菌組出現病徵，則稱病原菌與特定疾病相關。</p><p>儘管觀察到這種關聯性，但是從添加致病菌到病發之間仍有許多模糊之處。王老師認為，病原菌在侵入之前，會先接觸魚類表皮，而魚皮上的黏膜微生物可能是魚類發病的關鍵，於是預測黏膜微生物也與疾病相關。</p><p>王老師團隊採用的研究方法很多樣，不過我多數都忘記了。但是我很好奇，魚類混養跟單獨養殖得到的實驗結果會不會不一樣。人類皮膚上的細菌會因為親密接觸而交換，那麼魚塭裡的魚在搶著吃飼料的時候，會不會交換能抗病的菌群？然而老師們發問也很踴躍，所以我就沒搶到發言的機會了。</p><h2 id="遠紅光可用作光合作用產生氧氣？簡介藍綠菌的獨特策略-（何銘洋老師）"><a href="#遠紅光可用作光合作用產生氧氣？簡介藍綠菌的獨特策略-（何銘洋老師）" class="headerlink" title="遠紅光可用作光合作用產生氧氣？簡介藍綠菌的獨特策略 （何銘洋老師）"></a>遠紅光可用作光合作用產生氧氣？簡介藍綠菌的獨特策略 （何銘洋老師）</h2><p>其實在這節演講的一開始，我的思緒便飄出了地球。既然藍綠菌這類很早就出現的生物能利用遠紅光，那麼在離太陽較遠的天體要形成生命的話，例如歐羅巴或恩賽勒達斯，是不是得有較寬的吸收光譜，才能夠獲得足夠的能量？</p><p>然後我又聯想到夜間地表也會釋放遠紅光，很好奇這些微弱的能量能否激發光合作用。若成立的話，不知道可不可以在不見天日的地底發現利用遠紅外光維生的藍綠菌。另外，晝夜比例隨緯度而異，生物只能利用遠紅外光的時間也不一樣，如果真能利用地表輻射的遠紅外光，藍綠菌的型態和基因體是不是也會因為緯度而不一樣呢？</p><p>於是我開始查遠紅外光的特性，想知道能量到底多強。不過還沒查到演講就結束了，只好拿來問講者。結果我跟頂著牛奶的女孩一樣，地表輻射的遠紅外光波長太長了，能量不足以激發反應中心的電子躍遷，自然沒有後面一大堆奇想。事實上，藍綠菌用的遠紅外光還是很接近可見光的。</p><h2 id="垃圾食物家族"><a href="#垃圾食物家族" class="headerlink" title="垃圾食物家族"></a>垃圾食物家族</h2><p>「我們的熱量很高喔～」<br>抱歉，這不是講題。聽到後面精神不濟，回過神來發現自己只畫了一些圖，沒有記錄到演講內容……</p><h1 id="三分鐘演講和海報展示"><a href="#三分鐘演講和海報展示" class="headerlink" title="三分鐘演講和海報展示"></a>三分鐘演講和海報展示</h1><h2 id="三分鐘演講"><a href="#三分鐘演講" class="headerlink" title="三分鐘演講"></a>三分鐘演講</h2><p>主題演講後，主持人請海報投稿者輪流上台簡介他們的研究成果。由於我已讀過手冊裡的摘要，所以這階段想要學習不同講者取捨內容的策略。</p><p>口頭演講再詳細也不比海報或摘要，接連的短講也不利聽眾深入思考。所以我認為三分鐘演講的目的是鋪陳私下討論，而不是短時間內向聽眾傳達研究的來龍去脈。</p><p>例如有位講者把所有時間都拿來陳述研究問題，另一位講者則用四格漫畫的方式呈現結果。兩人都沒有講齊傳統摘要必備的 IMRAD 要素，但他們鎖定了聽眾好奇心和聽故事的渴望，吸引其他人上前互動。</p><p>鑒於這些觀察，我想我會用打廣告的方式準備下學期的碩士生總評量。出席總評量的是不情願參加的學生和老師，與其思考怎麼拿高分，不如思考怎麼吸引他們的注意力，然後在結尾附上論文和部落格連結供感興趣的聽眾參考。</p><h2 id="海報展示"><a href="#海報展示" class="headerlink" title="海報展示"></a>海報展示</h2><p>由於沒找到與研究題目相關的海報，所以我沒有積極向人請益，錯失了不少學習的機會。參加研討會或工作坊的目的是交流，儘管彼此的研究主題不同，採用的實驗設計、分析方法、研究材料多少會有共通點。</p><p>例如這次有以 16S rRNA 基因定序資料探討火山群微生物的報導，我其實可以上前請教標識基因分析的經驗。即使研究議題無關，也應該趁此機會跟其他人聊些科研或生活話題。畢竟人與人能互相學習的不只有科學，還有好多好多事情。</p><p>雖然沒有認識很多新朋友，但我有碰到之前在中研院聽演講時認識的同學，所以散會後找他聊一聊他的海報和留學申請的進度（點心擺放處和海報展示區在同個空間，所以休息時間大家擠來擠去也很難討論）。</p><p>這位同學蠻厲害的，他大學期間就在關注生命起源問題，也跟著老師研究原核生物演化為真核生物的過程。最近，他還通過了德國的馬克斯-普朗克研究院 Matter to Life 的書審，如果錄取的話，我相信台灣要多一位這個領域的學者了。</p><h1 id="主題討論"><a href="#主題討論" class="headerlink" title="主題討論"></a>主題討論</h1><h2 id="微生物生態學實驗設計（吳羽婷老師）"><a href="#微生物生態學實驗設計（吳羽婷老師）" class="headerlink" title="微生物生態學實驗設計（吳羽婷老師）"></a>微生物生態學實驗設計（吳羽婷老師）</h2><p>雖然題目是實驗設計，但多數時間是討論採樣的眉角。然而我的研究是分析公開資料，沒有實際去採樣，因此對大家分享的故事沒什麼具體想像。</p><p>討論中我有問「要怎麼排除縱向研究時，來自時間的干擾」，不過大家的建議都是去做實驗，把細菌養出來最直觀。但目前我根本沒辦法做實驗，只能把建議記在心裡：解決問題時應嘗試任何辦法，不要侷限於所學專業。</p><p>儘管如此，看到其他同學能較自由地設計試驗，內心還是有點疙瘩。首先，純生物資訊分析便注定研究只能做一半，沒辦法以實驗加強自己的論點。另外，我能用的分析手段受限於公開資料，若資料沒有想關注的項目，那就只能改變研究焦點了。</p><p>不過，每個人學習研究的途徑不同，從 dry lab 著手應該也沒什麼問題，我得多注重研究的品質，而不是自己和其他同學的差異才是。</p><h2 id="怎麼想研究題目"><a href="#怎麼想研究題目" class="headerlink" title="怎麼想研究題目"></a>怎麼想研究題目</h2><p>我也向老師請教，到底要怎麼想研究題目。多樣性中心的魏博士指出，回顧文獻是構思題目的關鍵，他認為台灣的學生缺乏這類訓練，以至於國內的生態學研究落後其他國家。</p><p>他說他在國外念博士班的第一年完全沒有做實驗，投注了所有時間在讀以前的文獻和寫研究計畫。因為唯有從文獻才能了解目前知識的空缺，辨識出研究的缺口，才有辦法思考自己能該如何填補這個未知。</p><p>不過僅強調文獻回庫恐怕時不夠的，因為多數人都明白文獻回顧的重要性，但要怎麼做我還是抓不到訣竅。目前我的想法是，把文獻回顧當研究的一部份。</p><p>當內心產生了問題或想法的時候，我們可以先查文獻尋找解答。由於這世界每分每秒都在產出論文，所以最初的靈感往往已經有人做過了。但想法重複沒有關係，因為研究成果會衍生出新問題，所以閱讀的過程中便會不斷產生問題。</p><p>提問、找文獻、讀文獻、產生新疑問、又去找文獻、……經過多次循環，直到自己不滿意所有既有文獻的解答，那個問題便是研究題目的開始。之所以說是「開始」，是因為後面還有精煉想法、初步測試和修正內容等功夫要下才能成為正式的論文題目。</p><h2 id="反應槽的歧異菌相"><a href="#反應槽的歧異菌相" class="headerlink" title="反應槽的歧異菌相"></a>反應槽的歧異菌相</h2><p>多數同學都是分享自己的研究內容，不過也有同學問碰上的疑難：「為什麼使用同樣的培養條件，卻會養出組成差異極大的菌群？」經過一連串討論，最後大家是猜測這些反應槽可能沒有頻繁滅菌，以至於汙染影響了分析結果。</p><p>聽到這點時，我開始思考人體微生物研究碰到的問題。由於研究對象的居住地點不同，很多大型研究的樣本收集和定序是在不同機構進行，技術造成的噪聲應該無法避免，以至於分析時發現研究對象間的菌群組成歧異，難以使用這類資料得出精細的推論。</p><h2 id="人體和動物微生物（劉勃佑博士）"><a href="#人體和動物微生物（劉勃佑博士）" class="headerlink" title="人體和動物微生物（劉勃佑博士）"></a>人體和動物微生物（劉勃佑博士）</h2><p>這一節討論的議題很多，例如：「人體微生物也能算是野生的嗎？」、「怎麼區分共棲菌和共生菌？」、「無菌鼠能作為因果推論的工具嗎？」、「要如何決定微生物研究的樣本數？」、「代謝體學研究能否迴避菌群互動研究的複雜性？」、「以科霍法則研究單一病原菌或益生菌是否有其限制？」、「系統方法（例如中草藥研究中常用的複方）能否用以研究多菌群對個體的影響？」</p><p>但最後真的太累了（第二天報到時間很早），所以沒有完整記下大家的討論內容。但我對其中一項議題有點想法，在討論「要如何決定微生物研究的樣本數？」時，有人問能否以稀釋曲線來判斷樣本數是否足夠。</p><p>然而依照我的理解，稀釋曲線是用來檢視定序結果能否代表從環境中採集到的樣本。至於樣本採集得夠不夠，應該不能靠稀釋曲線決定決定。</p><p>其實我對這問題也蠻困惑的，微生物研究總有好幾層抽樣，那每次統計檢定我們在推論的是哪一層呢？例如人體腸道微生物研究中會從全世界的人裡面，抽出符合特定條件的人群，又採集了他們特定時間點的排遺樣本，汲取一部分定序。如果我發現兩樣本的多樣性有統計顯著差異，那麼我可以下什麼結論呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 人體微生物研究裡，不同層次的抽樣</span><br><span class="line">Human --&gt; |A| Taiwanese --&gt; |B| Gut --&gt; |C| Stool --&gt; |D| Samples --&gt; |E| Reads</span><br></pre></td></tr></table></figure><p>我認為對照組與病例組的統計推論，只用在決定從研究對象得出的結果能否推廣 (A)，其餘環節都是靠既有的知識串聯。例如「排遺菌群是否代表腸道腸道菌群 (C)」，便是仰賴過去對兩類菌群的研究；而「樣本菌群是否代表整個排遺菌群 (D)」，則是由稀釋曲線決定。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>我一直不喜歡在人前講話，即使真的有疑問，也只敢在會後和講者私下討論。總是想像講者覺得我的問題很蠢，擔心提問而耽誤別人時間，害怕丟臉、害怕被嘲笑，害怕被痛電。</p><p>有次所上演講的主題是研究生涯中面對的抉擇，演講後我和幾個學弟妹到會議室跟講者繼續討論。那時我的內心有好多困惑，從「如何尋找研究問題」到「怎麼跳出框架經營自己」，從「能力不足以支持理想」到「現在能做什麼來改變社會」，結果我問了一個小時多的問題。</p><p>但到後面看到其他人坐立難安，想走又走不了的樣子，讓我覺得自己在他們面前像白癡一樣，不斷地暴露自己的憤怒、困惑、夢想與天真。不過，為什麼要在乎他們的想法？學妹會做便當給我吃嗎？學弟會幫我削水果嗎？講者也說了，人生只有一次：「你管別人怎麼想？」</p><p>可是，即使聽完演講也找了費曼那本書來看，還是不自覺受他人的看法影響（或受想像中他人的看法影響）。</p><p>經過苦思，我想到一句諺語：「細漢偷挽瓠，大漢偷牽牛」。將相本無種，即使是小偷，也要從小東西偷起；九層之臺，起於累土，要養成被討厭的勇氣，得從小地方著手。因此，我挺高興這次工作坊自己有問問題，起碼走了第一步吧？</p>]]></content>
      
      
      
        <tags>
            
            <tag> ecology </tag>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可能反映與嬰兒飲食相關的腸道菌相演替機制的現象</title>
      <link href="/phenomena-reflecting-successional-mechanisms-of-gut-microbiota-in-infant-diet/"/>
      <url>/phenomena-reflecting-successional-mechanisms-of-gut-microbiota-in-infant-diet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>人體腸道菌群建立攸關個體健康，為理解與菌群相關的致病機制並精進目前的干預治療手段，腸道微生物學應逐步從關聯分析邁向機制研究。</p><p>過往累積的數據已辨識出許多影響菌相的外在因素，為了發掘導致現象的機制，本文試圖以生態理論和調控原理連結觀察與機制，探討可能反映飲食作用機制或菌群演替原則的現象與問題，期望可以指引出往後研究的方向。</p><p>（此文是「生物調控原理」課程的報告。這門課以系統論與建模思維，重新介紹遺傳學、生物化學、細胞生物學課程中講授的觀念。我嘗試用課堂上學到的方式，思考微生物學的研究。那時候趕著交報告，沒有很完整發展想法，也沒辦法用資料實證。現在看來除了點子天真了，可行性也受限於總基因體定序資料的精密度。儘管如此，我相信老師的建議是對的：「有想法就寫出來跟大家分享，即使只幫到一個人、只幫到自己也好。」）</p><span id="more"></span><h1 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h1><h2 id="腸道菌群建立攸關個體健康"><a href="#腸道菌群建立攸關個體健康" class="headerlink" title="腸道菌群建立攸關個體健康"></a>腸道菌群建立攸關個體健康</h2><p>人類腸道菌的建立期間，個體的組織器官亦逐漸成熟，兩者的交互作用攸關消化系統、免疫系統乃至神經系統的健全 (Sommer and Bäckhed, 2013)。因此，嬰兒腸道菌群建立不僅關乎生命早期的健康狀態，也可能因影響宿主的生理平衡，從而增加往後罹患哮喘、一型糖尿病或發炎性腸病等疾病的風險 (Tamburini et al., 2016)。</p><h2 id="了解演替機制是干預治療的前提"><a href="#了解演替機制是干預治療的前提" class="headerlink" title="了解演替機制是干預治療的前提"></a>了解演替機制是干預治療的前提</h2><p>由於菌相失調與疾病的關聯，益生元、益生菌或是糞菌移植等針對腸道菌群的干 預療法日益蓬勃 (Petrof et al., 2013)，但相較於實務性的醫療成果，目前對於治療機制 的理解有限(Walter et al., 2018)，難以解釋不同徵狀下干預手段的療效差異，例如糞菌 移植能有效治療困難梭狀桿菌 (Clostridium difficile) 的反覆感染，卻不一定適用於其他疾病 (Qazi et al., 2017)。</p><p>為解決前述困難，除了釐清腸道菌群與疾病的關係，也需要深 入理解正常情況下菌群的演替機制。因為有效的治療意味著能精確地鑑別菌群類別，適當地設計干預方式，並準確地預期療效，這些條件奠基於對生態網路和演替動態的理解，兩者的前提皆為辨識腸道物種組成和闡明菌群相關因素 (Fischbach, 2018)。</p><h2 id="從關聯分析邁向機制研究"><a href="#從關聯分析邁向機制研究" class="headerlink" title="從關聯分析邁向機制研究"></a>從關聯分析邁向機制研究</h2><p>有賴顯微鏡、培養方法乃至核酸基礎的總體基因體學分析技術，腸道菌群的物種和功能組成日益明朗，總體基因體關聯分析 (MWAS, Metagenome-wide association studies) 也已辨識出許多與腸道菌相有關的外在因素，為了達成前述的目標，腸道菌群研究得逐步邁向機制研究。</p><p>人體微生物研究受限於干預手段不足、採樣手法限制還有臨床資訊混雜等因素，無法直接測試由假說衍伸的機制，必須仰賴流行病學或自然實驗方法，比對帶有不同特徵的研究定群，再從組間差異推論研究變項的涵意。</p><p>動植物生態學已累積相當多可供測試的假說和預測 (Prosser et al., 2007)，調控原理的課程也示範了從物理、化學至分子生物皆適用的原則，可作為指引腸道菌群研究的理論架構。</p><h2 id="嬰兒菌群建立可用以理解群集演替"><a href="#嬰兒菌群建立可用以理解群集演替" class="headerlink" title="嬰兒菌群建立可用以理解群集演替"></a>嬰兒菌群建立可用以理解群集演替</h2><p>相較於成人，嬰兒腸道菌相的變化幅度較大。嬰兒的腸道菌相在出生時即因分娩方式而異，隨後受母乳或配方奶等飲食形塑進一步分異，繼而併同器官組織發育逐年演替。</p><p>菌相變化最終在出生離乳後漸漸趨緩，在產後二至三年形成近似成人的腸道菌組成 (Milani et al., 2017)，藉由採集這段期間的排遺樣本，可以觀察腸道物種和功能組成的動態變化，歸納腸道菌隨年齡增長的演替模式。</p><p>此外，由於嬰兒的飲食和行為較成人單純，有利於衡量特定臨床因素與菌相的關係，透過檢視腸道菌群在分娩、離乳或是用藥後的菌相轉變，得以推論不同行為作用於腸道菌群的機制，或是腸道菌群因擾動而產生的反應 (Fischbach, 2018)。</p><h2 id="飲食行為是適合用以探討外在因素影響"><a href="#飲食行為是適合用以探討外在因素影響" class="headerlink" title="飲食行為是適合用以探討外在因素影響"></a>飲食行為是適合用以探討外在因素影響</h2><p>儘管有許多環境、遺傳和行為因素攸關嬰兒腸道菌群建立 (van Best et al., 2015)，本文將聚焦於飲食行為相關的菌群演替。因為嬰兒消化系統和免疫系統的成熟固然影響深遠，但一方面分析時難為發育的影響劃分明確的始末，另一方面既有資料也鮮有嬰兒發育狀態的臨床紀錄。</p><p>手足、寵物、居處皆和腸道菌相關，然而這些關聯卻不易推論作用機制。患病服藥雖然能追蹤干擾開始的時間，也得以從藥理學推論作用機制，但研究結果可能受疾病干擾，其數據亦不若飲食普及。</p><h2 id="本研究的目的是以理論連結相關現象與作用機制"><a href="#本研究的目的是以理論連結相關現象與作用機制" class="headerlink" title="本研究的目的是以理論連結相關現象與作用機制"></a>本研究的目的是以理論連結相關現象與作用機制</h2><p>綜上所述，本文將以與嬰兒飲食相關的菌群演替為研究對象，利用生物調控原理課程中講述的觀念，還有目前動植物生態學累積的理論，探討從關聯研究結果推論作用機制的可行方式。<br>本文首先將介紹菌群建立的生態學觀點，並且解釋群集演替的基本原則，繼而檢視飲食影響腸道菌的可能途徑，提出可能反映機制的相關現象。</p><h1 id="嬰兒腸道菌的建立可視為群集演替"><a href="#嬰兒腸道菌的建立可視為群集演替" class="headerlink" title="嬰兒腸道菌的建立可視為群集演替"></a>嬰兒腸道菌的建立可視為群集演替</h1><h2 id="人體共棲菌的生態學觀點"><a href="#人體共棲菌的生態學觀點" class="headerlink" title="人體共棲菌的生態學觀點"></a>人體共棲菌的生態學觀點</h2><p>二十世紀初人類的衛生觀念基於巴斯德和柯霍等人確立的細菌致病學說 (the germ theory of disease)，認為特定病原菌破壞人體健康狀態而導致疾病，所以當時的防疫觀念著重消毒，試圖透過全面滅菌降低細菌傳播。</p><p>在細菌致病學說指引下，透過系統地搜索病原菌，結合同時期發展的疫苗、化學療法和抗生素，降低了許多疾病的致死率。此外，細菌致病學說納入了病毒致病因素後，拓展為更為成熟的微生物致病學說，持續引領晚近的人體微生物學研究 (Institute of Medicine (US) Forum on Microbial Threats, 2006)。　</p><p>儘管微生物致病的典範取得了巨大的成功，這種以病原為中心的觀點 (pathogen-centered) 過度強調疾病與特定物種的關係，忽略了物種與物種、物種與宿主間交互作用變動造成的疾病，也沒有考慮到物種的多重屬性。</p><p>研究也指出體內微生物的組成和神經疾病、肥胖、過敏相關，這意味著微生物不只單純棲息於體內，它們可能參與人體生理的大小反應。</p><p>新興疾病的醫療危機以及微生物與宿主的生理相關性揭示了微生物與宿主間的複雜關係，於是學界漸漸重視微生物致病的其他因素，例如：微生物的變化、微生物與環境的關係、微生物間的作用網路、免疫系統與微生物間的互動、……等，模糊了人類與病原菌之間壁壘分明的界線。</p><p>換句話說，學界引進了生態學的思考方式，將人體視為棲息地 (human-as-habitat perspective) 而不是廝殺的戰場 (body-as-battleground perspective or the War matephor)，微生物是人體的一部份而非外來的異客，身體狀態是細菌與人體細胞共同作用的外顯特徵，而健康則是生態系平衡的紅利 (ecosystem service) 不是固有的狀態 (Costello et al., 2012)。</p><h2 id="腸道菌群建立可視為接連的狀態改變"><a href="#腸道菌群建立可視為接連的狀態改變" class="headerlink" title="腸道菌群建立可視為接連的狀態改變"></a>腸道菌群建立可視為接連的狀態改變</h2><p>援引化學熱力學的概念，腸道菌群的建立過程可以比擬為菌相在內外因素影響下接連的狀態改變 (Gilbert and Lynch, 2019)。</p><p>化學反應的熱力學因素決定反應是否可能發生，而動力學因素則左右反應發生的難易；群集演替的熱力學因素代表環境壓力及群集互動可容忍的菌相，而動力學因素則是意味著菌群在耐受環境擾動能力。化學反應中的位能低意味著穩定 (stable) ，活化能高意味著惰性 (inert)；群集演替中的菌相差異大謂之穩定，組成的變化範圍小謂之惰性。</p><p>然而菌群狀態不若化學反應中的分子穩定，即使被視為成熟的成人腸道菌群也有一定程度的波動。腸道菌群的狀態是指菌相變化侷限於相當的範圍內，歷經輕微干擾後也能順利恢，一旦干擾過大則會脫離先前的波動範圍，轉向另一個狀態 (Fierer et al., 2012)。</p><p>其次，有別於代謝途徑可列出明確的反應步驟，菌相變化卻發生在腸道菌群的不同屬性上，不易劃分菌群演替的過程。往往得借重生態學指標將抽象複雜的群集特徵以具體易懂的數字呈現，繼而聚焦所關注的層面研究，因此儘管菌群可能發生了數種變化，但研究中卻只以其中一項作為菌相的代表。</p><h1 id="四項群集生態學原則驅動菌群演替"><a href="#四項群集生態學原則驅動菌群演替" class="headerlink" title="四項群集生態學原則驅動菌群演替"></a>四項群集生態學原則驅動菌群演替</h1><p>基因調控、訊息傳遞與代謝反應等生理過程的狀態變化源於分子間的碰撞、結合與形變，其機制與動態得以物理化學原理解釋。然而腸道菌相轉變卻是族群消長、種間互作和環境干擾共同作用的結果，涉及不同尺度和類別的因素，因此衍生出紛雜的名詞、模型與概念以解釋群集的演替模式。</p><p>為了整合歧異的理論架構，Vellend, (2010)彙整既有的群集生態學理論，歸納出選擇 (Selection)、播遷 (Dispersal)、多樣化 (Diversification)和漂變 (Drift) 四項演替的基本動力。</p><h2 id="選擇-Selection"><a href="#選擇-Selection" class="headerlink" title="選擇 (Selection)"></a>選擇 (Selection)</h2><p>選擇是指由於不同細菌對於特定環境的適存度差異（例如繁殖速度、營養利用或環境耐受等），使得相異環境中群集物種組成比例不一的現象。</p><p>以人類腸道菌為例，儘管真細菌涵蓋數十個不同菌門，成年人的腸道菌群組成卻以厚壁菌門 (Firmicutes)、擬桿菌門(Bacteroidetes) 及變形菌門 (Proteobacteria) 為主 (The Human Microbiome Project Consortium et al., 2012)。</p><p>此外，人體各部位的共棲菌相在出生時有相當的個體差異，但是隨著年齡增長，同一部位的菌群物種組成日異相近，不同部位的菌群物種組成卻逐漸分異 (Chu et al., 2017)。</p><p>由於不同器官的構造、濕度、酸鹼值和營養來源差異，這些菌相因部位而異的現象，可反映選擇參與人體共棲菌的建立過程。</p><p>為了以選擇解釋不同臨床因素與菌相的關係，人體微生物研究中往往假定菌群已歷經環境選擇，接著檢視總體基因體中與目標因素相關的功能途徑數量在組間是否有明顯差異。</p><p>例如在評估母乳影響的研究中，即假設母乳寡糖為，以代謝寡糖的基因為特徵，詮釋哺餵母乳與餵食奶粉的嬰兒腸道菌相差異。</p><h2 id="播遷-Dispersal"><a href="#播遷-Dispersal" class="headerlink" title="播遷 (Dispersal)"></a>播遷 (Dispersal)</h2><p>播遷是指生物自其他棲地遷入並成功在既有群集中繁衍生存的現象。儘管孕婦體內少數的微生物可能藉由臍帶血或羊水等途徑定殖於胎兒(Perez-Muñoz et al., 2017)，但大量接觸環境微生物仍然始於分娩。</p><p>既有研究指出，新生兒的腸道菌相因分娩方式而異(Dominguez-Bello et al., 2010)，自然產嬰兒有較多於母親產道發現的物種，而剖腹產嬰兒則有較多成人皮膚上發現的物種，表示出生時的腸道菌相與微生物的潛在來源相關，意味著播遷差異是影響新生兒菌相的主因。</p><p>為了辨識與播遷相關的群集變化，通常會比較細菌潛在來源和播遷區域兩處的菌相，再藉由物種組成相似性推論是否有播遷的可能。</p><p>Pannaraj et al., (2017) 即比較母乳細菌與嬰兒腸道細菌的物種組成，發現腸道菌群與母乳菌群的相似程度與母乳攝取量正相關，支持細菌通過母乳定殖於嬰兒腸道的假說。</p><p>由於播遷涉及遷移和繁衍兩種行為，因此群集受播遷影響取決於族群的柏謙能力以及環境的抗力。</p><h2 id="多樣化-Diversification"><a href="#多樣化-Diversification" class="headerlink" title="多樣化 (Diversification)"></a>多樣化 (Diversification)</h2><p>多樣化是指菌群因突變與選擇壓力演化出不同性狀或特徵的現象。由於細菌的繁殖速率和突變率，在動植物上須要歷經長遠時間的演化現象可以在數十年內在腸道菌群中發生。儘管近期的研究漸漸留意到多樣化的作用，由於本文回顧的文獻中較少但討多樣化相關案例，故本文暫不討論多樣化的作用。</p><h2 id="漂變-Drift"><a href="#漂變-Drift" class="headerlink" title="漂變 (Drift)"></a>漂變 (Drift)</h2><p>漂變是指群集中無關乎物種特性的隨機數量變化。當選擇壓力較小或是族群規模不大時，因為物種間的差異不致於產生適存度差異或是無法承受隨機造成的滅絕事件，導致群集的物種組成取決於不同族群的自然消長和隨機事件，此時群集演替即由漂變主導。</p><p>儘管漂變於群集演替的重要性，但是因為諸多外在因素干擾，不易辨識其作用的相關證據。嬰兒在添加副食後，腸道菌群多樣性歷經短暫的降低 (Vallès et al., 2014)，漂變也許能解釋為何期間受影響的多屬低豐度菌屬。</p><h1 id="飲食影響腸道菌群演替的可能途徑"><a href="#飲食影響腸道菌群演替的可能途徑" class="headerlink" title="飲食影響腸道菌群演替的可能途徑"></a>飲食影響腸道菌群演替的可能途徑</h1><p>雖然飲食可能與其他臨床因素相關，因此相異飲食的菌相差異未必是飲食內容造成，但是本文意在探討飲食自身與腸道菌相演替的機制，因此將聚焦嬰兒飲食中有哪些物質可能影響腸道菌的四項演替原則。</p><h2 id="母乳的內容"><a href="#母乳的內容" class="headerlink" title="母乳的內容"></a>母乳的內容</h2><p>有別於配方奶的成分，母乳除乳糖、脂肪及蛋白質等嬰兒發育所需的營養素外，也含有生長因子、細胞素和激素等能調節免疫系統或促進組織發育的物質 (Ballard and Morrow, 2013)，這些物質可能不直接影響腸道菌群，但會作用在腸道及其周邊的組織，改變腸道菌的棲息環境。</p><p>另外，母乳寡糖 (HMOs, human milk oligosaccharides) 則有多項可能的功能，例如作為益生元促進特定細菌生長定殖、防範病原黏附於腸壁、以及平衡免疫細胞等 (Bode, 2012)。</p><p>這些生物活性物質 (bioactive components) 可能造成腸道菌群面臨選擇壓力，故得以在哺餵母乳的嬰兒腸道優勢菌屬為可代謝母乳寡糖的菌屬。</p><p>此外，既有研究已在母乳中發現多樣的細菌 (Togo et al., 2019)，意味著母乳可能是嬰兒腸道菌的潛在來源或是其它共棲菌的播遷媒介，代表母乳除了透過選擇，也可能透過播遷方式影響腸道菌群。</p><p>其他環境微生物的播遷和母乳菌群播遷的差異在於，母乳中的細菌可能已適應母乳營造的環境，故相較於環境微生物，母乳菌群同時經選擇和播遷影響嬰兒腸道菌群。</p><h2 id="奶粉、副食品以及成人餐食"><a href="#奶粉、副食品以及成人餐食" class="headerlink" title="奶粉、副食品以及成人餐食"></a>奶粉、副食品以及成人餐食</h2><p>奶粉、副食品和成人餐食欠缺母乳中的生物活性物質，非哺餵母乳的嬰兒往往有類似的特徵，即腸道中有較多梭菌屬(Clostridium) 或擬桿菌屬 (Bacteroides) 的細菌，腸道菌群也比較成熟。</p><p>儘管不同的營養成分和相異的菌屬有關 (Singh et al., 2017)，既有研究仍指出，嬰兒腸道菌群在離乳期間的變化可能非源於添加副食，而是因為停餵母乳 (Bäckhed et al., 2015)，暗示著這些飲食的選擇效應可能沒有母乳強烈，因此彼此相關的菌群特徵相似，同時飲食時無法造成明顯菌相轉變。</p><h2 id="飲食以直接或間接方式影響腸道菌"><a href="#飲食以直接或間接方式影響腸道菌" class="headerlink" title="飲食以直接或間接方式影響腸道菌"></a>飲食以直接或間接方式影響腸道菌</h2><p>總結嬰兒成長期間接觸的飲食內容，可以歸納出直接和間接兩種影響腸道菌相的方式。</p><p>母乳中的巨噬細胞和免疫球蛋白可抑制病原菌播遷，而母乳中的細菌則有機會定殖腸道，兩者皆直接作用於腸道菌群，沒有改變環境中可負荷的菌群種類，可歸為群集演替的動力學因素。</p><p>而母乳寡糖或調節生理機能的物質則改變了腸道環境，影響環境中可能負荷的菌群種類，故歸類為群集演替的熱力學因素。</p><p>飲食的間接影響又可再區分為短暫影響和長期影響。假如飲食透過改變環境中的可用資源，增加環境中的選擇壓力，原則上在轉換飲食後這類影響便逐漸消退。</p><p>然而，假如飲食透過永久改變腸道組織營造選擇壓力，則此項影響在轉換飲食後可能會持續作用在腸道菌群中。</p><h1 id="可能反映機制的現象"><a href="#可能反映機制的現象" class="headerlink" title="可能反映機制的現象"></a>可能反映機制的現象</h1><p>既已介紹了看待菌群的方式，也說明了菌群演替的基本原則，在了解飲食影響腸道菌群演替的途徑後，接著將要列舉幾則可能反映不同飲食作用機制的現象。</p><h2 id="嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異"><a href="#嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異" class="headerlink" title="嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異"></a>嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異</h2><p>既有研究往往透過哺餵母乳和餵食奶粉的嬰兒相互對照，檢視相異飲食者的腸道菌相差異，藉此推論不同飲食的作用機制。</p><p>儘管各項研究的結果仍有差異 (Davis et al., 2017)，相較於餵食配方奶的嬰兒，哺餵母乳者的腸道菌多樣性較低 (Bezirtzoglou et al., 2011)，而菌群中能代謝母乳寡糖雙歧桿菌屬 (Bifidobacterium) 和見於母乳的乳酸桿菌屬 (lactobacillus) 之物種比例較高 (Bäckhed et al., 2015; Stewart et al., 2018) 。</p><p>通過樣本的物種組成預測採樣時間，從而得出菌群年齡 (Microbiota age) 後也發現，純哺餵母乳者的腸道菌年齡往往低於非純餵母乳者 (Ho et al., 2018)。</p><p>如前所述，這些差異反映了母乳透過選擇影響腸道菌群，卻無法反映菌群在飲食持續干擾下的動態變化，這些得仰賴長期追蹤的時間序列資料，但時間資料卻會受年齡增長因素干擾，因此為了瞭解菌群在飲食干擾下的影響，有必要觀察切換飲食之際的菌相轉變。</p><h2 id="離乳期的腸道菌相轉變"><a href="#離乳期的腸道菌相轉變" class="headerlink" title="離乳期的腸道菌相轉變"></a>離乳期的腸道菌相轉變</h2><p>除了比較不同飲食的嬰兒之腸道菌相差異，追蹤離乳前後的菌相轉變亦可能反映飲食的作用機制。在一段純母乳哺育的時期以後，由於哺餵障礙或營養需求改變，嬰兒開始服用副食品並逐漸減少母乳攝取 (Li et al., 2008) ，期間腸道菌群歷經一轉變，最後改變趨緩直至。如前所述，母乳可能是效果強烈的選擇因子，離乳後選擇的效力會減弱，是否會使得漂變的比重提升，進而導致個體間的菌群差異較哺餵母乳時期的時候大？或是添加飲食帶來了多樣的營養素，增加了可用資源創造許多生態棲位使得選擇壓力下降，漂變的效力上升，使得個體間的菌群差異如 de Muinck and Trosvik, (2018) 觀測到的在添加副食後增加？</p><h2 id="相異分娩方式之嬰兒的飲食相關菌相差異"><a href="#相異分娩方式之嬰兒的飲食相關菌相差異" class="headerlink" title="相異分娩方式之嬰兒的飲食相關菌相差異"></a>相異分娩方式之嬰兒的飲食相關菌相差異</h2><p>儘管研究分娩方式和飲食型態的研究相當豐富，但關注兩者關聯的研究卻相對稀少。相較於自然產嬰兒，剖腹產的腸道菌群多樣性較低，而兩者物種組成也不相同。</p><p>倘若母乳以當中帶有的菌種影響腸道菌相，則是否會因為腸道中既有的物種組成不同，導致播遷受阻？Hill et al., (2017) 在剖腹產的嬰兒中觀察到母乳哺餵時長不一的嬰兒之菌相差異，但在自然產中卻沒觀察，也許此項發現可支持前述推論。</p><h2 id="過往哺餵母乳的經歷和當前哺餵母乳的狀態"><a href="#過往哺餵母乳的經歷和當前哺餵母乳的狀態" class="headerlink" title="過往哺餵母乳的經歷和當前哺餵母乳的狀態"></a>過往哺餵母乳的經歷和當前哺餵母乳的狀態</h2><p>既有研究指出母乳哺餵的經歷，例如哺乳期長短或純餵母乳歷時等皆於腸道菌相有關 (Azad et al., 2016) 如前所述，母乳的間接影響可能藉由改變腸道組織而有持續性的效果，比較母乳哺餵的經歷和當前哺餵狀態各自影響的菌群或許可以辨識出母乳作用的機制差異。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>本文以生態學的觀點看待腸道菌群，以狀態變化的觀念描述嬰兒菌群演替，接著透過群集生態學原則探討飲食的直接和間接影響，最後列舉了四項可能反映飲食影響腸道菌機制的觀察：比較相異飲食者的菌相差異、比較離乳前後的菌相差異、比較相異分娩方式者之菌相對飲食的反應、比較過往母乳哺餵經歷和當前母乳哺餵狀態對菌相的影響。儘管本文沒有呈現完整的實驗設計以驗證特定的機制，仍提出了潛在的研究方向，後續研究可以從這些問題出發，補足未竟的細節，以理解飲食影響人類腸道菌群的演替模式和機制。</p><h1 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h1><p>Azad, M.B., Konya, T., Persaud, R.R., Guttman, D.S., Chari, R.S., Field, C.J., Sears, M.R., Mandhane, P.J., Turvey, S.E., Subbarao, P., et al. (2016). Impact of maternal intrapartum antibiotics, method of birth and breastfeeding on gut microbiota during the first year of life: a prospective cohort study. BJOG Int. J. Obstet. Gynaecol. 123, 983–993. </p><p>Bäckhed, F., Roswall, J., Peng, Y., Feng, Q., Jia, H., Kovatcheva-Datchary, P., Li, Y., Xia, Y., Xie, H., Zhong, H., et al. (2015). Dynamics and Stabilization of the Human Gut Microbiome during the First Year of Life. Cell Host Microbe 17, 690–703.</p><p>Ballard, O., and Morrow, A.L. (2013). Human Milk Composition: Nutrients and Bioactive Factors. Pediatr. Clin. North Am. 60, 49–74.</p><p>van Best, N., Hornef, M.W., Savelkoul, P.H.M., and Penders, J. (2015). On the origin of species: Factors shaping the establishment of infant’s gut microbiota. Birth Defects Res. Part C Embryo Today Rev. 105, 240–251. </p><p>Bezirtzoglou, E., Tsiotsias, A., and Welling, G.W. (2011). Microbiota profile in feces of breast- and formula-fed newborns by using fluorescence in situ hybridization (FISH). Anaerobe 17, 478–482. </p><p>Bode, L. (2012). Human milk oligosaccharides: Every baby needs a sugar mama. Glycobiology 22, 1147–1162.</p><p>Chu, D.M., Ma, J., Prince, A.L., Antony, K.M., Seferovic, M.D., and Aagaard, K.M. (2017). Maturation of the infant microbiome community structure and function across multiple body sites and in relation to mode of delivery. Nat. Med. 23, 314–326. </p><p>Costello, E.K., Stagaman, K., Dethlefsen, L., Bohannan, B.J.M., and Relman, D.A. (2012). The application of ecological theory toward an understanding of the human microbiome. Science 336, 1255–1262.</p><p>Davis, E.C., Wang, M., and Donovan, S.M. (2017). The role of early life nutrition in the establishment of gastrointestinal microbial composition and function. Gut Microbes 8, 143–171. </p><p>Dominguez-Bello, M.G., Costello, E.K., Contreras, M., Magris, M., Hidalgo, G., Fierer, N., and Knight, R. (2010). Delivery mode shapes the acquisition and structure of the initial microbiota across multiple body habitats in newborns. Proc. Natl. Acad. Sci. U. S. A. 107, 11971–11975.</p><p>Fierer, N., Ferrenberg, S., Flores, G.E., González, A., Kueneman, J., Legg, T., Lynch, R.C., McDonald, D., Mihaljevic, J.R., O’Neill, S.P., et al. (2012). From Animalcules to an Ecosystem: Application of Ecological Concepts to the Human Microbiome. Annu. Rev. Ecol. Evol. Syst. 43, 137–155.</p><p>Fischbach, M.A. (2018). Microbiome: Focus on Causation and Mechanism. Cell 174, 785–790.</p><p>Gilbert, J.A., and Lynch, S.V. (2019). Community ecology as a framework for human microbiome research. Nat. Med. 25, 884.</p><p>Hill, C.J., Lynch, D.B., Murphy, K., Ulaszewska, M., Jeffery, I.B., O’Shea, C.A., Watkins, C., Dempsey, E., Mattivi, F., Tuohy, K., et al. (2017). Evolution of gut microbiota composition from birth to 24 weeks in the INFANTMET Cohort. Microbiome 5, 4. </p><p>Ho, N.T., Li, F., Lee-Sarwar, K.A., Tun, H.M., Brown, B.P., Pannaraj, P.S., Bender, J.M., Azad, M.B., Thompson, A.L., Weiss, S.T., et al. (2018). Meta-analysis of effects of exclusive breastfeeding on infant gut microbiota across populations. Nat. Commun. 9, 4169.</p><p>Institute of Medicine (US) Forum on Microbial Threats (2006). Ending the War Metaphor: The Changing Agenda for Unraveling the Host-Microbe Relationship: Workshop Summary (Washington (DC): National Academies Press (US)).</p><p>Li, R., Fein, S.B., Chen, J., and Grummer-Strawn, L.M. (2008). Why Mothers Stop Breastfeeding: Mothers’ Self-reported Reasons for Stopping During the First Year. Pediatrics 122, S69–S76. </p><p>Milani, C., Duranti, S., Bottacini, F., Casey, E., Turroni, F., Mahony, J., Belzer, C., Palacio, S.D., Montes, S.A., Mancabelli, L., et al. (2017). The First Microbial Colonizers of the Human Gut: Composition, Activities, and Health Implications of the Infant Gut Microbiota. Microbiol. Mol. Biol. Rev. 81, e00036-17.</p><p>de Muinck, E.J., and Trosvik, P. (2018). Individuality and convergence of the infant gut microbiota during the first year of life. Nat. Commun. 9.  </p><p>Pannaraj, P.S., Li, F., Cerini, C., Bender, J.M., Yang, S., Rollie, A., Adisetiyo, H., Zabih, S., Lincez, P.J., Bittinger, K., et al. (2017). Association Between Breast Milk Bacterial Communities and Establishment and Development of the Infant Gut Microbiome. JAMA Pediatr. 171, 647–654. </p><p>Perez-Muñoz, M.E., Arrieta, M.-C., Ramer-Tait, A.E., and Walter, J. (2017). A critical assessment of the “sterile womb” and “in utero colonization” hypotheses: implications for research on the pioneer infant microbiome. Microbiome 5, 48. </p><p>Petrof, E.O., Claud, E.C., Gloor, G.B., and Allen-Vercoe, E. (2013). Microbial ecosystems therapeutics: a new paradigm in medicine? Benef. Microbes 4, 53–65. </p><p>Prosser, J.I., Bohannan, B.J.M., Curtis, T.P., Ellis, R.J., Firestone, M.K., Freckleton, R.P., Green, J.L., Green, L.E., Killham, K., Lennon, J.J., et al. (2007). The role of ecological theory in microbial ecology. Nat. Rev. Microbiol. 5, 384–392. </p><p>Qazi, T., Amaratunga, T., Barnes, E.L., Fischer, M., Kassam, Z., and Allegretti, J.R. (2017). The risk of inflammatory bowel disease flares after fecal microbiota transplantation: Systematic review and meta-analysis. Gut Microbes 8, 574–588. </p><p>Singh, R.K., Chang, H.-W., Yan, D., Lee, K.M., Ucmak, D., Wong, K., Abrouk, M., Farahnik, B., Nakamura, M., Zhu, T.H., et al. (2017). Influence of diet on the gut microbiome and implications for human health. J. Transl. Med. 15, 73. </p><p>Sommer, F., and Bäckhed, F. (2013). The gut microbiota — masters of host development and physiology. Nat. Rev. Microbiol. 11, 227–238.</p><p>Stewart, C.J., Ajami, N.J., O’Brien, J.L., Hutchinson, D.S., Smith, D.P., Wong, M.C., Ross, M.C., Lloyd, R.E., Doddapaneni, H., Metcalf, G.A., et al. (2018). Temporal development of the gut microbiome in early childhood from the TEDDY study. Nature 562, 583. </p><p>Tamburini, S., Shen, N., Wu, H.C., and Clemente, J.C. (2016). The microbiome in early life: implications for health outcomes. Nat. Med. 22, 713–722. </p><p>The Human Microbiome Project Consortium, Huttenhower, C., Gevers, D., Knight, R., Abubucker, S., Badger, J.H., Chinwalla, A.T., Creasy, H.H., Earl, A.M., FitzGerald, M.G., et al. (2012). Structure, function and diversity of the healthy human microbiome. Nature 486, 207–214.</p><p>Togo, A., Dufour, J.-C., Lagier, J.-C., Dubourg, G., Raoult, D., and Million, M. (2019). Repertoire of human breast and milk microbiota: a systematic review. Future Microbiol. 14, 623–641.</p><p>Vallès, Y., Artacho, A., Pascual-García, A., Ferrús, M.L., Gosalbes, M.J., Abellán, J.J., and Francino, M.P. (2014). Microbial Succession in the Gut: Directional Trends of Taxonomic and Functional Change in a Birth Cohort of Spanish Infants. PLoS Genet. 10.</p><p>Vellend, M. (2010). Conceptual synthesis in community ecology. Q. Rev. Biol. 85, 183–206.</p><p>Walter, J., Maldonado-Gómez, M.X., and Martínez, I. (2018). To engraft or not to engraft: an ecological framework for gut microbiome modulation with live microbes. Curr. Opin. Biotechnol. 49, 129–139.</p>]]></content>
      
      
      
        <tags>
            
            <tag> ecology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔球</title>
      <link href="/lewis-2004-moneyball/"/>
      <url>/lewis-2004-moneyball/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近進度報告剛結束，在老師指點下發現研究策略和內容有些問題，若想要準時畢業勢必受限於時間與精力。在面臨這般困境的情況下，看到魔球簡介中斗大的副標：「逆境中求勝的智慧」，讓我決定研究一下看看能得到什麼啟發。</p><span id="more"></span><h1 id="運動家隊面臨了什麼樣的困境？"><a href="#運動家隊面臨了什麼樣的困境？" class="headerlink" title="運動家隊面臨了什麼樣的困境？"></a>運動家隊面臨了什麼樣的困境？</h1><h2 id="運動家隊的逆境：資本額限制所致的競爭失衡"><a href="#運動家隊的逆境：資本額限制所致的競爭失衡" class="headerlink" title="運動家隊的逆境：資本額限制所致的競爭失衡"></a>運動家隊的逆境：資本額限制所致的競爭失衡</h2><p>運動家隊的困境在於有限的經營資本，在《魔球》成書的前一年 (2002)，運動家隊的團體薪資不足洋基隊的三分之一。而資本差異會造成戰力的差距，富豪球隊不僅能網羅交易市場上最佳的球員，也能挖角其他隊伍的砥柱；窮困球隊只有次佳的人選或是其他戰力外的球員。</p><p>戰力落差將導致窮困球隊的戰績低迷，減損球迷進場意願，以至於營收下降。在利潤降低的情況下，團體薪資也受到波及，使球團更無力補充新秀和保住當家球星，進一步擴大其與富豪球隊的戰力落差。</p><h2 id="克服逆境的方式是贏球"><a href="#克服逆境的方式是贏球" class="headerlink" title="克服逆境的方式是贏球"></a>克服逆境的方式是贏球</h2><p>為了避免營收下降而陷入競爭力失衡的漩渦，運動家隊的總經理比利．比恩 (Billy Beane) 透過行銷部門調查問題的癥結點。他們發現，票房的關鍵不在眾星雲集，而在於勝負。結合有潛力的新秀和仍有價值的老將組成的無名團隊打出一連串漂亮的好仗，會比一票棒球巨星打出沉悶的敗仗還來得吸引觀眾入場。</p><p>只要能夠吸引球迷入場支持，便能夠增加票房，從而得到資金拓展球隊經營的手段與空間。因此，比恩的課題即是在贏球帶來票房的假設下，設法以有限的預算打贏最多場球賽，無論最終有無辦法獲得世界冠軍，都能藉此擺脫競爭失衡的困境。</p><h2 id="贏球的關鍵是能夠得分的球員"><a href="#贏球的關鍵是能夠得分的球員" class="headerlink" title="贏球的關鍵是能夠得分的球員"></a>贏球的關鍵是能夠得分的球員</h2><p>比恩的目標是以有限的資本取得更多勝利（最好能進季後賽），所以解決問題的第一步即是勾勒出目標的具體形象，接著規劃方向與階段任務，估算達成不同階段所需的成本，以免因追逐錯誤標的而虛耗。</p><p>根據比爾．詹姆斯 (Bill James) 的研究，勝場與得分息息相關。比恩的助理保羅．迪波德斯塔 (Paul DePodesta) 首先估計進入季後賽所需的勝場數，再透過得分與勝場的關係推算晉級要求的得分數。接著他根據球員過去的表現，預估往後一季運動家隊的得失分，從而衡量當前狀況是否有晉級季後賽的條件。</p><p>單局勝負在投打之間的對決，單場勝負則在教練間的運籌帷幄，而例行賽的爭霸則有賴球團對於人力資源的調度。因此，追求勝率的問題在比恩的眼裡便轉換為如何補強球員的問題。</p><h1 id="什麼樣的球員能夠幫助運動家隊克服逆境？"><a href="#什麼樣的球員能夠幫助運動家隊克服逆境？" class="headerlink" title="什麼樣的球員能夠幫助運動家隊克服逆境？"></a>什麼樣的球員能夠幫助運動家隊克服逆境？</h1><h2 id="身體素質僅片面反映球員的潛力"><a href="#身體素質僅片面反映球員的潛力" class="headerlink" title="身體素質僅片面反映球員的潛力"></a>身體素質僅片面反映球員的潛力</h2><p>一旦確認當前與目標的差距，即可判斷球隊需要投資多少預算補強選手，以獲足夠的得分與勝場。然而，要採用什麼指標才能找到能幫助球隊得分的球員？</p><p>在比恩仍是個潛力新秀的時期，評斷球員優劣的指標是投球、力量、跑速、守備、臂力等基礎素質，有時還加上球探對球員外貌和心理狀況的評價。基於對選手的期待和對農場的信賴，這些球探相信良好的身體素質配合有效的鍛鍊能夠養出新一代的大聯盟球星。</p><p>但是，球員在場上的表現也受臨場判斷和賽場經驗影響，田徑場上優秀的跑者對盜壘未必在行，能丟出快速球的標槍選手未必曉得蒙騙打者。因此，良好的身體素質是投打守等基本功的保證，但與得分能力間仍有許多未知的因素存在，所以仰賴素質不見得能正確評斷球員的價值。</p><h2 id="可以從統計數據觀察球員隱匿的長處"><a href="#可以從統計數據觀察球員隱匿的長處" class="headerlink" title="可以從統計數據觀察球員隱匿的長處"></a>可以從統計數據觀察球員隱匿的長處</h2><p>在身體素質之外，過去的表現可以提供認識球員的新管道。身體素質反映了球員投打守等基本功，紀錄則展示球員在賽場的真實表現；身體素質關注球員能夠培養的特質，紀錄則強調球員不可培養的天賦；身體素質放眼未來，紀錄則以過去為鏡。</p><p>是以無論身體素質還是攻守紀錄都是了解衡量球員的工具，只是在比恩擔任球團總經理的時候，球探們輕忽了數據的用處。由於直接量測球員在賽場的表現，所以數據最大的優點，是能夠揭示用肉眼在短期內看不出的能力差異。其次，數據較為客觀，能協助決策者擺脫個人經驗的限制。第三，也因為攻守紀錄的量化特質，它能夠被資料科學發展出來的工具利用。</p><p>雖然過去表現不等同未來表現，低階聯盟的成就也不盡然能在高階聯盟複製，但是長期積累的正面數據表示球員具有一些不易用數據呈現的特質。因此，在找尋到更好的指標之前，鑒於 (1) 數據與表現的關聯性，(2) 良性特質的持續性，(3) 數據的客觀性，以過往紀錄評估球員來年的表現仍是合理的決策。</p><h2 id="上壘率是衡量進攻能力的關鍵統計量"><a href="#上壘率是衡量進攻能力的關鍵統計量" class="headerlink" title="上壘率是衡量進攻能力的關鍵統計量"></a>上壘率是衡量進攻能力的關鍵統計量</h2><p>但並非所有數據都能忠實反映球員的能力。我們可能認為打點表示球員在關鍵時刻的打擊能力，但這也許是棒次安排的緣故，讓該名球員的打席得碰上較多次得點圈。而守備失誤則受紀錄組主觀判斷，很難說積極接球導致的失誤會劣於怠惰而造成的安打。這些例子並非否定失誤和打點的意義，但作為衡量能力的指標，有些數據混合了人為判斷和運氣因素，可能會錯估球員的能力。</p><p>對棒球的勝負而言，士氣、調度、佈陣等因素可能都會影響比賽的結果，但追根究柢，棒球最關鍵易懂的因素是出局數，一旦耗盡九局二十七個出局數，一場比賽便不再有任何可能；反之，如果沒有任何出局，球隊則能隨著打席演替不斷得分。是以任何能降低自己出局風險的事情都是好的，而增加出局風險的事情都是壞的。</p><blockquote><p>上壘率 &#x3D; （安打 + 四死球） ÷ （打數 + 四死球 + 高飛犧牲打）</p></blockquote><p>上壘率是球員不會出局的機率，所以它衡量了打者將進攻局往終點推進一步的可能性，然而其重要性卻一直被低估。在亨利．查德維克 (Henry Chadwick) 發展出攻守紀錄表之時，四壞保送被視為投手的失誤而非打者的技巧，因此打擊率便成為衡量球員進攻價值的主要指標。</p><p>然而，偶然的保送或許可以歸咎投手失誤，但高於平均的上壘率則意味著球員可能具有某些特長，例如良好的本壘板紀律或是纏鬥本領，所以上壘率也應該是衡量進攻能力的指標。</p><h1 id="逆境中該怎麼行動？"><a href="#逆境中該怎麼行動？" class="headerlink" title="逆境中該怎麼行動？"></a>逆境中該怎麼行動？</h1><h2 id="怎麼做到在逆境中求勝？"><a href="#怎麼做到在逆境中求勝？" class="headerlink" title="怎麼做到在逆境中求勝？"></a>怎麼做到在逆境中求勝？</h2><p>至此，再次回到開頭提出的問題：「如何用有限的預算打出競爭力？」</p><p>從分析得知，收益取決於票房，票房的關鍵是勝利，而勝利仰賴得分，得分則與球員組成息息相關。相較於身體素質，統計紀錄能反映球員肉眼不可見的能力。其中上壘率衡量了打者推展進攻局勢的可能性。</p><p>在比恩的時代，打擊率仍是評斷進攻能力的指標，這意味著某些具有得分能力的球員沒有受應有的重視。藉著網羅這些被低估的高上壘率球員，比恩便能以較低的成本，增加球隊在季賽中預期的得分數，達成提高勝率和吸引球迷入場的目標，最終擺脫競爭力失衡的循環。</p><h2 id="尋找自己的明星球員"><a href="#尋找自己的明星球員" class="headerlink" title="尋找自己的明星球員"></a>尋找自己的明星球員</h2><p>是以，比恩的經營策略便十分明朗了。在預算限制下，運動家隊無法買進明星球員，所以得關注初出茅廬的菜鳥或坐冷板凳的老將。由於需要詳盡數值把握球員的能力，相較於高中球員，他更青睞有較多出賽紀錄的大學新秀。即使這麼做可能會錯失一些潛力股，但保守的選才手段可以降低投資失敗的比率。</p><p>而球員之所以被冷落，表示他們有相當的缺陷，然而在欠缺資源的情況下必須取捨。重點不是完美，而是正確認知球員的價值和缺陷，以評估損益相抵後這些老將是否仍能為球隊帶來益處。<br>這也是《魔球》一再提及的中心價值，亦即使用適當的指標評價選手，再任用被低估的優秀球員。隨著時間演進、大聯盟環境和球隊需求變化，所謂適當的指標可能有所改變。然而逆境取勝的核心觀念都是理性思考和審慎評估，不要依賴印象和期待來決策。</p><h2 id="正確評估離隊球員的替代性"><a href="#正確評估離隊球員的替代性" class="headerlink" title="正確評估離隊球員的替代性"></a>正確評估離隊球員的替代性</h2><p>比起從市場購入現成的強者，透過前段敘述的方式挑選被低估的球員，再養出新的價值比較合算。然而資本限制導致球隊供不起養成的巨星，也保不住被挖腳的球隊棟樑。面對球員流失的困境，比恩的策略是 (1) 消極層面，用多位球員補強特定球員離隊的損失，(2) 積極層面，透過出售巨星的過程取得收益和選秀權等其他機會。</p><p>對勝負而言，球員的價值不在於個體，而是他的本領。因此，因應球員離隊的策略不是填補這個人的損失（無論有無這樣的人選，球隊都沒有足夠預算聘請），而是填補進攻和防守效率的損失。</p><p>比恩與運動家隊經營團隊把主力球員的能力拆分成不同的部分，仔細評估何者是影響戰力的關鍵，接著在市場上尋覓可負擔的替補球員，用迂迴的方式拼湊離隊球員帶走的得分貢獻。</p><h2 id="買低賣高、哄抬價碼、笑著交易"><a href="#買低賣高、哄抬價碼、笑著交易" class="headerlink" title="買低賣高、哄抬價碼、笑著交易"></a>買低賣高、哄抬價碼、笑著交易</h2><p>除了填補戰力，比恩也試著從交易球員的過程中佔便宜。例如利用市場上對終結者的迷戀，刻意培育一些資質還行的投手負責救援，讓他們累積亮眼的成績。接著刻意哄抬球員的本領，以高出市場的價碼出售，同時換來補償選秀權。</p><p>綜上所述，比恩與運動家隊使用被人低估的數據找到自己的明星球員。在主力球員離隊後，也能正確評估球員的替代性，以多位在單方面突出卻有其他缺陷的球員填補損失。此外，利用其他球隊對於一些虛妄數值的迷戀，比恩也能從交易的過程中，換得更便宜而且可能更有潛力的球員。</p><h1 id="魔球也能克服學術逆境嗎？"><a href="#魔球也能克服學術逆境嗎？" class="headerlink" title="魔球也能克服學術逆境嗎？"></a>魔球也能克服學術逆境嗎？</h1><h2 id="棒球與逆境、圍棋與人工智慧"><a href="#棒球與逆境、圍棋與人工智慧" class="headerlink" title="棒球與逆境、圍棋與人工智慧"></a>棒球與逆境、圍棋與人工智慧</h2><p>雖然《魔球》介紹的是棒球隊經理面臨逆境時的思考方式，但仍有應用在其他問題的價值。書中如先知般的棒球統計學教父詹姆斯曾說，他們把思考癌症、貧困和經濟等重大問題的能力用來思考棒球，可是我不認為思考棒球就比較不重要。</p><p>棒球數據分析是經營策略的有效參考。由於棒球採回合制，得失分的採計簡單（四個壘包），加上前人發展出一系列的描述統計方式，所以對其他領域的專家而言，棒球也能作為測試想法和挖掘關聯的模型。棒球和逆境思考的關係，如同圍棋和人工智慧的關係。對於人工智慧專家而言，圍棋本身不是重點，重點是複雜的棋局是測驗人工智慧的媒介。</p><p>綜觀《魔球》想表達的內容，即是以客觀的指標取代虛妄的猜想來衡量現況，在清楚分析問題和目標後，尋找被忽略的要素，以較高的效率克服資源有限的逆境。雖然這套方法無法保證有效（因為當今數據也有不足），卻能多少把握原先模糊的觀念，減少決策的隨機成分。</p><h2 id="陸永祥教授的科研團隊管理經驗"><a href="#陸永祥教授的科研團隊管理經驗" class="headerlink" title="陸永祥教授的科研團隊管理經驗"></a>陸永祥教授的科研團隊管理經驗</h2><p>當初讀《魔球》時也想過，學術圈其實很像大聯盟：各大教授教授帶著碩博士在物理聯盟、化學聯盟乃至生科聯盟作戰，必須在每個賽季裡撰寫計畫、爭取經費、網羅學生、做足研究。既有錢又大咖的教授有充裕的資本也有豐沛的人力，在學界呼風喚雨，做起研究來Nature 和 Science 連發；既貧困又要面臨升等壓力的教授，計畫屢投不中還要被刁難，學生少就算了，還得被校方凹去做行政業務。</p><p>面對學術圈的困境，有機會應用魔球的理論克服嗎？前幾周，普渡大學的陸永祥教授來我們所上演講，他說他擔任助理教授的時候，陷入計畫和論文屢投不中的困境。沒有計畫，資源無法到位，資源不足則無力招聘研究生，在沒有人力的情況下，研究進展也持續耽擱。</p><p>陸教授面臨的逆境，如同戰績低迷和票房銳減的運動家隊。他認為當前的目標是要維持研究進度，因為有了成果便能申請計畫帶來資金，所以陸教授又回到第一線做研究，同時參與民間單位的投資計劃籌備資金。</p><h2 id="被低估的大學生"><a href="#被低估的大學生" class="headerlink" title="被低估的大學生"></a>被低估的大學生</h2><p>然而自己做終究不是長遠之計，勢必得組織研究團隊經營中長期的規劃，所以陸教授打算以大學生取代碩博士成為團隊的研究主力。原則上大學生已經具備相當的研究能力，只是許多老師認為他們才剛入學什麼都不會，所以往往沒有留意到大學生的價值。</p><p>儘管不須支付大學生學費和生活費，仍須思考要用什麼報酬吸引他們無償加入。陸教授了解大學生較碩博士更注重實習帶來的經驗和履歷，所以提供對外合作或是組內培訓的機會，吸引想要有所成長的大學生投入。而這些機會的價值雖然是錢換不來的，但對於實驗室主持人而言還比準備碩博士獎學金廉價。</p><p>不過如同其他教授擔憂的，要怎麼確認大學生是否有能力從事研究？由於大學生的課業和經驗不足，不容易像研究所招生那樣憑成績單和履歷內容區分不同申請者的能力。所以陸教授透過對談來選材，如果雙方能在同個專業說上一個鐘頭，代表這位學生有相當的理解，至少能從事基本的工作。至於能否承擔重大的研究題目，則有賴進入實驗室後的觀察，而這也是因為招募大學生不用像收碩博士一樣對經費錙銖必較，才多少能承受選材的失誤。</p><h2 id="風險管控和長期經營"><a href="#風險管控和長期經營" class="headerlink" title="風險管控和長期經營"></a>風險管控和長期經營</h2><p>相較於碩博士，大學生從事研究的時間周期較短。為了維持團隊的研究計畫，陸教授除了在面試時篩選願意久待的人以外，也建立小組制度，培養團隊內的小組領導人。這樣不僅能夠有系統地培訓研究人力，也能拓展研究團隊的大小，主持多項計畫達到風險管理的作用。</p><p>綜上所述，陸教授的魔球策略就是以研究產出為目標，除了自己投入研究和積極找人合作，也以就業和學習機會吸引被低估的大學生，用面試篩選合格的研究能力，以較低的成本運營研究團隊，藉此擺脫科研的困境。</p><h1 id="研究生能從《魔球》裡找到避免延畢的智慧嗎？"><a href="#研究生能從《魔球》裡找到避免延畢的智慧嗎？" class="headerlink" title="研究生能從《魔球》裡找到避免延畢的智慧嗎？"></a>研究生能從《魔球》裡找到避免延畢的智慧嗎？</h1><h2 id="陸教授的新發現在台灣可能是常識"><a href="#陸教授的新發現在台灣可能是常識" class="headerlink" title="陸教授的新發現在台灣可能是常識"></a>陸教授的新發現在台灣可能是常識</h2><p>雖然陸教授在國外因為沒錢而被迫以大學生為研究主力，但這在國內某些學校可能是常態了。台灣讀博士的人較少，研究生又只待兩年，所以大學生從事研究的時數未必較短。而且各校的研究所往往無法吸引原校培養的大學生，所以研究生的水準不一定比提早進實驗室的大學生厲害。所以招生成效不彰的學校往往仰賴大學生為研究主力，而實驗課或計畫執行也需要大學生負責。</p><h2 id="延畢的危機"><a href="#延畢的危機" class="headerlink" title="延畢的危機"></a>延畢的危機</h2><p>然而現在我既不是一個球隊的總經理，也不是團隊的計畫主持人，而是個得為自己人生負責的研究生，我能從比利．比恩和運動家隊的故事中得到逆境中求勝的智慧嗎？我在研究上碰上的問題是先前風險管控沒做好，以至於當前的研究題目未必能夠得出明確結論，所以可能趕不上四個月後的口頭報告以及半年後的畢業期限。</p><p>我仔細分析後驗證了自己的想法，畢業的關鍵是論文，論文寫出來才有和指導教授談判的把握。而受到限制的則是時間，還有貧乏的智力，因此我的逆境是在有限的時間和智力下完成論文。</p><h2 id="魔球裡面的觀念每天都會碰到"><a href="#魔球裡面的觀念每天都會碰到" class="headerlink" title="魔球裡面的觀念每天都會碰到"></a>魔球裡面的觀念每天都會碰到</h2><p>由於時間有限，只能降低目標。但再低的目標都要有可以說嘴的結果才能寫論文，而要產出結果必須發掘前人忽略的指標，以表現實驗組與對照組的未曾報導的差異。《魔球》裡面雖然論證了指標的重要性，卻沒有介紹比恩和他的夥伴怎麼找出這些指標，所以我得自己想辦法。</p><p>首先，我要把研究問題和假說再想清楚一點。接著做出預測，在現有資料上測試已知的指標能否觀察到值得關注的現象。如果可以，那麼依照結果調整接下來的試驗；如果不行，<br>在檢視方法的同時，也開始調查既有的指標一一嘗試。最後根據資料、方法和研究三方限制的公約數，挑選要深入的方向。</p><p>不過這做起來恐怕沒有那麼容易，畢竟科學研究本來就一直在尋找前人忽略的東西，以在高度競爭的環境下爭取生存空間。</p><h2 id="認命吧，沒有克服絕望的捷徑"><a href="#認命吧，沒有克服絕望的捷徑" class="headerlink" title="認命吧，沒有克服絕望的捷徑"></a>認命吧，沒有克服絕望的捷徑</h2><p>儘管設想了那麼多，除了腳踏實地似乎沒有其他精明的選項。碩士班的研究不是賽局，而是個人的挑戰；團隊只有我一個人不算管理，題目只有一個稱不上大數據。魔球固然新穎，布萊德彼特主演的電影也很好看，但我的目的是解決問題，而不是拓展魔球理論，實在沒必要把目前的困境硬是嵌套在主人翁的背景裡。</p><p>如同書裡提到的「真正有威脅的，是冷靜、客觀的知識」，而不是對特定方法的景仰或崇拜，對於當前的研究困境我更該思考的是怎麼管理有限的時間和專注力，把握最重要的事情努力，不要逃避現實，即使還沒結果也趕快動筆。這樣積極行動以後，即使失敗了也學到了很多。</p><p>我相信許多嘗試在魔球裡找到人生解答的人應該也有相似的體悟。因為原書的副標題是「逆境中求勝的智慧」，但大家被電影裡小蝦米打倒大鯨魚的動人故事感動一場後，發現自己還是沒想到什麼有效的解決方式，而且近況似乎沒什麼改變。所以我猜看準失落心裡的書商在所以重新出版之際，把電影版書封副標改成「一個勇敢面對自己，逆轉勝的真實故事」。</p><h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><blockquote><p>神要毀滅一個人之前，會先說他「有前途」。(Cyril Connolly, Enemies of Promise)</p></blockquote><blockquote><p>多年以後，他會說他當年去打職業棒球的決定，是他這輩子唯一一次為了錢去做某件事。在那之後，他絕對不再只為錢做任何事，絕不再讓市場支配他的人生方向。(027)</p></blockquote><blockquote><p>要把這件事做得正確，需要某種自尊，或是要拋棄某些自尊。(058)</p></blockquote><blockquote><p>只要我們停止揣測其他人怎麼看，事情就可以做得更好。(059)</p></blockquote><blockquote><p>總教練們總是傾向於選擇最不可能失敗的戰術，而不是最有效率的戰術，公然出糗的痛苦，壓過了選擇最佳戰術得到的報酬。(108)</p></blockquote><blockquote><p>真正有威脅的，是冷靜、客觀的知識。(113)</p></blockquote><blockquote><p>不要模仿別人！要學會循著理性的路線自行思考。假設、反覆求證，絕不要以為答案已經完美無瑕；不要因為某位知名棒球員說某件事是真的，就以為它是真的。(128)</p></blockquote><blockquote><p>窮，就得取捨。關鍵在於你捨了什麼，取了多少？(177)</p></blockquote><blockquote><p>不要期待完美，而是要判斷哪些缺陷不重要。(180)</p></blockquote><blockquote><p>重點不在於發生什麼事，而在於我們的球員怎麼做。(187)</p></blockquote><blockquote><p>這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。(226)</p></blockquote><blockquote><p>失敗的次數，注定要比成功多。(254)</p></blockquote><blockquote><p>重點不是比恩永遠不會犯錯；重點是他掌握到一套思考體系，讓原本難以確定的判斷，也就是球員未來的表現，稍微更確定一些。他不是算命師。他是在賭場裡算牌的玩家。(362)</p></blockquote><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li>Jamie (2011)：魔球 (Moneyball)：一個 Hack Everything 的棒球故事。MR JAMIE（<a href="https://mrjamie.cc/2011/11/14/moneyball/">Link</a>）</li><li>海倫兒朱 (2019)：弱者只能等待失敗？錯！1 個小球帶來 3 個逆境中致勝的法門。豆瓣讀書（<a href="https://book.douban.com/review/10517250/">Link</a>）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《凝視太陽》 — 學習面對死亡也是學習自由</title>
      <link href="/yalom-2008-staring-at-the-sun/"/>
      <url>/yalom-2008-staring-at-the-sun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自我意識是人類最珍貴的特質，但伴隨著思考能力而來的，卻是對消亡的恐懼。雖然嬰兒在出生時沒有被灌輸死亡的觀念，但從季節更迭、花開花謝和親人離世等跡象中，他們也會留意到，有些東西會因某個原因「永遠消失」。</p><p>隨著成長，不祥的事例逐漸累積心中。儘管一開始可能無法理解，但從大人的反應，孩童也知道這些現象不會是好事情。一旦他們意識到自己終將面臨相同的命運，孩童的生活便蒙上了死亡的陰影。</p><span id="more"></span><h1 id="凡人的傷痛"><a href="#凡人的傷痛" class="headerlink" title="凡人的傷痛"></a>凡人的傷痛</h1><p>面對兒女萌生的死亡焦慮，父母往往把孩童的注意力轉移到奇幻故事、宗教寓言或是遙遠的未來，試圖脫離這個不吉利的話題。然而這些舉動雖然能讓孩童暫時淡忘，卻沒辦法把死亡逐出他們的腦海。死亡焦慮在青少年時期會沒入潛意識中悄悄作祟，使人們做出瘋狂的舉止以在行動中證明自己的存在。</p><p>不過，輕狂的歲月是短暫的。隨著出社會，人們將面臨社會壓力和成家立業的負擔，忙碌取代幼年的敷衍想像和青年的瘋狂舉止，掩蓋我們對於死亡的恐懼。</p><p>不過等到退休賦閒且兒女離家時，自己也年過半百。此時，我們再沒有能擺脫死亡的手段，只能直視它步步逼近。</p><h1 id="辨識死亡焦慮"><a href="#辨識死亡焦慮" class="headerlink" title="辨識死亡焦慮"></a>辨識死亡焦慮</h1><h2 id="死亡焦慮確實存在"><a href="#死亡焦慮確實存在" class="headerlink" title="死亡焦慮確實存在"></a>死亡焦慮確實存在</h2><p>受到佛洛伊德去死亡化的精神分析模式影響，死亡焦慮往往被視為其它種焦慮的替身。然而作者歐文．亞隆認為，死亡焦慮確實存在，只是因為隱匿得難以察覺，才會和其他焦慮混淆。</p><p>在死亡的陰影中，人們難以享受當下的愉快。細查那些沒來由的焦慮，很可能追溯到個體對死亡的不安，如果心理治療師沒辦法辨識恐懼的根源是什麼，便無法有效改善諮商對象的狀況。</p><p>所以這本書將從鑑別死亡焦慮開始，討論我們恐懼死亡的緣由，接著引用賢哲的智慧和作者的經歷，指出死亡不足懼的原因。最後提出正視死亡並緩解焦慮的可行手段，以幫助讀者度過充實的人生。</p><h2 id="死亡焦慮的形式"><a href="#死亡焦慮的形式" class="headerlink" title="死亡焦慮的形式"></a>死亡焦慮的形式</h2><p>如前所述，死亡焦慮可能偽裝成不同形式。有的人陷入購物瘋狂，有的人則在晚年迷上化妝，有的人擔心自己的事業會一夕間崩解，在這些案例裡，造成焦慮的行為實際上是諮商對象擺脫死亡陰影的途徑。</p><p>例如過分在意外表而一再補上濃妝的人，或許不是求偶焦慮，而是擔心在鏡面上顯露老態，讓自己意識到死亡的逼近。而對事業的擔憂，也是因為事業反映了諮商對象的存在價值，如果寄託的事物瓦解，那麼自己也不得不面對消亡的事實。</p><p>另外有些人在年紀輕時不願去同學會，但在年老時又樂於出席社交場合。因為這樣的場合讓他們想起年輕歲月，在交流中彷彿又能重新擁有對於刺激生活的夢想與期待。</p><h2 id="死亡焦慮怎麼現身？"><a href="#死亡焦慮怎麼現身？" class="headerlink" title="死亡焦慮怎麼現身？"></a>死亡焦慮怎麼現身？</h2><p>死亡焦慮之所以隱晦，是因為日夜笙歌的假象和案牘勞形的無暇都能讓我們暫時把注意力移到求生。然而我們賴以維持理智的人事物也有其壽命，不可能永遠隔開我們與死亡。</p><p>以父母過世為例，我們的痛苦不只是因為離別的哀傷，也是因為再也沒有人能擋在我們與死亡之間，我們得獨自面對死亡的憂鬱。</p><p>除了保護者離世讓人意識到自己的死亡，其他威脅到生命、意識到沒有明天、感受時間流逝、體會到老化、察覺到傾頹等人事物也會讓死亡焦慮現身。</p><p>雖然死亡焦慮是令人不安的經驗，可是一旦現身，便是我們嘗試面對與疏解的機會。</p><h1 id="為什麼害怕死亡？"><a href="#為什麼害怕死亡？" class="headerlink" title="為什麼害怕死亡？"></a>為什麼害怕死亡？</h1><h2 id="死亡：我們害怕自己對死亡的想像"><a href="#死亡：我們害怕自己對死亡的想像" class="headerlink" title="死亡：我們害怕自己對死亡的想像"></a>死亡：我們害怕自己對死亡的想像</h2><p>有些人害怕的是死亡本身和死後的痛苦。相信神的人擔憂最終的審判，不相信神的則害怕亡故後永遠困在不可知的黑暗。這些害怕是源於我們對死亡的想像，因此作者認為需要在觀念上轉變解決。</p><p>伊比鳩魯認為死亡是阻礙享樂的主因，也是痛苦的根源。他提出三項克服死亡恐懼的觀念：首先，靈魂將滅，所以不需要害怕死後迎來的懲罰和審判。其次，自我在死亡那剎即消失，我們根本意識不到死亡，也不必憂慮屆時是否懊悔、是否孤獨與寂寞。最後，生死對稱，死後如同出生前，不必抱著特別或驚恐的眼光看待。</p><p>換句話說，我們必須理解到死亡和死後本身不可懼，因為那時已經沒有我們的事了。</p><h2 id="無意義：害怕死亡讓一切喪失意義"><a href="#無意義：害怕死亡讓一切喪失意義" class="headerlink" title="無意義：害怕死亡讓一切喪失意義"></a>無意義：害怕死亡讓一切喪失意義</h2><p>然而理解死亡本身不可懼，不代表能抵禦死亡為世間一切帶來的無意義感。可曾有過一種顫慄經驗？也就是在面對廣袤無垠的宇宙，感受到自己的渺小，繼而對存在的意義起了懷疑。</p><p>然而意義實際上與尺度無關，也與其存在的時間無關。事物之所以有意義是因為它們令人驚艷，而不是它們很顯眼或是能否在往後重現。</p><p>作者引用佛洛伊德的論述，解釋美不會因其終將消逝而失去價值，重點在於美在當下帶來的感受。我們存在的意義也是一樣，和肉體或靈魂是否永垂不朽無關，只要曾激起他人心中的波瀾，曾惠澤家人朋友乃至不相識的人，我們在世界的一切便有其意義。</p><h2 id="孤獨：害怕死亡帶來的終極隔絕"><a href="#孤獨：害怕死亡帶來的終極隔絕" class="headerlink" title="孤獨：害怕死亡帶來的終極隔絕"></a>孤獨：害怕死亡帶來的終極隔絕</h2><p>孤獨有兩種，一種是人際關係上的孤立，另一種則是個人與世界的隔絕。第二種孤獨是死亡之所以讓人害怕的原因，我們自嬰兒起不斷為自己的獨立性奮鬥，想要與他人區隔，想要自主活動。但是我們又苦於死亡帶來的毀滅，所以嘗試與他人連結，這就是生與死的焦慮。</p><h1 id="存在性焦慮的改善方法"><a href="#存在性焦慮的改善方法" class="headerlink" title="存在性焦慮的改善方法"></a>存在性焦慮的改善方法</h1><p>總結恐懼死亡的原因，除了死亡本身，其實可以追溯到更深層的存在性焦慮。作者建議，我們要努力過活克服無意義感，並降低人際孤獨以緩解存在性孤獨。</p><h2 id="覺醒經驗：努力過活克服無意義"><a href="#覺醒經驗：努力過活克服無意義" class="headerlink" title="覺醒經驗：努力過活克服無意義"></a>覺醒經驗：努力過活克服無意義</h2><p>死亡給人立下界線，使人因理想挫敗而沮喪；我們應正視至種感覺，試著充實地活著，減少臨走前的遺憾。</p><p>作者將種種讓人意識到死亡的事件稱為刺激，而個人在受到刺激後從中頓悟，從原先僅關注生理和世俗層次的日常階段，轉向留意到自身存在意義的本體階段，進而努力活下去的過程，則稱為覺醒。</p><p>換言之，我們必須把意義的來源從外在事物轉向自身，以免那些短暫易逝的事物消失後，我們存在的證據也跟著不見。</p><h2 id="漣漪效應：透過聯繫緩解孤獨"><a href="#漣漪效應：透過聯繫緩解孤獨" class="headerlink" title="漣漪效應：透過聯繫緩解孤獨"></a>漣漪效應：透過聯繫緩解孤獨</h2><p>古代的陪葬習俗顯漏了人們想抗拒死亡帶來的存在性孤獨——它不僅隔絕人與人的關係，還把死者徹底玻璃這個世界。因此增進與他人的關係，並真誠地陪伴能減緩死亡的寂寞，尤其是為他人帶來恩澤的漣漪效應是對此的最大安慰。</p><h1 id="治療師與存在心理治療"><a href="#治療師與存在心理治療" class="headerlink" title="治療師與存在心理治療"></a>治療師與存在心理治療</h1><h2 id="察覺死亡：回憶錄"><a href="#察覺死亡：回憶錄" class="headerlink" title="察覺死亡：回憶錄"></a>察覺死亡：回憶錄</h2><p>此章呼應作者在治療過程中自我袒露的主張，主動分享它自己體認死亡的種種經歷，並且如何克服這種焦慮，寫書在某方面也是其一，它帶來的漣漪是作者最大的安慰。另一部份提到宗教和超自然論述，作者在治療中並不會刻意否定其功效，畢竟病患的福祉仍是最要緊的，可是作者自己並不依賴宗教，它認為宗教並無解決死亡焦慮，只是抹煞了死亡的事實。</p><h2 id="給治療師的建言"><a href="#給治療師的建言" class="headerlink" title="給治療師的建言"></a>給治療師的建言</h2><p>作者最後想表達，精神異常其實不只是生理和匱乏等因素造成，對「存在」的疑問也可能是造成絕望的原因。治療師應注意到這方面的問題，並且在與輔導對象的關係中不知不覺引入。</p><p>治療雖有理論根據，但過程卻是在與對象建立關係中進行。一段友好關係並非治療的目標，卻是確保過程順利的手段。治療師的工作並非挖掘過往種種或關切未來動向，而是從當下的關係中找尋癥結。每次治療都是人際十彥，能看出對象供述內容外的一手消息，還有他們最真實的反應。所以要留意此時此地，甚至是自己的情緒波動也要利用。</p><p>雖然這些主張有違正統，但如果對療程有益的話，適時講解治療遠裡或袒露自我的以增進治療效果</p><h1 id="結論與心得"><a href="#結論與心得" class="headerlink" title="結論與心得"></a>結論與心得</h1><p>海德格說：「死亡的定義是不再有任何可能。」</p><p>昆德拉說：「死亡最駭人之處不是沒有未來，而是失去過去。」</p><p>我想這些說法之間沒有衝突，而是每個人恐懼死亡的原因不同。我大概在七、八歲的時候意識到終將一死，那時聽著自己的心跳聲，我開始思考「萬一停下來了怎麼辦？」，然後我想像著之後的事情，逐漸感到害怕與不安。</p><p>直到現在，我仍會在夜深人靜之時突然陷入恐慌。雖然說起來很可笑，但我實在是沒辦法想像一個自己不在，但仍安然運轉的世界。就好像要求一台電腦估算自己關機的速率，人要怎麼在存活的時候想像不存在的狀態？所以對我而言，活著就好像待在時間的監獄一樣，困在時間軸的一小段裡面。</p><p>然而如同伊比鳩魯所述，死亡其實與當事人最沒關係，我們實際上更該關注於現世，而不是畏懼自己的想像。畢竟，有形的監牢會限制我們的自由，而無形的枷鎖也會讓我們淪為不自覺的奴隸。除了物質和虛妄的聲名，對於死亡的恐懼也約束著我們的所作所為。如果能夠學習面對死亡，那麼便沒有其他東西可以束縛我們了（生死之間就是在服人類役）。</p><p>所以我希望自己能好好過日子，好好與人相處，好好養生，這樣才能降低對死亡的恐懼。無懼死亡不是魯莽送死，而是可以自由地活著。生活中不須擔驚受怕，面對崇高理想時，也能慷慨赴義。</p><hr><p>歐文．亞隆（2017）。凝視太陽：面對死亡恐懼（全新增訂版）（廖婉如，陳耿雄譯）。心靈工坊（原著出版於 2008 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> philosophy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科學論文的結構與撰寫 (Zen of Scientific Writing)</title>
      <link href="/the-zen-of-scientific-writing/"/>
      <url>/the-zen-of-scientific-writing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這學期我選修了蔡東湖老師的「科學論文的結構與撰寫」。經過三個月洗禮，雖然研究進度一籌莫展，卻對發表 SCI 論文充滿自信。</p><p>我在這篇文章整理了課堂和講義提及的重要原則，但寫作能力其實要在實作中磨練。所以蔡老師建議我們以後閱讀論文，除了科學內涵以外，也要學著提煉文章的結構，收集常用的句型，畢竟：「寫 paper 沒那麼難，你看個五篇就會寫了。」</p><p>（科學論文的文章架構和句型模板可以參考廖柏森老師的著作。） </p><span id="more"></span><h1 id="如何撰寫及發表學術論文"><a href="#如何撰寫及發表學術論文" class="headerlink" title="如何撰寫及發表學術論文"></a>如何撰寫及發表學術論文</h1><p>發表學術論文包含三件事：英文（論文）、科學（學術）和投稿（發表）。</p><h2 id="不要讓語言阻撓你的科學"><a href="#不要讓語言阻撓你的科學" class="headerlink" title="不要讓語言阻撓你的科學"></a>不要讓語言阻撓你的科學</h2><ul><li>科學家不只要會想、會做還要會寫。重點不是你不會做實驗，你很會做實驗，但不會寫 paper。</li><li>語言和科學要分開，我們 focus 在科學，不要被英文困擾。我們要做科學家而不是文學家。</li><li>各位一定要相信，自己的英文能力寫兩三篇 SCI paper 足足有餘。</li><li>英文的問題，我們 consult English editor。如果要錢，就給他嘛。</li></ul><h2 id="科學不問對錯，只問合理"><a href="#科學不問對錯，只問合理" class="headerlink" title="科學不問對錯，只問合理"></a>科學不問對錯，只問合理</h2><ul><li>科學沒有對或錯，只有合理不合理。所以不要在實驗室追求真理，要追求證據。</li><li>拿到 PhD 不代表你有多厲害，那張紙證明的是你的熱情</li><li>書是讀越多越厲害，不是讀越久越厲害。</li></ul><h2 id="投稿是科研的一部份"><a href="#投稿是科研的一部份" class="headerlink" title="投稿是科研的一部份"></a>投稿是科研的一部份</h2><ul><li>做研究要有正確的心態，做完實驗朝發表 paper 的方向走。沒發表等於沒做，甚至比沒做更糟糕。想想花了多少時間，死了多少老鼠，辛苦做好久無論如何都要發表。</li><li>沒有賣不出去的房子，只有還沒找到的買家和賣多少錢而已。</li><li>發表了 research article，代表你對那個領域很熟悉，所以再補一篇 review article。</li><li>一邊整理學位論文，一邊準備投稿。你論文都寫出來了，為什麼不寫成 paper？很多事只欠缺堅持。</li><li>實驗我做，論文我寫，那沒做的人審什麼？合理性和你的邏輯。</li><li>Return 沒有看科學性，要 reject 才有檢視科學。而 revision 是投稿的重頭戲，我們的目標就是朝被接受的方向走，所以感謝 reviewer，在回覆裡面狗腿一下又怎樣。</li><li>Paper 被接受不是最高興的，自己的被接受，別人被 reject 更高興。</li></ul><h1 id="寫作準備"><a href="#寫作準備" class="headerlink" title="寫作準備"></a>寫作準備</h1><blockquote><p>Writing is easy. All you do is stare at a blank sheet of paper until drops of blood form on your forehead.（寫作也沒什麼難的，不過是盯著一張白紙直到額頭滲出血來罷了）<br>by Gene Fowler</p></blockquote><h2 id="挑選期刊"><a href="#挑選期刊" class="headerlink" title="挑選期刊"></a>挑選期刊</h2><ul><li>及早決定投稿期刊，及早按照規範寫，省得往後修改的麻煩。</li><li>選錯期刊要不被編輯 reject，要不得不到良性回饋，要不接受了卻沒人看。</li><li>挑期刊時看看引用過的文獻、查查領域內的排名、找找類似主題的論文。通常，學會期刊是最穩的。</li></ul><h2 id="不是寫論文，是修改論文"><a href="#不是寫論文，是修改論文" class="headerlink" title="不是寫論文，是修改論文"></a>不是寫論文，是修改論文</h2><ul><li>把章節列出來，現在就開始寫，再慢慢修改，一定可以改。</li><li>你不可能一口氣寫完一篇論文，一定會改很多次。寫論文修改三十到五十次，稀鬆平常。現在開始寫，改個五十次就一篇 paper 出來，為什麼不寫呢？</li><li>每次寫完前要草記接下來你要寫什麼，方便下一次延續你的思路。</li></ul><h2 id="安排寫作計畫"><a href="#安排寫作計畫" class="headerlink" title="安排寫作計畫"></a>安排寫作計畫</h2><ul><li>所謂寫作，就是空出時間寫作。</li><li>從何處開始寫都行，至少是個開始。</li><li>寫作要設定截止日，留下前置量，管理專注力，維持自律，保持流暢。</li><li>只是草稿的文章不要投。然而沒有文章是完美的，盡力修改後就投稿。</li></ul><h1 id="論文架構"><a href="#論文架構" class="headerlink" title="論文架構"></a>論文架構</h1><blockquote><p>All scientists have an unwritten contract with their contemporaries and those whose work will follow to provide observations honestly obtained, recorded, and published. （科學家和當代人與繼承者有個約定，他們將提供正當取得、誠實記錄和嚴謹發表的結果。）<br>CBE Style Manual Committee</p></blockquote><h2 id="IMRAD-體系"><a href="#IMRAD-體系" class="headerlink" title="IMRAD 體系"></a>IMRAD 體系</h2><p>科學論文遵照 IMRAD 體系，Introduction &#x3D; WHY，Materials and Methods &#x3D; HOW，Results &#x3D; WHAT，Discussion &#x3D; WHAT。</p><ul><li>WHY：Why did the experiment? What question (problem) was studied?</li><li>HOW：How was the problem studied?</li><li>WHAT：What were the findings?</li><li>WHAT：What do these findings mean?</li></ul><p>方法與結果成對，簡介與討論配對。簡介要提出問題，討論應回答問題。</p><h2 id="論文的類型"><a href="#論文的類型" class="headerlink" title="論文的類型"></a>論文的類型</h2><ul><li>科學論文是經同儕審查的論文。不要看人家在大會上報告很威風，會議論文的壽命只有一天，沒有同儕審查都是 non qualified。</li><li>但同儕是誰？老師和同學是你的 colleague，不是你的 peer。只有研究相同題目的人才是 peer。</li><li>好的科學家會重視研究的整體性，不會把一篇 paper 拆成好幾篇。一篇好的 original article 可以抵五篇 short communication，科學本來就是這麼無情。</li><li>什麼都沒有的時候，搬一台電腦到圖書館就可以寫 review paper，所以一定要會寫review。</li><li>不知道敵人在哪所以要小心點。會議論文我都亂寫，以免哪天被當重複投稿，要命。</li><li>如果你有很厲害的點子，也許能得到諾貝爾獎那種，要盡快用任何形式發表。</li><li>筆離開紙就留下版權，你不需要申告，但是需要舉證。</li></ul><h2 id="撰寫科學論文不是寫小說或散文"><a href="#撰寫科學論文不是寫小說或散文" class="headerlink" title="撰寫科學論文不是寫小說或散文"></a>撰寫科學論文不是寫小說或散文</h2><ul><li>自己做的用過去式，別人做的用過去式。所以摘要、結果與方法用過去式，簡介用現在式，討論視情況而定。</li><li>科學論文寫得艱澀又冗長就只有一命運，reject。</li><li>想要避免抄襲的話，寫筆記要紀錄引用來源，寫論文時別參考文獻。文獻等核對內容的時候才拿出檢查。</li></ul><h1 id="作者序、標題與摘要"><a href="#作者序、標題與摘要" class="headerlink" title="作者序、標題與摘要"></a>作者序、標題與摘要</h1><h2 id="決定作者序不是小事"><a href="#決定作者序不是小事" class="headerlink" title="決定作者序不是小事"></a>決定作者序不是小事</h2><ul><li>作者順序，自己放在第一個，學長姊其次，老師放最後面。研究生無論如何一定要 keep 自己是 first auther。</li><li>要怎麼 keep？把文章寫出來，idea 我出的，實驗我做的，paper 我寫的，誰是老大？</li><li>不要說沒人會寄信給你，論文作者的地址是辨識身分的途徑。</li><li>不要讓無關的人掛名，稀釋你對論文的貢獻；也不要隨便找人掛名，損害自己的名譽。</li><li>簽了名，就要負責。</li><li>出點子的、給想法的、設計實驗的放作者；執行的、借器材的、諮詢的放致謝。</li><li>作者的順序要在做實驗之前就講好，論文發表時也要所有的作者同意，否則朋友可能變敵人。</li></ul><h2 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h2><ul><li>Title should be sexy（標題必須性感），review 才適合寫大題目。</li><li>Keyword 可以補充文章沒出現過的字。</li><li>要假設你的論文會被不同時代、不同知識背景、不同閱讀媒介的專業讀者閱讀，所以有時效性的不要寫、艱澀難懂的術語不要寫、縮寫不要寫、廢話不要寫。</li><li>然後，不要裝可愛。</li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>摘要就是迷你論文，全文的 README (IMRAD)。</li><li>摘要獨立於論文，網路檢索往往只看得到摘要，因此要self contained。</li><li>不只要學會寫摘要，也要會畫圖，圖畫得好，一副要被人引用的樣子。不過賣得出去就好，管他不漂亮。</li><li>標題是標籤，不需要是完整的句子，所以標題用字和字序很重要。</li><li>結論可以在標題講一次、摘要講一次、簡介講一次、討論講一次。</li><li>沒做的實驗不要寫進摘要。</li></ul><h1 id="簡介與討論"><a href="#簡介與討論" class="headerlink" title="簡介與討論"></a>簡介與討論</h1><p>方法和結果是死的，Introduction 和 Discussion 才是重頭戲</p><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><ul><li><p>Introduction 的目標是 introduce 這篇論文。</p></li><li><p>撰寫 introduction 的重點在擺放概念的位置，還有提醒讀者「要來了」的轉折詞。</p></li><li><p>如果你不曾寫過論文，那就寫成漏斗狀：(1) 概述主題，(2) 依照時間順序描述前人的工作，(3) 解釋既有不足和研究問題，(4) 提出假說、研究目的和原創性。</p></li><li><p>文獻回顧：如果你對主題比 reviewer 還清楚，他還敢給你 reject 嗎？</p></li><li><p>原創性：如果不確定有沒有人做過，就寫出你找了多少文獻，讓 reviewer 幫你補充。</p></li><li><p>研究問題：提出的問題要合理要可被理解否則讀者不會有興趣。</p></li><li><p>研究目的：研究目的其實就是結論。</p></li></ul><h2 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h2><ul><li>好的 data 若沒有好的討論也會被退稿。</li><li>討論的目的是回答 Introduction 提出的問題，不要節外生枝產生更多困惑。</li><li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li><li>不要讓讀者讀完了有種「又怎樣」的想法。</li><li>討論不理想結果的句型要記住，為討論而討論的內容雖然不切題，但也討論了啊。</li><li>要把例外和限制講清楚，不要蒙混過關或睜眼說瞎話。</li><li>不要羞於討論結果的理論含意或應用價值，因為那是你的遠見和貢獻。</li><li>分清楚 future work（希望）、comming work（即將）和 upcomming work（已經）。</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul><li>作者要為每個結論簡述證據，所以結論不要下得像宇宙那麼大，不然會讓研究被質疑。</li><li>實驗沒做過的不要放進結論，也不要過度延伸結果 ，那沒有你的事。</li><li>你能做的是在一個地方聚焦事實。</li></ul><h1 id="方法與結果"><a href="#方法與結果" class="headerlink" title="方法與結果"></a>方法與結果</h1><blockquote><p>The greatest invention of the nineteenth century was the invention of the method of invention.（十九世紀最偉大的發明是創造了發明的方法。）<br>A. N. Whitehead</p></blockquote><h2 id="實驗記錄"><a href="#實驗記錄" class="headerlink" title="實驗記錄"></a>實驗記錄</h2><ul><li>做錯做慢都 OK，千萬不能造假。</li><li>筆記包含自己寫的內容 (print materials) 和引用的內容 (quoted meterials)。</li><li>不要相信人的記憶力。東西還在，記憶猶新，實驗邊做，paper 邊寫。</li><li>做研究時的想法要記錄，寫論文時才有底稿和素材。</li><li>可重複 (Repeatability) 是同個人使用相同方法和器材得到相同結果 ；可再現 (Reproducibility) 是不同人使用相同方法和不同器材得到相同結果。</li><li>實驗記錄要讓自己能重複，論文的方法要讓別人能重現。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>相較於藝術和玄學，科學的價值是可以被重現。所以方法被認為無法重複或重現就會被退稿。</li><li>方法可以出現在實驗記錄、論文的簡介和論文的方法中。你要在 Introduction 裡陳述並捍衛自己的實驗設計，在 Materials and Methods 給出細節，讓潛在的競爭對手可以重複。</li><li>方法的架構是：大處依照時間順序排列，小處依照方法類型分區，說明採用的方法後簡述原理。</li><li>舊方法要引用，新方法要詳述，改良的方法除了引用也要稍微解釋。</li><li>不管怎麼樣，以第三人稱描述方法最保險。</li><li>石器時代結束了，但石頭一顆也沒少。High tech depends on low tech.</li></ul><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><ul><li>如果方法和討論寫得好，結果應該是最短的 section。</li><li>科學論文不精簡，那只會得到一個字，redundancy，也只有一個命運，rejection。</li><li>撰寫結果只有三個原則：簡述實驗、呈現數據、時態用過去式。</li><li>數據得整理，文、圖、表擇一，方法結果要對應，確保行文一致性。</li><li>圖表沒有對錯，只有合適不合適，用在什麼場合。</li><li>結果呈現的原則：趨勢畫圖，數據製表，一般撰文。</li><li>文、圖、表各自獨立，圖表要 self-contained。</li><li>給老闆完整的資料，但給編輯代表性的資訊。</li><li>但不要只給老闆數據，你要寫成一個 section paraghragh。因為一旦你的 data 跟其他人做的混在一起，你的貢獻就沒了。</li></ul><h2 id="引用與致謝"><a href="#引用與致謝" class="headerlink" title="引用與致謝"></a>引用與致謝</h2><ul><li>Credit 要給原創者，不是給 review 的人，review 的人沒有做實驗。</li><li>Idea 只要不是自己的，一定要引用，寧可多引用給 reviewer 篩選，也不要少東少西。</li><li>引用要從優，挑選重要的一手文獻。</li><li>如果文獻值得引用，要在文中讓讀者了解原因。</li><li>完稿後要確認文內引用和參考文獻一一對應。</li><li>致謝跟科學論文沒什麼關係，因為禮貌是文明社會的生活型態。</li><li>公開的書面致謝是科學的玩法。</li><li>誰幫助你就感謝誰，但別謝過頭，反而損害自己的貢獻。</li></ul><h1 id="結論：科學論文寫作十訓"><a href="#結論：科學論文寫作十訓" class="headerlink" title="結論：科學論文寫作十訓"></a>結論：科學論文寫作十訓</h1><ol><li>不要讓語言阻礙科學。</li><li>科學不問對錯，只求合理；實驗室沒有真理，只有證據。</li><li>做完實驗一定要發表論文，論文發完發綜述。</li><li>科學論文由 WHY、HOW、WHAT、WHAT 組成 (IMRAD)，簡介與討論呼應，方法與結果配對。</li><li>寫作時，自己做的用過去式，別人做的用現在式。</li><li>Introduction 的目標就是 introduce 這篇論文：概述主題、文獻回顧、提出問題、說明目的。</li><li>實驗紀錄要能重複，論文方法要能重現。</li><li>撰寫結果只有三個原則：簡述實驗，呈現數據，文圖表擇一。</li><li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li><li>引用的榮耀屬於知識創造者，而非知識整理者。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戰爭，不再適用於描述宿主與微生物的關係</title>
      <link href="/forum-on-microbial-threats-2006-ending-the-war-metaphor/"/>
      <url>/forum-on-microbial-threats-2006-ending-the-war-metaphor/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>撇除雷文霍克和虎克那個用顯微鏡觀察微生物以展示風雅的時代，微生物學的重大發展皆與解決釀酒、蠶業、農業等產業問題息息相關，而人體微生物學也是源於臨床應用背景。</p><p>(Forum on Microbial Threats. (2006). Ending the War Metaphor: The Changing Agenda for Unraveling the Host-Microbe Relationship-Workshop Summary. National Academies Press.)</p><span id="more"></span><p>二十世紀初人類的衛生觀念基於巴斯德和柯霍等人確立的細菌致病學說（the germ theory of disease），認為特定病原菌破壞人體健康狀態而導致疾病，所以當時的防疫觀念著重消毒，試圖透過全面滅菌降低細菌傳播。在細菌致病學說指引下，研究者系統地搜索病原菌，結合同時期發展的疫苗、化學療法和抗生素挽救無數人性命。此外，細菌致病學說納入了病毒致病因素後，拓展為更為成熟的微生物致病學說，持續引領晚近的人體微生物學研究。　<br>　<br>儘管微生物致病的典範取得了巨大的成功，這種以病原為中心的觀點（pathogen-centered）過度強調疾病與特定物種的關係，忽略了物種與物種、物種與宿主間交互作用變動造成的疾病，也沒有考慮到物種的多重屬性。因此面對晚近浮現的超級細菌、腸道發炎疾病及自體免疫等的問題時，施用不同藥物試圖全面撲滅病原的策略往往不能奏效，傷害患者身體的同時還間接篩選更頑強的細菌。<br>　<br>除了致病菌以外，晚近的研究也指出體內微生物的組成和神經疾病、肥胖、過敏相關，這意味著微生物不只單純棲息於體內，它們可能參與人體生理的大小反應。</p><p>新興疾病的醫療危機以及微生物與宿主的生理相關性揭示了微生物與宿主間的複雜關係，於是學界漸漸重視微生物致病的其他因素，例如：微生物的變化、微生物與環境的關係、微生物間的作用網路、免疫系統與微生物間的互動、……等，模糊了人類與病原菌之間壁壘分明的界線。</p><p>換句話說，學界引進了生態學的思考方式，將人體視為棲息地（human-as-habitat perspective）而不是廝殺的戰場（body-as-battleground perspective or the War matephor），微生物是人體的一部份而非外來的異客，身體狀態是細菌與人體細胞共同作用的外顯特徵，而健康則是生態系平衡的紅利（ecosystem service）不是固有的狀態。</p><p>看待微生物的觀點轉變不僅影響研究圈，也會影響臨床醫療的決策。雖然傳統醫療手段不會被取代，但是面臨複雜症狀的疾病時需要更仔細考量發病的環境脈絡，以免貿然治療造成反效果。另外生態系適應性經營（adaptive management）或許能運用於人體，透過連續的調查與評估，鎖定生態網路中的致病節點，借鑑動植物生態學的經驗，修復生態或引進原生物種以移除病原（probiotics therapy）。</p><p>然而要達成上述目標需要更深入理解人體微生物生態學和演化學，並釐清微生物的組成、功能與交互作用網路，而 Allan 和Stankey 設想生態系適應性經營的四步驟則能協助理解的前提。首先必須識別生態紅利的供應者，篩選影響其功能的環境或生物因素，最後評估作用的時空限制。就此框架看來，僅確認微生物與特定現象的因果仍不夠，必須深入理解造成現象的特定因素，而這些關鍵的要素就藏在微生物的生態網路當中，所以架起了基礎科學和應用科學的聯繫。</p><p>由於觀測、培養和分類困難，微生物生態學的發展落後於動植物生態學，直到基於核酸的鑑定理論與方法成熟才得以開啟微生物學的博物學時代，此階段的研究雖然看起來像過往一樣遵循「鑑定物種分析關聯」的流程，但往後以功能與交互作用等更複雜的現象為目標。這些基礎科學的成果，不只有助於治療疾病也將能開拓微生物的應用價值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ecology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>馬丁說，這個世界是為了激怒我們而創造的。</title>
      <link href="/a-world-crafted-to-incite-our-ire/"/>
      <url>/a-world-crafted-to-incite-our-ire/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>　　最近老是流鼻水，所以趁著書報討論停課到學校附近的耳鼻喉科檢查。</p><span id="more"></span><p>　　「除了流鼻水還有什麼問題嗎？」醫生問。</p><p>　　「還有沒來由的怒意」我說。</p><p>　　「怒意？」醫生抬起頭看著我。</p><p>　　「對。」我說，「醫生你知道有個喜歡恐龍而且愛畫畫的女孩綺綺嗎？勇敢又體貼，即使生病也不放棄自己的夢想，但為什麼要受到先天疾病折磨？</p><p>　　「今年八月，三個環保志工被酒駕的垃圾撞死，其中一個媽媽已經行善了二十年，到底他們犯了什麼錯，要死得那麼不值，死得那麼悽慘？</p><p>　　「操他媽天公伯，這些事情都不放在眼裡嗎？酒駕的渣滓還是過他的人生，欺負別人的惡棍繼續招搖。我家附近那個把別人財產騙走，害老農自殺的廢物到現在還是用那些血腥的錢在台北過著日夜笙歌的生活。</p><p>　　「醫生，這還真是多采多姿又有意義的結局啊？不是嗎？用吊死的遺體、殘缺的肢臂、潰爛的瘡疤嘲笑他們生前的努力、慈愛和善良，用家屬的眼淚、無力和哭嚎妝點惡人的逍遙。</p><p>　　「這太荒唐了，什麼都不對勁，什麼也不合理！一個遵循物理和化學因果律的世界根本不該是這種噁心的模樣。」</p><p>　　「對，不合理，你終於意識到了。」醫生說。</p><p>　　「意識？」<br>　<br>　　「沒錯，儘管母體嘗試把這個空間打造得跟曾經存在的真實世界相似，但過於龐雜的細節和合理的運算速度無法兩全，所以才讓你發現這個空間的瑕疵。」醫生接著調出我健保卡裡的資料，但上頭什麼都沒有「你應該有印象自己看了幾次醫生吧？但為了節約能源，這個空間只以最小限度的資源運營，凡是你無法直接觸及的地方，都不會有物件與資訊存在」</p><p>　　 「你到底在說些什麼？母體？這是駭客任務嗎？你說我周遭的一切是虛構的數位空間？」</p><p>　　「我再次強調，沒錯。如果電影情節可以幫助你理解真實，那你這麼想也無妨。現在是二十三世紀，世上已經沒有不平等了，戰爭被消滅，剩下永恆的和平。機器人取代百分之九十九的勞動，人類只需要專注在自己感興趣的事上，用一生的時間探索未知和驚奇。沒有生老病死的惆悵，也沒有孤獨一人的寂寥，寂寞的時候可以任意找來仿真的機器同伴，仿真的父母、祖父母、兄弟姐妹、朋友女朋友。人類的智力也達到前所未有的提升，當代的劇作更加迷人，文學一樣興盛，而且醫療發達科技進步，現代人有更長的時間可以閱讀。<br>　　<br>　　「你所處空間的一切都是為了激怒人而存在，沒有任何道理。憤怒是現在最乾淨有效的能源，母體會吸取你們累積的憤怒，送入福利發電機轉換成電能以供真實世界所需。你可能會疑惑自己的才智、長相、財力和際遇，但這些都只是能激怒你的設定。 從宿舍前卿卿我我的情侶、在圖書館打鬧喧嘩的大學生、貪小便宜的小人到殺人放火酒駕殘殺等等任何你看不順眼的人事物都是母體營造的。如果你還是感到懷疑，那麼先仔細想想你有沒有調查過新聞上的事情是否真的發生過？」醫生說。 　<br>　　<br>　　「怎麼可能？新聞造假就算了，但從宿舍到辦公室，辦公室到街上，你說我每天看到無數讓人靠北的垃圾都是虛擬的？」<br>　　<br>　　「哦，我想你可能有些誤會我的意思了，我沒有否定你的存在性，你不用擔心自己。我可以保證你是真實存在的個體，但那些惱人的事物是虛擬的，不過它們的確能激起你真實的憎恨、憤怒還有愛。」</p><p>　　「那綺綺呢？志工媽媽呢？對我們家一直都很好的老農夫呢？他們在真實世界都怎麼樣了？」我問。</p><p>　　「他們都在真實世界過著幸福的日子。現在的生物科技已經允許我們重建暴龍、蛇頸龍乃至巨大的雙腔龍，我們在圭亞那有數座侏羅紀公園，喜歡恐龍的她一定去過好幾次了。</p><p>　　「而你在這個空間看到的惡人，現在也有專屬於他們的地獄。刑事科學最大進展就是了解肉體的疼痛不是最大的折磨，所以那兒可能比你在廟裡看到用來勸世的書籍來得可怕。」 　　<br>　　「太好了。」我心裡想，至少他們還好好的，至少這個世界不是幹你老師的噁心。</p><p>　　「既然你意識到了世界的不合理和瑕疵，也來到了母體對放電瓶們的窗口，在此我將給你一個選擇，」醫生一邊說，一邊拿出一顆紅色藥丸和一顆藍色藥丸。</p><p>　　「吞下這顆象徵虛假的紅色藥丸，流鼻水的症狀會立即解除，你走出這間診所後將再次面對醜陋、憤怒、還有一切說不出的苦痛 ; 但吞下這顆象徵真相、理性、自由和思辨的藍色藥丸，你將獲得平等、安樂和永遠幸福的權利。」</p><p>　　儘管他這麼講，我還是覺得很不對勁。 「等等，那為什麼這麼好的世界，會有人願意待在充滿憤怒的發電機器裡？」</p><p>　　「也許他們自願的，有些人的基因裡寫著被激怒的渴望。」醫生說。</p><p>　　簡直就是美麗新世界形容的未來，但又比美麗新世界好上不只兩倍。利用制約和生育管理營造的世界沒有自由意志，而在醫生所說的二十三世紀裡，愛恐龍的綺綺過得很好，志工媽媽的善心可以傳承下去，老農夫種的有機蔬果持續填飽那裡的人們，我也許可以不用每天被氣醒，可以安適地起床，可以和喜歡的人（或機器人）共度餘生，可以專心研究生命起源和意識的謎題……我心動不已，我好想相信有這樣的「現代」存在。</p><p>　　雖然好想相信一個可以補償所有缺憾與遺恨的世界，但是「萬一這裡才是真的怎麼辦？世界真的那麼……靠北，我一時想不出形容詞，但就是那麼過分怎麼辦。」</p><p>　　「你剛剛不是還在懷疑世界的合理性嗎？我也告訴過你，你遭遇的荒謬是母體與系統的設置，還有什麼疑惑嗎？」醫生說。</p><p>　　「這難道不是母體的陰謀嗎？假裝有個更好的地方，然後派個穿白袍的莫菲斯告訴我只要嗑下這些藥就可以擺脫這個鬼地方，但真實目的是要綁架我去當人體電池？」我說。</p><p>　　「這便是為什麼有人願意待在虛擬空間受折磨的一個原因，天堂不歡迎懷疑論者。」醫生說。</p><p>　　 「但沒關係，這不是電影，你永遠都有權選擇離開。紅藍藥丸在各大藥局都有賣，取得處方簽即可領藥。如果不太會吞膠囊，也能夠選購藥粉或藥水。</p><p>　　「離開後你的鼻水就會好了，如果之後有任何問題也能再回來找我。」醫生說。 　<br>　　<br>　　「你們是為了說服我離開虛擬空間才讓我流鼻水的嗎，如果真的有你宣稱的虛擬空間。」我邊說邊留意到鼻子可以順暢呼吸了。</p><p>　　「沒有，母體只是希望你的生活不便，內心累積更多所謂的『靠北』情緒而已，所以你回去後可能要再為麻疹、蜂窩性組織炎、禿頭、癌症和青春痘煩惱。」醫生說。 　</p><p>　　「……」</p><p>　　「既然你已經知道世界的真相，那要怎麼思考即是你的功課了。母體鼓勵理性和獨立思考，但只要你一天沒離開此空間，你眼前的一切都會持續激怒你。</p><p>　　「你想選擇野蠻人約翰的生活方式，或是阿爾法族列寧那的生活方式，母體都不會干預，這裡沒有一個穆斯塔法會駁倒你。」醫生說。</p><p>　　儘管還是有些遲疑，我仍向藥局領了一套紅色藥丸和藍色藥丸，也許我會向衛生局檢舉，但在那之前可能得送交食品檢驗處化驗，畢竟來路不明的藥物拿在手上，被誤會為毒蟲該怎麼辦？</p><p>　　「記住，現實世界是幸福的。」醫生在我離開診所前提醒我。我坐在桌前看診的對話大概是懂了，但不只怒意無法消散還多了很多疑惑。我盯著袋裡的兩顆藥丸，心想到底萬一兩顆都吞下去怎麼辦，母體會當機嗎？還是我會卡在時而幸福時而讓人憤怒的空間，照我自己的心情選擇想相信哪裡？如果我吃了藍色藥丸卻發現一切都是騙局，我能再次吞下紅色藥丸回到這個世界嗎？</p><p>　　我打開從圖書館借回來的《憨第德》，想看看伏爾泰怎麼嘲笑醫生今天講的萊布尼茲式樂觀主義，但是關鍵的頁面居然被一大片汙漬給蓋住。我把書頁拿到檯燈下，透著光讀著憨第德和馬丁的對話：</p><blockquote><p>憨第　　　「到底　　　　　為　　　目的而創　　？」　丁回答：　為了　　　我們。」</p></blockquote><p>　　因為什麼也看不清楚，所以我放棄了。我把書放回架上，但架子竟承受不住重量塌下，整本書掉進魚缸，擊中上週停電時倖存下來的小金魚。</p><p>　　「媽的。」我說，此時電視正報導著年輕爸爸在散步時在孩子面前被遙控飛機撞得頭破血流而亡的新聞。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡住、沒靈感、寫不出東西怎麼辦？</title>
      <link href="/what-to-do-when-you-are-stuck-in-writing/"/>
      <url>/what-to-do-when-you-are-stuck-in-writing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原本我開啟部落格編輯器是打算寫一篇文章，總結我兩周以來學習降噪演算法的經驗，但回過神來，已經盯著標題與目錄一個鐘頭了。我意識到再這樣下去不是辦法，於是把原先的標題刪除，開始思考「如果寫文章碰到瓶頸，除了躲在桌下哭訴沒有人愛我以外，還能做些什麼？」，在閱讀了網路和實體書籍資源後，我寫了這文章。因此，本文不只是各項建議的彙整，也是這些方法的實踐。  </p><span id="more"></span><h2 id="寫作瓶頸的成因為何？"><a href="#寫作瓶頸的成因為何？" class="headerlink" title="寫作瓶頸的成因為何？"></a>寫作瓶頸的成因為何？</h2><h3 id="我寫不下去了……"><a href="#我寫不下去了……" class="headerlink" title="我寫不下去了……"></a>我寫不下去了……</h3><p>儘管已經寫了十幾篇文章，每次開啟新文件的時候還是很掙扎，因為我要不是在文章的開頭感到絕望，就是在寫一半的時候覺得快不行了。我試著問論文寫作的老師，當他碰到寫作瓶頸時會怎麼克服，他說：「我在列完大綱後都能順利地寫完論文，所以沒有碰過這種障礙。」  </p><p>人類的悲喜和苦惱並不相通，我得靠自己找出解決辦法。  </p><h3 id="為什麼會碰到障礙？"><a href="#為什麼會碰到障礙？" class="headerlink" title="為什麼會碰到障礙？"></a>為什麼會碰到障礙？</h3><p>寫文章卡住多半是源於<strong>沒有東西寫（知識問題）和寫不出字來（心態問題）</strong>。在我的寫作經驗裡，大部分的情況都是碰到心態問題。畢竟無論是寫何種題目，至少都有個預設的目標，有目標表示有初步的想法，既然有想法便不至於沒內容可以寫。是以多數的情況是讀穿了參考資料，卻在文件上打兩個字刪三個字，好似永遠也寫不出文章來。  </p><h3 id="怎麼辨識寫作瓶頸的成因？"><a href="#怎麼辨識寫作瓶頸的成因？" class="headerlink" title="怎麼辨識寫作瓶頸的成因？"></a>怎麼辨識寫作瓶頸的成因？</h3><p>針對不同原因需要不同的解決辦法，那麼該如何辨識寫作瓶頸的成因呢？Esor Huang（電腦玩物的站長）建議大家口頭陳述想要表達的概念，由於打嘴砲不用負責，所以如果內心有點想法的話幾乎都能講出一些東西來，進而排除是知識問題。  </p><p>除了這個方法，我也提供一項判斷的策略：問問現在自己的感覺如何。假如<strong>真的沒東西寫了，那面對空白文件的時候，腦中浮起的應該是困惑</strong>：「什麼是微生物分析？」、「什麼是天文生物學？」、「我什麼都不知道，為什麼我會在這裡」，此時有充分好奇心的同學，應該會自動自發找資料，在資料搜索的過程中為撰寫文章準備。  </p><p>然而，<strong>如果是心態問題，打開文件時應該會出現恐懼、焦慮、害怕、猶豫、逃避等情緒</strong>。假如某個人笑著看著文件，卻不時點開社群網站和 Youtube 呵呵笑，即使沒有前述情緒，這個人也碰上了心態問題。  </p><h3 id="知識問題和心態問題需要不同的解決策略"><a href="#知識問題和心態問題需要不同的解決策略" class="headerlink" title="知識問題和心態問題需要不同的解決策略"></a>知識問題和心態問題需要不同的解決策略</h3><p>如果是知識問題，唯一的解決辦法就是充實知識，閱讀書籍也好，回顧先前的筆記也好，讓空乏的大腦裝滿寫作的素材克服無東西可寫的困難。如果是心態問題，那麼解決之道便是調整心態，想辦法擠出字來，榨乾自己直到碰上知識問題。我認為寫作一定會碰到障礙，從興起寫作的念頭，我們就開始「不知道寫什麼、閱讀和學習、寫不下去了、調整心態、榨乾自己、不知道寫什麼、……」的循環，既然決定寫文章，就拋開恐懼吧。  </p><h2 id="知識問題：該寫什麼？"><a href="#知識問題：該寫什麼？" class="headerlink" title="知識問題：該寫什麼？"></a>知識問題：該寫什麼？</h2><h3 id="成長是寫作與學習的循環"><a href="#成長是寫作與學習的循環" class="headerlink" title="成長是寫作與學習的循環"></a>成長是寫作與學習的循環</h3><p>關於知識問題，紀大偉老師有很棒的建議：<strong>研究所（或成長）是寫作與閱讀的循環。</strong>當寫得殫精竭慮，再也寫不出東西的時候，便該停下筆去學習或去閱讀。不必侷限於文章的主題，相關的專著或文章都可以接觸，既能補充匱乏的知識，也能促進知識間的連結，有助於寫作時有足夠且有趣的內容可以輸出。  </p><h3 id="學習不能作為逃避寫作的藉口"><a href="#學習不能作為逃避寫作的藉口" class="headerlink" title="學習不能作為逃避寫作的藉口"></a>學習不能作為逃避寫作的藉口</h3><p>然而<strong>吸收知識不能作為逃避寫作的藉口</strong>。之前寫多樣性分析的簡介文章時，因為總覺得不夠熟悉各項指標，所以遲遲無法下筆。我原本以為這是知識問題，但世上的知識是讀不完的，我的文章也非得涵蓋所有知識，因為對自己知識的不安而裹足不前，這是心理問題。  </p><p>擱置手邊的工作去閱讀是為了寫作，而不是為了享受閱讀的過程。如果真的發現要補足的知識讀不完，那麼應該重新審視文章的主題，而不是陷在學習的沼澤裡無法自拔。  </p><h3 id="為了寫作而學習，為了學習而寫作"><a href="#為了寫作而學習，為了學習而寫作" class="headerlink" title="為了寫作而學習，為了學習而寫作"></a>為了寫作而學習，為了學習而寫作</h3><p>因此，有效的閱讀要寫筆記。藉由寫筆記留下內容與思考的紀錄，之後撰寫文章便不需要回顧原始資料，還可以累積寫作的素材。例如這篇文章即是我讀了不同來源資料的筆記彙整出來的。  </p><h2 id="寫作兼具思考和表達兩種功能"><a href="#寫作兼具思考和表達兩種功能" class="headerlink" title="寫作兼具思考和表達兩種功能"></a>寫作兼具思考和表達兩種功能</h2><h3 id="寫作既是表達的媒介，也是協助思考的工具"><a href="#寫作既是表達的媒介，也是協助思考的工具" class="headerlink" title="寫作既是表達的媒介，也是協助思考的工具"></a>寫作既是表達的媒介，也是協助思考的工具</h3><p>在說明心態問題前得先釐清寫作的兩個功能。首先，寫作是傳達觀念的媒介，亦即寫作是表達的工具。但寫作有另一種身分，寫作是協助思考的方式，或著說，<strong>寫作其實是思考的一部份</strong>。  </p><p>因為這兩種功能的差異，所以儘管許多人曾碰到寫文章卡住的問題，仍有些編輯主張沒有寫作瓶頸這回事。因為從寫作即是思考的觀點而言，寫作之於思考有如呼吸之於跑步，跑步覺得有些吃力的時候，不該歸究於呼吸障礙而停止呼吸，應該專注於調整呼吸才對。寫作時亦然，想<strong>不到該寫什麼的時候，不應輕易中止寫作，反而要設法用寫作解決問題。</strong>  </p><h3 id="透過寫作思考的好處"><a href="#透過寫作思考的好處" class="headerlink" title="透過寫作思考的好處"></a>透過寫作思考的好處</h3><p>但為什麼寫作能夠協助我們思考並解決寫文章卡住的問題？首先，我們很難不依賴具體的東西把事情想清楚，例如在跟人說話的同時比劃手勢，或是利用紙筆和公式協助數學運算。因此，在寫不出東西的時候更要利用寫作呈現思考的過程，讓大腦主動思考，集中思緒在主題上，以免不同的想法在腦中衝撞，最後只剩下美食、假期和旅遊等無關事物。  </p><p>此外，我們的大腦無法一次處理太多事物。寫作留下的紀錄可以讓我們追溯思考的路徑，並依此延伸新想法，繼而組織文章的架構。  </p><h3 id="以寫作（思考性寫作）解決寫作（表達性寫作）問題"><a href="#以寫作（思考性寫作）解決寫作（表達性寫作）問題" class="headerlink" title="以寫作（思考性寫作）解決寫作（表達性寫作）問題"></a>以寫作（思考性寫作）解決寫作（表達性寫作）問題</h3><p>綜上所述，<strong>當我們寫文章卡住的時候，其實是用於表達的寫作中止了，但用於思考的寫作應持續進行</strong>，利用自由書寫等方式呈現把所想的內容保留在文字。如此一來，既推進了寫作的進度，也累積了一些文章的素材。  </p><p>##完美主義的心態問題</p><h3 id="最好是更好的敵人"><a href="#最好是更好的敵人" class="headerlink" title="最好是更好的敵人"></a>最好是更好的敵人</h3><p><strong>完成永遠比完美更重要</strong>，因為任何事都不可能完美，我自己寫作時經常犯完美主義的問題。以我部落格人氣最高的那篇文章為例，那篇就是完美主義的產物。你稍微看一眼可能會感到疑惑：「完美主義？可是那篇用字紊亂而且格式也歪掉了耶？看起來不是很完美啊！」  </p><p>沒錯，這就是完美主義的的下場。在撰寫開頭時便字斟句酌，隨後每寫一個字要反覆修改半天，這樣子不僅離完成遙遙無期，還會因為過分在乎細節，反而分不清文章各段的價值，忽略整體的優劣。截止日接近的時候，在匆忙之下也沒有時間充分的修改，最後不得不發布未經潤飾的最新版，而不是理想中的最佳版。  </p><h3 id="化解完美主義的心理暗示"><a href="#化解完美主義的心理暗示" class="headerlink" title="化解完美主義的心理暗示"></a>化解完美主義的心理暗示</h3><p>既然完美主義是心理問題，那解決問題的方式就是改變心態，以下是幾個在寫文章前可以提醒自己的事情。  </p><ul><li><p><strong>其實沒有人在乎你寫了什麼</strong>：我的網站雖然意在吸引那些潛在的同儕或貴人，但其實每天點進來的人真的很少，為了一兩個字或一句話搞些有得沒的實在不值得。</p></li><li><p><strong>其實也沒有人會好好看文章</strong>：其實我寫完文章的時候都會寄給朋友或老師看，他們未必對內容有興趣，即使有興趣也不會一個字一個字看，所以別太在乎一兩個字的差異。</p></li><li><p><strong>其實寫文章也沒什麼了不起</strong>：雖然寫了部落格記錄學習歷程，面試還是被嘴沒有實際作為實踐理想，在學校也不會因為多寫了什麼被打高分。所以與其寫得字字珠璣，還不如白話地寫出自己的見解，幫助自己才是寫作的初衷。</p></li><li><p><strong>其實在乎的事情可能是垃圾</strong>：寫文章不免來回增刪好幾次，要怎麼知道目前寫的那段是不是垃圾？只有寫完初稿才知道。所以不痛快下筆完成文章，有可能就是在垃圾堆裡面反覆撿拾垃圾，還以為自己很用心。</p></li><li><p><strong>其實沒寫完就是零</strong>：我的電腦裡還躺有好多文稿和寫作計畫，大腦裡也一直浮現新的點子和想法，但是沒寫出來誰也不知道有這些東西。你看，李嚴又帥又強，炸蝦讓人在電視前看了都想吃，結果少了收尾的醬汁還是被小當家打臉。</p></li></ul><p>當然寫這些不代表說寫文章是一文不值，文章累積起來還是很可觀的，只是要調整心態，畢竟寫完才有修改的空間。  </p><h3 id="在輕鬆的媒介寫作"><a href="#在輕鬆的媒介寫作" class="headerlink" title="在輕鬆的媒介寫作"></a>在輕鬆的媒介寫作</h3><p>除了心理暗示，也可以<strong>改變寫作的媒介降低完美主義的顧慮</strong>。大家應該有類似的經驗吧，新學期發了新課本，擔心頁面被弄髒不敢翻頁不敢做筆記，但讀二手書的時候怎麼劃記都不心疼。  </p><p>寫作也是一樣，當坐在高級辦公室、高級椅子、蘋果電腦、高品質文書編輯軟體前鄭重地打開文件卻寫不出字來時，不妨用隨便的態度看待寫作這件事，用廢紙、新文字文件等看起來很廉價的媒介去寫，寫爛了也不在乎，反而能擺脫完美主義的魔咒。這篇文在用電腦編輯前，即是在印壞的影印紙上擬出來的。  </p><p>或是找朋友聊天，即使朋友無法給出回饋，只要他能作為自己的聽眾便有助於克服完美主義的障礙。使用臉書、LINE 或 Instagram 等能記錄文字的通訊軟體聊一聊寫作主題，也順便留下草稿紀錄。我的經驗是，在對方不懂主題的情況下，自己為了裝出一副厲害的樣子便會大放厥詞，反而無意間寫出許多有價值的東西。  </p><p>如果沒有朋友，自己在紙上或社群網站開一則小文章自我對話也是不錯的選擇。想想平時在 PTT 或臉書發廢文的時候文思泉湧，但開 word 寫文章卻處處制肘，恐怕是社群平台本來就鼓勵大家發表沒路用的想法，在上頭可以在這種氛圍下擠出字來。  </p><h3 id="以截止日督促自己行動"><a href="#以截止日督促自己行動" class="headerlink" title="以截止日督促自己行動"></a>以截止日督促自己行動</h3><p>除了降低期待，設下截止日也是化解完美主義的必要方法。人都很浪漫的，如果沒有截稿日提醒現實的殘酷，也許還會以諾貝爾文學獎為目標慢吞吞地寫文章。藉由設下截稿日，讓自己意識到生存的危機，便不會浪費青春去雕琢一部大作了，從而腳踏實地展開行動。  </p><h2 id="工作負擔的心態問題"><a href="#工作負擔的心態問題" class="headerlink" title="工作負擔的心態問題"></a>工作負擔的心態問題</h2><h3 id="因為看不到完成的一天而拖延"><a href="#因為看不到完成的一天而拖延" class="headerlink" title="因為看不到完成的一天而拖延"></a>因為看不到完成的一天而拖延</h3><p>「完蛋，我一定完成不了」這是每個決心萬丈高樓平地起，千里始於足下的熱血男兒起步後的第一個念頭，於是整個人癱在電腦前不斷發呆，看似在網站上尋找解決問題的辦法，其實只是在逃避現實，最終在截止日當天被擊倒。  </p><p><strong>解決心理負擔的策略即是減少單次的工作量</strong>，例如權衡標題的廣泛性，縮減議題到可處理的範圍，列大綱和細綱將文章分為獨立的單元，利用每天的空閒時間自由書寫，再用完整的時間整合不同的片段形成段落，最後完成文章。  </p><h3 id="多少做一點努力"><a href="#多少做一點努力" class="headerlink" title="多少做一點努力"></a>多少做一點努力</h3><p>即使有很重的心理負擔，也不要全然放棄努力。運動、唱歌、爬山、耍廢都無助於完成文章，東摸西摸也不會加速完成的時間，只有專注於文章才有機會成功。因此在信心被擊倒的時候，得加減做些事情，例如調整大綱、加入新的圖片、改善排版、插入引用等等，在等候勇氣恢復的時候為之後寫作的過程減輕負擔。  </p><p>真的寫不出來，也可以先寫點其他的文章。此舉可以保持書寫的慣性和動力，讓大腦處在書寫模式，增加完成的文章的信心也順便磨筆頭。  </p><h3 id="安排可行的寫作計畫"><a href="#安排可行的寫作計畫" class="headerlink" title="安排可行的寫作計畫"></a>安排可行的寫作計畫</h3><p>安排寫作計畫的快感跟寫完一篇文章一樣，所以不要安於計畫。但有時仍需要可執行且可維持計畫，我自己的經驗是把文章撰寫分為蒐集資料、紀錄筆記、自由書寫、彙整想法、寫草稿、列大綱、撰寫文章、修改與校正等八個步驟，由於大家都不是專職作家，總會有俗務纏身，所以想要立下「今天要完成這篇文章」這種目標往往會失敗。  </p><p>因此，<strong>相較於以目標安排進度，用努力的程度來安排進度會比較適當</strong>，例如今天安排花三小時蒐集資料，如果蒐集不完就算了，用僅存的資料先走一步。如果全部流程走完，一篇文章的內容撐不起標題，那改標題即可，不需節外生枝。畢竟已經用努力來安排進度，每段時間都投注了最大的精力，如果只完成這些內容，那也沒有愧對任何人了，驕傲地把標題改小吧。  </p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>寫文章卡住的時候應釐清是源於知識問題還是源於心態問題。如果是知識問題，需要藉由閱讀和學習充實寫作的素材。如果是心態問題，則要逼自己擠出任何文字，直到腦中沒有任何想法，得重新學習為止。  </p><p>寫作既是思考的方式也是表達的方式，儘管寫作（表達）碰上障礙，也不要停止寫作（思考），藉由自由書寫呈現想法，保留思考的途徑和內容，將有助於規劃文章內容。  </p><p>完美主義和拖延的心態是完成文章的敵人，因此寫作時要降低期待，列大綱劃分文章為數個單元各個擊破。即使碰到障礙也不要輕言放棄，看書寫筆記、調整排版、繪製配圖和修正錯字等工作都有助於減輕之後的負擔。畢竟<strong>沒有克服絕望的方法，耍廢和講幹話只會讓時間流逝，面對寫作瓶頸只有硬著頭皮闖過去才有機會。</strong>  </p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><p>Esor Huang (2016)：<a href="https://www.playpcesor.com/2016/04/lifehack-8.html">[LifeHack 8] 先寫再想，激發靈感潛能的心流筆記法</a>。電腦玩物  </p></li><li><p>Esor Huang (2016)： <a href="https://www.playpcesor.com/2016/09/help-you-write-something.html">如何開始一場寫作風暴？編輯給任何人寫不出東西時的建議</a>。電腦玩物  </p></li><li><p>Esor Huang (2018)：<a href="https://www.playpcesor.com/2018/04/write-plan.html">不要這樣列寫作計畫，幫你不拖延完成論文、書籍與部落格創作</a>。電腦玩物  </p></li><li><p>Esor Huang (2019)：<a href="https://www.playpcesor.com/2019/03/write-speed.html">寫作加速法教學，解決寫報告論述文章的截稿壓力與速度瓶頸</a>。電腦玩物  </p></li><li><p>Mark Levy (2011)：《自由書寫術》。商周出版  </p></li><li><p>Steve Wallace (2018)：<a href="https://www.editing.tw/blog/progress/%E6%B2%92%E6%9C%89%E3%80%8C%E5%AF%AB%E4%BD%9C%E7%93%B6%E9%A0%B8%E3%80%8D%E9%80%99%E6%AA%94%E4%BA%8B.html">沒有「寫作瓶頸」這檔事</a>。華樂絲學術寫作部落格  </p></li><li><p>李連江 (2018)：《如何進行學術寫作．在學術界謀生存》。香港中文大學出版社  </p></li><li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E6%9C%9F%E6%9C%AB%E5%A0%B1%E5%91%8A%E8%87%AA%E6%95%91%E6%B3%95-%E5%AF%ABpaper-%E5%AF%AB%E8%AB%96%E6%96%87-%E5%AF%AB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E6%80%8E%E9%BA%BC%E8%BE%A6-add4ebb2c827">便秘：寫paper，寫碩論，卡住怎麼辦？</a>。♤研究生青紅燈♤  </p></li><li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E5%8E%BB%E9%9A%94%E5%A3%81%E5%81%B7%E8%8F%9C-%E8%AE%80%E6%9B%B8%E5%8D%A1%E4%BD%8F-%E5%AF%AB%E5%AD%97%E5%8D%A1%E4%BD%8F-%E6%80%8E%E9%BA%BC%E8%BE%A6-1f6cf064c324">去隔壁放鬆：讀書卡住、寫字卡住，怎麼辦？</a>。♤研究生青紅燈♤  </p></li><li><p>英論閣學術論文編修 (2018)：<a href="https://www.enago.tw/academy/%e7%aa%81%e7%a0%b4%e5%af%ab%e4%bd%9c%e7%93%b6%e9%a0%b8%e6%9c%89%e5%85%b7%e9%ab%94%e6%96%b9%e6%b3%95%e7%9a%84%ef%bc%81/">突破寫作瓶頸有具體方法的！</a>  </p></li><li><p>畢恆達 (2005)：《論文寫作症候群：寫作心理 ．教授為什麼沒告訴我》。學富文化  </p></li><li><p>彌糧糧 (2012)：<a href="https://paste.plurk.com/show/WypPD1CYUH0MqpNAQ7b8">大家都有寫報告寫心得寫論文寫文章卡稿的經驗吧？</a>。Plurk paste 彌糧糧</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從期望的結果反推現在要採取的行動</title>
      <link href="/reverse-engineering-actions-from-desired-outcomes/"/>
      <url>/reverse-engineering-actions-from-desired-outcomes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>準時到就是遲到</p></blockquote><p>國慶連假期間，台北市立圖書館總館舉辦了兩場留學講座。我大概在開始前十分鐘進場，結果進門便看見講師一面在白板上振筆疾書，一面說明需要準備哪些申請文件。</p><p>「不是下午兩點開始嗎？」我心想，還打開手機確認自己有沒有搞錯時間，不過我的疑惑很快就得到答案了。</p><p>「你們這些早到的人很聰明，可以趁人少的時候跟講師或其他同學交流，也能提早準備課程所需的東西。」講師說。</p><p>「雖然學校會跟你們講申請的收件截止日是幾月幾號，但不要傻傻地等到那時候才寄出資料，因為你無法保證快遞公司或是郵局能順利把申請資料送到指定學校，也無法保證自己不會遺漏應附的文件，所以一定要預留數周的前置時間。</p><p>「其次，有些學校採取隨到隨審制度 (Rolling admission)，收滿為止。等到截止日才寄出資料恐怕已經額滿，那時候有多好的條件也沒機會了。」講師說。</p><p>這是當天的第一個教訓，我再也不會相信甘道夫了。</p><p>（講師：洪健庭，社團法人中華民國愛公益協會公關主任）</p><span id="more"></span><h1 id="留學申請-PDCA-架構"><a href="#留學申請-PDCA-架構" class="headerlink" title="留學申請 PDCA 架構"></a>留學申請 PDCA 架構</h1><p>雖然代辦可以在申請初期提供許多幫助，節省蒐集和閱讀資料的時間，但是許多代辦其實不熟悉你要申請的領域，甚至沒有出國或留學的經驗，這樣你還願意把未來交付給他們嗎？</p><p>因此，自己的人生要自己作主，把校系申請當作專案管理，全力和來自印度、中國、日本等國家的學生競爭。</p><h2 id="Planing"><a href="#Planing" class="headerlink" title="Planing"></a>Planing</h2><p>申請學校的前要了解申請流程和文件。首先，你需要一張表格記錄目標校系的申請門檻、學雜費用、計畫內容等資訊，清單內要有夢幻、穩健和保底等不同層級的校系，不要孤注一擲或裹足不前。</p><p>接著要準備五份文檔：自傳、推薦信（要求的數量 + 預備的數量）、履歷、自我介紹信和研究報告 (essay or writing sample)，這些文件是你能力和努力的證明，所以在還沒申請前就要思考怎麼充實，申請期間也需要經過多次修改才能完善。</p><p>最後還有英文成績單和個人基本資料，這些都是無法改變的東西，記得提早準備好，不要拖到截止日前還要匆匆忙忙的。一旦學校的申請系統開放，就陸續上傳資料，即使沒有錄取，這些資料保留在系統中可以免去往後補充資料的麻煩。</p><h2 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h2><p>要排好時間規劃，英文不可能一次考過，老師們也會耽擱你的推薦信，申請也未必能準時送達，所以你必須做風險管控，確保事情不會搞得一團糟。</p><h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><p>不要當完美主義者，要當漸進主義者，從錯誤中學習和成長。每年都期待明年會更好，可是等待和準備期間，時間也溜掉了。即使自己不在乎，也不能無視父母年紀漸長，可能有長期照護等問題，早點出國才不會有後顧之憂。</p><p>所以不要打嘴砲，不要給自己藉口，能做的事現在就去做，爛得不堪入目也沒關係，因為遲早會在失敗中得到經驗。丟臉的不是犯錯，是從來不願意付諸實踐。</p><h2 id="Act"><a href="#Act" class="headerlink" title="Act"></a>Act</h2><p>深思熟慮才叫行動，其他都是亂來。</p><h1 id="社會資本和人脈"><a href="#社會資本和人脈" class="headerlink" title="社會資本和人脈"></a>社會資本和人脈</h1><p>台灣人留學的地區以英美為大宗，所以要善用人數優勢打團體戰，不要單打獨鬥。出國前就建立好人脈，和戰友分享資訊，和強者保持聯絡。出國後更要參與學長姐舉辦的迎新說明會等活動，融入留學生的圈子裡。即使往後不出國，交些會出國的朋友也能交流經驗拓展視野。</p><p>除了留學生彼此互助，我們的政府也能幫到不少忙，但不是等到出事情才急急忙忙找別人，平常就要跟可能幫助自己的人打交道。盡可能出席節日、國慶、路跑、過年、聖誕等吃得到家鄉滷肉飯的活動，有餘力便自願承擔接待外賓或協助翻譯等服務以與當地的官員打好關係。</p><p>人們往往彼此分享資訊或介紹工作，所以隨著人脈拓展，機會也逐漸增加，所謂的貴人，就是幫助你不一定獲益，卻仍願意伸出援手的人。但要提升遇到貴人的機率，得先學習如何有效幫人，所以有些資訊未必用得到，但記得保留起來幫助別人。前述累積社會資本和人脈的行為即是為了在需要的時候能夠在自助之餘得到人助。</p><h1 id="選校評估"><a href="#選校評估" class="headerlink" title="選校評估"></a>選校評估</h1><h2 id="了解自己"><a href="#了解自己" class="headerlink" title="了解自己"></a>了解自己</h2><p>出國留學前一定要了解自己。重點不是你是哪個科系畢業或有多少豐功偉業，而是要搞清楚出國的動機，有動機才會有明確的目標，有明確的目標才有持續的動力，有動力的話，出國這件事才會從空想變得可行。</p><h2 id="碩博班選校策略差異"><a href="#碩博班選校策略差異" class="headerlink" title="碩博班選校策略差異"></a>碩博班選校策略差異</h2><p>因為碩士多半要自費，錢要用在刀口上，所以如果打算快攻碩士學位，出國時要選擇排名大於前一學歷的名校，務必在畢業後得到一個響亮的稱號。但就讀博士班很辛苦，所以要選提供全額獎學金的學校，往後的生活和學業才有保障。</p><h2 id="選校方式"><a href="#選校方式" class="headerlink" title="選校方式"></a>選校方式</h2><p>建立一個表格，詳列目標校系的申請門檻、英檢成績還有費用等資訊，才不會搞得一蹋糊塗。此外，如果不同學校位在同個地理區，跨校聽演講、學技術、參加研討會都很方便，所以不要只看要申請的學校，關心一下周遭有什麼其他學校，調查潛在的可利用資源。</p><h2 id="也要關注國內的教師"><a href="#也要關注國內的教師" class="headerlink" title="也要關注國內的教師"></a>也要關注國內的教師</h2><p>想要留學的話不要只把目光放在國外的學校，也要普查國內在該領域耕耘的老師，了解一下他們讀了什麼學校和什麼科系。因為這些老師們成功從那些學校畢業，而且成功在競爭中找到教職存活到現在，可以作為選校的參考依據。</p><h1 id="自我介紹信"><a href="#自我介紹信" class="headerlink" title="自我介紹信"></a>自我介紹信</h1><h2 id="自我介紹信的用途"><a href="#自我介紹信的用途" class="headerlink" title="自我介紹信的用途"></a>自我介紹信的用途</h2><p>在申請季之前就該寄自我介紹信向教授們問招生資訊或研究議題，讓對方感受到你的熱誠。而且自我介紹信是所有文件當中最容易準備的，所以一定不要放過這個機會。</p><h2 id="自我介紹信的寫法"><a href="#自我介紹信的寫法" class="headerlink" title="自我介紹信的寫法"></a>自我介紹信的寫法</h2><p>自我介紹信的主旨要明確，務必開門見山讓對方了解寫信的用意。此外，因為詐騙信件很多，為了不被教授或招生負責人誤會，標題要令人產生點開信件的念頭。（也許能參考農場標題或拋出問題請教對方，說不定能勾起教授們解題的好奇心）</p><p>初次聯絡時只談研究議題或申請相關的事務，不要談錢。如果對方沒有回覆，可以擇期寄信提醒，但要體諒對方可能需要時間處理你的事情，如果在公務繁忙時一再寄信催趕可能會收到反效果。</p><p>為了避免這種狀況一定要掌握外國人的作息，例如英國人早上十點到中午十二點，下午兩點到四點是工作時間，上至院長下至打掃阿姨，只要掌握對方的作息就能接觸到對方。</p><h2 id="自我介紹信的格式"><a href="#自我介紹信的格式" class="headerlink" title="自我介紹信的格式"></a>自我介紹信的格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">To: address</span><br><span class="line">Subject: Applicant (no. register ID) a question about application yyyy</span><br><span class="line"></span><br><span class="line">Dear Professor OOO</span><br><span class="line"></span><br><span class="line">This is Mr. XXX (name) from Taipei city, Taiwan.</span><br><span class="line"></span><br><span class="line">I would like to apply for *** (programs or courses)</span><br><span class="line"></span><br><span class="line">May I have more information about the application process?</span><br><span class="line"></span><br><span class="line">Sincerely,</span><br><span class="line"></span><br><span class="line">XXX</span><br><span class="line">Department</span><br><span class="line">Contact information</span><br></pre></td></tr></table></figure><h2 id="自我推薦不要侷限於電子郵件"><a href="#自我推薦不要侷限於電子郵件" class="headerlink" title="自我推薦不要侷限於電子郵件"></a>自我推薦不要侷限於電子郵件</h2><p>隨著時代進步，自我推薦的管道也不再限於電子郵件，只要有和申請對象接觸的機會，任何途徑都不要放過。</p><p>除了官方網站，臉書、推特、Instagram、Youtube等社群網站也是許多學校投放獎學金或申請資訊的地方。若已有預計申請的校系名單，務必追蹤他們廣宣的平台，既能接收攸關申請的最新消息，也能熟悉該校的環境與文化，在入學前就取得往後與對方交流的素材。由於這些媒體的管理員可能同時是該校的員工或學生，積極在網站上按讚留言，可以增進自己和該校的連結（這些網站平常沒什麼人看，外國粉絲這樣熱情，他們的小編應該會很感激你）。</p><h1 id="支持文件-supporting-documents"><a href="#支持文件-supporting-documents" class="headerlink" title="支持文件 (supporting documents)"></a>支持文件 (supporting documents)</h1><h2 id="自傳-state-of-purpose"><a href="#自傳-state-of-purpose" class="headerlink" title="自傳 (state of purpose)"></a>自傳 (state of purpose)</h2><p>申請時填寫的線上系統是強調的是過去，但 SOP 強調的是未來，所以要展現你的潛力。你必須在 SOP 中回答兩個問題：你能為學校帶來什麼好處？學校有什麼資源能協助發揮你的潛力？</p><h2 id="推薦信"><a href="#推薦信" class="headerlink" title="推薦信"></a>推薦信</h2><p>要先寫好推薦信草稿以免推薦人臨時趕不出來，即使對方好整以暇地，草稿也能作為對方撰寫的參考方向。總之要要替推薦人著想，提供完整的參考資料和上傳指南，文檔用 word 等格式方便修正。</p><h2 id="履歷-curriculum-vitae"><a href="#履歷-curriculum-vitae" class="headerlink" title="履歷 (curriculum vitae)"></a>履歷 (curriculum vitae)</h2><p>履歷平常要準備，裡頭不外乎教育、發表、得獎、研究經歷、線上經驗（交換、交流、研討會）、線下經驗（證照、競賽、個人網站）等能證明自己的事蹟。如果成績好的話就把成績放進去，成績不好別拿石頭砸自己腳。語言能力不錯也記得補充，畢竟在還無法實地確認你的能力前，英檢成績就是你唯一的證明（或標籤）。</p><h2 id="研究報告-essay-or-writing-sample"><a href="#研究報告-essay-or-writing-sample" class="headerlink" title="研究報告 (essay or writing sample)"></a>研究報告 (essay or writing sample)</h2><p>研究報告展現個人的表達能力、理解能力、領域專精程度還有研究的熱誠。考量讀者的專注力，把代表作論文寫成千字摘要即可。若沒有論文發表，回顧文獻、書評、研究計畫甚至是大學期間曾撰寫過的任何文章都可以整理成研究報告。即使是中文撰寫的也可以翻譯為英文，這樣至少不會沒東西給人家看。</p><h1 id="獎學金"><a href="#獎學金" class="headerlink" title="獎學金"></a>獎學金</h1><h2 id="申請獎學金的心態"><a href="#申請獎學金的心態" class="headerlink" title="申請獎學金的心態"></a>申請獎學金的心態</h2><p>公費留考或校方提供的獎學金看似鉅額，但扣除飲食交通、房屋租賃以及購書學習等開銷也所剩無幾，一份獎學金其實根本不夠花。所以，拿錢的時候千萬不要手軟。如果有需求就要盡量拚獎學金，有本事拿多少就不要退讓。因為這些獎學金有許多人競爭，你不申請便被中國或印度等國家的對手拿走（或任何你不願意看到他們拿到獎學金的人拿走）</p><p>由於錄取後獲得獎學金的機率會提升，所以錄取後要即刻調查獎學金的申請管道。不只系級、院級、宿舍級乃至校級提供的獎學金，國際學生辦公室 (offfice of international affairs) 提供的資訊也要特別關注。</p><p>獲得獎學金後，得到的不只是經濟援助，也是榮耀。要學會用獲獎紀錄當成談判與溝通的利器，說服對方你需要其他獎學金，而且你也值得受到更多栽培，產生 1 + 1 &gt; 2 的效果（錢生錢的效果）。</p><p>最重要的，找資源的進取心和對自己的信心一定要有。以前多爛都無所謂，獎學金是拚未來的潛力，不是你的過去。</p><h2 id="申請獎學金的管道"><a href="#申請獎學金的管道" class="headerlink" title="申請獎學金的管道"></a>申請獎學金的管道</h2><p>外交部、經濟部、僑委會、科技部、教育部、銀行的獎學金多到看不完，要學會蒐集資訊和取得資源。已經在國外留學的學長姐不能給你錢，但可以向他們探聽獎學金的申請管道，重要的消息往往在小圈子裡傳遞。</p><h2 id="公費留考的面試經驗"><a href="#公費留考的面試經驗" class="headerlink" title="公費留考的面試經驗"></a>公費留考的面試經驗</h2><p>教育部提供了留學獎金（已出國者，書審）、公費留考（未出國者，甄試和筆試）、百大獎學金（僅博士班），其中公費留考在筆試通過後，將由申請領域內國內各校院長等級以上的大咖來面試，所以平常便該關注國內同領域大咖的動態。</p><p>即使心裡很緊張，入場時一定要有氣勢，把玻璃心丟一邊去，拿出你的勇氣來。因為審查委員要確保納稅人的錢投資在有潛力的人身上，在那個場合他們一定電你，把你講得一無是處，這些挑戰都是正常的，笑笑聽過就好。</p><p>通常會要求英文對話以確認你能在國外生存，所以沒事多練中英文自我介紹，確保到場不會緊張出糗。此外，公費留考的面試時間通常很短，務必把握有限的機會見人說人話，見鬼說鬼話，投審查委員所好。</p><h1 id="一入學就思考畢業後的價值"><a href="#一入學就思考畢業後的價值" class="headerlink" title="一入學就思考畢業後的價值"></a>一入學就思考畢業後的價值</h1><p>現在就想想十年後想成為什麼人，一入學就要為求職做準備（因為找工作本身也需要練習）。無論之後要走產業還是學術，都要學著從嚮往的結果反推現在要採取的行動，那些等到畢業那天才開始思考未來的人往往等著回國吃自己。</p><p>因此，不管當初選擇留學有什麼打算，都要預想回國發展的途徑、留在當地的方法以及在其他國家遊走的機會。放開自己的眼界，不要把成長的經驗套用在陌生環境中。</p><p>如果想要留在當地工作，務必要利用志工、實習、研究助理等經驗建立個人與當地的連結。因為你的履歷都是在台灣收集的，對方可能對這些經歷沒有共鳴，所以不要奢望一開始便能全職待在國外，從志工開始也是一個起點，漸漸從事兼職繼而獲得全職工作的機會。（從事學術者也類似，最重要的是一定要找到願意收你的老師）</p><p>總而言之，走學術要拚發表，走實業要拚經驗，不要把工作和出國當兩回事，兩者是相輔相成的。</p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>這份筆記其實不只包含上周日的講座，也整理了洪老師之前在中興大學分享的內容。我覺得這系列講座想要傳達的衍生意義有三點：</p><h2 id="動起來"><a href="#動起來" class="headerlink" title="動起來"></a>動起來</h2><p>人生是自己的，所以不要僥倖。無論之前怎麼過生活，一旦起了出發的念頭，大腦就要全速運轉，思考接下來要採取的行動，然後全力以赴去做。人生可以接受失敗，只要棺材板還沒蓋上，都有機會從失敗中學習經驗而後東山再起，最遺憾是裹足不前，連自己可以走到哪都不知道。</p><p>畢竟一場演講也沒辦法細講留學文件的撰寫方式，但如果你的渴望很強烈，也會自己想辦法在網路上找到這些資訊。</p><h2 id="敢於勝利"><a href="#敢於勝利" class="headerlink" title="敢於勝利"></a>敢於勝利</h2><p>除了熱烈的動機、縝密的計畫和積極的作為，心態上也敢於勝利，捨棄玻璃心、怕丟臉和完美主義等壞習慣。儘管志在出國者對知識分子的形象多少有些期許，或許沒意識到包裝自己或拓展人脈等聽起來很俗的事其實很重要，所以不願意分神去做。</p><p>然而內心有原則很好，但做事的時候要權宜。如果對自己的本事有信心，就不要怕別人的評價，能夠提升勝率的事情就去做，取得一次勝利就要想辦法全盤皆勝，不要把機會讓給你認為不夠格的人。</p><h2 id="回饋社會"><a href="#回饋社會" class="headerlink" title="回饋社會"></a>回饋社會</h2><p>強調務實不是要成為一個自私的人，是要把心思放在值得的人身上。仔細想想平時把體貼、忍讓和謙退用在哪些人身上？在爭取機會的場合軟弱，怎麼對得起一路幫助自己的人，還有那些沒有機會追尋理想的人？</p><p>因此，儘管成就自己的過程要狠，但內心要想著怎麼幫助他人，畢竟人類本來就有一堆缺點，世界又這樣不公平，所以需要互助提醒。</p>]]></content>
      
      
      
        <tags>
            
            <tag> career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天體生物學和尋找外星生命</title>
      <link href="/astrobiology-and-the-search-for-extraterrestrial-life/"/>
      <url>/astrobiology-and-the-search-for-extraterrestrial-life/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>低調的人類從學會抬頭那一刻，就不斷在地球、月球、火星乃至其它銀河尋找自己不特別的證據。</p><span id="more"></span><h1 id="Astrobiology-是什麼？"><a href="#Astrobiology-是什麼？" class="headerlink" title="Astrobiology 是什麼？"></a>Astrobiology 是什麼？</h1><h2 id="Astrobiology-簡介"><a href="#Astrobiology-簡介" class="headerlink" title="Astrobiology 簡介"></a>Astrobiology 簡介</h2><p>除了地球生靈以外，宇宙中還有其他生命嗎？無論這個問題的答案是肯定還是否定，都能引發我們省思。假如能找到任何外星生命跡象，那麼我們肯定對其外型感興趣，也會想了解地球生命與外星生命的關係。但如果地球是唯一能孕育生命的星球，所有尋找外星生命的努力都注定是徒勞，這個問題也還沒完。因為我們勢必會感到疑惑，究竟地球有哪些獨一無二的特徵，容許生命在此發源繁盛？</p><p>雖然外星生命是想像作品的熱門題材，但在二十世紀中葉以後逐漸興起的天體生物學（Astrobiology，以下譯為天文生物學，理由見第三節）正是以事實與理論為基礎，試圖在太陽系乃至其他銀河搜尋地外生命的科學。</p><p>儘管目前未搜索到任何地外生命，鑒於宇宙龐大的規模以及地球生命形成的速度，存在地外生命仍然是合理的想像。何況，天文生物學除了尋找地外生命外，也肩負了解生命定義和地球生命起源的任務。</p><h2 id="天文生物學的研究方向"><a href="#天文生物學的研究方向" class="headerlink" title="天文生物學的研究方向"></a>天文生物學的研究方向</h2><p>包含尋找地外生命在內，天文生物學有以下三個研究方向。</p><p>釐清生命的定義與特質：雖然生命在地球隨處可見，卻難以為生命立下明確的定義，並區隔其與物質的差異。原則上，生命仍受制於物理和化學法則，但以人類目前的科技水準尚無法在實驗室中合成任何現今定義為生命的個體。生命與非生命之間的差異是什麼？人造生命的嘗試還欠缺何種要素？為了回答這些問題，天文生物學的首要目標即是研究生命的特質以了解生命究竟是什麼。<br>了解地球生命形成的條件與機制：除了比較生命與物質的差異，研究無機物轉變為生命的過程亦有助於了解生命的特性。當物質隨時間逐漸變得複雜，哪一刻起可稱之為生命？在形成生命的許多反應途徑中，何者是關鍵的一步？哪種環境條件是生命形成所必須？哪種環境條件造就了地球生命的特色？天文生物學的目的不只是理解地球生命形成的條件與機制，也試圖以地球生命起源為基礎，探討其它宇宙生命的特徵。<br>搜索地外的適居環境與生命跡象：理解生命的另一條途徑就是尋找地外生命。地球生命是目前已知唯一的生命形式，所以至今人類只能從僅有的樣本推論所有生命的普遍特徵。如果能夠找到任何地外生命，便能夠比較兩地生物的異同，得知生物的那些特徵是生命的通性，哪些又因形成環境而異，進而促進生命本質的理解。因此天文生物學的第三個研究方向，即是增加生命的樣本數。</p><p>總言之，天文生物學的研究方向是了解生命的本質，所以天文生物學一方面從地球生命的起源推論所有潛在生命的共同特徵，另一方面則試圖搜索地外生命以增加推論的依據。達成這些目標仰賴生物學、地球科學與天文學等學科知識，因此雖然天文生物學的主軸是生物，實際的研究課題卻跨越了不同領域。</p><h2 id="天文生物學的譯名"><a href="#天文生物學的譯名" class="headerlink" title="天文生物學的譯名"></a>天文生物學的譯名</h2><p>了解天文生物學的研究內容後，再來談談天文生物學的名稱。實際上這名稱曾讓許多初次接觸的人感到困惑，以為天文生物學只與望遠鏡有關和顯微鏡無關。</p><p>天文生物學在發展初期曾有許多不同的名字，例如萊德柏格 (Joshua Lederberg, 1925 - 2008) 即提倡以 Exobiology（地外生物學）表示研究生命在宇宙中發源、演化和分布的學科。然而國際生命起源研究社群卻對其中搜索地外生命的部分有異議，最終發明Bioastronomy（生物天文學）來描述以望遠鏡搜索地外生命的學問。</p><p>不過這兩個名稱的爭議在於，在找到地外生命之前「地外」或是「生物天文」等詞彙是否合宜？</p><p>於是到 1997 年，NASA 開始推廣以 Astrobiology 取代 Exobiology 等其它術語。在那之後還有許多關於名稱的爭議，可以閱讀 Lemarchand (2000) 的 A New Era in the Search for Life in the Universe  獲得其它細節。不過如今我們知道，Astrobiology 成為這個學科的主流名稱。</p><p>Astrobiology 結合了希臘字 astron（星星或天體）和德國字 Biologie（生物學），字面上解釋作「星星的生物學」，常見譯名有天體生物學、天文生物學或太空生物學等。雖然前述譯名中，天體生物學較其他兩者普及，但 Astrobiology 的研究範圍其實不限於特定天體，還涵蓋了生命在其他宇宙空間的分布與演變，所以我認為「宇宙生物學」較能反映其特質，但宇宙生物學應另指 Cosmobiology 一詞，因此為了顧及字根與學術含意，譯為天文生物學也還算恰當。</p><h1 id="從天文生物學到廣義生物學"><a href="#從天文生物學到廣義生物學" class="headerlink" title="從天文生物學到廣義生物學"></a>從天文生物學到廣義生物學</h1><p>我已經說明了天文生物學的具體目標，接著我將解釋天文生物學的含意。</p><h2 id="生命之樹與生物學"><a href="#生命之樹與生物學" class="headerlink" title="生命之樹與生物學"></a>生命之樹與生物學</h2><p>如果以系統發生樹描繪歷史上曾經出現過的生物，會發現地球生命化作一棵大樹，真細菌、古菌和真核生物等枝枒最後匯集在名為最後共祖 (Last universal common ancestor, LUCA) 的根部。透過研究這棵樹上各式各樣的生物，造就了當今的生物化學、分子生物學還有演化學等學科。</p><p>也因為現今的生物傳承一段共同的演化歷史，所以研究細菌得出的分子機制往往能夠推廣到其他的生物。然而，如果生命在地球形成了數次，我們能否想像其中一支在不受干擾的情況下獨立演化，以至於這種生命形式與已知的生命毫無親緣關係？</p><p>這種生命被稱為影子生物圈 (Shadow biosphere) ，牠們或由不同的元素構成，或採不同的遺傳機制和生化過程，奠立於已知生命的現代生物學可能無法直接適用於影子生物圈。</p><h2 id="人造生命與合成生物學"><a href="#人造生命與合成生物學" class="headerlink" title="人造生命與合成生物學"></a>人造生命與合成生物學</h2><p>然而到目前為止，仍未找到任何影子生物圈存在的證據。原因可能是生命形成時遭逢浩劫導致僅有一支生命形式流傳下來，也可能是生命僅能以地球生命的形式萌生，或僅僅是我們選擇了錯誤的搜索方式。</p><p>究竟是何種原因仍未有定論，不過合成生物學的研究方向或許能為此帶來一絲線索。合成生物學涵蓋兩個目標：第一，重組既有生命的組件（例如基因、胞器或細胞等）實踐工程目標。第二，從複雜程度不等的物質試圖合成生命。</p><p>人造生命可以在兩方面促進生命的理解：第一，人造生命直接拓展我們對於生命可能形式的見解。第二，製造人造生命雖然不等同地球生命形成的真實過程，但卻可以作為測試生命起源理論的對象。</p><h2 id="地外生命與天文生物學"><a href="#地外生命與天文生物學" class="headerlink" title="地外生命與天文生物學"></a>地外生命與天文生物學</h2><p>天文生物學則採取跟合成生物學相反的管道，直接搜索可能從地外天體萌生的生命。如同合成生物學，發現任何地外生命都能拓展已知生命的樣本數，也能從地外生命的演化歷程推論地球生命起源的條件與機制。</p><p>我想天文生物學家們多少心知肚明，如果我們沒有在太陽系內找到任何其他生命，即使其他恆星系統存在生命，以人類的科技水準也沒有直接研究的指望。因此，儘管天文生物學似乎一再強調「地外」或是「天體」，研究範圍從行星、太陽系以至其他銀河，但天文生物學的基礎不是建立在還沒找到的生命，而是是地球生命本身。</p><h2 id="生命之林與廣義生物學"><a href="#生命之林與廣義生物學" class="headerlink" title="生命之林與廣義生物學"></a>生命之林與廣義生物學</h2><p>在一系列討論中，我已經提及三種未知的生命形式：於地球上誕生的影子生命、於實驗室誕生的人造生命，還有其他星球誕生的地外生命。這些假設的生命形成了涵蓋許多潛在生命形式的生命空間（類似向量空間的概念。向量空間是給定向量的所有可能組合，生命空間則是給定物質和能量，所有可能形成的生命形式）</p><p>目前的生物學專注於生命空間中的地球生命，對於其他潛在生命的解釋能力有限。合成生物學和天文生物學分別透過製造生命和尋找生命拓展我們已知的生命空間，如果這些嘗試取得成果便會多出許多研究標的。如此一來，生物學將不再限於探討地球生命，而會推廣到其他的生命形式，衍生出「星際生態學」或「碳基與矽基比較生物學」等聽起來很科幻的學科。</p><p>換句話說，生物學將從研究生命之樹的學科轉變成研究生命之林的廣義生物學。從這個角度看來，合成生物學建造新的生命之樹，天文生物學則連結已經存在的諸多生命之樹，兩者都是廣義生物學的一部份。</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>天文生物學的研究目標是了解生命本質，探討生命形成的機制和搜索地外生命。其與合成生物學的研究進展能促進我們對於其他生命空間的理解，將生物學推廣為廣義生物學。</p><p>若想了解更多天文生物學的知識，可參考<a href="https://www.coursera.org/learn/astrobiology">〈天體生物學和尋找外星生命〉線上課</a>。〈天體生物學和尋找外星生命〉是愛丁堡大學天文生物學教授既英國天文生物中心的創辦人 Charles Cockell 於 Coursera 平台開設的入門課程，內容涵蓋生命起源、地球生物史以及搜索地外生命等天文生物學核心議題。</p><p>雖然授課內容淺顯，隨堂考也很簡單，可是舉凡天文生物學的理論背景、科學問題的前提假設或是各項發現的衍伸含意都講得很清楚。</p>]]></content>
      
      
      
        <tags>
            
            <tag> astrobiology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hipster Karaoke</title>
      <link href="/5uperb0y-2019-hipster-karaoke/"/>
      <url>/5uperb0y-2019-hipster-karaoke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>考完微積分的那天下午，穿著時尚的女孩們把課本、試卷、焦慮與懊惱丟開，興高采烈地邀約班上的男生到站前那家新開的KTV一同「夜書」。</p><p>「欸，東霖， 要不要一起去？大學生不夜書一次就落伍囉！」」一行人中最活潑好動的婉嘉代表她害羞的夥伴們提出邀請。</p><p>「可是我明天要回家……」</p><p>見這男孩猶豫不決的模樣，一旁的孟芳也開口說：</p><p>「你把行李帶著呀，明天早上可以搭首班車離開A縣。」</p><p>「……」</p><p>「走啦走啦，你沒機車嗎？這好辦，我們等會兒ｃａｌｌ小胖啊！婉嘉，你有沒有小胖的電話號碼？」</p><p>「我找找看……有了！」婉嘉舉起手上的ｐｈｏｎｅ　ｗａｔｃｈ撥號，鈴聲響沒半次就接通，好似線路的另一端正在電話前守候。</p><p>「喂，小胖嗎？我是婉嘉。」</p><p>「是，我是，怎麼了嗎？」</p><p>「今晚你有沒有空？我們想去夜書，但少一台車，要不要一起去呢？」</p><p>「好啊，要什麼時候出發？」</p><p>「跟你約晚上七點半男宿門口喔！」</p><p>「知道了，那……」</p><p>「嘟——」</p><p>短暫的連結就此中斷，婉嘉的聲音仍在腦海迴盪，小胖一面走向衣櫃一面喃喃自語：「男宿……男宿？」</p><p>位於OOO路與XXX三街交叉口的浪跡地是A縣地區唯一的高階影視伴寫娛樂場所，大小包廂有70間，可容納百來人。附設的自助吧檯可以讓消夜與早餐一併解決，深受青少年朋友歡迎。進門後即可看到櫃台後方的牆上寫著種種優惠方案，不過這些都不需要消費者操心，穿西裝打領帶的接待人員會幫他們算好最優惠的價格。</p><p>小胖吃力地提著行李箱，緩步跨入大廳。一旁的接待人員沒有因為僅一人造訪而怠慢，仍熱切地上前招待。</p><p>「先生您好，請問有預約嗎？」</p><p>「啊……還有幾個朋友在路上，我先坐一下。」</p><p>「好的，只要通知一聲就替您帶位。」</p><p>不久，伴隨著歡笑與香氛，男男女女們終於到齊。</p><p>「東霖有來過嗎？我和孟芳高中時常常來這邊玩呢！而且……咦，小胖怎麼還坐著？一起走，一起走！」　</p><p>店內最熱門的包廂是追憶似水年華和里斯本夜車，臨時起意的少男少女沒緣體驗，他們沿著豐饒之海走入古都，爬上金閣寺，最後停在挪威的森林。</p><p>包廂內有各式燈光可以選擇，除了的白熾光和傳統燈泡，還有蘋果綠、英國藍、曼谷橙……等俏皮色彩。</p><p>木製的桌椅散發出樸實的氣味。</p><p>「我先來去端吃的喔~」真可愛，一個戴牙套短頭髮的女生說。</p><p>小胖拿著大桌上沾著清檸香的信紙摺摺紙飛機。</p><p>「聶魯達、波特萊爾、濟慈……」東霖翻著手中的詩集拿不定主意，婉嘉一把搶去，點了首《多佛海攤》。</p><p>「……到窗邊來吧，海風多麼甜！」</p><p>前方70吋的monitor播映著一名憂愁的男子走在海邊的影像，伴著富有磁性的男聲輕輕詠著，底下字幕欄照著筆順浮出字來。</p><p>「……以緩慢顫抖的節拍 送來永恆悲哀的聲響……」</p><p>架上陳列無數種鋼筆，原子筆、中性筆，日系、歐系、美式一應俱全。</p><p>少男少女伏案聽寫，陶醉在朗誦中。</p><p>「你的字好漂亮，尤其是『永恆』真寫到心坎裡！」</p><p>當然純然書寫有什麼樂趣？他們也會把信紙用口紅膠黏成一大張，兩個人合寫。</p><p>或是乾脆把信紙撕得一小片一小片，預先寫好字母並按照順序排好；當詩人開始吟詩時，手忙腳亂地從中拿取正確的紙片黏在另一張紙上。</p><p>「在他心中引起人類苦……歌聲從音樂的身上脫落，終歸剩下了音樂的身軀……」</p><p>「誰啦？幹嘛切詩？」</p><p>「你不喜歡馮至的十四行嗎？」</p><p>……</p><p>就這樣吵吵鬧鬧、寫寫念念，大家受不了疲倦在椅子上打盹，鋼筆、紙張、食物散落各地。</p><p>服務生敲門進來收錢，還清醒的小胖幫大家代墊，他坐在這而能清楚聽到隔壁傳來的情侶吵架聲。</p><p>小胖拿起麥克筆，在紙上草草寫下幾個字準備迎接新的一天。</p><hr><p>5uperb0y（2019）。Hipster Karaoke。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《太空生物學》</title>
      <link href="/lee-2017-astrobiology/"/>
      <url>/lee-2017-astrobiology/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>李炎的太空生物學是台灣少見的天文生物學專著，不過內容卻虛實參半。前半段摘錄新聞網或部落格報導的奇聞軼事，補充維基百科的條目說明，加上一些感想湊成討論生命起源和地外生命的篇章。然而，參考資料似乎不限於期刊論文，好比「墨西哥人發現外星人寶寶」之類的農場新聞也直接收錄，並沒有加以解釋或編輯。</p><span id="more"></span><p>中段改編自美國國家太空生物研究中心發表的《人類在太空的生理學》(Human Physiology in Space)，這是太空生物學(Space biology)的一環，雖然和字面上的涵義和天文生物學(Astrobiology)相似，但是前者研究太空環境對既有生物的影響，後者探討生命是怎麼來的。</p><p>太空生物學有許多實用價值，例如若能了解動物的生理變化將有助於設計太空人的健康維護措施，而掌握植物的太空生理學知識也能應用在太空農業上。至於微生物生長繁殖的狀況，則與天文生物學息息相關。由於各行星可能因隕石衝擊而把表土拋向太空，假如土中的微生物能捱過最初的撞擊，並在微重力、高輻射的極端環境存活，便有機會把生命播種到其他星球。</p><p>此書各章節較為零碎，例如第一部分看起來像鄉野奇談、第二部分讀起來像人體生理學課本，較難看出與主題的關聯。此書末以幾篇應用藍菌淨化代謝廢物的實驗報告作結。查詢了作者與其研究生的論文，發現原文僅提到可處理畜牧業或廚餘廢水，沒說明是否能應用在太空船的維生系統，因此這部分內容可能是作者自行延伸而來。</p><p>這部分有點可惜的是，作者用很大的篇幅（幾乎把整份論文貼了上來）來強調藍菌具有生物淨化的潛力。可是，閱讀以太空生物學為題的作品時，會期待能了解太空與畜牧環境差異，以及應用時會碰上的困難，但是作者較少著墨這些問題。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李炎 (2017)《太空生物學》，漢珍數位圖書股份有限公司。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> life in the universe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《再創世紀：合成生物學將如何重新創造自然和我們人類》</title>
      <link href="/church-2014-regenesis/"/>
      <url>/church-2014-regenesis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《再創世紀》的作者將合成生物學的各項里程碑比擬為生物演化和產業革命的重要階段，簡介晚近的基因工程技術並討論其引發的倫理爭議。雖然主題不是講解天文生物學，但是此書前三章關於合成生命的討論對釐清生命的定義有許多啟發。</p><span id="more"></span><p>人造生命可分為三種：由現有物種重組新物種、以生物原料製造生命和電腦模擬的虛擬生命。</p><p>2010年克雷格凡特團隊的人工基因組細菌即是重組生物的一個案例，研究者合成出維持生命所需的最短基因，再轉殖到細菌中取代原本的基因，這種極簡生命體不只排除了影響生產效率或實驗結果的未知干擾，製作過程中也有助於辨別何為生命的必須要素。至於從無到有建立生命的嘗試則能在找不到地外生物的情況下，拓展或是挑戰我們對生命的定義。</p><p>目前這問題仍莫衷一是，除了國中生物課本採用的條列式定義（生命具有繁殖、生長、代謝、運動等性質），還有NASA的定義：生命是能自我增值並遵循達爾文演化的化學系統。</p><p>作者則主張生命並非涇渭分明的概念，而是一種連續的屬性，可以透過再現複雜度（replicated complexity）度量。然而作者沒有明講其定義，只能從他舉的例子推測再現複雜度是指「重現近似複雜結構的能力」和「複雜結構間的關聯性」。這觀念可以解釋條列式定義的反例，例如：</p><ul><li><strong>病毒</strong>：得仰賴宿主的酵素系統複製基因組，因此只有有限重現能力，是再現複雜度較低的生命形式。</li><li><strong>騾子</strong>：雖然不能繁殖，但是體內細胞仍有自我複製能力，而且個體的複雜度源頭可連結自親代，仍有相對高的再現複雜度。</li><li><strong>火焰</strong>：火焰也是能夠成長和自我複製的系統，但是延燒火焰的性質和燃燒物有關，和原本的火焰關聯較低，因此再現複雜度不高。</li></ul><p>不同的定義反映著不同的哲學觀。好比說NASA把生命限制為化學系統是基於太空搜索的實用目的；但是作者作為創造生命的鼓吹者，自然不滿足於這種限制，因此他的定義能涵蓋自我複製並演化的機械人。我覺得重要的不是比較這些定義的優劣，而是了解定義的理論背景和適用範圍。</p><hr><p>喬治．丘奇，艾德．里吉西（2017）。再創世紀：合成生物學將如何重新創造自然和我們人類（周東譯）。電子工業出版社。（原著出版於 2014 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> what is life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我們就是火星人：尋找宇宙中的地外生命》</title>
      <link href="/bignami-2012-we-are-the-martians/"/>
      <url>/bignami-2012-we-are-the-martians/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>生命和宇宙的聯繫是《我們就是火星人》的主旋律。大霹靂後的原初核合成（Big Bang nucleosynthesis）雖然僅持續短暫時間，卻製造了宇宙含量最豐富的元素氫、氦。然而隨著空間持續膨脹，溫度下降到無法維持核融合反應，導致原初核合成中止。</p><p>直到第一批恆星誕生，最初的元素才在恆星核融合過程中轉變成組成身體的碳、呼吸所需的氧以及胺基酸裡的硫和氮。不過比鐵更重的銅、鉬等微量元素，得仰賴超新星的爆炸核合成。它提供足夠能量形成這些元素，填補了元素週期表其他空白。另外因超新星爆發而四逸的元素聚集為星際氣體，它們的組成成分隨著每次爆發變得越來越多元，成為孕育複雜分子和行星系統的搖籃。</p><span id="more"></span><h2 id="生命起源的隨機性與決定性"><a href="#生命起源的隨機性與決定性" class="headerlink" title="生命起源的隨機性與決定性"></a>生命起源的隨機性與決定性</h2><p>若形成最初生命的分子證實來自外太空，那麼宇宙物質的種類與數量分布可能影響了生命的型態，了解它們的源頭與生成機制，就有依據推測為何生物僅採用特定分子而不用另一群分子的謎題（例如手性不對稱）。然而目前為止，這些現象是隨機事件導致的巧合（生命原料源於外太空），還是分子差異演化所致結果（生命原料在地球生成）仍未有定論。</p><p>不過最重要的是明白「隨機」和「決定」的含意，如果形成生命的樞紐是可遇不可求的事件，那麼就意味著即便備齊良好條件，沒有機運仍然不會產生生命；反之，如果生命是反應的必然結果，那我們就更有可能從其他條件良好的星球發現生命跡象。</p><p>除了體內元素和宇宙的歷史連結，作者還說明了怎麼透過光、隕石和火箭聯繫我們、天體和遙遠的過去。第三章聚焦在搜索行星的觀測天文學，討論觀測結果對行星理論的衝擊。由於行星是生存的根據地，所以適居行星的形成機率也是攸關生命是否普及在宇宙中的關鍵。</p><h2 id="接觸天文學與泛種論的關聯"><a href="#接觸天文學與泛種論的關聯" class="headerlink" title="接觸天文學與泛種論的關聯"></a>接觸天文學與泛種論的關聯</h2><p>而在第四、五、六章介紹的接觸天文學，則是從墜落地球的隕石或是從其他天體採集的岩石中直接獲取資訊，由於沒有被瘋狂的地質活動風化，它們仍保留歷史的痕跡，研究者可以藉此得知岩石以至地球的過去。其中較有趣的是默奇森隕石和ALH84001，前者含有豐富有機物質，後者則有疑似微生物的化石，它們暗示著生命源於外太空的泛種論（Panspermia）。</p><p>泛種論可以追溯到希臘哲學家Anaxagoras，繼而由提出解離說的阿瑞尼斯發展，解釋胞子受輻射推動從一個星球飄到另一星球（Radiopanspermia），發現DNA雙螺旋結構的克立克亦曾參與，但他認為是外星智慧刻意安排生命在星際中遷移。此書則採用岩石泛種論（Lithopanspermia）試著估算微生物附著在拋向太空的岩石上，散播到其他天體的機會。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>我已經陳述了此書的知識概要，雖然大半篇幅是看似無關的天文學細節上，但這是因為作者一再強調的事——生命和宇宙的過往緊緊聯繫著。探索生命起源之謎可以從既有生命回推古早生命，但追尋古早生命的無機物源頭也是個途徑，沒理由不從天文學找線索，或許能從中找到生命之所以如此的終極原因。</p><h2 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h2><p>查詢天文生物學相關書籍時往往會碰上名、實不符的狀況。有些書意不在探討形成生命的機制，但內容卻涉及機制的關鍵環節，得了解這領域的研究方向才會注意到。</p><p>另外，生命起源和地外生物也是宗教人士愛好的話題，所以有些書雖然叫作「揭開生命起源的奧祕」，實則在提倡智慧設計和玄學理論。還有一些像此書一樣，書名看起來像科幻童書，卻正正經經地介紹組成生物體的物質源頭。</p><p>因此，為了挑到合宜的文本，除瀏覽作者背景和內容概要外，還可以透過圖書館分類號確認，其中與天文生物學密切相關的有361.9（天文生物學）和361.12（生命起源）。</p><hr><p>貝格美（2013）。我們就是火星人：尋找宇宙中的地外生命（涂泓譯）。科學出版社（原著出版於 2012 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> life in the universe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《解開生命之謎：運用量子生物學，揭開生命起源與真相的前衛科學》</title>
      <link href="/mcfadden-and-ai-khalili-2016-life-on-the-edge/"/>
      <url>/mcfadden-and-ai-khalili-2016-life-on-the-edge/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我覺得英文書名（life on the edge）比中文書名更能反映作者的生物觀點。無機物和生命體在肉眼可見的範圍皆遵循牛頓力學，但其差異在於部分粒子的變動能否影響整體的行為。無機物的特性（熱漲冷縮、結晶、……）源於數量龐大的粒子分攤掉個別粒子的隨機特性，因此個別粒子無法影響整體。</p><p>但是生命卻可以營造合宜環境，隔離或駕馭不規則擾動，保持個別粒子的特性，進而擴增到整個生命體驅動大大小小的反應，而這種特性可以用量子力學描述。換句話說，生命是在量子力學或古典力學支配的兩種秩序中間的微妙平衡，死亡意味著這平衡被打破，喪失微觀秩序和巨觀秩序的連結。</p><span id="more"></span><p>薛丁格在《生命是什麼》中提及基因包含的原子數量不足以用熱力學原則（秩序源於大量不規則行為的平均）說明其遺傳精確性，因此得援用量子力學解釋。繼承此信念的物理學家在生物體內找尋能應用量子力學的場合，因為量子效應僅出現在微觀尺度，又容易受細胞內隨機運動的粒子影響而失效，所以這類反應系統應該只涉及數目少、質量小的粒子，而且能藉由孤立空間或其他方法排除干擾。此外，反應系統需在維繫生命運作的關鍵位置上維持平衡，使微觀層次的變動得牽動巨觀層次。</p><p>此書前半部討論的酵素活性位、植物光系統、嗅覺受器以及磁導航器官皆屬此例，它們是維持生命的重要反應，又僅涉及電子或質子等小粒子轉移。作者用大量篇幅回顧這些領域的研究成果，接著點出傳統理論的缺陷，再舉出量子效應在其中扮演重要角色的證據，最後用比喻的方式引介量子生物學詮釋，幫助讀者理解抽象概念。</p><p>為了呼應其生物觀點，作者在後半部將量子理論應用到生物演化、大腦意識和生命起源等議題上，試圖將之推廣為為生命運作的基石。不過相較於前半段內容有較多實驗和文獻支持，這部份把量子理論套用在巨觀階層的種種模型仍屬推測。</p><p>雖然含有大量物理術語，可是畢竟這是介紹如何應用量子力學解釋生物現象的科普作品，不是量子物理課本。即使沒有讀通（但可了解作者嘗試讓我們更容易理解的努力），也能評估這樣的應用有何優點和限制，並且留意到一些值得思考的問題：</p><ul><li>書中提到的是經實驗佐證的理論還是大膽的猜測？</li><li>這些有證據的理論是挑戰了傳統學說，還是其解釋含糊的細節？</li><li>是生物體依賴量子效應，還是量子效應出現在生物體中？</li><li>微觀尺度的量子效應是否影響巨觀層次？</li><li>量子效應是反應的先決條件，還是從眾多選擇演化而來的結果？</li></ul><p>生命起源相關的議題集中在第一、二、九和十章，當中介紹的生命起源機制奠基於RNA世界說，只是傳統理論難以解釋該如何從有機分子中產生自我複製體，所以想像了一個能利用量子效應同時展現各種結構的「原酶」，能比化學重組更有效率地測試可能結構。當某個結構出現自我複製功能時，原酶就會喪失量子效應，維持穩定並持續複製下去。然而傳統理論的挫敗無法證明這個理論是對的，而且這想法只停留在模型階段還沒有任何證據支持，因此應謹慎看待。</p><p>作者在最後對建造人工細胞的提議類似《再創世紀》裡面提到的方法，沒有推翻以往研究者的成果：湊齊已知生命需要的功能元件、酵素和分子，安裝在脂肪隔間裡。不過強調要考慮量子效應，否則人工生命體沒辦法運作。</p><p>題外話：簡中版的書名叫《神秘的量子生命》，乍看之下讓人聯想到劉慈欣小說《球狀閃電》裡的量子幽魂，一眼之下還以為是什麼靈修著作，和正體版一樣都沒有凸顯此書前半部嚴謹的敘述，反而把重點放在仍有許多討論空間的後半部，還過度延伸些作者一直澄清不該和科學混淆的靈魂、哲學、神學概念，這點實在讓人感到困惑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> what is life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知識內容寫作課：寫一篇真材實料的網路爆紅好文章</title>
      <link href="/zheng-2018-knowledge-content-writing-course/"/>
      <url>/zheng-2018-knowledge-content-writing-course/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這本書意在指引專家學者撰寫科普文章以發揮他們的知識影響力。作者強調科學溝通的必要性後，提供了爆紅文章的架構與撰寫流程，接著解釋這些文章引人注目的要素，並且從泛科學網站的文章瀏覽資料中彙整出熱門主題供讀者參考。最末兩章聚焦行銷與傳播，講述如何從寫文推廣到建立個人知識品牌。</p><span id="more"></span><h1 id="為什麼專業人士要重視科學傳播？"><a href="#為什麼專業人士要重視科學傳播？" class="headerlink" title="為什麼專業人士要重視科學傳播？"></a>為什麼專業人士要重視科學傳播？</h1><p>科學傳播不是為了譁眾取寵，而是要匡正視聽。</p><p>科學的影響不會限於學術圈，而會隨時間進展漸漸擴及社會。然而知識在傳遞過程中不免因為概念艱澀、傳遞媒介不佳以及有心人士惡意扭曲造成誤解，這些混淆的觀念可能會引發無端的恐慌或是失當的決策，甚至動搖大眾對專業的信任。</p><p>因此專家學者需要重視自己的發語權，學習有效的科學溝通方式，以免專業知識為善於行銷的外行人詮釋。</p><p>儘管作者在序章亦提及科學傳播在促進跨界合作的功效，不過書中的指引仍著重普羅大眾，而非尋求合作的跨領域研究者，所以我認為重點依舊是學習透過撰寫科普文章破除大眾迷思，或推廣知識以鞏固社會對學界的支持。</p><h1 id="如何開始撰寫文章？"><a href="#如何開始撰寫文章？" class="headerlink" title="如何開始撰寫文章？"></a>如何開始撰寫文章？</h1><p>科普文章是專業知識和吸睛元素結合的產物。具備厚實的知識基礎後，首先要吸引受眾接觸，才有機會進一步傳播內容。然而不是每個人都對專業知識感興趣，要怎麼在受眾仍不感興趣的情況下吸引他們的注意呢？</p><p>作者的方法是利用原先便會吸引讀者的事物引導他們的注意力，再漸漸融入專業知識。舉例來說，即將上映的電影通常會激起人們的好奇心，如果能結合電影內容與相關知識撰寫文章，便有機會在上映期間觸及喜好電影卻不曾關心專業知識的受眾。</p><p>這種吸引注意力的事物，作者稱之為「熱點」。常見的熱點有</p><ul><li>節慶：傳統習俗、百貨公司周年慶、學校考試或開學、……等週期發生的事件</li><li>流行文化：電影、遊戲、小說、……等受廠商大力宣傳的事物</li><li>名人：政客、影星、歷史人物、……等已具備相當知名度的人物</li></ul><p>熱點的特性是能長期吸引受眾的注意力。因為引人注目，所以可以作為傳播知識的引子；因為名氣長紅，所以不會過時且具有充裕時間準備文稿。</p><p>與這些熱點相對的就是時事。時事並非不能利用，只是撰寫時事文章仰賴長期的知識累積才能快速反應，並且要不時結合其他熱點維持議題熱度。因為時事熱潮的起落難以預測，往往在準備文稿的過程中，事件的熱潮就消退了。而且事件當下情報紛亂，不易拿捏文章觀點，容易引起爭議與負面評價。</p><p>因此作者建議初學者要把握具有長期討論價值的通用熱點，掌握撰寫網路科普文的要點後，再按部就班接觸時事文章寫作。</p><p>此處還要補充的是，因為是透過其他事物來吸引讀者，所以讀者來源就受限於熱點的受眾，例如考試會吸引學生與家長，而長照政策會吸引年長者。撰文者要考量熱點受眾的水準與興趣調整知識內容，或是針對目標受眾挑選熱點，以免文章投放錯誤乏人問津。</p><h1 id="如何讓讀者願意讀下去？"><a href="#如何讓讀者願意讀下去？" class="headerlink" title="如何讓讀者願意讀下去？"></a>如何讓讀者願意讀下去？</h1><h2 id="連結熱點與專業知識"><a href="#連結熱點與專業知識" class="headerlink" title="連結熱點與專業知識"></a>連結熱點與專業知識</h2><p>利用熱點吸引讀者的注意力後，接著要建立「場景」把注意力引渡到和專業知識相關的情境中，同樣的熱點能夠依據不同的場景連結到不同的領域。</p><p>假設以團圓飯為熱點，可以從大眾的共同體驗寫起：「為什麼隨著長大年味愈來愈淡了呢？」，接著利用社會學或是心理學的角度解釋，同時帶入這方面的知識。或是營造面臨選擇的局面：「年菜有這麼多樣，該從哪些菜吃起？」，解釋策略之餘也介紹了營養學或生理學。</p><p>建立場景的要點就是讓讀者明白專業知識和自己關注的事物有共同點，藉此延長他們的注意力。</p><h2 id="博取讀者信任"><a href="#博取讀者信任" class="headerlink" title="博取讀者信任"></a>博取讀者信任</h2><p>除了吸引讀者注意，撰文者也要降低讀者的排斥感，具體的作法就是提供知識的來源，包含知識創造者的背景、發明與發現的歷程以及撰文者的來歷。這些資訊可供讀者判斷文章的可信度，也有助於讀者理解科學觀念。</p><p>可信又易懂的文章不只維持了讀者的注意力，也在累積讀者對撰文者的信任感。讀者越是信任，也就越願意傳播，這對於形塑個人的專業形象和發揮正向影響力很有幫助。</p><h2 id="解答讀者心中的疑惑"><a href="#解答讀者心中的疑惑" class="headerlink" title="解答讀者心中的疑惑"></a>解答讀者心中的疑惑</h2><p>撰文者成功以熱點與場景吸引讀者，並且博取讀者信任後，就要告訴讀者這篇文章可以解決他們心中的疑惑，值得他們花上時間閱讀下去。所以撰文者要針對目標受眾設想核心問題，文章所有布局都是為了回答核心問題而設，透過一連串提示讓讀者意識到此問題的重要性，激發尋求解答的渴望，吸引讀者繼續閱讀下去。</p><h1 id="如何促使讀者展開行動？"><a href="#如何促使讀者展開行動？" class="headerlink" title="如何促使讀者展開行動？"></a>如何促使讀者展開行動？</h1><h2 id="提出合理且有用的結論"><a href="#提出合理且有用的結論" class="headerlink" title="提出合理且有用的結論"></a>提出合理且有用的結論</h2><p>讀者閱讀到最後，他會獲得核心問題的解答，也就是文章的結論。結論不只回應了問題，同時也指出讀者想改善某些狀況可採取的行動。如此一來，讀者即便忘記正文中為了維持其注意力而安排的細節，也能把握結論中交代的關鍵概念改變思維或是展開行動。</p><p>儘管撰寫結論時仍然要留意可信度，過度延伸或抽象都會降低讀者對文章的信賴，交代結論的限制條件和可能性反而能博取信任。</p><h2 id="引發讀者的情感"><a href="#引發讀者的情感" class="headerlink" title="引發讀者的情感"></a>引發讀者的情感</h2><p>理解要靠理性，但做出選擇仰賴感性。既然撰文的目的是改變讀者思維進而促使讀者展開不一樣的舉止，所以除了專業知識內容外，也可以適度訴諸情感，激起讀者對於核心問題的憤怒、疑惑、感傷、同情、……等情緒，進而依據撰文者提出的結論採取行動。</p><h2 id="列出延伸資訊"><a href="#列出延伸資訊" class="headerlink" title="列出延伸資訊"></a>列出延伸資訊</h2><p>圖表、參考文獻、事例等延伸資訊的用意不外乎</p><ul><li>佐證正文內容，博取讀者信任</li><li>改變文章節奏以免單調</li><li>提供作者理解議題的其他管道</li></ul><h2 id="知識寫作的文章架構"><a href="#知識寫作的文章架構" class="headerlink" title="知識寫作的文章架構"></a>知識寫作的文章架構</h2><table><thead><tr><th>步驟</th><th>解釋</th><th>架構</th><th>用途</th></tr></thead><tbody><tr><td>熱點</td><td>引人注目的事物</td><td>標題與開場</td><td>吸引讀者</td></tr><tr><td>場景</td><td>連結熱點與專業知識的情境</td><td>開場</td><td>吸引讀者</td></tr><tr><td>誰</td><td>知識創造者、發明與發現流程、撰文者的目的與來歷</td><td>內文</td><td>說服讀者</td></tr><tr><td>為什麼</td><td>核心的問題意識</td><td>邏輯理路與小標題</td><td>引發行動</td></tr><tr><td>怎麼做</td><td>知識推倒過程</td><td>內文解釋</td><td>說服讀者</td></tr><tr><td>結果</td><td>研究成果與可能性</td><td>結論</td><td>說服讀者</td></tr><tr><td>展望</td><td>研究用途與未來方向</td><td>結論</td><td>引發行動</td></tr><tr><td>感受</td><td>希望讀者產生的情緒與行動</td><td>表達方式</td><td>引發行動</td></tr><tr><td>參考資料</td><td>值得相信的理由</td><td>補充</td><td>說服讀者</td></tr><tr><td>圖像影音</td><td>輔助文字表達概念、調整閱讀節奏</td><td>閱讀節奏</td><td>吸引讀者</td></tr></tbody></table><h1 id="可以寫些什麼？"><a href="#可以寫些什麼？" class="headerlink" title="可以寫些什麼？"></a>可以寫些什麼？</h1><h2 id="人們喜歡的內容"><a href="#人們喜歡的內容" class="headerlink" title="人們喜歡的內容"></a>人們喜歡的內容</h2><p>了解撰寫文章的流程後，接下來要了解人們喜歡什麼樣的內容。據作者的說法，人類追求某項事物會基於親近以及新奇兩種矛盾的感受，親近源於採集，新奇源於狩獵，人類有賴這兩種活動才能存活至今，與之相關的親近與新奇感也連帶保留，所以很自然地人們會喜歡能帶來新奇或熟悉感的內容。</p><h2 id="創造親近元素"><a href="#創造親近元素" class="headerlink" title="創造親近元素"></a>創造親近元素</h2><p>創造親近元素的關鍵就是要把自己和溝通對象擺在平等地位，安排內容要考量對方的教育背景、生長環境以及感受，行文要避免出現區別雙方的字眼。</p><h2 id="創造新奇元素"><a href="#創造新奇元素" class="headerlink" title="創造新奇元素"></a>創造新奇元素</h2><p>新奇就是令人意外的東西，可以是以下幾種</p><ul><li>特定條件下最____的人事物</li><li>特定條件下唯一的人事物</li><li>帶有特定秩序的人事物</li><li>背離常識和直覺的人事物</li><li>尋常環境中極端特殊的人事物</li></ul><h1 id="文章框架與熱門主題"><a href="#文章框架與熱門主題" class="headerlink" title="文章框架與熱門主題"></a>文章框架與熱門主題</h1><table><thead><tr><th></th><th>內容</th><th>特性</th><th>展現的人格特質</th></tr></thead><tbody><tr><td>教學文</td><td>傳授特定技術或解決問題的方法</td><td>讀者容易實踐文章內容、文章容易傳播且容易撰寫</td><td>樂於分享</td></tr><tr><td>新知文</td><td>介紹專業領域的最新發展</td><td>長期發布新知文，能吸引關注該領域的讀者追蹤</td><td>掌握專業領域前沿</td></tr><tr><td>翻案文</td><td>顛覆以往大眾認知的事實</td><td>容易吸引目光並傳播、用字遣詞要特別謹慎</td><td>不畏懼權威且敢於接露真相</td></tr><tr><td>熱點文</td><td>（前述知識寫作流程中強調的文章類型）</td><td>容易吸引目光</td><td>掌握熱點</td></tr><tr><td>大補帖</td><td>列舉並介紹同一主題但彼此獨立的知識點</td><td>文章容易閱讀及撰寫</td><td></td></tr></tbody></table><p>作者自泛科學歷年文章彙整出的熱門主題包含：破解迷思、空想科學、職場現況、食衣住行、社會爭論、體現抽象概念、剖析性愛、……等，這些主題其實就是抽換文章的熱點和場景，書本的解析有限，所以要觀摩網站上的文章以得到更多收穫。</p><h1 id="文章寫完了，要怎麼推廣？"><a href="#文章寫完了，要怎麼推廣？" class="headerlink" title="文章寫完了，要怎麼推廣？"></a>文章寫完了，要怎麼推廣？</h1><h2 id="掌握關鍵人脈"><a href="#掌握關鍵人脈" class="headerlink" title="掌握關鍵人脈"></a>掌握關鍵人脈</h2><p>網路時代的資訊傳播不再侷限於新聞台或報社，社群網路也是個人散播資訊的管道。投放資訊在社群網路的門檻較低，不像投稿傳統媒體得接受審查和過濾，然而投放的資訊是否能存活下來就有賴社群網路中的關鍵節點</p><ul><li>連結者：連結者是人脈豐沛的人，所以若能與連結者搭上關係，就能透過他來觸及更多讀者。</li><li>專家：特別指在領域內具有相當人脈的專家，儘管認識的人沒有連結者多，可是專家的背書能增加知識傳播者的信用，讓讀者更願意買單。</li><li>推銷員：推銷員是指願意嘗試新事物並推薦新事物的人，他們是知識傳播的第一步，募集足夠的推銷員，才能確保知識傳遞鍊不會斷掉。</li></ul><h2 id="從借勢到造勢"><a href="#從借勢到造勢" class="headerlink" title="從借勢到造勢"></a>從借勢到造勢</h2><p>在還不出名的時候，知識傳播者得仰賴熱點吸引讀者，等到寫出成績，養起一批讀者以後，就要利用其他機會甚至自己創造寫文的時機。</p><ul><li>藉由回應批評造勢：回應讀者合理的批評一方面能藉由接納或反對開啟新議題，另一方面也表示自己態度開明且願意與讀者互動。</li><li>藉由回應提問造勢：藉由答覆讀者的提問補充文章內容甚至撰寫其他議題，延伸單一主題的討論價值與熱潮。</li><li>藉由共同策展造勢：提供其他合作者發表意見的舞台，募集相同議題不同的看法。</li><li>藉由邀請創作造勢：邀請讀者或其他合作者共同撰文，重點是藉由邀請（提問或徵文等），刺激讀者回饋內容、製造話題。</li></ul><h1 id="建立知識品牌的步驟有哪些？"><a href="#建立知識品牌的步驟有哪些？" class="headerlink" title="建立知識品牌的步驟有哪些？"></a>建立知識品牌的步驟有哪些？</h1><h2 id="瞭解建立知識品牌的階段任務"><a href="#瞭解建立知識品牌的階段任務" class="headerlink" title="瞭解建立知識品牌的階段任務"></a>瞭解建立知識品牌的階段任務</h2><ul><li>前期：針對目標讀者挑選既有的熱門平台，在上頭撰寫文章檢驗自己的計劃是否可行，觀察讀者的反應調整品牌風格。</li><li>中期：確認文章受歡迎以後，首先利用免費平台建立個人的文章發布據點，規律發文以維持熱度。</li><li>後期：和夥伴合作擴張影響力，例如合作撰文、互相宣傳、建立共同品牌等等。</li></ul><h2 id="建立品牌風格"><a href="#建立品牌風格" class="headerlink" title="建立品牌風格"></a>建立品牌風格</h2><p>即使是同樣主題的知識品牌，也會因為風格不同而吸引到不一樣的人群，因此要根據自己的性格與目標讀者建立品牌風格。</p><table><thead><tr><th></th><th>定義</th><th>例子</th></tr></thead><tbody><tr><td>Different</td><td>對同一議題的看法與眾不同</td><td>柯文哲</td></tr><tr><td>Dazzleing</td><td>表達方式亮眼</td><td>蔡阿嘎</td></tr><tr><td>Deep</td><td>討論的議題格外深入專一</td><td>馬雅人</td></tr></tbody></table><h2 id="決定知識角色"><a href="#決定知識角色" class="headerlink" title="決定知識角色"></a>決定知識角色</h2><p>也就是決定要用何種方式幫助讀者。</p><table><thead><tr><th></th><th>發文頻率</th><th>內容</th><th>知識領域</th><th>情緒張力</th><th>讀者價值</th><th>範例</th></tr></thead><tbody><tr><td>知識健身教練</td><td>密集，每日 1 - 2 次</td><td>穩定且份量小的知識內容</td><td>單一</td><td>低</td><td>低負擔累積新的知識存量</td><td>熱心腸日報</td></tr><tr><td>知識廚師</td><td>中等，每月 1 - 4 次</td><td>經整理過的複雜知識</td><td>多元</td><td>中</td><td>協助管理知識流量</td><td>邏輯思維</td></tr><tr><td>知識清淨機</td><td>不固定，隨事件發文</td><td>針對知識議題撥亂反正</td><td>單一</td><td>高</td><td>辨識並排除糟糕知識</td><td>科學新聞解剖室</td></tr></tbody></table><h2 id="募集鐵粉"><a href="#募集鐵粉" class="headerlink" title="募集鐵粉"></a>募集鐵粉</h2><p>有了相當數量的鐵粉就能確保品牌生存，而募集粉絲的手段有：</p><ul><li>粉絲服務：回應粉絲的要求辦特定事項</li><li>幕後故事：揭示自己的日常和工作生活</li><li>自我介紹：分享自己的喜好和成長背景等資訊</li><li>大談目標：吐露自己的理想以及做某些行為的目的</li><li>自謙：讓讀者認為自己是個願意學習的乖孩子</li></ul><p>儘管辦抽獎活動這類外源性獎勵可以迅速累積曝光度，但是吸引的不是為了內容的讀者，對於增加鐵粉的效益有限。重要的還是讓粉絲能有歸屬感、優越感、成就感，這種因為品牌促成的正面感受（內源性獎勵）才是鞏固粉絲的重點。</p><hr><p>鄭國威（2018），知識內容寫作課：寫一篇真材實料的網路爆紅好文章。PCuSER電腦人文化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科學溝通能力的重要性</title>
      <link href="/the-importance-of-science-communication/"/>
      <url>/the-importance-of-science-communication/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>科學溝通能力究竟有什麼重要性，為何值得投注心力練習？</p><p>溝通是學術的一環。科學的進展大抵可以分為「發現新知」和「傳播新知」兩個部分。發覺問題、建立假說，最後設計實驗證明的過程，仰賴研究能力；將新發現以具體而且可信的論證方式傳遞給他人，則仰賴表達能力。</p><p>越是非凡的發現，越需要清晰的語言才能充分闡明。因此，除了研究的本領，科學溝通的能力也值得重視。</p><span id="more"></span><p>在學界內最普及的溝通方式就是撰寫論文，論文不僅是傳達和保留研究成果的媒介，也是評斷個人成就的標準。在論文以外，還有研討會或學者間的非正式交流，讓研究者得以接觸學界前沿的狀況。</p><p>除了和他人溝通，研究者在探索問題的途中也得不斷和自己對話，例如撰寫計劃書安排研究進度，或是時時回顧實驗記錄，藉此鞏固概念及引導思考以順利完成研究。</p><p>最後，隨著科學的進展，研究成果的影響不會只限於學術圈，而會漸漸擴及社會。然而知識在傳播中可能被誤解，混淆的觀念恐怕扭曲大眾對科研的看法，導致恐慌及失當的決策。這些問題有賴研究者、媒體和社會間有效的溝通才能解決。</p><p>換句話說，社會支持著學術圈，學術圈則讓個人有立足空間，個人再反過來影響學界與社會。溝通參與了個人、學術乃至於社會三方面的發展，這也是為什麼值得投入心力在科學溝通能力養成的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平凡人找指導教授指南</title>
      <link href="/ordinary-students-guide-to-finding-a-supervisor/"/>
      <url>/ordinary-students-guide-to-finding-a-supervisor/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這篇文章是我找指導教授的經驗談，希望能幫助一些跟我一樣搞不清楚狀況，但還是想要讀研究所的人。</p><span id="more"></span><h1 id="徬徨的理由"><a href="#徬徨的理由" class="headerlink" title="徬徨的理由"></a>徬徨的理由</h1><p>找指導教授不該是考上研究所後才要煩惱的事情。理想情況下，選讀碩士班是一個人在大學期間培養充分知識並了解學界現況後，衡量能力與興趣所作的慎重決定，因此「要讀哪間學校？要跟隨哪個老師」這種問題早在參與考試前就已經決定好了。</p><p>不過，有些人其實對未來不抱明確想法，只因不知該何去何從或對學界、業界有錯誤期待，便興沖沖報名考試，進了學校後才開始煩惱要怎麼選指導教授。</p><p>有沒有這樣的人啊？</p><p>當然有，就好比寫了這篇心得的我。然而經過一個月的努力我終於找好指導教授，期間得網路上許多先進的文章幫助，所以也想把這段經歷寫成文章，獻給所有站在大學與研究所邊界徬徨不已的人。</p><p>追根究柢，徬徨源於無知。無知導致沒能掌握狀況，不知何處使力，面對出社會的壓力時心有餘而力不足，最終產生不安。不論是逃避或拖延都會阻礙人們求知，因此解決無知的第一步就是勇敢審視自己，哪個教授和學校適合你都要從人生經歷和生涯規劃中尋找答案。</p><h1 id="從自己出發"><a href="#從自己出發" class="headerlink" title="從自己出發"></a>從自己出發</h1><p>先別急著找資料，得確認自己的需求與嚮往後才會有篩選標準，因此想想三個問題：</p><ul><li>「為什麼要念研究所？」</li><li>「為什麼要讀 OO 系&#x2F;所，而非 XX 系&#x2F;所？」</li><li>「為什麼讀這間？」</li></ul><p>這些問題很可能在面試前就已經思考過了，但這回要拋棄迎合教授的答案，在入學前好好考慮到底要不要讀研究所。如果是為更好的薪資待遇，除了查清楚這是否為職場現實，也要計算投入碩班的機會成本。不為收入的人，需確認究竟是喜歡「接觸已知」還是「探索未知」，學習的人只需面對個人的未知，但研究者卻要面對全人類的未知，這種壓力會降低學習的樂趣。所以只是喜歡學習新知者未必要讀研究所，即是做各行各業都能持續充實自我。</p><p>若立下讀研究所的決心，便要檢查有沒有選錯學校和系所。差異較大的學科可以從簡介教科書判斷，至於名字相同或相似的系所就得查詢它們的網站，看看各自偏重何處。檢查無誤就開始調查指導教授；發現念錯系則要考慮重考或和現實妥協找理由念下去。</p><p>在反思的過程中，也許會有些疙瘩：「我是真的有興趣讀，還是找個理由讓自己不要瘋掉？」不過興趣並非決定生涯的關鍵因素。研究不可能只鑽研有興趣的部分，必定包含其他無趣的細節。就算如願找到契合興趣的實驗室，一旦興趣變成職業，行政瑣事和競爭壓力都要連帶承擔。所以我認為一再強調興趣很糟糕，很多時候就算沒興趣也會硬著頭皮上，因為驅動我們的不是喜歡什麼東西，而是想要成為什麼人，想要做什麼事情，簡言之就是「理想」，我們不是逃避痛苦或追求歡快而活，是為追逐理想而活。</p><p>以這觀點來看，職業難度和個人能力只會限制實踐理想的途徑，不會規範理想的內容。讀研究所固然辛苦又有風險，它不會是「無處可去」的去處，然而有任何職業可以當避風港嗎？就是志願役，長官也希望你進來是為了當兵掙榮譽，而不是做不來其他事情才簽下去。僅因能力不及便轉換跑道，那碰上新困難時要逃哪去？重點不是依照能力分類職業，而是評估能力思索怎麼在職業中發展。</p><p>能確定志向的話，不用在意興趣和能力，也不須執著是從小的夢想還是剛剛想出來的理由，沒有根據的理想都比沒有想法好，有了目標至少能看出現實與理想的差距，作錯時知道該修正該往哪走，而不是在原處發慌。</p><h1 id="查詢教授資訊"><a href="#查詢教授資訊" class="headerlink" title="查詢教授資訊"></a>查詢教授資訊</h1><p>雖然很多事要進了實驗室才知道，可是也不能把選指導教授交給運氣，蒐集越多資料就能消除越多機運成分。由於我還沒開始讀碩班，所以沒能力分享「如何找到好教授」，僅列舉能取得資訊的網站，至於資訊涵義可以讀其他心得或請教前輩獲知。</p><h2 id="系所網站-個人網站"><a href="#系所網站-個人網站" class="headerlink" title="系所網站&#x2F;個人網站"></a>系所網站&#x2F;個人網站</h2><p>系所簡介僅用於排除不合需求的領域，不能當作選老師的依據，因為它只概括了實驗室曾作過的題目，沒有細講現在作些什麼，因此可能和實際情況不符。</p><h2 id="科技部研究人才查詢"><a href="#科技部研究人才查詢" class="headerlink" title="科技部研究人才查詢"></a>科技部研究人才查詢</h2><p>著作和學經歷公布在系所網站上，實驗室計畫要到「研究人才查詢」才找得到，網站會列出計畫名稱和經費多寡，能看出近期實驗室的研究主題。</p><h2 id="臺灣博碩士論文知識加值系統"><a href="#臺灣博碩士論文知識加值系統" class="headerlink" title="臺灣博碩士論文知識加值系統"></a>臺灣博碩士論文知識加值系統</h2><p>學長姐的論文最能看出實驗室的研究方向，這網站不只可以找從前的論文，還能畫出這些論文涉及知識的心智圖。查資料時可以從這裡下手，熟悉背景知識後再把同主題的文章集中一起看。讀到能夠大略講出研究材料、方法和目的即可，重點是和自己有什麼關係，想要研究哪一項？又需要什麼本事？老師還有沒有做？真的搞不清楚的地方便等面談時提出。</p><h1 id="準備個人資料"><a href="#準備個人資料" class="headerlink" title="準備個人資料"></a>準備個人資料</h1><p>錄取後的個人資料不用寫求學心路歷程以及讀研究所的憧憬和動機，可以聚焦學識素養和研究興趣。若覺得寫成文章很困難，就用方便搜索的表格呈現。盡可能言簡意賅而且明確具體，節省時間也透漏表達能力。一份簡歷包含以下資訊：</p><ul><li>基本資料：姓名、學歷、科系、相片、聯絡方式</li><li>學識狀況：語言能力、在校總成績、專業技能、修課履歷</li><li>學術興趣：學術興趣、背景知識、碩班關聯性</li><li>附件：專題報告、專題經驗、成績單、讀書計畫</li></ul><p>簡歷隨面談信寄出前檢查有無在檔名標記姓名、身分、學校、日期等資料方便老師檢索。面談前印成紙本帶去，讓老師可以即時參考。</p><h1 id="聯絡教授"><a href="#聯絡教授" class="headerlink" title="聯絡教授"></a>聯絡教授</h1><h2 id="面談預約信"><a href="#面談預約信" class="headerlink" title="面談預約信"></a>面談預約信</h2><p>標題寫「新進研究生面談預約」，後面同樣標記姓名、身分、學校。開頭介紹身分來歷後向老師說明目的，即向老師約時間請益研究主題的細節和實驗室運作方式。這段可以把查資料時整理的問題扼要提出，讓老師預先準備。繼而列出幾個時段供挑選，並表示「若這幾天皆不可，由學生配合老師可行的時間」，再列出自己不行的時段。最後向老師道謝，註記附件內容和聯絡方式。<br>預約信本文不用多，充實附件備查即可，但要注重禮節。即使老師回信不拘形式，還沒熟識之前正式一點不會有壞處。</p><h2 id="時間確認信"><a href="#時間確認信" class="headerlink" title="時間確認信"></a>時間確認信</h2><p>若老師告知無法收學生，回信表示感謝；同意面談，則寫確認信回報拜訪時間。重開「面談時間確認信」，由於之前已經寄過信，所以簡化寒暄直接說明何時拜訪，然後告訴老師拜訪前會寄信或打電話提醒。老師遲不回信者再接再厲，表達已聯絡卻沒回應，或向所辦詢問老師是否忙於公事，麻煩他們轉告。</p><h2 id="提醒信"><a href="#提醒信" class="headerlink" title="提醒信"></a>提醒信</h2><p>假設沒有回信確認，或是面談時間在兩周後，那麼得在訪談前一、兩天寄提醒信，免得老師忘記。我之前覺得老師都大人了，沒必要耳提面命，結果面談當天被放鴿子，所以凡事還是謹慎一點比較好。</p><h1 id="面談"><a href="#面談" class="headerlink" title="面談"></a>面談</h1><p>教授想從推甄面試看出學生優劣，但考後面談則是學生想挖出網路沒有的資訊。他人評語或教授自述是二手資料，面談當下教授的回應語氣、肢體動作和表情態度能直接看出他是怎樣的人，所以要把握面談此時此刻，除了交談內容也要留意其應對方式。</p><h2 id="面談前一天"><a href="#面談前一天" class="headerlink" title="面談前一天"></a>面談前一天</h2><p>寄送提醒信以免老師忘記面談，準備行李和整理問題。</p><h2 id="面談當天"><a href="#面談當天" class="headerlink" title="面談當天"></a>面談當天</h2><p>穿著整齊服裝，攜帶個人資料、紙筆提早出門。容易緊張的同學可以準備一張備忘錄。緊張時會不知所措導致表現失常，但並非無法克服，只要預先設下指引，讓自己知道該做什麼，就不會胡思亂想或腦袋放空。具體的方法是在面談前在一張卡片上標註面談開始到面談結束每個階段要做什麼&#x2F;要問什麼問題，讓冷靜的自己指導慌張的自己行動。</p><h2 id="面談前"><a href="#面談前" class="headerlink" title="面談前"></a>面談前</h2><p>老師遲到時，先到所辦確認下落，老師忘記赴約的話再次聯絡，最好的情況是能在同一天完成，不過即使老師不在也可以拜訪學長姊，問「當初為什麼選這個教授？」、「進來之後和期待有什麼落差？」、「還有找過其他教授嗎？」，藉此探聽目標老師和其他老師的資訊。</p><h1 id="面談初期"><a href="#面談初期" class="headerlink" title="面談初期"></a>面談初期</h1><p>打招呼說明來歷之後，若老師有意主導節奏就順著他，需要額外提問時再插入。沒有的話照預設的流程跑，自我介紹並講清楚面談目的後即可發問。</p><h2 id="研究主題"><a href="#研究主題" class="headerlink" title="研究主題"></a>研究主題</h2><p>因為每個人對網路資訊理解程度不一，所以研究主題的問題比較多樣，但原則都是「消除個人理解和實際情況的差異」，試著跟老師解釋自己的想法，向他確認有無錯誤。可以問的包括「實驗室還在做我想做的題目嗎？」、「實驗室擁有的技術能否支持我想做的題目？」、「這些題目和我想像的差在哪？」、「研究生可以做到什麼程度？」、「能力可能無法應付那些題目？」、……等，哪裡有問題就問什麼。</p><h2 id="實驗室運作"><a href="#實驗室運作" class="headerlink" title="實驗室運作"></a>實驗室運作</h2><p>實驗室運作就是通用問題了，大家關心的都差不多：老師怎麼帶學生？（親自帶&#x2F;委任他人）、怎麼決定論文主題？（自己找&#x2F;老師給&#x2F;接計畫）、作息（上下班時間、周末）、討論會頻率和形式、研究費、修課規定、給題目時間、其他要求、……等。當然有些不方便問得可以改問學長姊。</p><h2 id="請教"><a href="#請教" class="headerlink" title="請教"></a>請教</h2><p>最後抱著向研究前輩討教的心情問些問題吧，不同的教授會有不同反應，很有趣的。流程跑完後跟老師道謝，說明會再聯絡便結束了。</p><h1 id="簽指導教授同意書和以後"><a href="#簽指導教授同意書和以後" class="headerlink" title="簽指導教授同意書和以後"></a>簽指導教授同意書和以後</h1><p>整理資料後把教授排序，選出要進一步聯絡的人選，發信詢問指導意願，再會談一次當面確認後就可以簽指導教授同意書了。</p><p>不過這樣反覆面談、找資料會不會錯過一些熱門教授？我想這不是大問題，對於沒有想法的人而言，熱門不熱門只是片面之詞，怎麼知道合不合適？不如好整以暇蒐集情報，再三確認後才下手，畢竟忙碌至此，研究生涯也才剛到了起點，若為了搶快卻搞錯方向一點意義都沒有。</p><p>註：如果還有其他問題，都可以留言詢問。</p>]]></content>
      
      
      
        <tags>
            
            <tag> career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《路上觀察學入門》</title>
      <link href="/akasegawa-2014-introduction-to-street-observation/"/>
      <url>/akasegawa-2014-introduction-to-street-observation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>路上觀察是基於樂趣而非其他目的，在都市中觀察人文物件的活動，不僅著重它們溢出框架的特性，也關心其蘊藏的故事，因此即使是同樣的物件，也會因為每個人的聚焦點不同而展現出各式各樣的韻味。所謂框架，不單指具體的空間配置，亦包含無形的秩序、美感和理論，有些物件偏離原先的位置或規模，有些則擺脫實用價值流露出其他感覺，觀察這些脫序的事物正是路上觀察學和帶有宣傳意味的廣告、賦予作者意念的藝術品、有理論支持的博物學，或關切秩序的空間觀察者最大的不同。</p><h1 id="從考現學到路上觀察學"><a href="#從考現學到路上觀察學" class="headerlink" title="從考現學到路上觀察學"></a>從考現學到路上觀察學</h1><p>1923 年，關東大地震震垮了原先井然有序的東京，讓一切化為灰燼，人們得從零開始生活。新事物在斷垣殘壁中源源不絕冒出，新舊雜陳的景況激起許多人的興趣，當中以吉田謙吉為先驅，在隔年於《建築新潮》發表了考現學最早的文獻〈東京克難招牌之美〉。而考現學的另一位開拓者，時任早稻田大學建築系教授的今和次郎對先前跟隨柳田國男下鄉從事的民俗調查漸漸產生疑慮與空虛，不滿忽略今日一再追尋過去的態度，也對將鄉間當作異類觀察的工作反感。於是在吉田謙吉的啟發下，轉而注意起都市的現代風俗，將田野調查手段應用到街道上。</p><p>今和次郎一面協助裝修美化克難屋，一面觀察人們如何重新打理生活，復原殘破的建築與文物。他和吉田謙吉結伴上街，以素描見證復興與創始的新奇感受，其成果在《婦女公論》雜誌連載，後來受紀伊國書店的創辦人田辺茂一邀請，以「考現學」為名佈展，為當時的社會留下翔實紀錄，供後人理解重建時期東京人的日常。</p><p>待災後重建告一段落，當初的開創者也就沒再發展下去，考現學被商業界過度利用，逐漸從個人用語演變成書報常用詞，其內涵也變成高度發展的商業文化下促進消費的宣傳媒體了。</p><p>70 年代日本安保抗爭才剛告一段落，整個城市還在學運的餘波中，地景和秩序被被壞產生大量脫序事物，創造了關東大地震一樣的空間錯置效果，路上觀察學繼承了考現學的基礎，在社會動盪中誕生。藝術家赤瀨川原平和建築師藤森照信等人各自成立社群，在自己感興趣的領域開拓。「湯馬森」便是其中一項發現。</p><p>湯瑪森是附著於建築或道路上，毫無用途卻完整美麗地保存下來，無法解釋的凹凸物件，源於 1981 年被日職巨人隊重聘以接替王貞治的大聯盟選手 Gary Thomasson，由於其表現不如預期被挪用於此。那種開在二樓的門或隔壁房屋拆除留下的痕跡都是湯馬森的例子。</p><p>從湯馬森、看板建築到招牌考現學，路上觀察累積了豐碩的成果，於是一行人在 1986 年集結起來創立路上觀察學會，偶爾舉行成果展並以出版書籍。</p><h1 id="路上觀察學的特徵"><a href="#路上觀察學的特徵" class="headerlink" title="路上觀察學的特徵"></a>路上觀察學的特徵</h1><h2 id="講求有趣"><a href="#講求有趣" class="headerlink" title="講求有趣"></a>講求有趣</h2><p>不執著目的和成就，從生活中的「理所當然」看出樂趣才是最重要的。</p><h2 id="反消費主義"><a href="#反消費主義" class="headerlink" title="反消費主義"></a>反消費主義</h2><p>關注物件可看之處而不是其帶來的效益。要注意的是，儘管有些企業會在商品宣傳中加入都市學要素，刻意營造路上觀察的氛圍，但這只是錯覺，其目的仍然是吸引目光促進銷售。純粹的路上感覺不是接受「別人希望我們看見的東西」，而是從平凡的都會中找出「自己在乎的東西」。</p><h2 id="和博物學的差異"><a href="#和博物學的差異" class="headerlink" title="和博物學的差異"></a>和博物學的差異</h2><p>雖然觀察和紀錄也是博物學的基礎，但相對於路上觀察把觀察當成樂趣的本質，博物學者在觀察自然的同時，亦抱著驗證自然觀的目的，換句話說，觀察是完善知識的手段。</p><p>另外一個差異在，隨著資料累積和詮釋，建立起嚴謹的知識體系，於是無數個新學門自博物學衍生，最終導致博物學自身日漸衰微。但是路上觀察學因自身限制不會分化成學科，得以源源不絕保持原貌。若將嚴謹的學科比喻作固體，鬆散的現實比作氣體，研究非常規事物的路上觀察學就是處在秩序和混亂中間不穩定的液態學門，一旦跨過界線就會陷入規範中演變成某種人文學科了。所以路上觀察永遠都不會有結論，它是一種入門學問，不能更深入只能往橫向發展。</p><h2 id="和藝術的差異"><a href="#和藝術的差異" class="headerlink" title="和藝術的差異"></a>和藝術的差異</h2><p>路上觀察和藝術都在追尋美，但是藝術來自創作，必定蘊含作者的心理、思考和對美的想法，可以鑑賞或買賣。然而路上觀察注視的對象雖然也是人造物，可是它們的製造目並非創造美感或激發思考，當採用欣賞的角度看待時，無法察覺到來自任何創作者的情感和意念，對於這種物件我們只能觀察然後賦予意義，不能評斷優劣也無法出價收藏。</p><h2 id="和空間派的差異"><a href="#和空間派的差異" class="headerlink" title="和空間派的差異"></a>和空間派的差異</h2><p>同樣以路上觀察為基調的還有關切都市設計和環境心理學的空間派，但他們從大局著眼，試圖解讀藏在空間的規則，還抱著建立和諧秩序的企圖。路上觀察則忽略整體，也沒有插手改變的野心，只是單純欣賞那些擺脫框架，展現特色的物件。</p><h1 id="編輯架構"><a href="#編輯架構" class="headerlink" title="編輯架構"></a>編輯架構</h1><p>《路上觀察學入門》於 1986 年出版，由路上觀察學會的發起人赤瀨川原平、藤森照信和南伸坊編輯。全書分四部，「宣言」中的兩篇文章分別講述編輯者踏上路上觀察的心路歷程，和路上觀察與眾不同之處。「街道的呼喚」則透過對談方式，討論重要概念與其成形背景，「我的田野筆記」彙整了高中女生制服觀察、考現學作業、建築碎片收藏等報告，展示不同觀察者獨到的眼光。最後一部「觀察之眼」從博物學的歷史和漫畫考察並講解路上觀察精神。本書不是體例嚴謹、層次分明的指導手冊，而是一種成果展示和概念分享，讀者得自行整理散落各處的核心觀念，並從實踐中體會何謂「走在路上的正確方法」。</p><h1 id="路上觀察在台灣"><a href="#路上觀察在台灣" class="headerlink" title="路上觀察在台灣"></a>路上觀察在台灣</h1><p>本書出版前台南已有社區大學開設路上觀察課程，台大的畢恆達老師亦曾在其通識課程中介紹。行人出版社於 2014 年引進後各地社團林立，台北市立美術館還邀請到路上觀察的元老藤森照信來台參展，並規畫為期三天的台北探索。不過隨著熱潮消退，目前僅剩台南路上觀察團、台北路上觀察學會以及出版社創設的路上觀察學院較活躍。</p><h2 id="台北路上觀察學會"><a href="#台北路上觀察學會" class="headerlink" title="台北路上觀察學會"></a>台北路上觀察學會</h2><p>台北路上觀察學會的前身是 2014 年四月由設計師林承毅在HPX 社群下籌組的路上觀察研修會，募集不同專長背景但同樣對人文和都市觀察有興趣者，籌組讀書會研讀《路上觀察學入門》及《空間就是想像力》，定期舉行成果報告，還組團考察建築歷史變遷、尋訪廟宇或參與節慶。隔年，內部運作的研修會轉型為向外推廣的台北路上觀察學會，展開一系列演講和活動，意在提升全民觀察興趣和敏銳度。近期學會籌畫了尋找河神——文山區文史實境遊戲，也預計在今年秋季邀請日本路上觀察界極推崇的林丈二來台舉行分享會。</p><h2 id="台南路上觀察團"><a href="#台南路上觀察團" class="headerlink" title="台南路上觀察團"></a>台南路上觀察團</h2><p>在眾人鼓吹之下，台南路上觀察團亦於 2015 年四月在府城成立，除了書籍共讀，也探索特定場域和議題，試圖激起人們對社會、環境的討論，並且透過這些行動定義屬於居民，而非媒體、政府欲營造的台南形象。例如去年他們就號召關心城市發展的民眾一起紀錄將拆遷的舊魚市場周邊可能消失的景物，同時講述河岸歷史與開發計畫，引領大眾思索對家鄉的期許。</p><h2 id="路上觀察學院"><a href="#路上觀察學院" class="headerlink" title="路上觀察學院"></a>路上觀察學院</h2><p>相對於前兩個重視行動和集會的團體，出版社的路上觀察學院是在臉書上純粹的分享平台，成員有萬餘人，至今仍保持穩定發文量。</p><p>在社團剛創立時，貼文仍循著前輩建立的範例，多半紀錄些在地的人孔蓋、新種類湯馬森或有設計感的號誌等。之後愈來愈多人加入，也累積愈來多內容，但多樣性卻沒有隨數量顯著提升。近期貼文有追求新奇的趨勢，這可能是多數分享者沒有主動觀察的緣故。</p><p>社團內的報告可歸類為誇張的商業廣告、文字遊戲（藉由諧音、錯誤讀序、添字產生趣味）、隨機秩序（借位構圖、物品意外地整齊排列）、異常和矛盾（例如無障礙坡道被圍欄封住），它們的共同特徵是引人注目。推測發文者是在通勤或逛街途中被路上顯著物件吸引，於是隨手拍照上傳，所以發文內容逐漸偏向新穎事物，忽略了較不突出的東西。由於不脫那幾種類型，同類型內又有新奇程度差異，久而久之就成了老梗，不再那麼吸引人。</p><p>然而能帶來趣味的不只有新奇，有些樂趣在需要人們空出一段時間，抱著好奇心才能留意到、投入心思才能發現隱藏的樂趣。以郵筒為例，如果不是主動關心，那只有被招牌砸彎的彎腰郵筒會因為新奇而爆紅。但是如果仔細觀察各地的郵筒擺設方式和位置，就會發現有的綠色郵筒孤身一人，有的紅綠郵筒倆倆倚偎，即便是倆倆一塊兒的郵筒，也有負氣吵架背對而立者和親膩面對面者。</p><p>因為個人奇想和多樣本比對，讓原本不起眼的郵筒浮現新的關注點，社團內的資料正缺乏敘述和統整，所以儘管累積了很多圖片（甚至有重複），卻沒有從中挖掘出像湯馬森那般新種類的物件。</p><p>這可以算路上觀察嗎？</p><p>另有一些有違路上觀察精神的貼文。首先是廣告文，路上觀察鼓勵人們看見事物用途外的元素，但廣告本身即為吸引人注意而生，例如：「夾不到娃娃屋」、「超難吃便當店」，若觀察者沒有從中看出其他意味，那分享這些招牌不就掉入宣傳的陷阱了嗎？</p><p>其實不只廣告文，還有少數沒有實地觀察，直接轉貼的照片，以及偷渡奇怪議題的貼文，我不太喜歡這種現象，不過硬是畫分界線也有違路上觀察的精神，畢竟從考現學以來，這項學門不曾嚴謹地規範愛好者的活動，而是以「追求趣味」的宗旨連結許多愛好者。路上觀察在日本已有多樣面向，飄洋過海到台灣後，發展出觀念推廣、關懷議題和趣聞分享等不同樣貌。或許這樣才是常態，因為路上觀察學是由大眾的行動和想法定義，而非一個權威決定。</p><h1 id="我的考現學報告"><a href="#我的考現學報告" class="headerlink" title="我的考現學報告"></a>我的考現學報告</h1><h2 id="圖書館的考古學"><a href="#圖書館的考古學" class="headerlink" title="圖書館的考古學"></a>圖書館的考古學</h2><p>第一次讀這本書是大學一年級的時候，那陣子常常飯也不吃，趁著午後空閒帶著筆記本到圖書館去，既不為觀察建物，也不為調查行人動向，我只想要尋找書中不屬於作品的種種。</p><p>一本書除了傳達作者想法的文字外，不免會有歲月造成的黃斑與磨損，隨著每次借閱也能看見文明的痕跡：官方訊息、分泌物、昆蟲以及粗心借閱者遺留的物品。我最感興趣的是被棄置在書頁中的紙張，它們就像拋向宇宙的無線電波、漂浮海中的瓶中信或跌落泥沼的恐龍一樣，一埋就是好久好久，直到有緣份的人將這些訊息從遺忘掘出。</p><p>或許這聽起來不像典型的路上觀察學或考現學，但我在附近的書店翻完這本書時，覺得它很貼切地描述了我的行為。雖然空間的尺度從街巷轉換到書架上，可是同樣用另一種眼光看待脫離原本脈絡的物件啊。我總是把圖書館想像成考古據點，架上的書是不同地層，有的書很難讀（硬度），有的書很多冊（深度）各有各的特性，而我自己則是個挖掘文物的考古學家，享受找到時光膠囊的樂趣。</p><p>我的母校雖然歷史不長，可是和鄰近學校合併後收納了不少老書，因此藏書量其實很豐富，然而我沒辦法調查所有的書籍，當時推測借閱率越高的書越容易夾藏東西，所以從日本文學專櫃開始。我把筆記本掛在脖子上，從這頭到那頭，一本本地翻閱，紀錄找到東西的同時也記錄翻閱冊數、分類號和作家名稱，因為我覺得這些東西應該和物件出現率有關，也許能歸納出一些規律來。至於我都找到些什麼呢？撇除本來就夾在書中的廣告單，至少看過外國車票、同學會名單，還有一封情書，可是怎麼會有人把這麼重要的東西亂丟呢？</p><h2 id="小小的研究成果"><a href="#小小的研究成果" class="headerlink" title="小小的研究成果"></a>小小的研究成果</h2><p>回顧當時的紀錄，我的研究效率顯然不怎麼樣。如同整理自家書櫃，一旦看到有趣的書便會讀得如癡如醉，忘記原本的目的。而且我也不是全然專注在蒐集上，約七成時間耗費在空想「圖書館考古學」的細節，在一旁的自習桌上，用潦草的筆跡記下不存在的理論以及支持這些理論的虛擬教授，還有他們無關緊要的爭論。當時讀了什麼就往一股腦兒往裏頭塞，於是創造出「總體圖書館考古學」、「滅絕係數」、「群論」之類千奇百怪的專有名詞。</p><p>後來我對借閱者留下東西的現象越來越感興趣，以我們學校圖書館的日文區來說，有5%的書籍中夾藏物品（調查了約一千本而已），它們是什麼時候放進去的？能經過幾次借閱而不被移除？這些問題沒辦法單靠觀察得出答案，所以我買了一些漂亮的卡片放在一些書中，試圖從實驗中看出端倪。</p><p>其中一個計畫是研究夾在「錯置書」的物件究竟可以放多久。錯置有好幾種類型，擺錯位置、編錯分類號，當中最棘手的是貼到別本書的標籤，導致網頁上顯示的資料和實際不符。想要找這本書的人在網路上搜尋不到正確位置，因為出現在錯誤的地方，在該區瀏覽的讀者也不會拿來讀，所以借閱率應該非常低。因為沒找到其他錯置書，所以只能主動下手，當時還很擔心萬一有人也在圖書館裡蒐集這些物件，會不會干擾實驗結果，不過是我多慮了，這書真的如我所料到畢業前都沒有人借來看，藏在當中的卡片仍好端端留在原處。　</p><h2 id="嚴肅起來就不好玩了"><a href="#嚴肅起來就不好玩了" class="headerlink" title="嚴肅起來就不好玩了"></a>嚴肅起來就不好玩了</h2><p>圖書館考古（現）學一直進行到升上大二，漸漸覺得原本享受找東西的愉悅消失了，為了模仿正式的學科，一再添入的嚴謹性反而成為一種壓力，所以心裡想著「該把這樣的衝勁和好奇心放在專業上」，將找到的東西歸檔後封存起來，結束午後跑圖書館的日子。</p><p>最近整理雜物的時候又翻出那時的筆記，想為中斷的研究作交代，於是寫下這篇文章紀念曾經無憂無慮的自己，留下曾「認真幹些沒意義的事情」的證明。</p><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li>(2014)〈 <a href="http://forgemind.net/media/archives/1768">日本建築師藤森照信帶領「台北路上偵探團」觀察城市裡的枝微末節</a>〉。準建築人手札網站 Forgemind ArchiMedia</li><li>五十嵐祐紀子 (2011)：〈<a href="http://mypaper.pchome.com.tw/liulanggou/post/1322057862">進行路上觀察的好處</a>〉。革命的戰場，正是我們的餐桌！</li><li>林承毅 (2015)：〈<a href="https://www.slideshare.net/taipeitsoc/20150426-47725440">原來我們同在路上觀察這一路</a>〉。</li><li><a href="https://www.slideshare.net/taipeitsoc/20150426-47725440">台北路上觀察學會 TSOC</a></li><li>洪瑞琴 (2017)：〈<a href="https://news.ltn.com.tw/news/life/breakingnews/2051945">「台南路上觀察團」為保留81歲台南魚市場發聲</a>〉。自由時報</li><li><a href="https://www.facebook.com/flaneur.culture.lab/photos?tab=album&album_id=10152087002937913">路上觀察學入門試閱+路上觀察手冊</a></li></ul><hr><p> 赤瀨川原平, 藤森照信, 南伸坊 （2014）。路上觀察學入門（嚴可婷、黃碧君、林皎碧譯）。行人。（原著出版於 1986 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> modernology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《微國家：獨立建國的簡易操作手冊》</title>
      <link href="/strauss-2008-how-to-start-your-own-country/"/>
      <url>/strauss-2008-how-to-start-your-own-country/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這套書由方法篇和實踐篇組成，作者在方法篇中分析五種可行的建國方式，繼而討論該用何種體制經營之，再列舉許多歷史案例，評論其成敗關鍵，最後探討個人建國的前景。實踐篇則是台灣出版社彙編的建國案例以及兩篇專訪，補充已不再更新的原著。</p><span id="more"></span><p>微國家並非梵諦岡或安道爾之類主權獨立但領土狹小的國家，也不同於我們這樣陷入爭議但確實存在的政治實體，微國家維基中將之解釋成任何欲取代、模仿或與既有國家共存的政治體，但僅單方面宣稱獨立，不受國際組織或其他國家承認。</p><p>雖然因現實條件限制，其規模通常不大且得立足於既有國家的主權範圍內，卻仍表現出構成國家的部分要素，例如公民、政府等，甚至有些微國家會發行自己的貨幣與郵票。顯然前述定義還是難以涵蓋多樣的微國家形式，不過原書其實沒有強調這名詞，其主題是無權無勢的市井小民該如何創建自己的國家，「微國家」只是暫時狀態而非追求的目標。</p><p>儘管作者著重於介紹手段，沒有談論建國動機，但是從訪談和議論中可以推測：建立國家的用意不全然是對抗政府，很大一部分是在反思既有的權力結構。當今多數國家仍依循民族主義的想法以共同的語言、風俗和歷史等要素凝聚國民，可是即便在同樣民族之下，國民間仍有許多歧異，各自代表不同的利益和價值觀，然而政府依舊積極地營造認同感，讓人民甘於滿足偽裝成國族的特定受益者（不一定是人民自身），不自覺地背負無關的責任與義務。</p><p>於是建立微國家就成為伸張個人主權的行動，表達對個人特質的擁護、對政府體制的懷疑和對隱私財產的堅持。即便無法動搖現狀，在自己的臥室經營模型國家也能起到轉變視角的作用，能從「外國」的視角審視政府以大眾為號召施政的用意和合理性，衡量自己（外國）會受到什麼衝擊，並採取適當行動。</p><p>目前建立國家的最大阻力來自既有國家壓迫，弱勢方不僅沒有容身的根據地，也無可靠的武力對抗傳統軍事動員，所以作者建議從依附強權的小國發跡，一方面只須和單一國家交涉減少複雜狀況，另一方面也能藉強國排除其他國家介入，或者與小國競爭強國支持。</p><p>不過作者推論這種情況會在幾世紀後隨著大規模殺傷性武器成本下降以及星際殖民普及有所改變，外太空將成為待開拓的新天地，大規模毀滅武器也會削弱倚恃傳統武力的國家之優勢。無法承受破壞的政府將因此妥協，於是愈來愈多野心家投入，掀起建立新國家的浪潮，最終導致民族國家式微。</p><p>這推論的前提是大國懾於威脅而向建國者妥協，因此建國者不僅要避免武器被破壞，也得讓大國相信他們擁有相應的報復能力和決心。這當中牽涉到不可捉摸的心理因素，若雙方情報量不對等或是具有同樣決心時，嚇阻的效力就會降低，此時相較於建國者，大國多了輿論操作、傳統兵力、諜報組織等行動自由，故就這點而言對建國者是很不利的。</p><p>此外，建國者不只要面對大國，還得與己方派系或其他建國者鬥爭，由於雙方皆不能承受核攻擊，唯一勝算是先發制人，當競爭者數量達到一定程度時，極可能出現莽撞動手的一方，所以即便已與大國達成協議，建國者間還未必能維持平衡。況且武力不是決定國家存續的僅有條件，微型國家的資源、人力和產業規模仍不及傳統國家，能否捱過經濟壓力仍是未知數。</p><p>當然，除了用武力當基礎的傳統國家，作者也提出了幾個克服領地或主權問題的建國方案，例如先宣稱獨立再和政府打官司的訴訟途徑，仿效吉普賽人擺脫政府管制的離群索居生活，抑或掛著獅子山及賴比瑞亞的船旗馳騁大海，雖不完整但仍擁有構成國家的部分要件。<br>　<br>最後，不管是採用常規還是非典型方式建立國家都不意味著能隱於世俗擺脫其他國家騷擾，建國是向世人表示自我的存在，因此從草創時期到後續經營都會面臨許多既有利益者挑戰。若不想受人擺布，就得主動排除外在干涉，處理內部爭端，在混亂的世局中掙扎求生。</p>]]></content>
      
      
      
        <tags>
            
            <tag> zatsugaku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSYCHO-PASS 心靈判官</title>
      <link href="/psycho-pass-anime-and-novel/"/>
      <url>/psycho-pass-anime-and-novel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《PSYCHO-PASS 心靈判官》系列包含電視版一／二季、劇場版、改編漫畫與小說（台灣僅代理本傳和標本事件前傳。），以下是電視、劇場版和本傳小說的心得。</p><span id="more"></span><h1 id="小說"><a href="#小說" class="headerlink" title="小說"></a>小說</h1><p>雖然融合了cyberpunk和動作元素，《心靈判官》的本質仍是反烏托邦小說，透過虛構一個由電腦系統主宰民眾職業、婚配甚至罪刑的究極官僚社會，再描述當中發生的種種矛盾以彰顯個人意志對人類的重要性。</p><p>故事背景是世界陷入經濟崩潰和政府解體的２２世紀，唯有採用希貝兒系統的日本倖免。希貝兒是由強化大腦連結成的平行運算系統（以下簡稱「系統」），挑選不受既有規範、情感、交際影響的超常人格者為成員，利用人類優於機械的圖像、氣質、……等判斷直覺，替代電腦執行判斷。</p><p>其宗旨是促成大多數國民的最大幸福，幸福在此定義成「不須面對抉擇」，由希貝兒代替人民作出最佳選擇。系統愈健全，裁決就愈精準，離理想社會也將更進一步。要讓民眾放心地接受系統裁示得先讓他們信任系統，所以為達成目的，它必須完善系統運作，甚至不擇手段提升效能。</p><p>然而追求完美並不可行，較實際的作法是掩飾失敗，讓人民誤以為完美。用虛擬顯影建立都市整潔形象，或隱匿不利資訊（其他可能的社會體制、存在免罪體質者），把反動分子和低層民眾驅趕到刻意留下的廢墟區，冠上汙名轉移市民焦點。對於無法處置或隱瞞的案例，如免罪體質罪犯，則納入系統周延判斷能力，同時消滅之。</p><p>儘管書中沒直接提到，但穩定的秩序也應是順利運作的前提。系統藉由監控全體國民精神狀況，揪出潛在犯案者處置，危害小者收容治療，無根治希望者就地處決。由此可知系統沒有定義什麼是「邪惡」、「正義」、「罪愆」與「懲戒」，維持治安就像免疫系統排除病原一樣，不論犯行，端看有無害處。刑警們是向百姓展示維安實力的棋子，他們辦理的案件也只是須優先解決的病灶。</p><p>角色和系統的認知落差即故事展開處。主角群由具潛在犯身分的執行官和監督前者的監視官組成，隸屬系統底下的刑事局，負責追查案件，並依系統判斷處置人犯。這些執行官是體制的受害者，因種種原因被剝奪正常人生和從前的生存態度，本作藉由他們質疑系統正當性和討論社會議題。例如前刑警征陸仍抱有舊時代的正義觀，對於以心靈指數定罪卻輕視證據的態度不以為然；前監視官狡齒則不忘殺死對方的是自己而非系統的指示。</p><p>各角色多少有表達異議，但最重要的提問者卻是反派槙島聖護，他在幕後策畫一連串案件，藉此質問人民一味聽從指示的扭曲社會中，是否仍存在個人意志和主體性。就像用案件發表一場演說，首先在金原祐治案中展示他的手段：不直接參與犯案，而是給予具有強烈動機的普通人超越法律或倫理的力量，觀察人們會不會基於自我意識越矩行動。<br>　　接著協助病態粉絲御堂將剛殺死偶像篡奪虛擬形象，可是御堂沒有善用這些理想形象，反而滿足於成為他人，在眾多虛假的面貌中迷失自我。另外，被殺掉的偶像能被粉絲取代，這不意味著「……每個人都是空虛的，不再有人需要他人，不論是什麼才能都能找到替代品，任何人都是替代者的替代者，……」那一個人還有什麼獨特性嗎？　</p><p>「刺激會帶來活力，那是與死毗鄰的危險報酬」、「……不知道絕望，就不會有希望。」王陵瑠華子支解屍體為素材，模仿父親的畫作，繼承其警惕世人的意志；泉宮寺豐久策畫人類狩獵，想在生死交關中強烈地感受到活著。槙島藉兩起案件拋出這議題：危險和壓力固然是痛苦的根源，但它們也是生存的證據；認知現實的晦暗與殘忍能喚醒理性與良知。用藥物控管心理狀況，紓解壓力並排除所有不良因子的同時，是不是也抹煞了生命？</p><p>泉宮寺豐久被處決後，槙島出現在主角常守朱面前，作勢要殺了她朋友。由於槙島是免罪體質者，心理指數不因犯案提升，所以常守朱不能用主宰者制裁，得用傳統火器擊斃他。但用其他武器的含意不只是違反規定，還代表她不能把殺人的責任推給制度，得獨自扛下。</p><p>「……，人只有在基於自我意志行動時才有價值。」</p><p>這就是槙島最後的提問：自主的個體得親自選擇未來並為此煩惱，同時承擔選擇的後果，害怕背負責任與風險而將之推給社會、推給希貝兒系統的民眾還稱得上人嗎？<br>　　<br>情節至此，已完整陳述這世界的矛盾，後半段則要揭露系統真相，指出其不得不為的理由，並且讓成長的常守朱從中得出最終結論。</p><p>槙島綁架常守朱的朋友是想觀察她會不會為了救人而自願背負不義，但是常守朱心中顯然還有其他顧慮：開了槍就等於破壞至今穩固社會的體制。然而她還是閉著眼睛開槍，似乎在逃避什麼，和狡齒的對話也曾提過「殺死對手的不是主宰者，而是我的殺意……」，所以推測初次面對矛盾狀況的她比較接近不敢攻擊。</p><p>事件過後她才漸漸堅定信念。她肯定體制的成效和必要，但不贊同其功利價值觀，想從中找回正義的理念；她亦承認反派對系統的質疑，但不認同視人命為草芥的態度，即便在系統支配的社會生存，人類仍然有寶貴的價值。</p><p>人們並非被動地活在規範中，如結尾所述：「不是法律守護人，而是人民要守護法律。」「我們憎恨罪惡，尋求正確人生的心情累積形成的就是法律。那不是條文，不是系統，而是存在於任何人心中，脆弱卻有無可替代的心情。相較於憤怒或憎恨的力量，可說是無比脆弱、極易碎裂。因此，為了不讓過去所有想創造出更美好世界者的祈禱變得毫無意義，我們必須堅守法律，不可輕言放棄。」常守朱想在全面破壞與死守體制兩種瘋狂之中，試著走出實際的路，所以她要阻止狡齒復仇，以免破壞體制，也主張加開法庭審理以維護法治。</p><p>從建立世界觀，點出爭議，到最終和解，《PSYCHO-PASS 心靈判官》已進行了一次漂亮的論辯。然而有些美中不足的是，因為以警察劇為軸，所以結尾只做出關於正義與法律的思辨，但角色的提問還涵蓋很多東西：自小被系統決定人生的騰秀星有選擇的自由嗎？「盲從系統決定的適性，滿足於被強加的幸褔」還可以保有夢想嗎？在系統呵護下，不需合作也能達成目標，彼此連結是否變得無關緊要？</p><p>這些議題也許會持續出現在往後的續作中，只是受限於主角的身分和性格，應該永遠都不會提出解答。</p><h1 id="電視版第一季"><a href="#電視版第一季" class="headerlink" title="電視版第一季"></a>電視版第一季</h1><p>我先看了電視版才補完小說，《PSYCHO-PASS心靈判官》的動畫節奏拿捏得很好，每集都斷在令人在意的地方，數集描述一個事件，同時也逐步醞釀最後的大陰謀。人設吸引人、配樂又好聽，雖然動作戲不多，但是懸疑推理的氛圍看得也很過癮。</p><p>小說和電視版最大的差異在於小說比較積極營造反烏托邦氣氛，一開頭就說明日本在系統治理下成了「理想的社會」，並且提到廢墟區的功能、人們依適性選擇職業、參考電腦配對發展婚姻（電視版要到第二季才提到。）。另外刪除六合塚來歷以及國營企業命案兩個支線，並且加入番外篇描述其他成員間的關係。</p><p>小說把角色心理描寫得更細，亦補充說明一些電視版較含糊的地方，例如「為什麼不拘捕犯人追查共犯？」、「霜月明明認為王陵琉華子很可疑卻推好友入火坑？」、「全身義體化的泉宮寺豐久還測得到心靈指數嗎？」、「為什麼用人腦而不是用電腦當主機？」</p><p>其他零零碎碎的相異處還很多。我印象比較深刻的是介紹標本事件時，電視版的六合塚在吃泡麵，可是小說中卻在喝能量飲料，沒有提到六合塚喜歡更變態的東西。</p><h1 id="電視版第二季"><a href="#電視版第二季" class="headerlink" title="電視版第二季"></a>電視版第二季</h1><p>在希貝兒系統建立前，日本政府曾打算藉由監控人民行動和經濟活動預測犯罪，設施完成後在交通網路試作。然而這項建設卻被厚生省蓄意干擾，使得監控系統失靈，導致嚴重交通事故頻傳，最終棄置原先計畫轉而採納厚生省支持的希貝兒先知系統。反派鹿矛圍桐斗正是其中一場意外的倖存者，但他並非一個體，而是由罹難者的遺體和大腦拼湊成的集合體。</p><p>因為系統自知的其心理指數超標，若採計集體心理指數將不得不審視自己的統治合法性，故默認集合體的心理指數為空，讓自己可不受監督，維護體制完整，可是這麼做也使他們無法監測同為集合體的鹿矛圍，對其舉動束手無策。</p><p>鹿矛圍的目的是逼迫系統計算集體心理指數，將系統自身列為制裁的對象，然後用主宰者毀滅之；另一方面，也能藉此得知自己的心理指數是多少。他利用降低心理指數的技術，培養出一批接近免罪體質的犯罪者，由於系統無法透過收編他們解決問題，又不能坐視動亂不管，只能選擇對付鹿矛圍。</p><p>倘若循體制內作法，會危及執法的正當性；若無視規則私下解決，便間接承認系統侷限，同樣會重挫民眾信心，動搖社會的基礎。面臨兩難的系統分為兩派：東金母子黨打算越過程序殺人滅口，凌虐小朱祖母嫁禍鹿矛圍，想激怒常守朱除掉他。其餘成員則採納常守朱的建議：承認集體心理指數的同時，自主汰除不良分子，讓心理指數穩定在正常範圍內。</p><p>最終東金母子挫敗，鹿矛圍雖然戰死但成功迫使系統納入監督體制。系統暫時度過危機，卻也種下新危機的種子：個體和集體心理指數不一定一致，純淨的心可能聚集成混濁墮落的組織，純淨的群體也可能由罪大惡極者組成，為了制裁一個團體，要傷害其中無辜的個人。目前仍無法計算社會的集體心理指數，一旦社會心理量化的那天來臨，或許會因此引發更大的混亂。</p><p>第二季的野心很大，試圖討論集體與個體心靈指數關係以及執法者的統治正當性，只是劇情安排和人物刻劃搞砸導致風評很差，但這是和第一季相比的結果，單獨看的話其實還可以。</p><p>剛看完時覺得這回的反派不夠有力，雖然鹿矛圍立意明確、計畫縝密，但和槙島聖護「英雄式預言者式的氣質，創造愉快交談空間的能力，對任何事物都能抒發己見的智力」的領袖氣質相比，還有很大落差。</p><p>從犯案動機來看，鹿矛圍是純粹功能導向的。首先挾持酒酒井監視官測試自己可否操作主宰者，於藥局人質事件中驗證監視官一樣會被制裁，繼而引誘刑事局落入埋伏奪取主宰者，最後藉由濫發主宰者造成運算負荷，推算出系統核心位置，帶領一批人發動總攻擊。完美、精準而且確實，但少了槙島那種質問世人的戲劇性。</p><p>而且槙島在第一季有很多表達意見的場合，除了主線另有狡齒的私仇這條支線；可是鹿矛圍似乎礙於篇幅沒辦法充分表現，只能作為被追捕的對象成為角色間的話題。</p><p>不只反派，其他人物也刻畫不足。加入和常守朱意見相左的霜月監視官可能是想營造觀念衝突，但霜月不管做什麼都被打臉，僅成了為主角實力背書的祭品（還有觀眾唾棄的對象）。而犯罪指數史上最高的東金執行官，剛開始似乎有填狡齒缺的氣勢，但劇情跑到最後被證明只是一個病態的嬤控。至於六合塚和新人物雛河翔則沒什麼存在感，默默地做事默默地被淡忘。</p><p>再來提主角常守朱。先前宜野座、征陸、狡齒各司其職，但這一季宜野座被削弱得比較圓滑，其他人物又沒什麼影響力，所以前一季的所有屬性都灌到常守朱身上，化解觀念衝突也減少了劇情張力，最後看起來就像她一個人在東京開無雙。</p><p>要挑毛病的話，還可以從犯案方法、追捕手段、……等找瑕疵，但覺得點到為止即可，若不是寫心得比較兩季動畫，我根本不會看得這麼細，音樂播放、槍戰開始的時候我就陷在故事裏了。僅提一點之前覺得是bug，但後來覺得沒問題的地方：最後對峙時，系統排除惡性成員降低心理指數，讓鹿矛圍無法攻擊它。可是若鹿矛圍真想瓦解系統，為何不用其他冷兵器攻擊？</p><p>我想一想，鹿矛圍不是單純想毀掉系統，他要讓系統自毀，也就是毀於自己的審判機制，這樣才能強調他的訴求「執法者也要被監督」。</p><h1 id="劇場版心得"><a href="#劇場版心得" class="headerlink" title="劇場版心得"></a>劇場版心得</h1><p>劇場版時間點接在第二季後，但可以獨立觀看。這次的舞台在海外，東南亞聯合政府打算從日本引進希貝兒系統，借重其監控設施和無人武裝弭平內亂。刑事局一課逮捕來自該國的恐怖分子後，發現逃亡的前執行官狡齒涉入動亂，於是派遣常守朱前往調查。</p><p>在調查中意外揭發東南亞聯合政府軍方隱匿己方異常的犯罪指數，濫用系統鎮壓反對派。東窗事發後，政府方早一步捉拿常守朱欲除之後快，所幸來自刑事一課在危急時趕上，一舉掃蕩軍中的潛在犯。原來，這一切都在系統的策畫中，為了平定鬥爭局面需要利用政府軍的力量，故先前刻意縱容，一旦時局較穩定則解決這些惡徒，收回控制權。</p><p>雖然劇場版也有要討論的議題，例如統治的合法性、動亂國家的悲哀、手段正當性……等，但都沒辦法充分展開推論。另外人物塑造不深刻，前頭把反抗軍首領講得很重要，很能鼓舞人心，後頭卻草草地收了他。政府軍上校看起來是個有故事的人，卻什麼主張都沒有提就被殺了。</p><p>所以這部的重點還是小朱和狡齒重逢、宜野座與狡齒的man talk以及滿滿的武打駁火吧，至於劇情深度和合理性就其次了。</p><p>明年的三部劇場版分別以霜月／宜野座（罪與罰）、征陸／須鄉（Frist Guardian）、狡齒（恩仇的彼端）為主軸。征陸的故事應該會描述系統建立前的社會景況，而霜月那部正好補充這角色先前不足的形象。希望不只是單純動作戲，也能從不同角度考察希貝兒治理的世界，畢竟心靈判官的設定其實有很多題材可以發揮啊！</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科學的終結</title>
      <link href="/5uperb0y-2018-the-end-of-science/"/>
      <url>/5uperb0y-2018-the-end-of-science/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>　　Ｎ大學位於港都郊區，創校已五百餘年，即便科學風潮日衰，始終維持嚴謹學風，作育無數英才。</p><p>　　期中考前兩天，大學三年級的Ｓ生無精打采地坐在學生餐廳裡，一面思考難題，一面味如嚼蠟地扒著咖哩飯。瞥見同班的Ｒ生，便端著餐盤上前打招呼：「哈囉，Ｑ今天怎麼沒來上演習課？」</p><p>　　「聽說已經犯感冒還熬夜準備考試，在家暈倒送醫了。」</p><p>　　「他怎麼這麼堅持啊！」</p><p>　　「畢竟出生地方有名的書香世家，除了校內的競爭，還有來自家庭的壓力。」</p><p>　　「難怪他不顧身子，拚了命也要爭得好名次，若一時怠懈，恐怕要被後輩追過。」</p><p>　　「唉，不過這時也顧不得Ｑ了，上周的作業我想半天仍找不出頭緒，待會兒怕是要開天窗囉。」Ｒ懊惱地扶著額頭，「你呢？你寫完沒？」</p><p>　　「原來連你也碰壁了，虧我剛才還想請教你。」Ｓ生把餐盤放到一旁，自背包拿出厚厚一疊草稿紙，上頭寫滿方程式與註記。「已經在封閉條件下證明羅姆尼第七十三定理，但一直沒辦法將適用範圍推廣到開放空間。」他指著一條重寫過無數遍的式子。「這裡似乎要先以柱座標表示原式，再套用佛蒙特規則計算。雖然這麼做可以得出定理的原始形式，但會多出一組不能化簡的無窮級數。」</p><p>　　「讓我看看，」Ｒ把Ｓ手上的卷子抽來仔細檢查。「你的算法跟課本不一樣，還蠻特別的……嗯，我懂了，這邊用柱座標不好解，以極坐標系套用萊頓公式會比較容易。」</p><p>　　「天啊，還有萊頓公式？這應該是國中內容吧。」</p><p>　　「起初我也沒想到這點，見到你的計算過程才靈機一動。」</p><p>　　「新課題這麼重，還要回顧這麼久以前的知識，我開始覺得這輩子讀不完……算了，時間也差不多，把作業留到課後，我們走吧。」</p><p>　　「你的咖哩飯還沒吃完喔。」　</p><p>　　「應該是老了，吃不太下。」</p><p>　　「說什麼傻話。」</p><p>．　．　．</p><p>　　「這次要推導伯納德定理第一千七百五十二引理，請同學務必留意它和戴森定理第九千零八十二引理的差異。」</p><p> 　　「老師，這些難道無法統一成簡單和諧的系統嗎？」面對龐雜的知識內容，Ｓ生絕望地提問。</p><p>　　「這問題很好，然而答案可能要令各位失望了：這些知識體系無法整合成統一理論。既然課程不趕，容我岔開正課，替同學簡介兩百多年前朗拜爾的研究，他證明科學是發散而不是收斂的。」</p><p>　　「發散？」</p><p>　　「很特別對吧？詳細證明留待研究所的課程說明，目前你們只需了解如今物理體系龐雜笨重，而且動輒數千則定理數萬條公式的原因為何。」</p><p>　　「讓我們引用蘇格拉底的比喻以理解問題。圓形內部是已知事物，外部象徵未知事物。」老師在黑板上畫了大小不同的圓形，「相較於小圓，大圓雖然具有較多已知部分，然而它的未知部分也比較多。」</p><p>　　「從前的學者在知識邊緣朝外探索，逐步擴大人類對世界的理解。然而隨著疆界擴張，將和這裏的大圓圈一樣觸及更多未知，引發新的研究課題。</p><p>　　「但是知識能無限擴張下去嗎？撇除社會因素和認知界線，在前人的基礎下朗拜爾證明了理論上未知是無窮的，知識擴張也同樣無止盡。」</p><p>　　「老師，可是有些科目似乎不符合這個斷言。」</p><p>　　「是的，你沒注意到學校很早就裁併生物學和醫學部門嗎？關於這點學界也論戰了許久，總而言之，描述性、歷史性科學的未知部分是有限的。我們並不期待人體解剖學在維薩里後一千年還能有什麼新意，自然史也只有一種樣貌。它們的差異在於前者發展到最後可以周延未知部分，而後者的發展因技術和線索限制，只能盡可能趨近事實，但不等於事實。甚至有些科目，例如四維生物學，我們離知識全貌還很遠，但基於三維生物的限制，我們的研究只能停在這個階段。</p><p>　　「然而物理學卻不是如此，朗拜爾指出物理學，精確地說是廣物理學的未知部分沒有疆界，每項成果都將觸及更多新難題。」</p><p>　　「這代表我們永遠也得不到真相嗎？」</p><p>　　「可以這麼說，人類的理解會越來越深，但無法抵達終點，自此研究物理將是永恆的追逐。這並非悲觀的事實，對於年輕的科學家而言，即便物理理論逐漸脫離經驗常理，甚至看似彼此矛盾，但他們不會像化學家、地理學家、生物學家一樣看到學科的黃昏。</p><p>　　「這種發散性質要以複雜為代價，千萬條公式、交錯互補卻無法替代的種種力學體系。也許２１世紀的物理學家看見這樣龐雜笨重的物理學會因為美感而放棄研究，但我們的未來就在這裏頭。</p><p>　　「你們大學生首要目標是努力了解現有知識的全貌，盡可能接觸人類知識的邊緣，然後在研究所中朝未知邁出小小一步，然後用盡一生作出點突破。</p><p>　　「回歸課題吧！待會講解的應用是將來研究的基礎，這裏要應用高等胞物理學的定理，先記下用法，之後再好好理解原理。剛剛講到哪裡了？好，我們從第五千七百七十六引理講起……」</p><p>．　．　．</p><p>　　Ｓ和Ｒ兩人走在回到宿舍的路上，Ｓ回想起課堂的內容不禁感嘆：「朗拜爾真是舉世無雙的天才啊。」</p><p>　　「我查完他的簡歷，沒想到主要研究在他大學期間就完成了。」</p><p>　　「真不敢相信……要是我們恐怕到畢業都還做不出任何有意義的貢獻吧。」</p><p>　　「不要說做出貢獻了，能不能順利畢業我看都是個問題。」</p><p>　　「講什麼不吉利的話，想點樂觀的事吧，倒是說說畢業後想做什麼啊。」</p><p>　　「仔細想想我們研究的東西已超出人類能把握的範圍了，兩百年來的研究到目前為止都沒有產生實質應用。上週不才報導政府又削減了科研預算嗎？其實我想著轉系和我弟弟一塊兒務農，不過現在恐怕太遲了。」</p><p>　　「你想得太晦暗了吧？不提這了，我急著回房讀考古題，咱們考前見！」</p><p>．　．　．</p><p>　　考試當天，Ｑ生仍未出席。考後Ｓ和Ｒ決定一同到醫院探望他。</p><p>　　「你不乖乖養病，還讀這麼重的書啊！」Ｓ拿起桌上的教科書瞧一瞧。</p><p>　　「不過是上課影帶後面的補充資料罷了，趁在病床上不用打理生活多讀一些。咳、咳」</p><p>　　「我們把上課筆記帶來了，這次考試不簡單喔，你補考可要多加油。對了，你的家人呢？」Ｒ把硬碟交給Ｑ，還調侃了她一番。</p><p>　　「他們出外買點心，待會兒就回來了……啊，他們到了。讓我介紹一下吧！」Ｑ熱切地說</p><p>　　「這是讀小學４６年級的曾孫、這是讀國中１２年級的孫子、這是剛升高５的女兒。」</p><p>　　接著是他們不絕於耳的問候「叔叔好」、「叔公好」、「曾叔公好」</p><p>　　「喔，好好好！」</p><p>．　．　．</p><p>　　結束拜訪後，Ｓ和Ｒ走出醫院時又閒聊一番。</p><p>　　「唉，還是勸不動他那老骨頭，再這樣下去還沒踏進研究院就要先歸西囉。」</p><p>　　「是啊，若不好好養生，可念也念不完。」</p><p>　　「最近找到一家不錯的中醫，他們的針灸還挺有效的，要不要明天放假我們一起去？」</p><p>　　「好啊好啊，這身腰酸背痛也該找人看看了。」</p><hr><p>5uperb0y（2018）。科學的終結。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡西尼號與行星保護</title>
      <link href="/planetary-protection-rules-and-the-end-of-cassini-probe/"/>
      <url>/planetary-protection-rules-and-the-end-of-cassini-probe/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>歷經20年的太空旅行，美國航太總署（NASA）的卡西尼號（Cassini）太空船今天將最後的訊號傳回地球後，高速衝撞土星，以分解蒸發的壯烈方式，結束13年的土星任務。</p></blockquote><p>卡西尼號是艘軌道探測船，任務結束後沒有能量脫離行星軌道，所以不能像飛掠探測器一樣（航海家 II）飛向深空。它會留在土星系統中，最終因為故障或其他緣故減速而失控墜入土星或其他衛星。</p><p>然而土星的衛星中有幾個可能有生命存在（尤其是土衛六泰坦），所以主動讓卡西尼號墜入較無生命可能的土星中，以免滅菌不徹底的機體造成汙染。不過，這種壯烈的自殺已經不是第一次了，2003 年伽利略探測船也為保護木衛二歐羅巴而撞入木星濃厚的大氣層中。</p><p>雖然這邊只提到墜毀階段，其實所有的太空任務都有防止生物汙染其他天體的措施，不過依照天體性質和任務類別可以分為五類。此處，我把重點聚焦在分類的依據和理由，而不是防範措施（詳細作法可以在厚厚的行星保護指導手冊中找到。）</p><h2 id="第一類任務"><a href="#第一類任務" class="headerlink" title="第一類任務"></a>第一類任務</h2><p>第一類任務是飛掠、繞行或登陸月球、水星和多數小行星，這些天體沒有足夠的液態水維持生命，所以除了例行消毒外，探測船並不需特別處理。</p><h2 id="第二類任務"><a href="#第二類任務" class="headerlink" title="第二類任務"></a>第二類任務</h2><p>第二類任務則涉及那些可能沒有生物，但是對於生命起源研究有重要參考價值的天體。例如：土衛六、金星、類木行星和彗星。</p><p>2014年羅賽塔號登陸彗星就是第二類任務。那次任務檢測到了胺基酸、醇類等有機物，它們很可能透過彗星撞擊為早期地球帶來形成生命的必要分子。（這些有機物質可能是彗星經過星際塵埃時沾上，或是經過恆星附近起反應形成的。順道一提，首次在星際中發現胺基酸的是師大的管一政教授喔！）</p><p>雖然金星現在因為失控的溫室效應已經成為高溫煉獄，但是在太陽還沒今天熾熱、溫室效應也沒失控前可能存在一段宜居的時候。另外金星大氣層中有個溫度合宜，且有硫化物補給的區間，若當初有生命誕生，也許能在此續命。相關任務有 2015 年 ESA 的金星快車（繞行任務）和先前蘇聯因大氣壓扁而早夭的登陸任務。</p><p>土衛六和土星因為可能有液態水、有機物存在所以同屬二類，但是土衛六多了可棲息的表面以及大氣層中的有機反應，所以研究價值還好過土星。本次墜毀的卡西尼號曾在 2005 年釋放惠更斯探測器登陸土衛六，可惜登陸不久便失聯了，所幸有留下空降時和登陸當下的照片，大家可以找看看，我覺得看起像是乾涸的水庫……</p><h2 id="第三類任務和第四類任務"><a href="#第三類任務和第四類任務" class="headerlink" title="第三類任務和第四類任務"></a>第三類任務和第四類任務</h2><p>第三類是火星和歐羅巴（木衛二）的「繞行」、「飛掠」任務，這兩天體是太陽系內最有可能找到地外生命證據（無論死活）的地方，執行第三類任務的太空船都要經過嚴密滅菌才行。</p><p>火星過去可能有水流、磁場和大氣層，這些都是利於生命誕生維持的要素；即便是今日，生物也可能在岩石與冰層間的夾縫中生存。另一個誘人的證據是1984年找到的火星隕石 ALH84001，上頭有疑似細菌化石、生物代謝排遺。</p><p>歐羅巴冰層下可能有液態水層，這些水層不僅和岩層接觸促進物質互動（而土衛六可能是隔絕水層），也能隔絕致命輻射保護生命體。</p><p>由於這兩顆天體可居，即便沒有原生種，也擔心地球生物在上頭大肆繁殖影響後續監控，所以火星與歐羅巴的「登陸」升級為第四類任務。</p><p>雖然我們猜測火星很可能有生物，可是1976年的海盜I&#x2F;II登陸任務卻沒有發現關鍵證據。因為第四類任務的預備很麻煩，所以為了往後探測任務方便，又把它分為三個子類，滅菌等級漸增：非適居區登陸（防止地球細菌汙染火星）、生命探測任務（防止地球細菌干擾實驗）、適居區登陸（防止雙向汙染）。</p><h2 id="第五類任務"><a href="#第五類任務" class="headerlink" title="第五類任務"></a>第五類任務</h2><p>至於第五類則是所有回收太空船到地月系統的任務，涵蓋月球是因為它是將來重點開發區域，若受到地外生物汙染，登陸月球會升級到二三類任務，太空船多了一堆滅菌要求會讓開發變得十分不方便。前陣子 NASA 招募的行星保護官就是要專職這種任務的調查工作。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後提一提行星保護的規範。最早是寫在聯合國於 1967 年制定的《關於各國探索和利用包括月球和其他天體在內外層空間活動的原則條約》當中的第九條：<br>各締約國從事研究、探索外層空間（包括月球和其他天體）時，應避免使其遭受有害的污染，以及地球以外的物質，使地球環境發生不利的變化。<br>詳細指導方針則由國際科學理事會下轄的太空研究委員會負責負責。</p><p>由於當時台灣還沒退出聯合國所以也簽了這條約，想看詳細內容可以去網路上查中文的手寫文本。雖然台灣至今仍沒有進行任何登陸任務，不過得知我們也曾籌畫整個宇宙開發的小小部分，仍有莫名的參與感。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life in the universe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>〈老表〉</title>
      <link href="/5uperb0y-2016-utopian-education/"/>
      <url>/5uperb0y-2016-utopian-education/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>　　夢臨市的天空是電腦的顏色，電腦死機的蔚藍。</p><p>　　「人終究會走出自己的路來。」眼前就有一條長廊，路面被通勤者腳步給蝕刻出間格規律的腳印，老表在雜遝足跡中找到屬於他的坑，踩著五十年如一的步伐來到一座有一百三十七層高的藍紅色建築物，正門上方寫著幾個大字：中央教育測驗服務社(CETS)。</p><span id="more"></span><p>　　大樓坐東朝西，插滿因巨大流量而肥腫的動靜脈，不安、臉色鐵青的孩童比肩繼踵地往內流動，形成樓外粗枝交錯的青筋；從大樓伸出的管道則注滿自信得意面容紅潤的孩童，他們在社會的肝臟中成熟，最終送往社會的大腦、社會的肌肉、社會的腎臟和社會的肛門。</p><p>　　夾在地底志留紀筆石與泥盆紀裸蕨間的是大樓負四十二層，適性教育中心。穿過緩衝道是一座兩千公升的儲存槽，槽身有一半被拖入地底，一條條銅線將濃度、溫度與酸鹼值等參數傳入檯座上的監控幕。三架人形機具頂著清潔罩，外披屍白色辨識裝小心繞過儲存槽，全神貫注地把一塊塊磚頭運進隔離室，除了齒輪回應齒輪，這兒就只有攪拌子在槽內轟隆旋轉的聲音。老表的辦公室〈也是諮商室〉就在隔離室隔壁，門旁停靠一台拙夫腳踏車，上頭垂掛著棉製內褲、塑膠護手和一套無塵制服。辦公桌上批不完的公文堆積成山，一份紅色封套的急件從天花板的轉送口墜落砸在山峰，連同一大捆文件從桌沿嘩啦啦沖下，激盪出迷濛霧霾；灑落地面的文件淹沒桌腳氾濫到走道、沙發甚或流進休息室，文件的河流最終在辦公室沖積出一塊纖維平原，失去動能的那封急件恰好在老表腳前沉澱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　﹝機考成績﹞ </span><br><span class="line">　　姓名：灰仔(13,男性)</span><br><span class="line">　　羅格標準智商指數：五十(底標)</span><br><span class="line">　　霍蘭德興趣偏差：正負零點零八六(無取向)</span><br><span class="line">　　柯賽人格氣質量表：？？？(不鮮明)</span><br><span class="line">　　HSF測驗：V項，三十四分；Q項，十五分；AW項，零點五(失能)。</span><br></pre></td></tr></table></figure><p>　　「哦喔。」老表打了嗝，往背面翻去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　﹝問卷紀錄﹞</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的志向是什麼？」</span><br><span class="line">　　受測者：「……」</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的興趣是什麼？」</span><br><span class="line">　　……</span><br></pre></td></tr></table></figure><p>　　還沒讀完，護理機器人已把這位男孩帶到老表面前。</p><p>　　「除了視力、體脂率過高和手指頭長期發炎導致的扭曲外沒有其他問題。」死板的聲音從機殼傳出，在老表點下確認鈕後滑步離開。</p><p>　　「灰仔你好，這邊……」老表一面說一面翻找那部可以讓人放鬆的儀器，把一大把文件移開後，終於在散落的紙張下找到。</p><p>　　「……這邊坐。」老表指著椅墊，但男孩似乎沒聽見，五感深埋實境頭盔裡，專心敲開磚頭挖出金幣，使勁踩爛長著獠牙又會跑動的香菇，吞下看得見陽光的花朵。</p><p>　　老表走上前，輕柔地抓住他的肩膀把實境機的電源關上，小心翼翼地把頭盔拆下，將他引到沙發去。斷離數碼世界，男孩的眼神空洞了十來分鐘才重新聚焦。「是雙機眼。」老表心想。義務教育絕種後，缺少定期眺望黑板休息的機會，無時無刻不死盯著藍光頻幕導致近視加深速度比換眼鏡還快。嫌麻煩的父母索性把歷經億萬年錯亂的達爾文實驗才長出的兩粒珍珠摘下，換上僅三十年歷史的電腦眼球。</p><p>　　老表再次拿出那份報告，從第一列掃視起。</p><p>　　「什麼時候才可以走？」</p><p>　　「一下子、一下子，只要回答幾個問題。」</p><p>　　「咦？」</p><p>　　「簡單的問題，幫助你找尋自我定位和生涯的目標。」</p><p>　　「哦？」</p><p>　　「我的意思是回答完你就可以走了。」</p><p>　　「哈！」</p><p>　　「不花十分鐘。」老表放下報告，安上鬧鐘，用紅筆在公文附錄的磚瓦實業廠職缺表上打勾。</p><p>　　「首先，你的志向是什麼？」老表啪嚓啪嚓踏過紙堆，來到門邊腳踏車旁，</p><p>　　「我要打電動！」</p><p>　　「那你的興趣呢？」把內褲遠遠甩到一邊，從坐墊上拎起無塵防護服抖落上頭的灰塵。</p><p>　　「我喜歡打電……」</p><p>　　「你的專長是什麼呢？」套上它，檢查外覆層上每個可能的縫隙，</p><p>　　「我會打……」</p><p>　　「你的理想是什麼呢？」走向儲存槽，把填充瓶注滿金黃色的「霓麻」，</p><p>　　「……」</p><p>　　「依照你的興趣和能力，我很確定你能把這份工作做好。」</p><p>　　老表嘴巴開合著，足像一具發條機器人不合節奏地吐出一個個標點符號。鬧鐘「滴滴滴滴、滴滴滴滴」作響，催促這場對話的結束。</p><p>　　「可以……走了？」</p><p>　　「是的，灰仔，你會在你喜歡的事物中找到未來。」疲乏的節奏，無力的嗓音。</p><p>　　男孩被帶到隔壁的隔離室，房間中央堆著他熟悉的磚頭。隨後門關上，鼓風機運轉，層流吹襲循環整座隔離室。老表熟練地背起噴霧器，一壓一放間，陳舊的幫浦發出哀鳴，噗嘶噗嘶地將霓麻撒在磚上，即使被隔絕在四層纖維之下，老表仍能嗅到那熟悉的甜味。霓麻在近地處積累，慢慢向上蒸騰成雲，最後將燈源與通風口遮住，陰影壓在兩人身上，佐劑和緩衝劑在瀰漫的雲中製造出驚人的化學電光，霓麻蒸發吸收了熱量使得隔離間溫度湊降，冰晶凝結在牆壁、手把、老表與灰仔呆愣的面孔上。飽和，再也容不下更多，氣氛死寂陰冷悲愁憂傷。第一滴雨跌落，兩滴，三滴，四滴，最終化成傾盆大雨，濕透男孩頭髮，衣服，每寸肌膚。</p><p>　　「這是什麼，好甜！」</p><p>　　老表並沒有回答，他徐步退後，從另一個出口離開。卸去一身負擔，累得轉不開水龍頭，勉強走到休息間把自己摔在床上，使不出拉棉被的力氣，虛弱得只蓋得上眼皮。闔眼前老表透過玻璃窗隱約看見男孩吸吮手指殘餘的霓麻，看他把上衣脫掉，頭承著衣服，雙手用力擰出汁來貪婪吞下。</p><p>　　「會找到，」疲憊無力，老表慢慢進入夢鄉「自己的……」</p><p>　　擠盡最後一口汁液的男孩注意到一旁疊放的磚頭，被霓麻結晶漆成金黃色，像極價值連城的金塊，他拋開衣服猛然撲上，以不協調的姿勢爬到推疊最高處，舔著，發狂舔著，滿心歡喜地舔著，曾經最愛的實境遊戲機就遺棄在旁。</p><p>．　．　．</p><p>　　老表從口袋掏出墨鏡戴上避免被星光曬傷，穿著海灘褲塗好防曬油的卡爾薩根乘著幽浮在眼前呼喚「要不要跟我一起同享這個宇宙與世代啊？」於是他開始奔跑，雖然沒有腳，卻有下身長出的兩條右臂。</p><p>　　其實也沒有地板，老表是在一條橡皮圈上團團繞，繞出時間的漩渦把他送回十三歲的時候，薩根的臉和適性教育中心的輔導長融合在一起。</p><p>　　「小表，你的志向是什麼？」</p><p>　　「星……」</p><p>　　「那你的興趣呢？」</p><p>　　「ㄒ……」</p><p>　　「你只是串會思考的芭蕉。」</p><p>　　連同蕉皮被丟進廚餘桶，老表依稀聽見幫浦抽放的聲音，感覺到霓麻在舌尖跳動的興奮。外頭年老者在街頭閒晃「高齡比七成，沒人力浪費的空間了。」從跨下傳來主任嚴厲的聲音「把對的人放到對的地方：智商指數頂標和HSF測驗頂標者，是為學者；人格氣質量表領袖類，是為企業家。至於沒有方向或方向錯誤的……失調者，」上班第一天，他坐在主任睿智的禿頭上。「是你的職責。」主任耳朵旁的頭髮將老表兩腿緊緊纏住，將他拖入腦漿中。從眼眶能清楚看到四點三光年外的半人馬阿爾法星，追逐上去！一條條物理公式擋在前頭，攀越直積高牆，撐起積分篙，用範數作筏橫渡空集合，絕對值大道在眼前開展變寬，星，就在不遠的地方。然而，根號勾住衣角，被圓周率絆倒，有理數沉沉壓在背上，從海馬迴、杏仁核與額葉聯絡區襲來的梯度與正則子群刺得他滿身是傷。</p><p>　　星星、符號、薩根、空氣漸速遠去，殘影紅移一路散逸微波輻射拖拉了數萬光年。現在這世界到處都是輔導長、主任和被霓麻漆成金黃色的噴霧器，熟悉的甜味周圍飄來，輔導長和主任喋喋不休地說著：</p><p>　　「照你喜歡的去做。」</p><p>　　「畢竟擅長打鐵卻偏要去念書是個悲劇，也是浪費。」</p><p>　　「會在你喜歡的事物中找到未來的。」</p><p>　　「輔導，是對失調者的社會救濟。」</p><p>　　「小表很適合當輔導師。」</p><p>　　 ……</p><p>．　．　．</p><p>才剛被昨天沒洗的衣服熏醒，老表又躺回去睡。</p><p>　　今天是一年一度的「輪休日」，適性中心黑壓壓一片。沒有對未來徬徨的小孩會送來，也沒有新的公文要蓋章，把工作當樂趣的時代，休息就成為義務。</p><p>　　這五個月來老表時常夢見符號、公式和掛在天上閃亮亮的東西，醒來後總有股怪異的衝動湧現，他察覺到對噴霧器漸漸失去興趣。起初利用職務之便暗地施用額外的霓麻維持工作的熱情，然而用量卻日益膨脹。這三星期來只能用高劑量的霓麻壓抑對噴霧器的厭惡。</p><p>　　必須，必須離開這裡。</p><p>　　左顧右盼了一會，小心翼翼自枕套裡挖出一本盜印的參考書〈決勝CETS‧新西方〉。書齡估計有七十五年，書背沒標上ISBN，作者也無從找起，內頁更被蠹魚游出一片大洋，徒存沒有本文的註腳。經過一個下午的時間，殘破的訊息終於完整謄錄到公文紙背面，老表坐起身，從第一頁看起。</p><p>　　讀書對老表而言無疑是種折磨，段落完整處不多，句子離散得像詩，有些部分還只能當書法欣賞。每停駐一個字都有股刺痛感產生，一針一針扎著他顱內的韋尼克區。嘗試將支離破碎的字詞拼湊出意義，卻失敗的一蹋糊塗，換來更劇烈的痛苦，他撇過頭等待痛楚消退才翻頁。暫停，繼續，暫停，繼續……老表一把抓起筆記，揉成紙團用力往牆面砸，紙團不踏實地打中繪有世界地圖的卷軸，發出輕輕聲響。他躺回床上，從枕套裡拿出橙色信封放進口袋，什麼都不想，沉沉入睡。</p><p>．　．　．</p><p>　　三架人形機具仍然在隔離間忙進忙出，不過這次他們搬運碗盤；又一封紅色急件砸在諮詢室的大堆文件上；護理機器人帶來一個滴著口水，皮膚鑲嵌七八種色塊的女孩進來。</p><p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p><p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p><p>　　「……」</p><p>　　沒人回應的機器人僵在門口死板地重複通知，女孩掙脫機器手臂好奇地往辦公室探頭，黑漆漆的半個人影都沒有。</p><p>．　．　．</p><p>　　「主任馬上就到。」秘書機器人再次向久候的來訪者告知。</p><p>　　會客室在CETS大樓頂層，日光照進東側的大落地窗，非常明亮；從窗邊可以俯瞰整座夢臨市：藍色緞帶似的河道蜿蜒繞過市中心，機動風帆船悠悠地在河面行駛，遞送南北區的物流。然而老表只是一味踱來踱去，在腦海裡不停排練想像待會的對話，絲毫沒去注意窗外匆忙的世界。就在他糾結於該怎麼替對話收尾時，主任，CETS的實質負責人，輕快地走進來。</p><p>　　他調低空調溫度，把秘書機器人支開。「看來你是對工作失去熱忱了，老表。」他說。</p><p>　　老表嚇了一跳，先是看看主任又轉而盯著長桌旁的罌粟花試圖閃躲主任的眼神，不知如何反應掙扎了一會兒，最後脫口：「辭……辭職。」疲乏的節奏，無力的嗓音。</p><p>　　「但你幹得真不錯，」主任撫著手，「幹得真不錯。」</p><p>　　「可是，」老表繼續說，「雖然幾十年間喜歡的工作，但是……呃，就是……」</p><p>　　「我得勸你留在崗位上，只剩十年呢！」長桌上映射出老表的人事資料，簡歷只有一條：CETS專任輔導師。</p><p>　　老表吞吞口水滋潤乾澀的喉嚨，才鎮定下來說「我仍要轉行。」</p><p>　　「轉行？」主任露出一絲詫異的笑容。</p><p>　　「對，天文學家。」慢慢地，一字一字念出。</p><p>　　主任把當年老表的應試結果調出，投影到他眼前。「這樣的成績，無論觀測員或理論學者你都無法勝任。」摺疊起資料夾，又笑笑補了一句「更何況輔導員可沒辦法把恆星撒上霓麻，這點你應該最清楚。」</p><p>　　「沒效，」老表臉孔扭曲地說，「霓麻已經克制不住，工作的厭倦。」</p><p>　　「這不是新案例，」主任從書架取出〈醫典〉，扣在檢索機上。書本開始唰唰唰翻頁，愈來愈快，爾後漸漸減速：DRUG、DRUG DEPENDENCE、DRUG SEN-SITIZATION……最終在DRUG TOLERANCE停下。「藥物耐受性，因對霓麻暴露量超標引發的藥物耐受性。」，「不過並不是大問題，最新研究的佐劑能重置對藥物的敏感度，延長職業壽命。」</p><p>　　「不需要霓麻，星辰本身就值得嚮往……」老表小聲插嘴。</p><p>　　「嚮往星辰？那你嚮往哈密頓系統、傅立葉分析及弗里德曼方程式嗎？」</p><p>　　「一定得喜歡物理嗎？」這令老表回想到昨晚挑燈夜讀的痛苦經歷，和被數學符號砸得頭破血流的夢境。不僅從沒念過一本物理書，事實上，他對物理一點興趣都沒有。</p><p>　　「若不喜歡，那探索天文就只是一連串和數字掙扎的痛苦歷程，最終庸碌一生。」</p><p>　　「我不要求成為牛頓、愛因斯坦那樣的名家。」</p><p>　　「但對教育者而言，放任失調者不合宜地去研究出破銅爛鐵、出版劣質的小說、烹調難下嚥的食物——是教育的失敗和社會人力的浪費。」</p><p>　　「繳稅，我還繳稅不虧欠社會什麼。」</p><p>　　「你打算放棄自己擁有的才華，待在不適任的位置然後逼自己做不喜歡的事，就為滿足心裡空無的期待？」</p><p>　　「不是……」老表沒有辦法反駁，腦袋一片空白。被適性測驗挑出的失調者用霓麻培養喜好，用霓麻建立興趣，經林立市郊的職訓所針對專長養成技能，有能力有熱忱，處在各行各業都能驕傲地勞動，這樣有什麼不好？</p><p>　　「事實上，你選擇了折磨自己。」</p><p>　　「可是，我喜歡天空……」老表思考能力到了極限，外加熬夜的疲憊幾乎要跪倒。他拿出橘色信封，裡面備齊身分資料，還有工作多年的積蓄。「拜託讓我重新參加測驗。」卑微地，老表伏在地上，「我願意去做那些噁心厭煩、令人頭痛欲裂的事！」</p><p>　　「是嗎？隨便你。」主任說畢轉身離去。</p><p>．　．　．</p><p>　　不安、臉色鐵青的孩童比肩繼踵地往內移動，有個面容枯槁的老人不協調地排在人龍中間，跟著隊伍往前。查驗機吞下准考證，三道雷射自閘門上方向下掃描，分別檢驗了基因、金屬反應與外型特徵，電腦遲疑了一會兒才發出合格鳴叫。通過身分認證後，老表朝向第213036試場走去。試場有六扇門，每扇門後有一部機考駕艙，它們將依據應試結果駛向對應的職訓中心。</p><p>　　老表年老萎縮的身軀還勉強能擠入設計給孩童的應考座，大腿貼著胸口，下巴抵在膝上，雙手沒地方擺只得僵硬地半舉。警鈴響起，艙門喀鏘關上，裏頭一片黑暗，老表緊張得直發抖，嘴巴喃喃默背著參考書內容「托勒密布魯諾哥白尼克普勒伽利略，PV&#x3D;NRT，M&#x3D;m+5lgR」</p><p>　　前方的黑暗亮起倒數字幕，虛擬的指導人聲開始說明應考程序。附有吸盤的軟管從坐墊下伸出，向上攀升最後牢牢固定在老表的後頸。視線左上角跳出一個愛心符號，中間數字印著一百二十二，右上角的氣體含量表顯示當前二氧化碳濃度過高。老表心想，如今他像個嬰兒一樣，屈身金屬子宮以光纖臍帶與母電腦連結，等待十小時煎熬後的重生。</p><p>　　長達兩千兩百道是非題存成一株高入雲天的二元樹，參雜無數誘答與實驗選項，排除了隨意作答與背誦舊題的偏差(即使適性測驗補習班幾乎銷聲匿跡)。老表全身顫抖地在選項間遊蕩，穿過無數條分岔的迴廊：愛好動物&#x2F;喜歡機械、偏愛操作&#x2F;擅長思考、活潑奔放&#x2F;害羞內向……每次抉擇都捨棄了半數可能，二分之一、四分之一……以O(logn)時間複雜度指向一個對老表而言未知的未來。</p><p>　　最後一個指令輸入，第一階段結束。駕艙正「喀鐺、喀鐺」朝下個應考點前進，即使五感都被封鎖在機殼內，仍能感受到因慣性從椅背傳來的壓迫。</p><p>　　「試判斷有沒有一個正整數n, 可使n恰可被2000個相異的質數整除，且可被n整除。」</p><p>　　「……」</p><p>　　「有一時鐘的時針長度為 5 公分，分針長度為 8 公分。假設時針針尖每分鐘所移動的弧長都相等。試求時針針尖每分鐘所移動的弧長。」</p><p>　　「……」</p><p>　　「同時擲出一枚50元與一枚10元硬幣，兩枚都出現正面的機率為多少？」</p><p>　　「……」</p><p>　　時間條如火藥引信逐漸燒盡，因正確率過低電腦不斷調低題目水平，老表被無止盡的挫折包圍，在汪汪題海中捲入錯答的漩渦死命掙扎。</p><p>　　「5×6＝？」</p><p>　　「一、二、三……」僅存三十秒時間，好不容易碰上有把握的題目，老表扳著手指吃力計算。</p><p>　　「1＋1＝？」</p><p>　　終止的警鈴在作答前響起，駕艙緩緩剎車紮實停在地面，老表視線落在熄滅的螢幕上，呆愣地搓揉發麻的雙腳等候艙門打開。</p><p>　　「喀鏘！」</p><p>　　門縫透出一線光芒，他嗅到一股熟悉的甜味，不遠處公文砸在辦公桌上的聲音傳來。</p><p>　　「回……回來了嗎？」正當老表失落地想跨出腳步時，</p><p>　　「轟隆」</p><p>　　機器起了劇烈搖晃，他一個踉蹌跌回座上。下降，駕艙失控地下降，失重感侵襲全身，一幕幕過去從腦中閃過，恍惚間，他回到熱衷噴灑霓麻的時候，回到被輔導的時候，回到上次參加測驗的時候，昏厥前一刻，老表回到了一歲的時候。</p><p>　　老表癡愣地坐在地上，眼前似乎有筆、有試管、有衣服、有手槍……周遭的成人不知道在鼓噪些什麼，像是認份般他賣命往前爬，奮力一抓，卻什麼也沒抓住。</p><hr><p>5uperb0y（2016）。老表。</p>]]></content>
      
      
      
        <tags>
            
            <tag> story </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《夜幕低垂》</title>
      <link href="/asimov-1941-nightfall/"/>
      <url>/asimov-1941-nightfall/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>習慣光亮的文明偶然經歷一個全然陌生的體驗──夜晚，陷入集體瘋狂導致文明崩潰。</p><span id="more"></span><h1 id="故事摘要"><a href="#故事摘要" class="headerlink" title="故事摘要"></a>故事摘要</h1><p>小說背景是一個有六顆太陽的行星。</p><p>由心理學家薛林五O一調查的神祕隧道案引出謎團的第一個線索：體驗黑暗將使人失卻理智喪心病狂。另一方面，考古學家賽芙拉八九發現的上古文明以兩千年為週期，破壞又重建了無數次；天文學家畢奈二五原以為他算出恆星軌道偏差是推翻重力理論的證據，沒想到卻是另有顆不曾觀察到的行星在擾動；光明使徒們對末日的預言「……太陽都會消失……星斗將從黑暗的天空射下火焰……」</p><p>各自分述的奇異發現在「2049」這數字下串聯在一起，它是古文明毀滅重建的週期、預言中末日的週期、也是那顆不曾見過的行星掠過單陽日(天上只有一顆太陽)產生日蝕的週期！從宗教預言得知未來梗概，由物理證實夜幕降臨的必然，經心理學推導出人群的歇斯底里的反應，最後在考古遺址中看到文明的命運。</p><p>即便書中腳色在察覺事態後積極防範，但當天上唯一的光源被蝕去，人類終究承受不住衝擊。為了製造光源而焚燒一切，民生的、學術的、美的、善的都付之一炬。社會體制瓦解，市民為逃離紊亂的市中心遁入森林，然而森林卻是更加險惡的生存地。只有教團用信仰力量減少黑夜的心理衝擊，仍保持良好秩序並試圖以教權重建世界。</p><h1 id="背景設定"><a href="#背景設定" class="headerlink" title="背景設定"></a>背景設定</h1><p>此作把背景定在六體系統內的行星，隨時都有恆星掛在天上，沒有夜晚也見不到星空。而六顆行星造成的影響可不只永晝，多體運動複雜的軌跡可能和行星軌道重疊，即使沒撞上也可能因為行星脫離適居帶而使生態圈崩壞或是強大引力作用扯開行星。</p><p>《三體》裏頭的三體文明就面對這般多變的生存困境，演化出獨特的乾燥身體結構還有別於地球的科學史。《夜幕低垂》中，文明的生理結構並沒特別敘述（也是能夠享受美酒的那種生物）但是重力理論也因星體多變的行跡，很晚才被發現。<br>書中有個天文台台長用電腦計算行星軌跡的橋段，值得討論的是「少了萬有引力理論，科學能走到哪？」也許一點影響都沒有。</p><p>牛頓把前人對力的概念統整在三大定律中，雖然能用天文發現為它們佐證（像是月球繞地球的圓周運動、克普勒三大定律……），但是從伽利略做比薩斜塔丟羽毛鉛球的實驗、斜面滾鐵球的實驗推出第一第二定律的結果來看，定律本身不需由天體啟發。</p><p>不了解物與物如何互相吸引，沒辦法解釋蘋果墜地的原因（和太陽落不下來的原因）仍能研究生物、製造電腦、討論量子力學。那個只有六顆太陽的世界，天文學恐怕比我們枯燥好多，重力理論最終可能會在卡文迪西那樣的實驗中被某個龜毛實驗物理學家發現，再由微物實驗的模型推廣到星球尺度和蘋果與星球的關係。</p><h1 id="情節安排"><a href="#情節安排" class="headerlink" title="情節安排"></a>情節安排</h1><p>我覺得這本書比基地系列、正子人、醜小孩都好看。一向喜歡以科研為軸，從眾多異相中找到線索、擬定假說並且隨著情節抽絲剝繭逐漸解開謎團的故事。這部前頭各個看似互不相干的研究在後面串聯一塊，然後逐漸累積末日的恐懼，很合我胃口。</p><p>但是整本書的到真相大白那刻也就劇終了。後面末日景象，浩劫後殺人求生據地為王的描述，似乎是為了給的宏大開場做個交代，卻沒有寫得像其他災難小說那麼精彩。我能明白為了營造末日氛圍，作者需要安排一些暴力情節和道德淪喪的情節，例如：保安隊要求女角脫衣服、女角被愛慕的同事強襲、男角和女角的愛情等。然而，我後來回顧劇情覺得是欠缺讓人共鳴的心理或景物描述，才會感到沒有主軸的生存冒險故事拖了百頁，直到最後才回到宗教救贖部分。</p><p>同樣是天文劇變，就拿《時間迴旋》做個比較：</p><table><thead><tr><th></th><th>夜幕低垂</th><th>時間迴旋</th></tr></thead><tbody><tr><td>災難內容</td><td>星星出現</td><td>星星消失</td></tr><tr><td>災難時間點</td><td>劇情中間</td><td>劇情開始</td></tr><tr><td>災難持續時間</td><td>短（數小時內）</td><td>長（幾十年）</td></tr><tr><td>災難認知</td><td>災難前已釐清原因</td><td>災難後才逐漸解開謎團</td></tr><tr><td>後續效應</td><td>極巨大</td><td>慢慢變化</td></tr><tr><td>宗教</td><td>試圖匡正世道</td><td>逃避現實</td></tr></tbody></table><p>時間迴旋兩年前看的，剩這點印象</p><h1 id="末日的結局該怎麼收呢？"><a href="#末日的結局該怎麼收呢？" class="headerlink" title="末日的結局該怎麼收呢？"></a>末日的結局該怎麼收呢？</h1><p>我覺得兩本的閱讀體驗都是前期的推理解謎比較好，但夜幕低垂好像整本書的一半都在收尾。解謎線很早斷掉，後面轉為末日背景的冒險動作小說。我覺得這也是寫作者的難題，既然主題是夜幕低垂，如果把怎麼在瓦解的社會裏頭冒險寫得太誇張會使劇情失焦，但是寫得搔不到癢處又可能讓讀者感到乏味。想營造氛圍時，還得避免讓腳色好像為了劇情推移才站在那個位置而失卻該有的性格判斷。</p><p>最後是對小說結構的一點看法。如果災難發生在一開始，那推演劇情的時候除了能描寫人群恐懼心理、生存鬥爭，還能時時扣回末日主題試圖解開災難的原因，增添懸疑元素。劇情一開始若花了很大篇幅把災難來龍去脈描述完，那後面就少一樣元素可以寫，無論後頭怎麼發揮和前面營造的解謎感都會有所差別，處理不好讀起來會有些不協調。</p><hr><p>艾西莫夫，席維伯格（2000）。夜幕低垂（駱香潔 &amp; 葉李華譯）。天下文化。（原著出版於 1941 年）</p>]]></content>
      
      
      
        <tags>
            
            <tag> sf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
