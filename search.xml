<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>〈教育的烏托邦〉</title>
    <url>/5uperb0y-2016-utopian-education/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>　　夢臨市的天空是電腦的顏色，電腦死機的蔚藍。</p>
<p>　　「人終究會走出自己的路來。」眼前就有一條長廊，路面被通勤者腳步給蝕刻出間格規律的腳印，老表在雜遝足跡中找到屬於他的坑，踩著五十年如一的步伐來到一座有一百三十七層高的藍紅色建築物，正門上方寫著幾個大字：中央教育測驗服務社(CETS)。</p>
<span id="more"></span>

<p>　　大樓坐東朝西，插滿因巨大流量而肥腫的動靜脈，不安、臉色鐵青的孩童比肩繼踵地往內流動，形成樓外粗枝交錯的青筋；從大樓伸出的管道則注滿自信得意面容紅潤的孩童，他們在社會的肝臟中成熟，最終送往社會的大腦、社會的肌肉、社會的腎臟和社會的肛門。</p>
<p>　　夾在地底志留紀筆石與泥盆紀裸蕨間的是大樓負四十二層，適性教育中心。穿過緩衝道是一座兩千公升的儲存槽，槽身有一半被拖入地底，一條條銅線將濃度、溫度與酸鹼值等參數傳入檯座上的監控幕。三架人形機具頂著清潔罩，外披屍白色辨識裝小心繞過儲存槽，全神貫注地把一塊塊磚頭運進隔離室，除了齒輪回應齒輪，這兒就只有攪拌子在槽內轟隆旋轉的聲音。老表的辦公室〈也是諮商室〉就在隔離室隔壁，門旁停靠一台拙夫腳踏車，上頭垂掛著棉製內褲、塑膠護手和一套無塵制服。辦公桌上批不完的公文堆積成山，一份紅色封套的急件從天花板的轉送口墜落砸在山峰，連同一大捆文件從桌沿嘩啦啦沖下，激盪出迷濛霧霾；灑落地面的文件淹沒桌腳氾濫到走道、沙發甚或流進休息室，文件的河流最終在辦公室沖積出一塊纖維平原，失去動能的那封急件恰好在老表腳前沉澱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　﹝機考成績﹞ </span><br><span class="line">　　姓名：灰仔(13,男性)</span><br><span class="line">　　羅格標準智商指數：五十(底標)</span><br><span class="line">　　霍蘭德興趣偏差：正負零點零八六(無取向)</span><br><span class="line">　　柯賽人格氣質量表：？？？(不鮮明)</span><br><span class="line">　　HSF測驗：V項，三十四分；Q項，十五分；AW項，零點五(失能)。</span><br></pre></td></tr></table></figure>
<p>　　「哦喔。」老表打了嗝，往背面翻去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　﹝問卷紀錄﹞</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的志向是什麼？」</span><br><span class="line">　　受測者：「……」</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的興趣是什麼？」</span><br><span class="line">　　……</span><br></pre></td></tr></table></figure>
<p>　　還沒讀完，護理機器人已把這位男孩帶到老表面前。</p>
<p>　　「除了視力、體脂率過高和手指頭長期發炎導致的扭曲外沒有其他問題。」死板的聲音從機殼傳出，在老表點下確認鈕後滑步離開。</p>
<p>　　「灰仔你好，這邊……」老表一面說一面翻找那部可以讓人放鬆的儀器，把一大把文件移開後，終於在散落的紙張下找到。</p>
<p>　　「……這邊坐。」老表指著椅墊，但男孩似乎沒聽見，五感深埋實境頭盔裡，專心敲開磚頭挖出金幣，使勁踩爛長著獠牙又會跑動的香菇，吞下看得見陽光的花朵。</p>
<p>　　老表走上前，輕柔地抓住他的肩膀把實境機的電源關上，小心翼翼地把頭盔拆下，將他引到沙發去。斷離數碼世界，男孩的眼神空洞了十來分鐘才重新聚焦。「是雙機眼。」老表心想。義務教育絕種後，缺少定期眺望黑板休息的機會，無時無刻不死盯著藍光頻幕導致近視加深速度比換眼鏡還快。嫌麻煩的父母索性把歷經億萬年錯亂的達爾文實驗才長出的兩粒珍珠摘下，換上僅三十年歷史的電腦眼球。</p>
<p>　　老表再次拿出那份報告，從第一列掃視起。</p>
<p>　　「什麼時候才可以走？」</p>
<p>　　「一下子、一下子，只要回答幾個問題。」</p>
<p>　　「咦？」</p>
<p>　　「簡單的問題，幫助你找尋自我定位和生涯的目標。」</p>
<p>　　「哦？」</p>
<p>　　「我的意思是回答完你就可以走了。」</p>
<p>　　「哈！」</p>
<p>　　「不花十分鐘。」老表放下報告，安上鬧鐘，用紅筆在公文附錄的磚瓦實業廠職缺表上打勾。</p>
<p>　　「首先，你的志向是什麼？」老表啪嚓啪嚓踏過紙堆，來到門邊腳踏車旁，</p>
<p>　　「我要打電動！」</p>
<p>　　「那你的興趣呢？」把內褲遠遠甩到一邊，從坐墊上拎起無塵防護服抖落上頭的灰塵。</p>
<p>　　「我喜歡打電……」</p>
<p>　　「你的專長是什麼呢？」套上它，檢查外覆層上每個可能的縫隙，</p>
<p>　　「我會打……」</p>
<p>　　「你的理想是什麼呢？」走向儲存槽，把填充瓶注滿金黃色的「霓麻」，</p>
<p>　　「……」</p>
<p>　　「依照你的興趣和能力，我很確定你能把這份工作做好。」</p>
<p>　　老表嘴巴開合著，足像一具發條機器人不合節奏地吐出一個個標點符號。鬧鐘「滴滴滴滴、滴滴滴滴」作響，催促這場對話的結束。</p>
<p>　　「可以……走了？」</p>
<p>　　「是的，灰仔，你會在你喜歡的事物中找到未來。」疲乏的節奏，無力的嗓音。</p>
<p>　　男孩被帶到隔壁的隔離室，房間中央堆著他熟悉的磚頭。隨後門關上，鼓風機運轉，層流吹襲循環整座隔離室。老表熟練地背起噴霧器，一壓一放間，陳舊的幫浦發出哀鳴，噗嘶噗嘶地將霓麻撒在磚上，即使被隔絕在四層纖維之下，老表仍能嗅到那熟悉的甜味。霓麻在近地處積累，慢慢向上蒸騰成雲，最後將燈源與通風口遮住，陰影壓在兩人身上，佐劑和緩衝劑在瀰漫的雲中製造出驚人的化學電光，霓麻蒸發吸收了熱量使得隔離間溫度湊降，冰晶凝結在牆壁、手把、老表與灰仔呆愣的面孔上。飽和，再也容不下更多，氣氛死寂陰冷悲愁憂傷。第一滴雨跌落，兩滴，三滴，四滴，最終化成傾盆大雨，濕透男孩頭髮，衣服，每寸肌膚。</p>
<p>　　「這是什麼，好甜！」</p>
<p>　　老表並沒有回答，他徐步退後，從另一個出口離開。卸去一身負擔，累得轉不開水龍頭，勉強走到休息間把自己摔在床上，使不出拉棉被的力氣，虛弱得只蓋得上眼皮。闔眼前老表透過玻璃窗隱約看見男孩吸吮手指殘餘的霓麻，看他把上衣脫掉，頭承著衣服，雙手用力擰出汁來貪婪吞下。</p>
<p>　　「會找到，」疲憊無力，老表慢慢進入夢鄉「自己的……」</p>
<p>　　擠盡最後一口汁液的男孩注意到一旁疊放的磚頭，被霓麻結晶漆成金黃色，像極價值連城的金塊，他拋開衣服猛然撲上，以不協調的姿勢爬到推疊最高處，舔著，發狂舔著，滿心歡喜地舔著，曾經最愛的實境遊戲機就遺棄在旁。</p>
<p>．　．　．</p>
<p>　　老表從口袋掏出墨鏡戴上避免被星光曬傷，穿著海灘褲塗好防曬油的卡爾薩根乘著幽浮在眼前呼喚「要不要跟我一起同享這個宇宙與世代啊？」於是他開始奔跑，雖然沒有腳，卻有下身長出的兩條右臂。</p>
<p>　　其實也沒有地板，老表是在一條橡皮圈上團團繞，繞出時間的漩渦把他送回十三歲的時候，薩根的臉和適性教育中心的輔導長融合在一起。</p>
<p>　　「小表，你的志向是什麼？」</p>
<p>　　「星……」</p>
<p>　　「那你的興趣呢？」</p>
<p>　　「ㄒ……」</p>
<p>　　「你只是串會思考的芭蕉。」</p>
<p>　　連同蕉皮被丟進廚餘桶，老表依稀聽見幫浦抽放的聲音，感覺到霓麻在舌尖跳動的興奮。外頭年老者在街頭閒晃「高齡比七成，沒人力浪費的空間了。」從跨下傳來主任嚴厲的聲音「把對的人放到對的地方：智商指數頂標和HSF測驗頂標者，是為學者；人格氣質量表領袖類，是為企業家。至於沒有方向或方向錯誤的……失調者，」上班第一天，他坐在主任睿智的禿頭上。「是你的職責。」主任耳朵旁的頭髮將老表兩腿緊緊纏住，將他拖入腦漿中。從眼眶能清楚看到四點三光年外的半人馬阿爾法星，追逐上去！一條條物理公式擋在前頭，攀越直積高牆，撐起積分篙，用範數作筏橫渡空集合，絕對值大道在眼前開展變寬，星，就在不遠的地方。然而，根號勾住衣角，被圓周率絆倒，有理數沉沉壓在背上，從海馬迴、杏仁核與額葉聯絡區襲來的梯度與正則子群刺得他滿身是傷。</p>
<p>　　星星、符號、薩根、空氣漸速遠去，殘影紅移一路散逸微波輻射拖拉了數萬光年。現在這世界到處都是輔導長、主任和被霓麻漆成金黃色的噴霧器，熟悉的甜味周圍飄來，輔導長和主任喋喋不休地說著：</p>
<p>　　「照你喜歡的去做。」</p>
<p>　　「畢竟擅長打鐵卻偏要去念書是個悲劇，也是浪費。」</p>
<p>　　「會在你喜歡的事物中找到未來的。」</p>
<p>　　「輔導，是對失調者的社會救濟。」</p>
<p>　　「小表很適合當輔導師。」</p>
<p>　　 ……</p>
<p>．　．　．</p>
<p>才剛被昨天沒洗的衣服熏醒，老表又躺回去睡。</p>
<p>　　今天是一年一度的「輪休日」，適性中心黑壓壓一片。沒有對未來徬徨的小孩會送來，也沒有新的公文要蓋章，把工作當樂趣的時代，休息就成為義務。</p>
<p>　　這五個月來老表時常夢見符號、公式和掛在天上閃亮亮的東西，醒來後總有股怪異的衝動湧現，他察覺到對噴霧器漸漸失去興趣。起初利用職務之便暗地施用額外的霓麻維持工作的熱情，然而用量卻日益膨脹。這三星期來只能用高劑量的霓麻壓抑對噴霧器的厭惡。</p>
<p>　　必須，必須離開這裡。</p>
<p>　　左顧右盼了一會，小心翼翼自枕套裡挖出一本盜印的參考書〈決勝CETS‧新西方〉。書齡估計有七十五年，書背沒標上ISBN，作者也無從找起，內頁更被蠹魚游出一片大洋，徒存沒有本文的註腳。經過一個下午的時間，殘破的訊息終於完整謄錄到公文紙背面，老表坐起身，從第一頁看起。</p>
<p>　　讀書對老表而言無疑是種折磨，段落完整處不多，句子離散得像詩，有些部分還只能當書法欣賞。每停駐一個字都有股刺痛感產生，一針一針扎著他顱內的韋尼克區。嘗試將支離破碎的字詞拼湊出意義，卻失敗的一蹋糊塗，換來更劇烈的痛苦，他撇過頭等待痛楚消退才翻頁。暫停，繼續，暫停，繼續……老表一把抓起筆記，揉成紙團用力往牆面砸，紙團不踏實地打中繪有世界地圖的卷軸，發出輕輕聲響。他躺回床上，從枕套裡拿出橙色信封放進口袋，什麼都不想，沉沉入睡。</p>
<p>．　．　．</p>
<p>　　三架人形機具仍然在隔離間忙進忙出，不過這次他們搬運碗盤；又一封紅色急件砸在諮詢室的大堆文件上；護理機器人帶來一個滴著口水，皮膚鑲嵌七八種色塊的女孩進來。</p>
<p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p>
<p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p>
<p>　　「……」</p>
<p>　　沒人回應的機器人僵在門口死板地重複通知，女孩掙脫機器手臂好奇地往辦公室探頭，黑漆漆的半個人影都沒有。</p>
<p>．　．　．</p>
<p>　　「主任馬上就到。」秘書機器人再次向久候的來訪者告知。</p>
<p>　　會客室在CETS大樓頂層，日光照進東側的大落地窗，非常明亮；從窗邊可以俯瞰整座夢臨市：藍色緞帶似的河道蜿蜒繞過市中心，機動風帆船悠悠地在河面行駛，遞送南北區的物流。然而老表只是一味踱來踱去，在腦海裡不停排練想像待會的對話，絲毫沒去注意窗外匆忙的世界。就在他糾結於該怎麼替對話收尾時，主任，CETS的實質負責人，輕快地走進來。</p>
<p>　　他調低空調溫度，把秘書機器人支開。「看來你是對工作失去熱忱了，老表。」他說。</p>
<p>　　老表嚇了一跳，先是看看主任又轉而盯著長桌旁的罌粟花試圖閃躲主任的眼神，不知如何反應掙扎了一會兒，最後脫口：「辭……辭職。」疲乏的節奏，無力的嗓音。</p>
<p>　　「但你幹得真不錯，」主任撫著手，「幹得真不錯。」</p>
<p>　　「可是，」老表繼續說，「雖然幾十年間喜歡的工作，但是……呃，就是……」</p>
<p>　　「我得勸你留在崗位上，只剩十年呢！」長桌上映射出老表的人事資料，簡歷只有一條：CETS專任輔導師。</p>
<p>　　老表吞吞口水滋潤乾澀的喉嚨，才鎮定下來說「我仍要轉行。」</p>
<p>　　「轉行？」主任露出一絲詫異的笑容。</p>
<p>　　「對，天文學家。」慢慢地，一字一字念出。</p>
<p>　　主任把當年老表的應試結果調出，投影到他眼前。「這樣的成績，無論觀測員或理論學者你都無法勝任。」摺疊起資料夾，又笑笑補了一句「更何況輔導員可沒辦法把恆星撒上霓麻，這點你應該最清楚。」</p>
<p>　　「沒效，」老表臉孔扭曲地說，「霓麻已經克制不住，工作的厭倦。」</p>
<p>　　「這不是新案例，」主任從書架取出〈醫典〉，扣在檢索機上。書本開始唰唰唰翻頁，愈來愈快，爾後漸漸減速：DRUG、DRUG DEPENDENCE、DRUG SEN-SITIZATION……最終在DRUG TOLERANCE停下。「藥物耐受性，因對霓麻暴露量超標引發的藥物耐受性。」，「不過並不是大問題，最新研究的佐劑能重置對藥物的敏感度，延長職業壽命。」</p>
<p>　　「不需要霓麻，星辰本身就值得嚮往……」老表小聲插嘴。</p>
<p>　　「嚮往星辰？那你嚮往哈密頓系統、傅立葉分析及弗里德曼方程式嗎？」</p>
<p>　　「一定得喜歡物理嗎？」這令老表回想到昨晚挑燈夜讀的痛苦經歷，和被數學符號砸得頭破血流的夢境。不僅從沒念過一本物理書，事實上，他對物理一點興趣都沒有。</p>
<p>　　「若不喜歡，那探索天文就只是一連串和數字掙扎的痛苦歷程，最終庸碌一生。」</p>
<p>　　「我不要求成為牛頓、愛因斯坦那樣的名家。」</p>
<p>　　「但對教育者而言，放任失調者不合宜地去研究出破銅爛鐵、出版劣質的小說、烹調難下嚥的食物——是教育的失敗和社會人力的浪費。」</p>
<p>　　「繳稅，我還繳稅不虧欠社會什麼。」</p>
<p>　　「你打算放棄自己擁有的才華，待在不適任的位置然後逼自己做不喜歡的事，就為滿足心裡空無的期待？」</p>
<p>　　「不是……」老表沒有辦法反駁，腦袋一片空白。被適性測驗挑出的失調者用霓麻培養喜好，用霓麻建立興趣，經林立市郊的職訓所針對專長養成技能，有能力有熱忱，處在各行各業都能驕傲地勞動，這樣有什麼不好？</p>
<p>　　「事實上，你選擇了折磨自己。」</p>
<p>　　「可是，我喜歡天空……」老表思考能力到了極限，外加熬夜的疲憊幾乎要跪倒。他拿出橘色信封，裡面備齊身分資料，還有工作多年的積蓄。「拜託讓我重新參加測驗。」卑微地，老表伏在地上，「我願意去做那些噁心厭煩、令人頭痛欲裂的事！」</p>
<p>　　「是嗎？隨便你。」主任說畢轉身離去。</p>
<p>．　．　．</p>
<p>　　不安、臉色鐵青的孩童比肩繼踵地往內移動，有個面容枯槁的老人不協調地排在人龍中間，跟著隊伍往前。查驗機吞下准考證，三道雷射自閘門上方向下掃描，分別檢驗了基因、金屬反應與外型特徵，電腦遲疑了一會兒才發出合格鳴叫。通過身分認證後，老表朝向第213036試場走去。試場有六扇門，每扇門後有一部機考駕艙，它們將依據應試結果駛向對應的職訓中心。</p>
<p>　　老表年老萎縮的身軀還勉強能擠入設計給孩童的應考座，大腿貼著胸口，下巴抵在膝上，雙手沒地方擺只得僵硬地半舉。警鈴響起，艙門喀鏘關上，裏頭一片黑暗，老表緊張得直發抖，嘴巴喃喃默背著參考書內容「托勒密布魯諾哥白尼克普勒伽利略，PV&#x3D;NRT，M&#x3D;m+5lgR」</p>
<p>　　前方的黑暗亮起倒數字幕，虛擬的指導人聲開始說明應考程序。附有吸盤的軟管從坐墊下伸出，向上攀升最後牢牢固定在老表的後頸。視線左上角跳出一個愛心符號，中間數字印著一百二十二，右上角的氣體含量表顯示當前二氧化碳濃度過高。老表心想，如今他像個嬰兒一樣，屈身金屬子宮以光纖臍帶與母電腦連結，等待十小時煎熬後的重生。</p>
<p>　　長達兩千兩百道是非題存成一株高入雲天的二元樹，參雜無數誘答與實驗選項，排除了隨意作答與背誦舊題的偏差(即使適性測驗補習班幾乎銷聲匿跡)。老表全身顫抖地在選項間遊蕩，穿過無數條分岔的迴廊：愛好動物&#x2F;喜歡機械、偏愛操作&#x2F;擅長思考、活潑奔放&#x2F;害羞內向……每次抉擇都捨棄了半數可能，二分之一、四分之一……以O(logn)時間複雜度指向一個對老表而言未知的未來。</p>
<p>　　最後一個指令輸入，第一階段結束。駕艙正「喀鐺、喀鐺」朝下個應考點前進，即使五感都被封鎖在機殼內，仍能感受到因慣性從椅背傳來的壓迫。</p>
<p>　　「試判斷有沒有一個正整數n, 可使n恰可被2000個相異的質數整除，且可被n整除。」</p>
<p>　　「……」</p>
<p>　　「有一時鐘的時針長度為 5 公分，分針長度為 8 公分。假設時針針尖每分鐘所移動的弧長都相等。試求時針針尖每分鐘所移動的弧長。」</p>
<p>　　「……」</p>
<p>　　「同時擲出一枚50元與一枚10元硬幣，兩枚都出現正面的機率為多少？」</p>
<p>　　「……」</p>
<p>　　時間條如火藥引信逐漸燒盡，因正確率過低電腦不斷調低題目水平，老表被無止盡的挫折包圍，在汪汪題海中捲入錯答的漩渦死命掙扎。</p>
<p>　　「5×6＝？」</p>
<p>　　「一、二、三……」僅存三十秒時間，好不容易碰上有把握的題目，老表扳著手指吃力計算。</p>
<p>　　「1＋1＝？」</p>
<p>　　終止的警鈴在作答前響起，駕艙緩緩剎車紮實停在地面，老表視線落在熄滅的螢幕上，呆愣地搓揉發麻的雙腳等候艙門打開。</p>
<p>　　「喀鏘！」</p>
<p>　　門縫透出一線光芒，他嗅到一股熟悉的甜味，不遠處公文砸在辦公桌上的聲音傳來。</p>
<p>　　「回……回來了嗎？」正當老表失落地想跨出腳步時，</p>
<p>　　「轟隆」</p>
<p>　　機器起了劇烈搖晃，他一個踉蹌跌回座上。下降，駕艙失控地下降，失重感侵襲全身，一幕幕過去從腦中閃過，恍惚間，他回到熱衷噴灑霓麻的時候，回到被輔導的時候，回到上次參加測驗的時候，昏厥前一刻，老表回到了一歲的時候。</p>
<p>　　老表癡愣地坐在地上，眼前似乎有筆、有試管、有衣服、有手槍……周遭的成人不知道在鼓噪些什麼，像是認份般他賣命往前爬，奮力一抓，卻什麼也沒抓住。</p>
]]></content>
      <categories>
        <category>sf</category>
        <category>story</category>
      </categories>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>常見的生物資訊軟體開發文件</title>
    <url>/a-collection-of-essential-documents-for-bioinformatis-software/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>撰寫軟體的理想目標是讓程式碼自我解釋，使得任何受過訓練的工程師能夠僅靠程式碼本身理解其含意。然而，隨著軟體功能與部件日益複雜，我們仍須依賴額外的文件來說明程式碼的商業邏輯、運作情境與潛在限制等背景知識。</p>
<p>在生物資訊軟體開發領域，尤其是醫療軟體開發中，文件的詳盡程度與正確性尤為重要。為了把關產品品質與和保障用戶權益，醫療產品驗證要求產品送審時提供完整的軟體設計、需求分析和產品驗證報告。這些文件的種類繁多且規範細緻，撰寫和維護這些文件往往成為開發者的重擔。</p>
<p>減輕這種負擔的一種方法是讓開發人專注於與開發相關的文件，並將這些文件作為合規文件的來源。透過簡化文件類別和統一內容來源，來簡化文件撰寫和維護的流程。</p>
<p>因此，本文整理了常見的生物資訊軟體開發文件，闡述與開發密切相關的文件類型，並列舉優良的撰寫指南，同時對各類文件的定位差異提出個人見解。</p>
<span id="more"></span>

<h1 id="常見的生物資訊軟體開發文件清單"><a href="#常見的生物資訊軟體開發文件清單" class="headerlink" title="常見的生物資訊軟體開發文件清單"></a>常見的生物資訊軟體開發文件清單</h1><p>雖然文件內容會依專案性質與規模而有所不同，但在開發過程中通常會隨專案進展逐步納入以下幾種文件，</p>
<table>
<thead>
<tr>
<th>名稱</th>
<th>內容</th>
<th>額外受眾</th>
<th>指引</th>
</tr>
</thead>
<tbody><tr>
<td>Issues</td>
<td>紀錄 bugfix 或 feature request 等開發需求與問題</td>
<td>專案經理</td>
<td><a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Feature-Requests">Writing Good Feature Requests</a> &amp; <a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Bug-Reports">Writing Good Bug Reports</a></td>
</tr>
<tr>
<td>Docstring &amp; Type hints</td>
<td>描述程式模組的功能、參數與回傳資訊</td>
<td>開發者</td>
<td><a href="https://peps.python.org/pep-0257/">PEP 257</a> &amp; <a href="https://peps.python.org/pep-0484/">PEP 484</a></td>
</tr>
<tr>
<td>Code comments</td>
<td>程式碼的補充說明，包括任務標記和權益作法提示</td>
<td>開發者</td>
<td><a href="https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/">Best practices for writing code comments</a></td>
</tr>
<tr>
<td>Built-in help</td>
<td>軟體內建的用戶幫助訊息</td>
<td>用戶</td>
<td><a href="http://docopt.org/">docopt</a></td>
</tr>
<tr>
<td>Commit messages</td>
<td>摘要程式碼異動的內容、理由與背景</td>
<td>開發者</td>
<td><a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional commits</a></td>
</tr>
<tr>
<td>Pull requests</td>
<td>簡述為滿足需求對應的軟體異動及其理據</td>
<td>審查者</td>
<td><a href="https://www.pullrequest.com/blog/writing-a-great-pull-request-description/">Writing A Great Pull Request Description</a> &amp; <a href="https://github.blog/2015-01-21-how-to-write-the-perfect-pull-request/">How to write the perfect pull request</a></td>
</tr>
<tr>
<td>README</td>
<td>介紹專案目標、安裝使用與授權等入門資訊</td>
<td>用戶</td>
<td><a href="https://www.makeareadme.com/">Make a README</a></td>
</tr>
<tr>
<td>CHANGELOG</td>
<td>紀錄專案開發歷程與各版本更新內容</td>
<td>用戶</td>
<td><a href="https://keepachangelog.com/en/1.1.0/">Keep a CHANGELOG</a></td>
</tr>
</tbody></table>
<p>除了專案進展，開發文件的內容和格式也會根據團隊或任務需求而異。例如，單一腳本構成的小型專案在初期可能僅需程式碼註解和內建幫助訊息；隨著專案成熟，可以逐漸增加 README 文件來補充安裝和授權資訊，並在軟體定版後定期更新CHANGELOG。而個人開發的專案可能沒有 Pull Request 資訊；但團隊開發除了需要 pull request 把關軟體品質外，還需要 issues 管理專案排程。</p>
<p>表中的連結已提供詳細的文件撰寫指引，以下我將補充一些對個別文件定位的看法。</p>
<h1 id="README-和-CHANGELOG-的差異"><a href="#README-和-CHANGELOG-的差異" class="headerlink" title="README 和 CHANGELOG 的差異"></a>README 和 CHANGELOG 的差異</h1><p>README 呈現專案的現況，包括專案簡介、安裝和使用方法、軟體授權等必要資訊，是用戶或開發者了解專案的首要途徑。除此之外，README 還充當軟體文件的目錄，連結到用戶手冊、常見問題和開發指南等資源，供進階用戶或開發者參考。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># README</span><br><span class="line"></span><br><span class="line">## Introduction</span><br><span class="line"></span><br><span class="line">## Quick start</span><br><span class="line"></span><br><span class="line">## installation</span><br></pre></td></tr></table></figure>
<p>CHANGELOG 則記錄專案的過往，包括軟體變更和版本號次等更新資訊，是用戶或開發者了解開發歷程的入門管道。此外，CHANGELOG 也充當專案歷程的目錄，連結到 issue 和 pull request 等資源，供進階用戶或開發者參考。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CHANGELOG</span><br><span class="line"></span><br><span class="line">## [1.1.0] - 2019-02-15</span><br><span class="line"></span><br><span class="line">### Added</span><br><span class="line"></span><br><span class="line">- Danish translation (#297).</span><br><span class="line">- Georgian translation from (#337).</span><br></pre></td></tr></table></figure>

<p>換言之，README 和 CHANGELOG 總結了專案的現況與過往，是用戶與開發者了解專案最基礎的媒介。因此，這兩份文件通常會擺在專案目錄的最頂層，確保所有人一眼就能找到。</p>
<h1 id="Commits-和-CHANGELOG-的差異"><a href="#Commits-和-CHANGELOG-的差異" class="headerlink" title="Commits 和 CHANGELOG 的差異"></a>Commits 和 CHANGELOG 的差異</h1><p>如前所述，CHANGELOG 主要記錄軟體的重要變更，這些變更可能影響軟體的功能或使用方式。典型的 CHANGELOG 會按時序編排條目來排列，並依版本和變更類型組織變更紀錄。每條記錄不僅簡要描述了變更內容，還會連接到相關的需求文檔，補充軟體變更背景資訊。</p>
<p>相較之下，commit messages 主要面向開發者，著重於個別程式碼的變更，而非對整體用戶的影響。標準的 commit messages 通常包括變更類型和簡要說明，其中類型方便篩選和查找相關資訊，而簡要說明則提供了變更的摘要。這些資訊讓查閱者能夠追蹤開發歷程（例如使用 <code>git log --onelines</code>），並在需要時回溯程式碼的變更。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure>
<p>更完整的 commit messages 則包含了變更的背景、原因或機制的詳細解釋，有時還會附上註腳標記相關的 issue 連結，補充程式碼變更的需求情境</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure>
<p>雖然兩者都是開發紀錄的一部分，但 CHANGELOG 著重於需求的處置，commit 則聚焦程式碼的具體變更；CHANGELOG 通常隨著軟體更新而更新，而 commit 則在提交後鮮少變更；CHANGELOG 強調變更的影響，而 commit 則更注重變更的細節。由於這兩種文件的目標受眾和內容尺度殊異，直接從 commits 生成 CHANGELOG 可能會導致不必要的冗餘資訊，從而無法達到 CHANGELOG 的設計目的。</p>
<h1 id="Code-comments-和-Docstring-的差異"><a href="#Code-comments-和-Docstring-的差異" class="headerlink" title="Code comments 和 Docstring 的差異"></a>Code comments 和 Docstring 的差異</h1><p>程式碼內的文字不被執行的文字片段可分為 code comments （註解）與 docstring。以 Python 為例，docstring 是記錄函數、類別或模塊的特殊屬性，它們被夾註在三重雙引號之中，用於描述功能、參數和回傳資訊等自訂資訊。透過內置的 <code>__doc__</code> 方法可以取得 docstring，使其能被語義化工具解析，用於自動化文件生成，如 docopt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def complex(real=0.0, imag=0.0):</span><br><span class="line">    &quot;&quot;&quot;Form a complex number.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    real -- the real part (default 0.0)</span><br><span class="line">    imag -- the imaginary part (default 0.0)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if imag == 0.0 and real == 0.0:</span><br><span class="line">        return complex_zero</span><br></pre></td></tr></table></figure>
<p>另一方面，註解也是程式碼中不執行的文字片段，可用於解釋程式碼的背景或機制。值得注意的是，註解通常無法以內置方法取得，因此較常用於標記任務（如：<code>TODO</code>）、提供權宜性解法的提示或對複雜程式碼進行補充說明，並會隨著程式碼的改進而被簡化或刪除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TODO: remove the deprecated method</span><br><span class="line"></span><br><span class="line"># Use the name as the title if the properties did not include one (issue #1425)</span><br><span class="line"></span><br><span class="line"># Magical formula taken from a stackoverflow post at &lt;URL&gt;, reputedly related to human vision perception.</span><br></pre></td></tr></table></figure>
<p>總結來說，註解的內容較為多樣，可能包括臨時註記或任務提醒；而 docstring 則是程式碼正式文件的一部分，記錄了關於程式本身使用上的更多資訊。</p>
<h1 id="開發文件應存放何處？"><a href="#開發文件應存放何處？" class="headerlink" title="開發文件應存放何處？"></a>開發文件應存放何處？</h1><p>理想上，開發文件應具備好找、好讀和好維護等特性。這些特性可以這樣定義：</p>
<ul>
<li><strong>好找</strong>：文件應支援全域搜尋或資料庫搜尋，方便獲取重要資訊。</li>
<li><strong>好讀</strong>：文件應能在網頁、圖形介面或終端機中打開，並且資訊清晰簡潔。</li>
<li><strong>好維護</strong>：文件應集中存放於單一位置並能進行版本控制，以減少文件與開發進度不一致的風險。</li>
</ul>
<p>考量到這些原則，一些常見的文件格式可能不適合管理開發文件。例如，Office 系列文件不易進行搜尋和版本控制。將文件存放在品管系統 (ISO) 或多個資料夾中也不利於取得文件。而 HTML 和 LaTeX 等格式則包含過多無關的排版標記，使內容難以閱讀。</p>
<p>因此，目前最普遍的做法是使用 Markdown 進行純文本編輯，並將文件統一存放在專案目錄下。這樣不僅便於備份、版控和搜尋，還可以像程式碼一樣按照開發流程更新文件，從而將開發和文件緊密結合，降低不一致的風險。</p>
<p>常見的專案文件結構如下，例如 Python 的 <a href="https://github.com/psf/requests">requests</a> 專案或生物資訊領域的 <a href="https://github.com/nf-core/sarek/tree/3.4.0">nf-core</a> 等專案都採用了這樣的結構。</p>
<p>將 README 和 CHANGELOG 這兩種反映專案主要內容的文件放在專案根目錄，方便用戶或開發者取得這些資訊。再以單獨的目錄管理其他自訂文件，並共享多媒體資源，如圖片、影片或字體等。這種做法的好處除了方便管理外，還可以通過程式碼工具將文件編譯成網頁或 PDF 等易於閱讀與分享的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">|- README.md 					# 專案現況的學習途徑                   </span><br><span class="line">|- CHANGELOG.md              	# 開發歷程的入門管道   </span><br><span class="line">|- docs/                        # 自訂文件</span><br><span class="line">    |- assets/                  # 共享的多媒體資源</span><br><span class="line">    |- &lt;usage/output/faq&gt;.md    # 用戶、開發者或分享用的文件</span><br><span class="line">    |- &lt;makefile&gt;               # 用以編譯文件檔為其他格式</span><br></pre></td></tr></table></figure>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>在生物資訊軟體開發的領域中，常見的文件類型可以分為三大類：程式碼本身 (Source Code)、軟體當前狀態 (README)、以及開發歷程 (CHANGELOG)。這些文件不僅涵蓋了軟體的關鍵資訊，還透過互相連結和註腳形式，串聯起相關的文件內容。這樣的做法有利於在必要時將內容改寫為合規文件的格式。最佳的文件管理方法是將其儲存在專案目錄下，採用 Markdown 格式進行純文本編輯。這不僅保證了文件的可檢索性和易讀性，還可通過 Git 進行版本控制，確保文件的維護和更新與程式碼開發流程同步，從而達到易於維護的目的。</p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href="https://academic.oup.com/bib/article/19/4/693/2907814">Top consideratios for creating bioinformatics software documentation</a></li>
<li><a href="https://understandlegacycode.com/blog/where-to-put-documentation/">Where should you put the documentation</a></li>
<li><a href="https://agilemodeling.com/essays/agiledocumentation.htm">Lean&#x2F;Agile Documnetation: strategies for agile teams</a></li>
<li><a href="https://www.ithome.com.tw/voice/95002">技術文件產能工具</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>天體生物學和尋找外星生命</title>
    <url>/astrobiology-and-the-search-for-extraterrestrial-life/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>低調的人類從學會抬頭那一刻，就不斷在地球、月球、火星乃至其它銀河尋找自己不特別的證據。</p>
<span id="more"></span>

<h1 id="Astrobiology-是什麼？"><a href="#Astrobiology-是什麼？" class="headerlink" title="Astrobiology 是什麼？"></a>Astrobiology 是什麼？</h1><h2 id="Astrobiology-簡介"><a href="#Astrobiology-簡介" class="headerlink" title="Astrobiology 簡介"></a>Astrobiology 簡介</h2><p>除了地球生靈以外，宇宙中還有其他生命嗎？無論這個問題的答案是肯定還是否定，都能引發我們省思。假如能找到任何外星生命跡象，那麼我們肯定對其外型感興趣，也會想了解地球生命與外星生命的關係。但如果地球是唯一能孕育生命的星球，所有尋找外星生命的努力都注定是徒勞，這個問題也還沒完。因為我們勢必會感到疑惑，究竟地球有哪些獨一無二的特徵，容許生命在此發源繁盛？</p>
<p>雖然外星生命是想像作品的熱門題材，但在二十世紀中葉以後逐漸興起的天體生物學（Astrobiology，以下譯為天文生物學，理由見第三節）正是以事實與理論為基礎，試圖在太陽系乃至其他銀河搜尋地外生命的科學。</p>
<p>儘管目前未搜索到任何地外生命，鑒於宇宙龐大的規模以及地球生命形成的速度，存在地外生命仍然是合理的想像。何況，天文生物學除了尋找地外生命外，也肩負了解生命定義和地球生命起源的任務。</p>
<h2 id="天文生物學的研究方向"><a href="#天文生物學的研究方向" class="headerlink" title="天文生物學的研究方向"></a>天文生物學的研究方向</h2><p>包含尋找地外生命在內，天文生物學有以下三個研究方向。</p>
<p>釐清生命的定義與特質：雖然生命在地球隨處可見，卻難以為生命立下明確的定義，並區隔其與物質的差異。原則上，生命仍受制於物理和化學法則，但以人類目前的科技水準尚無法在實驗室中合成任何現今定義為生命的個體。生命與非生命之間的差異是什麼？人造生命的嘗試還欠缺何種要素？為了回答這些問題，天文生物學的首要目標即是研究生命的特質以了解生命究竟是什麼。<br>了解地球生命形成的條件與機制：除了比較生命與物質的差異，研究無機物轉變為生命的過程亦有助於了解生命的特性。當物質隨時間逐漸變得複雜，哪一刻起可稱之為生命？在形成生命的許多反應途徑中，何者是關鍵的一步？哪種環境條件是生命形成所必須？哪種環境條件造就了地球生命的特色？天文生物學的目的不只是理解地球生命形成的條件與機制，也試圖以地球生命起源為基礎，探討其它宇宙生命的特徵。<br>搜索地外的適居環境與生命跡象：理解生命的另一條途徑就是尋找地外生命。地球生命是目前已知唯一的生命形式，所以至今人類只能從僅有的樣本推論所有生命的普遍特徵。如果能夠找到任何地外生命，便能夠比較兩地生物的異同，得知生物的那些特徵是生命的通性，哪些又因形成環境而異，進而促進生命本質的理解。因此天文生物學的第三個研究方向，即是增加生命的樣本數。</p>
<p>總言之，天文生物學的研究方向是了解生命的本質，所以天文生物學一方面從地球生命的起源推論所有潛在生命的共同特徵，另一方面則試圖搜索地外生命以增加推論的依據。達成這些目標仰賴生物學、地球科學與天文學等學科知識，因此雖然天文生物學的主軸是生物，實際的研究課題卻跨越了不同領域。</p>
<h2 id="天文生物學的譯名"><a href="#天文生物學的譯名" class="headerlink" title="天文生物學的譯名"></a>天文生物學的譯名</h2><p>了解天文生物學的研究內容後，再來談談天文生物學的名稱。實際上這名稱曾讓許多初次接觸的人感到困惑，以為天文生物學只與望遠鏡有關和顯微鏡無關。</p>
<p>天文生物學在發展初期曾有許多不同的名字，例如萊德柏格 (Joshua Lederberg, 1925 - 2008) 即提倡以 Exobiology（地外生物學）表示研究生命在宇宙中發源、演化和分布的學科。然而國際生命起源研究社群卻對其中搜索地外生命的部分有異議，最終發明Bioastronomy（生物天文學）來描述以望遠鏡搜索地外生命的學問。</p>
<p>不過這兩個名稱的爭議在於，在找到地外生命之前「地外」或是「生物天文」等詞彙是否合宜？</p>
<p>於是到 1997 年，NASA 開始推廣以 Astrobiology 取代 Exobiology 等其它術語。在那之後還有許多關於名稱的爭議，可以閱讀 Lemarchand (2000) 的 A New Era in the Search for Life in the Universe  獲得其它細節。不過如今我們知道，Astrobiology 成為這個學科的主流名稱。</p>
<p>Astrobiology 結合了希臘字 astron（星星或天體）和德國字 Biologie（生物學），字面上解釋作「星星的生物學」，常見譯名有天體生物學、天文生物學或太空生物學等。雖然前述譯名中，天體生物學較其他兩者普及，但 Astrobiology 的研究範圍其實不限於特定天體，還涵蓋了生命在其他宇宙空間的分布與演變，所以我認為「宇宙生物學」較能反映其特質，但宇宙生物學應另指 Cosmobiology 一詞，因此為了顧及字根與學術含意，譯為天文生物學也還算恰當。</p>
<h1 id="從天文生物學到廣義生物學"><a href="#從天文生物學到廣義生物學" class="headerlink" title="從天文生物學到廣義生物學"></a>從天文生物學到廣義生物學</h1><p>我已經說明了天文生物學的具體目標，接著我將解釋天文生物學的含意。</p>
<h2 id="生命之樹與生物學"><a href="#生命之樹與生物學" class="headerlink" title="生命之樹與生物學"></a>生命之樹與生物學</h2><p>如果以系統發生樹描繪歷史上曾經出現過的生物，會發現地球生命化作一棵大樹，真細菌、古菌和真核生物等枝枒最後匯集在名為最後共祖 (Last universal common ancestor, LUCA) 的根部。透過研究這棵樹上各式各樣的生物，造就了當今的生物化學、分子生物學還有演化學等學科。</p>
<p>也因為現今的生物傳承一段共同的演化歷史，所以研究細菌得出的分子機制往往能夠推廣到其他的生物。然而，如果生命在地球形成了數次，我們能否想像其中一支在不受干擾的情況下獨立演化，以至於這種生命形式與已知的生命毫無親緣關係？</p>
<p>這種生命被稱為影子生物圈 (Shadow biosphere) ，牠們或由不同的元素構成，或採不同的遺傳機制和生化過程，奠立於已知生命的現代生物學可能無法直接適用於影子生物圈。</p>
<h2 id="人造生命與合成生物學"><a href="#人造生命與合成生物學" class="headerlink" title="人造生命與合成生物學"></a>人造生命與合成生物學</h2><p>然而到目前為止，仍未找到任何影子生物圈存在的證據。原因可能是生命形成時遭逢浩劫導致僅有一支生命形式流傳下來，也可能是生命僅能以地球生命的形式萌生，或僅僅是我們選擇了錯誤的搜索方式。</p>
<p>究竟是何種原因仍未有定論，不過合成生物學的研究方向或許能為此帶來一絲線索。合成生物學涵蓋兩個目標：第一，重組既有生命的組件（例如基因、胞器或細胞等）實踐工程目標。第二，從複雜程度不等的物質試圖合成生命。</p>
<p>人造生命可以在兩方面促進生命的理解：第一，人造生命直接拓展我們對於生命可能形式的見解。第二，製造人造生命雖然不等同地球生命形成的真實過程，但卻可以作為測試生命起源理論的對象。</p>
<h2 id="地外生命與天文生物學"><a href="#地外生命與天文生物學" class="headerlink" title="地外生命與天文生物學"></a>地外生命與天文生物學</h2><p>天文生物學則採取跟合成生物學相反的管道，直接搜索可能從地外天體萌生的生命。如同合成生物學，發現任何地外生命都能拓展已知生命的樣本數，也能從地外生命的演化歷程推論地球生命起源的條件與機制。</p>
<p>我想天文生物學家們多少心知肚明，如果我們沒有在太陽系內找到任何其他生命，即使其他恆星系統存在生命，以人類的科技水準也沒有直接研究的指望。因此，儘管天文生物學似乎一再強調「地外」或是「天體」，研究範圍從行星、太陽系以至其他銀河，但天文生物學的基礎不是建立在還沒找到的生命，而是是地球生命本身。</p>
<h2 id="生命之林與廣義生物學"><a href="#生命之林與廣義生物學" class="headerlink" title="生命之林與廣義生物學"></a>生命之林與廣義生物學</h2><p>在一系列討論中，我已經提及三種未知的生命形式：於地球上誕生的影子生命、於實驗室誕生的人造生命，還有其他星球誕生的地外生命。這些假設的生命形成了涵蓋許多潛在生命形式的生命空間（類似向量空間的概念。向量空間是給定向量的所有可能組合，生命空間則是給定物質和能量，所有可能形成的生命形式）</p>
<p>目前的生物學專注於生命空間中的地球生命，對於其他潛在生命的解釋能力有限。合成生物學和天文生物學分別透過製造生命和尋找生命拓展我們已知的生命空間，如果這些嘗試取得成果便會多出許多研究標的。如此一來，生物學將不再限於探討地球生命，而會推廣到其他的生命形式，衍生出「星際生態學」或「碳基與矽基比較生物學」等聽起來很科幻的學科。</p>
<p>換句話說，生物學將從研究生命之樹的學科轉變成研究生命之林的廣義生物學。從這個角度看來，合成生物學建造新的生命之樹，天文生物學則連結已經存在的諸多生命之樹，兩者都是廣義生物學的一部份。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>天文生物學的研究目標是了解生命本質，探討生命形成的機制和搜索地外生命。其與合成生物學的研究進展能促進我們對於其他生命空間的理解，將生物學推廣為廣義生物學。</p>
<p>若想了解更多天文生物學的知識，可參考<a href="https://www.coursera.org/learn/astrobiology">〈天體生物學和尋找外星生命〉線上課</a>。〈天體生物學和尋找外星生命〉是愛丁堡大學天文生物學教授既英國天文生物中心的創辦人 Charles Cockell 於 Coursera 平台開設的入門課程，內容涵蓋生命起源、地球生物史以及搜索地外生命等天文生物學核心議題。</p>
<p>雖然授課內容淺顯，隨堂考也很簡單，可是舉凡天文生物學的理論背景、科學問題的前提假設或是各項發現的衍伸含意都講得很清楚。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>writing</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜我們就是火星人：尋找宇宙中的地外生命</title>
    <url>/bignami-we-are-the-martians/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>生命和宇宙的聯繫是《我們就是火星人》的主旋律。大霹靂後的原初核合成（Big Bang nucleosynthesis）雖然僅持續短暫時間，卻製造了宇宙含量最豐富的元素氫、氦。然而隨著空間持續膨脹，溫度下降到無法維持核融合反應，導致原初核合成中止。</p>
<p>直到第一批恆星誕生，最初的元素才在恆星核融合過程中轉變成組成身體的碳、呼吸所需的氧以及胺基酸裡的硫和氮。不過比鐵更重的銅、鉬等微量元素，得仰賴超新星的爆炸核合成。它提供足夠能量形成這些元素，填補了元素週期表其他空白。另外因超新星爆發而四逸的元素聚集為星際氣體，它們的組成成分隨著每次爆發變得越來越多元，成為孕育複雜分子和行星系統的搖籃。</p>
<span id="more"></span>

<h2 id="生命起源的隨機性與決定性"><a href="#生命起源的隨機性與決定性" class="headerlink" title="生命起源的隨機性與決定性"></a>生命起源的隨機性與決定性</h2><p>若形成最初生命的分子證實來自外太空，那麼宇宙物質的種類與數量分布可能影響了生命的型態，了解它們的源頭與生成機制，就有依據推測為何生物僅採用特定分子而不用另一群分子的謎題（例如手性不對稱）。然而目前為止，這些現象是隨機事件導致的巧合（生命原料源於外太空），還是分子差異演化所致結果（生命原料在地球生成）仍未有定論。</p>
<p>不過最重要的是明白「隨機」和「決定」的含意，如果形成生命的樞紐是可遇不可求的事件，那麼就意味著即便備齊良好條件，沒有機運仍然不會產生生命；反之，如果生命是反應的必然結果，那我們就更有可能從其他條件良好的星球發現生命跡象。</p>
<p>除了體內元素和宇宙的歷史連結，作者還說明了怎麼透過光、隕石和火箭聯繫我們、天體和遙遠的過去。第三章聚焦在搜索行星的觀測天文學，討論觀測結果對行星理論的衝擊。由於行星是生存的根據地，所以適居行星的形成機率也是攸關生命是否普及在宇宙中的關鍵。</p>
<h2 id="接觸天文學與泛種論的關聯"><a href="#接觸天文學與泛種論的關聯" class="headerlink" title="接觸天文學與泛種論的關聯"></a>接觸天文學與泛種論的關聯</h2><p>而在第四、五、六章介紹的接觸天文學，則是從墜落地球的隕石或是從其他天體採集的岩石中直接獲取資訊，由於沒有被瘋狂的地質活動風化，它們仍保留歷史的痕跡，研究者可以藉此得知岩石以至地球的過去。其中較有趣的是默奇森隕石和ALH84001，前者含有豐富有機物質，後者則有疑似微生物的化石，它們暗示著生命源於外太空的泛種論（Panspermia）。</p>
<p>泛種論可以追溯到希臘哲學家Anaxagoras，繼而由提出解離說的阿瑞尼斯發展，解釋胞子受輻射推動從一個星球飄到另一星球（Radiopanspermia），發現DNA雙螺旋結構的克立克亦曾參與，但他認為是外星智慧刻意安排生命在星際中遷移。此書則採用岩石泛種論（Lithopanspermia）試著估算微生物附著在拋向太空的岩石上，散播到其他天體的機會。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>我已經陳述了此書的知識概要，雖然大半篇幅是看似無關的天文學細節上，但這是因為作者一再強調的事——生命和宇宙的過往緊緊聯繫著。探索生命起源之謎可以從既有生命回推古早生命，但追尋古早生命的無機物源頭也是個途徑，沒理由不從天文學找線索，或許能從中找到生命之所以如此的終極原因。</p>
<h2 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h2><p>查詢天文生物學相關書籍時往往會碰上名、實不符的狀況。有些書意不在探討形成生命的機制，但內容卻涉及機制的關鍵環節，得了解這領域的研究方向才會注意到。</p>
<p>另外，生命起源和地外生物也是宗教人士愛好的話題，所以有些書雖然叫作「揭開生命起源的奧祕」，實則在提倡智慧設計和玄學理論。還有一些像此書一樣，書名看起來像科幻童書，卻正正經經地介紹組成生物體的物質源頭。</p>
<p>因此，為了挑到合宜的文本，除瀏覽作者背景和內容概要外，還可以透過圖書館分類號確認，其中與天文生物學密切相關的有361.9（天文生物學）和361.12（生命起源）。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜再創世紀</title>
    <url>/church-2014-regenesis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《再創世紀》的作者將合成生物學的各項里程碑比擬為生物演化和產業革命的重要階段，簡介晚近的基因工程技術並討論其引發的倫理爭議。雖然主題不是講解天文生物學，但是此書前三章關於合成生命的討論對釐清生命的定義有許多啟發。</p>
<span id="more"></span>

<p>人造生命可分為三種：由現有物種重組新物種、以生物原料製造生命和電腦模擬的虛擬生命。</p>
<p>2010年克雷格凡特團隊的人工基因組細菌即是重組生物的一個案例，研究者合成出維持生命所需的最短基因，再轉殖到細菌中取代原本的基因，這種極簡生命體不只排除了影響生產效率或實驗結果的未知干擾，製作過程中也有助於辨別何為生命的必須要素。至於從無到有建立生命的嘗試則能在找不到地外生物的情況下，拓展或是挑戰我們對生命的定義。</p>
<p>目前這問題仍莫衷一是，除了國中生物課本採用的條列式定義（生命具有繁殖、生長、代謝、運動等性質），還有NASA的定義：生命是能自我增值並遵循達爾文演化的化學系統。</p>
<p>作者則主張生命並非涇渭分明的概念，而是一種連續的屬性，可以透過再現複雜度（replicated complexity）度量。然而作者沒有明講其定義，只能從他舉的例子推測再現複雜度是指「重現近似複雜結構的能力」和「複雜結構間的關聯性」。這觀念可以解釋條列式定義的反例，例如：</p>
<ul>
<li><strong>病毒</strong>：得仰賴宿主的酵素系統複製基因組，因此只有有限重現能力，是再現複雜度較低的生命形式。</li>
<li><strong>騾子</strong>：雖然不能繁殖，但是體內細胞仍有自我複製能力，而且個體的複雜度源頭可連結自親代，仍有相對高的再現複雜度。</li>
<li><strong>火焰</strong>：火焰也是能夠成長和自我複製的系統，但是延燒火焰的性質和燃燒物有關，和原本的火焰關聯較低，因此再現複雜度不高。</li>
</ul>
<p>不同的定義反映著不同的哲學觀。好比說NASA把生命限制為化學系統是基於太空搜索的實用目的；但是作者作為創造生命的鼓吹者，自然不滿足於這種限制，因此他的定義能涵蓋自我複製並演化的機械人。我覺得重要的不是比較這些定義的優劣，而是了解定義的理論背景和適用範圍。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Church &amp; Regis. (2014). Regenesis: how synthetic biology will reinvent nature and ourselves. 中國由電子工業出版社翻譯並出版，《再創世紀：合成生物學將如何重新創造自然和我們人類》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Complementing a strand of DNA (REVC)</title>
    <url>/complementing-a-strand-of-dna/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 序列，回傳其反向互補序列。</p>
<blockquote>
<p>Given: A DNA string s of length at most 1000 bp.</p>
<p>Return: The reverse complement sc of s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/revc/">https://rosalind.info/problems/revc/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>2017 年交大某生物相關研究所入學考試其中一題為：「若 DNA 其中一股序列為 ATCGATCG，求其 complementary DNA 序列為何？ (A) AUCGAUCG (B) ATCGATCG (C) TAGCTACG (D) GCTAGCTA。」<br>解題的關鍵在了解分子生物的專有名詞定義，以下是各種 DNA 序列的簡介</p>
<ul>
<li>DNA: 去氧核醣核酸</li>
<li>RNA: 轉錄 DNA 之產物</li>
<li>complementary DNA (cDNA)：反轉錄 RNA 之產物</li>
<li>complementary strand of DNA：DNA 兩股互為彼此的 complementary strand of DNA</li>
<li>reverse complement of DNA：順序反轉的 complementary strand of DNA</li>
</ul>
<p>若 DNA 在轉錄後未經加工，原則上對於 DNA 的其中一股而言有以下關係：</p>
<ul>
<li>DNA 序列 &#x3D; complementary DNA 序列</li>
<li>RNA 序列 &#x3D; 把 T 換成 U 的 complementary strand of DNA 序列</li>
<li>complementary DNA 的序列和 complementary strand of DNA 互補</li>
</ul>
<p>因此，答案為 (B) ATCGATCG，若混淆 complementary DNA 和 complementary strand of DNA 會選到完全相反的答案。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>取得反向互補序列的任務可分解為替換鹼基和反轉序列順序。</p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 的字串可以像 list 一樣以索引值提取數值，因此得以 <code>str[::-1]</code> 取得反向序列，此表達式的涵義為「由字串的最後一個字符，一次一個取出所有字符」。而替換互補鹼基則要先建立密碼表（即 A to T, T to A, C to G, G to C），再參考密碼表替換字串中的字符。我使用的第一個策略是以 dictionary 儲存互補鹼基的密碼表，接著建立逐一替換輸入的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    comp = &#123;<span class="string">&quot;A&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;T&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;G&quot;</span>: <span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(comp[nt] <span class="keyword">for</span> nt <span class="keyword">in</span> dna[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>第二個方法則是使用 maketrans(old, new) 建立字符替換的密碼表，再以 translate() 依據密碼表同時替換字串中相應的字符。由於maketrans 是字串這個物件的靜態方法，所以需要在前面加字串來調用之。既然這字串跟副程式其它功能無關，就用空字串表示以免混淆，不然理論上用什麼字串都行，可參考 <a href="https://stackoverflow.com/questions/64513034/purpose-of-string-in-front-of-maketrans">Purpose of string in front of maketrans</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> dna[::-<span class="number">1</span>].translate(<span class="string">&quot;&quot;</span>.maketrans(<span class="string">&quot;ATCG&quot;</span>, <span class="string">&quot;TAGC&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下則是我最初的錯誤嘗試，原先打算連續使用 replace() 替換鹼基，但後來發現第一次迴圈的結果會被第二次會圈抵銷掉（第一次：A to T, 第二次 T to A），所以才會採用前述的方法迴避問題。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># WRONG METHOD!</span><br><span class="line">code = &#123;&quot;A&quot;: &quot;T&quot;, &quot;T&quot;: &quot;A&quot;, &quot;C&quot;: &quot;G&quot;, &quot;G&quot;: &quot;C&quot;&#125;</span><br><span class="line">rcdna = dna</span><br><span class="line">for i, j in code.items():</span><br><span class="line">    rcdna = rcdna.replace(i, j)</span><br><span class="line">print rcdna</span><br></pre></td></tr></table></figure>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>相較於 python，R 無法以索引值擷取字符，所以需要將字串轉變為其他格式再處理，以下方法參考 Four ways to reverse a string in R[<a href="https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]">https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]</a></p>
<ol>
<li>利用 strsplit() 將字串分割為 list，再以 rev() 反轉 list 順序，最後使用 paste0() 將 list 合併為字串。</li>
<li>利用 utf8ToInt() 將字串中 utf-8 編碼的字符轉變為 UTF-32 編碼的整數向量，再以 rev() 反轉向量順序，最後用 intToUtf8() 恢復 utf-8 編碼的字符組成之字串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dna &lt;- &quot;AAAACCCGGT&quot;</span><br><span class="line"># strsplit() method</span><br><span class="line">reversed &lt;- paste0(rev(strsplit(dna, &quot;&quot;)[[1]]), collapse = &quot;&quot;)</span><br><span class="line"># utf8ToInt() method</span><br><span class="line">reversed &lt;- intToUtf8(rev(utf8ToInt(dna)))</span><br></pre></td></tr></table></figure>

<p>由於 gsub() 只能把多種匹配到的字符串替換為一種字符串，<br>，所以得倚重可同時替換多種指定字符的 chartr()。  chartr() 的用法接近 bash 的 tr，會將字串中的 old (舊字符) 替換為 new (新字符)，例如 chartr(“AC”, “TG”, str) 表示 A to T, C to G。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rcdna &lt;- chartr(old = &quot;ATCG&quot;, new = &quot;TAGC&quot;, reversed)</span><br><span class="line">print(rcdna)</span><br></pre></td></tr></table></figure>

<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>bash 的作法較 python 和 R 簡潔，讀取字串，以 rev 反轉字串順序，再以 tr 替換互補鹼基等步驟可寫成一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dna=&quot;AAAACCCGGT&quot;</span><br><span class="line">echo &quot;$dna&quot;| rev | tr ATCG TAGC</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Counting DNA Nucleotides (DNA)</title>
    <url>/counting-dna-nucleotides/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 字串，依照 “A”、”C”、”G”、”T” 的順序，印出四種鹼基符號的數量。</p>
<blockquote>
<p>Given: A DNA string s of length at most 1000 nt.</p>
<p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols ‘A’, ‘C’, ‘G’, and ‘T’ occur in s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/dna/">https://rosalind.info/problems/dna/</a>)</p>
<span id="more"></span>

<p>在此例使用 dictionary 的 key 記錄鹼基符號，利用 value 記錄出現頻率，透過迴圈遍歷整個字串，每逢與 key 相同的字符即增加該 key 之 value。</p>
<p>儘管統計鹼基的方法很直觀，但輸出的順序要留意。題目要求以 A、C、G、T 之順序輸出鹼基出現頻率，但 python 的 <em>dictionary</em> 為無排序的雜湊表，所以值不會依照字母的順序或定義時的順序印出。為了回傳排序後的統計量，要在輸出前調整順序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    freq = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0</span>, <span class="string">&quot;T&quot;</span>: <span class="number">0</span>, <span class="string">&quot;C&quot;</span>: <span class="number">0</span>, <span class="string">&quot;G&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> nt <span class="keyword">in</span> dna:</span><br><span class="line">        freq[nt] = freq[nt] + <span class="number">1</span></span><br><span class="line">    output = <span class="string">&quot; &quot;</span>.join( <span class="built_in">str</span>(freq[nt]) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span> )</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>也可以不自己寫迴圈，套用 python 的字串方法 <em>count()</em> 來統計特定鹼基的數量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">str</span>(dna.count(nt)) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>shell script 要尋找字串也有許多寫法，其中一種做法是透過 grep -o 取得匹配的鹼基，再傳給 wc -l 計算列數（即字串中，指定鹼基符號的數量）。四種鹼基符號的統計值儲存於 array 並以空格間隔，以便輸出時辨識 array 各項目的數值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC&quot;</span></span><br><span class="line">d=()</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> A C G T;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    d+=$(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$s</span> | grep -o <span class="variable">$ch</span> | <span class="built_in">wc</span> -l) <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span>  <span class="string">&quot;<span class="variable">$&#123;d[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Counting Point Mutations (HAMM)</title>
    <url>/counting-point-mutations/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定兩等長字串 s 和 t，計算兩者的 Hamming distance dH(s,t)</p>
<blockquote>
<p>Given: Two DNA strings s and t of equal length (not exceeding 1 kbp).</p>
<p>Return: The Hamming distance dH(s,t).</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/hamm/">https://rosalind.info/problems/hamm/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>分子生物學的突變 (mutations) 是基因序列的改變。其中，點突變 (point mutations) 是指單一鹼基的變化，依照變化的模式可分為 transition（pyrimidine → pyrimidine, purine → purine）和 transversion (purine ←→ pyrimidine)。</p>
<p>點突變的常見原因為化學修飾或複製錯誤。例如亞硝酸 (nitrous acid) 可透過氧化脫胺將 cytosine 轉化為 uracil，導致該位置的鹼基在下一輪複製發生 transition：C≡G (initial base pair) → U≡G (after mutation) → U&#x3D;A (after replication)。</p>
<p>由於 Hamming distance 是兩等長字串對應位置之字符不相符的數量，一條序列要轉變為另一條序列最少需要的點突變次數可用 Hamming distance 描述，藉此得以推論源於共同祖先的兩條基因序列的最簡演化途徑。</p>
<ul>
<li>ATCG 和 AAAA 的 Hamming distance 為 3</li>
<li>1234 和 1233 的 Hamming distance 為 1</li>
<li>dog  和 god  的 Hamming distance 為 2</li>
</ul>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>使用迴圈依序比對兩字串對應位置的鹼基是否一致，再透過記數變項統計不相符的數量即可計算 Hamming distance</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;GAGCCTACTAACGGGAT&quot;</span></span><br><span class="line">t = <span class="string">&quot;CATCGTAATGACGGCCT&quot;</span></span><br><span class="line">hdist = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i] != t[i]:</span><br><span class="line">        hdist = hdist + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> hdist</span><br></pre></td></tr></table></figure>
<p>此任務亦可配合 zip 改寫為 list comprehension 形式，即合計兩字串對應位置鹼基符號不相符的數量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">sum</span>([a != b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(s, t)])</span><br></pre></td></tr></table></figure>

<p>簡言之，zip 可將兩 list 的元素依序取出配對形成新的 list，所以能配合 for 一次處理兩個 list 的元素。例如輸入 zip(“abc”, “def”) 會回傳 [(“a”, “d”), (“b”, “e”), (“c”, “f”)]。zip() 的介紹詳見 <a href="https://blog.gtwang.org/programming/python-iterate-through-multiple-lists-in-parallel/">Python 使用 zip 與 for 迴圈同時對多個 List 進行迭代</a></p>
<p>至於 List comprehension 則能以較簡潔的程式碼應用 for loop，也往往有較高的執行效率。此表達法的典型形式為 [expression for item in iterable]。例如要從字串中取出非A的序列，一般的 for loop 寫法為</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># common method</span><br><span class="line">str = []</span><br><span class="line">for i in &quot;AATCGG&quot;:</span><br><span class="line">	if i != &quot;A&quot;:</span><br><span class="line">		str.append(i)</span><br><span class="line">print str</span><br></pre></td></tr></table></figure>
<p>使用 List comprehension 可將程式碼簡化為一行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># list comprehension method</span><br><span class="line">print [i for i in &quot;ATCGG&quot; if i != &quot;A&quot;]</span><br></pre></td></tr></table></figure>
<p>使用 list comprehension 的其他特性，可參考<a href="https://stackoverflow.com/questions/16341775/what-is-the-advantage-of-a-list-comprehension-over-a-for-loop">What is the advantage of a list comprehension over a for loop?</a> </p>
<p>回到 hamming distance 的計算，另一種寫法是不直接加總 True&#x2F;False，而是用判斷式把不相符時的距離加權記錄在程式中，這樣可以明確表達鹼基不符時，要計算多少距離。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_distance</span>(<span class="params">s1, s2</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Calculating hamming distance of two strings with equal length</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span>( <span class="number">1</span> <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s1, s2) <span class="keyword">if</span> c1 != c2 )</span><br></pre></td></tr></table></figure>

<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>R 的作法則是使用 strsplit 將字串轉換為 list，再以向量運算對應位置的鹼基是否一致，最後以 sum 統計相異鹼基的數量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s &lt;- &quot;GAGCCTACTAACGGGAT&quot;</span><br><span class="line">t &lt;- &quot;CATCGTAATGACGGCCT&quot;</span><br><span class="line">sum(strsplit(s, &quot;&quot;)[[1]] != strsplit(t, &quot;&quot;)[[1]])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Enumerating Gene Orders (PERM)</title>
    <url>/enumerating-gene-orders/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一正整數 n，求包含數字 1 到 n 的所有可能數列與其總數。</p>
<blockquote>
<p>A permutation of length n is an ordering of the positive integers {1,2,…,n} . For example, π&#x3D;(5,3,2,1,4) is a permutation of length 5.</p>
<p>Given: A positive integer n≤7 .</p>
<p>Return: The total number of permutations of length n , followed by a list of all such permutations (in any order).</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/perm/">https://rosalind.info/problems/perm/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>基因體重排（genome rearrangement）泛指基因體上發生的刪除（deletion）、插入（insertion）、重複（duplication）、反轉（inversion）或易位（translocation）等現象。這些變動通常涉及數百至數百萬對鹼基，相較於點突變，它們的影響更為廣泛。</p>
<p>基因體重排的發生機制主要有<sup id="fnref:gu2008"><a href="#fn:gu2008" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.
">gu2008</span></a></sup>：</p>
<ul>
<li>non-allelic homologous recombination (NAHR)：細胞分裂中，染色體對齊時發生錯位，導致片段重組。</li>
<li>non-homologous end-joining (NHEJ)：DNA 斷鍊修復時，連結了非同源的染色體。</li>
<li>Fork Stalling and Template Switching (FoSTeS)：DNA 複製時因故停滯時，新合成的 DNA 意外移動到其他模板進行複製。</li>
</ul>
<p>這些變化可能導致基因無效而喪失功能、彼此融合而改變功能，或是副本數變動而加強&#x2F;減弱功能，從而影響細胞結構與生理。許多疾病和癌症與基因體重排有關，例如 BRCA1 和 BRCA2 的副本數變化與乳癌發作密切相關。<sup id="fnref:ewald2009"><a href="#fn:ewald2009" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.
">ewald2009</span></a></sup></p>
<p>基因體重排不僅是疾病基因體學的重要研究對象，也因為被視為種化的分子機制之一，而在演化生物學中占一席之地。相較於點突變，基因體重排的發生頻率較低，使得親緣關係相近的物種在染色體層級上保持一致，即使它們在局部基因序列上略有不同。</p>
<p>然而，親緣關係較遠的物種則可能因為基因體重排而有顯著差異。在演化過程中，這些沒有被分離到道不同區域或染色體的基因彼此聚集成 synteny block。在比較基因體學中，synteny block 提供了一種比染色體數量和大小更細緻的描述單位，有助於在不過度瑣碎的層級上討論基因體的變化。透過比較 synteny block 的繼承與變化，可以推輪物種分化的歷史。<sup id="fnref:touchman2010"><a href="#fn:touchman2010" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">touchman2010</span></a></sup></p>
<p>這題的設計反映了基因體重排的概念，將每個數列視為一條染色體，其中每個數字代表一個 synteny block，數字的順序則代表這些 block 在餐考基因體上出現的順序或染色體編號。透過模擬單一染色體 synteny block 的不同排列，探索可能的重排情境。</p>
<h1 id="解題"><a href="#解題" class="headerlink" title="解題"></a>解題</h1><p>讓我們從最簡案例來推論怎麼用遞迴解這題。假設數列只有一個數字，也就只有一種可能的排列；而兩個數字的排列也很直觀。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n = 1</span></span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># n = 2</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>現在考慮數列有三個數字的情形。由於沒辦法一眼得到解答，於是我們需要更系統的解決辦法，其中一個策略是：</p>
<ol>
<li>先取出其中一個數字</li>
<li>排列剩下的數字</li>
<li>把取出的數字加回排列結果</li>
<li>重複取出所有數字後，便得到數列的所有可能</li>
</ol>
<p>如同以下各數列所示，我首先依序取出 1、2、3 （數列的首項），然後再排列剩餘兩個數字，再把取出的數字與排列後的數列結合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n = 3</span></span><br><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>歸納前述方法，便能用 python 實作以下關係：</p>
<ul>
<li>若數列只有一個數字，回傳此數列</li>
<li>若數列不只一個數字，則依序取出各數字，排列剩餘數字，再把取出的數字加到排列的結果中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Permutations of a list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [l]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>隨後便可整理排列的結果為題目要求的格式。由於我們已經列出所有可能數列，所以直接計算數列總數即可，不用多做一次階乘計算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_permutations</span>(<span class="params">n</span>):</span><br><span class="line">    num_perms = lperm(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(num_perms))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> num_perms:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, p)))</span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>我解這題的靈感來自 <a href="https://stackoverflow.com/questions/23116911/all-permutations-of-a-string-in-python-recursive">All Permutations of a String in Python (Recursive)</a> 這串問答，我只需要把原方法改寫為適合 list 的方式即可。不過一開始我寫成以下形式，能看出會報什麼錯誤嗎？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !!!! WRONG SOLUTION !!!!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> = [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>關鍵在於遞迴關係的初始狀態設定，這個 function 預期要回傳一個存儲所有可能數列的巢狀 list，但我在初始狀態的時候寫成 <code>return l</code>，導致遞迴調用 function 回傳了一個攤平的 list。於是 <code>p</code> 就成了整數，自然無法和 <code>[e]</code> 相連，讓程式無法運作。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:ewald2009"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">ewald2009.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.<a href="#fnref:ewald2009" rev="footnote">↩</a></span></li><li id="fn:gu2008"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">gu2008.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.<a href="#fnref:gu2008" rev="footnote">↩</a></span></li><li id="fn:touchman2010"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">touchman2010.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/</a><a href="#fnref:touchman2010" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>《時空旅人之妻》的人物描繪分析</title>
    <url>/exploring-character-depictions-in-the-time-travelers-wife/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《時空旅人之妻》細膩地刻劃出由於時空錯置所引發的複雜情緒，如悲傷、惆悵與無奈等。以主角亨利為例，在他首次覺悟到，自己竟然是唯一的時空穿越者的情節中，作者精確地捕捉並揭露了年幼亨利的失落與成年亨利的無助，以及無論在何時都無法擺脫的孤獨。</p>
<p>這橋段我非常喜歡，因此全文引述如下：</p>
<blockquote>
<p>這若即若離的半透明時刻。另一個我原先搞不太清楚，然後就懂了。就像現在這樣，我看著這件事情發生，希望同時成為我們兩個，希望再感受那種迷失自己的感覺，希望再一次感受第一次看到未來和現在夾雜在一起的感覺。但是我已經太習慣、太熟悉這種感覺了，所以我只能當個局外人。我想起我九歲時的驚訝，我那時突然了解：我的朋友、導師兼哥兒們，就是我。我，就只有我。這種感覺真寂寞。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>「你就是我。」<br>「但你比較老。」<br>「可是……其他人呢？」<br>「其他的時空旅人嗎？」<br>他點點頭。<br>「我不認為還有別的時空旅人，我從來沒碰過其他人。」</p>
<p>有顆淚珠凝聚在他左眼眼角。當我還是個小鬼頭時，我想像有一大群時空旅人，而亨利，也就是我的老師，是一名使者，被派來訓練我；而我最後也能加入這個友好的大圈子。我到現在依然覺得自己就像個被世人遺棄的人，是某個曾經繁榮族類碩果僅存的一人。這就好像魯賓遜在海灘上發現了人類的足跡，但後來才知道那是他自己的腳印。那個我自己，那個小得像片樹葉、薄得像水的自己，哭了起來。我抱住他，抱住自己，久久不放。</p>
<p>後來，我們向客房服務點了熱巧克力，一邊觀賞強尼．卡森的節目。燈還亮著，亨利就睡著了。節目播完後，我盯著他看，直到他消失無蹤，回到我爸公寓的那個老房間，昏昏欲睡地站在以前那張床的床邊，然後滿心感激地倒在床上。我把電視和床頭燈關掉，一九七三年的街道噪音從打開的窗戶飄進來。我想回家。我躺在旅館硬梆梆的床上，很孤單、很寂寞，還是不明白這是怎麼一回事。</p>
</blockquote>
<p>除了情感的刻劃，角色和環境的描寫也栩栩如生。加上作者巧妙地運用時間跳躍的設定，為角色的日常生活情節添加了懸疑、推理，甚至是動作的元素，所以即便故事的主線是描述日常的愛情關係進展，卻仍然能引人入勝。</p>
<p>因此，我認為值得花時間去研究和學習作者的寫作技巧。例如，書中描述亨利偶然在過去碰見母親的片段，在此場景，亨利以旁觀者的角度，描述眼前母親的形象：</p>
<blockquote>
<p>我看到媽媽跟我在一起的情況：她懷孕了；他們把我從醫院抱回家了，她推著嬰兒車去公園，坐下來背樂譜，輕聲唱著歌，還微微比著手勢，對我扮鬼臉，拿玩具逗我；或是牽著我的手散步，欣賞松鼠、汽車、鴿子，以及任何會動的東西。(page 127)</p>
</blockquote>
<p>作者以行為而非外觀作為起點，透過描繪與母親共度的生活點滴，來塑造出讀者可以共鳴的人物形象。</p>
<p>我覺得有趣的地方在於，這段文字雖然字詞簡潔，描述亦不繁複，然而，這些行為的涵義已深深烙印在大眾的共識中，無論這些印象來源於媒體或個人經驗。因此，儘管沒有明示行為中的親情元素，讀者仍能依照自己的經驗，補全對於「慈愛」的回憶與想像。</p>
<p>換言之，在敘述故事時，文字不只是人物形象的代言，更是激發讀者想像力的媒介。我們如何描述人物，其實源於我們如何觀察人。當我們在腦海中塑造人物形象時，我們最關注的是什麼特質？在寫作時，我們又希望這些人物如何在故事和我們的想像中活躍？除了外貌、打扮和性格標籤外，什麼樣的行為可以讓人物顯得充滿生命力？</p>
<p>此外，我也摘錄了書中一些描述人物外觀的段落，試圖了解作者怎麼形容人物的外觀，並藉此佐證透過人物行為所營造的形象。</p>
<p>案例一，亨利描述他的母親：</p>
<blockquote>
<p>她穿著布做的外衣還有七分褲，腳上套著懶人鞋。她有一頭烏黑的秀髮、引人注目的五官、豐滿的嘴唇、大大的眼睛、俏麗的短髮；她看起來像義大利人，但其實是猶太人。我媽連去乾洗店也會擦口紅、畫眼線、塗睫毛膏、刷腮紅還有畫眉毛(page 127)</p>
</blockquote>
<p>案例二，克萊兒首次拜訪亨利家時，見到金咪（很照顧亨利的鄰居）的印象：</p>
<blockquote>
<p>亨利敲了敲一間公寓的門。有個嬌小的韓國女人馬上就把門打開，那是金咪，她穿著一件藍色絲質洋裝，還塗著大紅色的口紅，她的眉毛畫得有點左右不平衡，頭髮是黑白相間的那種灰色。她把頭髮編成辮子，然後在兩邊的耳朵旁各盤了一個髮箕。不知為什麼，她讓我想到了羅絲．高登。金咪身高大概到我肩膀，她把頭往後仰，說，「亨利，她長得太漂亮了！」(page 250)</p>
</blockquote>
<p>案例三，克萊兒瞧著亨利的父親：</p>
<blockquote>
<p>我點點頭，然後跟著她走進客廳，亨利的爸爸也在裏頭，坐在一張扶手椅上。<br>他什麼話也沒說，就只是盯著我看。亨利的爸爸高高的，瘦骨嶙峋，看起來很疲憊的樣子。他長得不太像亨利，有一頭灰白的短髮、黑眼睛、長鼻子、薄嘴唇，嘴角有一點下垂。他縮成一團坐在椅子裡，我注意到他的手，又長又優雅，就像正在打盹的貓咪躺在他的膝蓋上。(page 251)</p>
</blockquote>
<p>案例四，初次約會時，亨利對克萊兒的觀察：</p>
<blockquote>
<p>「哈囉，」我打了個招呼，克萊兒穿著一件酒紅色的絲絨洋裝，戴著珍珠項鍊，看起來就像是用約翰．葛萊姆手法所寶線出來的波提切利畫下的女子，有著灰色的大眼睛、挺直的鼻子、日本藝妓般的櫻桃小口。她的紅色秀髮及肩，遮住了她的肩膀。克萊兒實在是太蒼白了，看起來就像燭光下的蠟像。我把玫瑰花送到她的面前，「送給妳的。」(page 21)</p>
</blockquote>
<p>案例五，亨利與往後的摯友首次見面：</p>
<blockquote>
<p>電鈴聲很嚇人，我把門打開。「往上走就對了！」一個低沉的男性嗓音喊道。我慢吞吞地爬了四段樓梯。嗓音來自一個高大的金髮男性。留著舉世無雙的龐巴度髮型，叼著一根菸，穿著波蘭「團結工聯」的T桖。他看起來很面熟，但我一時想不起曾在哪裡見過他。對一個有著西班牙名「戈梅茲」的人來說，他看起來太像……波蘭人了。後來我才知道他的真名是楊．戈莫林斯基。(page 147)</p>
</blockquote>
<p>案例六，亨利與克萊兒的父親見面：</p>
<blockquote>
<p>克萊兒介紹我時，他們突然微微露出一股嫌惡之情，不過菲利普．艾布希爾是名律師，可以主宰他臉上的五官，所以在一分鐘之內就換成了一張和藹可親的笑臉。這位東道主，也就是我女朋友的爸爸，一個頭逐漸禿了的中年人，戴著飛行員眼鏡，有一副鬆弛中的運動員身材，還有一雙肥厚有力的手、打網球的人的手，雖然他很推心置腹地咧著嘴笑，但是一直用灰色的眼睛充滿驚覺地盯著我。(page 187)</p>
</blockquote>
<p>案例七，亨利去拜訪肯德瑞克博士（亨利的主治醫師）：</p>
<blockquote>
<p>我進入肯德瑞克博士的辦公室，他在某個檔案夾上記東西。我坐了下來，他還在寫。他比我想像的更年輕，大概才三十七、八歲吧。我總以為醫生都是老人家，沒辦法，這是我小時候見過無數個醫生所留下來的印象。肯德瑞克博士有一頭紅髮，臉很瘦，留著絡腮鬍，還帶著鏡片很厚的金屬框眼鏡。他看起來有點像 D. H. 勞倫斯，穿著一套很好看的炭灰色西裝，打著細長的深綠色領帶，領帶上別著虹鱒的領帶夾。這間房間瀰漫著香菸的煙霧，雖然她現在沒有抽菸，但菸灰缸都滿出來了。房間裡的一切都很現代：鋼管、米色的斜紋布、淺色的木頭。他抬頭看著我，對我微笑。(page 327)</p>
</blockquote>
<p>總結這些段落，我們可以發現，人物的介紹始於一個事件，事件讓文字聚焦在人物身上，也確定了描繪的起點。新角色透過感知（案例五）、回憶（案例一）、空間轉換（案例二、案例七）等情況自然地進入場景。</p>
<p>進入場景的事件也限制了最初描繪人物的方式。比如在案例五中，如果亨利是透過聽到呼喊聲才意識到戈梅茲的存在，那麼一開始，應該只能仰賴聽覺描述，隨著戈梅茲進入視線範圍，才會加入視覺描述。</p>
<p>在案例二中，當金咪出現在門口時，克萊兒首先注意到的是金咪的衣著（個人最明顯的特徵），然後才是對方的臉，特別是對髮型的詳細描述。而在案例三中，克萊兒是被動地注意到亨利父親的視線，所以反而是先描述對方五官的形象，然後再描寫手部的狀況。</p>
<p>完成初步描述後，作者的描述模式因角色而有所不同，但仍可以歸納為以下幾點：</p>
<ol>
<li>陳述引入人物的事件，然後根據事件的性質，給出人物的初步描述。</li>
<li>從最顯眼處描述人物的衣著、五官或身材，然後從頭到腳或從腳到頭補充細節。例如在案例六中，因為首先描述了克萊兒父親的禿頭，所以接下來才從上到下描述角色的眼睛、身材和手；而在案例二中，則是先看到金咪的口紅，所以從下到上依次描述眉毛與發型。</li>
<li>詳細描述能反映角色形象的外觀特徵，比如在案例一中的母親的妝容、案例二中的金咪的髮型、案例三中的亨利父親的手，以及案例五中的熟悉的面孔。</li>
<li>可以穿插敘述者對人物的印象或比喻等，幫助讀者想像。</li>
</ol>
<p>儘管這些內容還不全面，但我認為這樣的模式已經可以指引一些寫作方向。畢竟，人物描寫不僅僅是文筆問題，還涉及到如何選擇對象、要觀察哪些特徵、如何尋找故事性、要選擇哪些詞語等問題。因此，為了提高人物描述的能力，我可能會進行以下的練習：</p>
<ol>
<li>留意記憶中或生活中值得關注的人物。</li>
<li>回想這些人物因為何種事件或行為讓人印象深刻。</li>
<li>按照本文總結的模式進行人物描寫。</li>
<li>通過描寫的過程，了解自己在詞匯和觀察方面的不足。</li>
<li>思考這些人物描述可以放在故事的哪個環節，需要多少篇幅才合適。</li>
</ol>
<p>當然，這些指導是為了練習寫作而設計的，除了外觀和行為，人物形象還包括思想、習慣、信仰、目標、能力和恐懼等面向，而人物描述也只是故事的其中一個環節。</p>
<p>然而，外表和行為是最容易觀察的項目，也是反映人物態度與選擇最直接的線索。因此，從這些外顯要素著手，對於寫作新手的我來說，或許是一個非常好的出發點。</p>
]]></content>
      <categories>
        <category>sf</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>寫論文的糟糕和美好經驗</title>
    <url>/good-and-bad-experiences-in-journal-article-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我對論文寫作的第一印象是「寫論文很難，要花很長的時間才能完成，而且從準備到發表過程中會受到大量的批判，一路過關斬將才有機會嶄露頭角」。</p>
<p>所以每當開啟 word 檔開始打字的時候，都有起步的焦慮感：覺得自己還沒準備好，想要把文獻回顧完全，研究結果做到滴水不漏才有辦法動筆。</p>
<p>這種印象部分奠基於碩士論文寫作經驗，當時往往盯著螢幕許久沒有任何想法，最後歸因於自己文獻回顧不夠完整或是研究做得不夠完善。</p>
<p>我意識到阻礙我進展的是對於完美論文的期待，我期待論文能夠達到讓我感到愉悅和成就感的標準。</p>
<p>然而，人們總是無法在初稿時達到滿意的程度吧？而且論文需要於修改中逐漸精緻，沒辦法一蹴可幾，我的期待反過來成為我的壓力。</p>
<p>為了舒緩這種壓力和焦慮，我轉而把精力投注在文獻回顧或改進研究內容。雖然多做準備能暫時減緩我的焦慮和踏實感，但這只是將自己的壓力和負擔延後，之後將面對更多的時間、資源和要求的壓力。</p>
<span id="more"></span>

<h2 id="「發表論文的初衷是感謝」"><a href="#「發表論文的初衷是感謝」" class="headerlink" title="「發表論文的初衷是感謝」"></a>「發表論文的初衷是感謝」</h2><p>而我對論文的美好經驗則來自研究所的老師。我的指導教授從前曾問我：「你認為我們為什麼要投稿論文？」</p>
<p>從功利的角度講，Publish or Perish。發表論文是在學術界生存的根本，也是一個人能力的證據，舉凡畢業、獎學金、申請學校、公司求職、學校教職等皆可能需要論文作為能力的佐證。</p>
<p>然而，我的指導教授認為這些都只是其次，發表論文的初衷是感謝。</p>
<p>為什麼感謝？做研究總是關注著某些議題，為了解決問題，我們參考了這麼多文獻，我們正是對於前人的文獻表達感謝。</p>
<p>表達感謝的途徑有二，首先是引用這些文獻，彰明他們的貢獻；其次是基於這些文獻發展出我們的想法，促進對議題的理解，讓這些想法得以演化和繁衍下去。</p>
<p>科學是尋求解釋的活動，而我們對世界的認知並非一日造就而成的。無論是科學革命還是漸進式的科學史觀，當今的知識體系都是多人長年活動累積的結果，一項研究的鑄成往往有其思想根基和參考依據，無論是要贊同、反駁還是引發想法，都會踏過前人的足跡。</p>
<p>經過長期演變，論文已是紀錄和傳播科學活動成果的最有效和公認的媒介，研究和發表其實就是：我們感到疑惑，我們開始研究，我們參考了誰的想法和觀念，我們想到了一些點子和把持一些觀點。</p>
<p>我們想要提供一些新的解釋，我們感謝前人對於我們思想和研究的幫助，我們回饋學界這些觀念，用一種經過長期演變且公認最有效率的媒介，論文。</p>
<p>以感謝的角度來看待論文發表很大程度地舒緩了寫論文的恐懼和壓力，即使論文有那些功利價值，但我的指導教授還是提醒了我研究和發表理想和溫暖的一面。</p>
<h2 id="「一則文獻既不是最重要的也不是最不重要的」"><a href="#「一則文獻既不是最重要的也不是最不重要的」" class="headerlink" title="「一則文獻既不是最重要的也不是最不重要的」"></a>「一則文獻既不是最重要的也不是最不重要的」</h2><p>而對論文另一部份美好經驗則來自論文寫作課的老師。</p>
<p>有別於我的指導教授，寫作課老師從實用角度分析論文的寫作與發表，將論文寫作描述得很像 youtube 上頭 8 分鐘的 DIY 影片，好像我們在某個閒暇無事的下午，點開影片照著做就可以完成，不是什麼無法做到的事。</p>
<p>總結他的課程，他強調論文寫作縱使有那些功利價值，也不需要感到壓力，論文發表會被 reject 沒錯，但再換家推銷就好。</p>
<p>換句話說，寫作課老師讓我感受到，即使沒有達到最完美的狀況，論文還是有價值；即使還沒有準備好，也能開始動筆；即使能力還不夠，進展中就會有所成長；即使被批判，那也是很自然，因為這都是科學過程的一部分。</p>
<p>一則文獻既不是最重要的也不是最不重要的，科學重視的是合理而非真理，文獻呈現的是探索的過程，我們沒辦法在一則文獻中完全佐證我們的主張或對世界的看法。</p>
<p>錯誤與正確都是研究累積後，後世對我們的評價而已，所以不用太擔心文獻被批判等等，這本來就是科學新陳代謝的一環。</p>
<h2 id="正向寫作經驗的關鍵"><a href="#正向寫作經驗的關鍵" class="headerlink" title="正向寫作經驗的關鍵"></a>正向寫作經驗的關鍵</h2><ul>
<li><strong>寫作是 routine</strong>：寫作跟運動很像，寫作的愉悅需要一點投資，最重要的投資就是起步的意願，隨後是堅持的決心。寫作是 routine，而非儀式行為。是以，治療寫作不快或抑鬱的方法跟控制慢性病一樣，每天吃藥（寫作）。</li>
<li><strong>參與感</strong>：讓寫作交流可以提升寫作的回饋感，因為寫作終究是科學交流的一部份。透過研討會、一對一討論、編修等途徑，可以從中得到寫作靈感而疏通寫作瓶頸，也可以從交流中獲得參與感和社群歸屬，最終得到「意義」</li>
<li><strong>正面看待評論</strong>：看待拒稿和批評的認知轉換有助於降低寫作的恐懼，投稿寫作就跟賣東西一樣，一定有人買，只是看誰會買和賣什麼價碼而已。論文跟基因不一樣，別人罵你先天特徵是沒機會改變，但別人批評論文內容有改善的機會。</li>
<li><strong>分享的心</strong>：如果真心喜歡自己的研究，那寫作就是分享自己熱情和喜好的管道。若有類似的經驗便能體會為什麼用分享看待寫作可以增加正向寫作經驗。</li>
</ul>
<h2 id="當然還是有糟糕的經驗"><a href="#當然還是有糟糕的經驗" class="headerlink" title="當然還是有糟糕的經驗"></a>當然還是有糟糕的經驗</h2><p>儘管羅列了一堆美好經驗和建立正面想法的「要點」，寫論文還是有坐困愁城和自我質疑的時候，像是指示牴觸價值觀、結果不明又不想自欺欺人、截止日到但品質不滿意等等。</p>
<p>舉我的例子來說，我不太習慣被 Paul Nurse 稱之為「修正主義 (revisionist)」的科學敘事 (Nurse. (2016). Cell, 165(6), 1301-1306.)。就我理解，這是指論文敘事隱藏了科研的意外與不可控，調整文章內容以說個毫無破綻的好故事，而不是說個貼近事實的發現歷程。</p>
<p>最容易接觸這類修正主義的途徑可能是台灣的理科教科書。從歐幾里得、牛頓、孟德爾、波爾、拉瓦節，課本呈現的是生硬且不直觀，但和諧線性的科學史觀。理論的發展與邏輯的推演高度相符，彷彿有了前提、假設和足夠的測量，理論即順水推舟浮現，科學史跟課本都能一併翻向的新頁。</p>
<p>我想，為了溝通的效率，精簡內容和梳理邏輯是撰寫論文的必要過程。然而，當論文呈現與事實迥異的發現軌跡，後人要追溯某項理論的沿革時，只能走在一條虛構的途徑上，而這條途徑很可能只在想像中行得通。</p>
<p>等到開始寫論文，我也希望自己能夠避免這種狀況，想盡可能讓論文的敘事貼近發現的過程，保留激發研究點子的關鍵因素，討論理論與結果衝突的理由與和解方式，而不是為了結果而調整敘述過程的方向。</p>
<p>雖然只是一點點，但我也想要為自己認同的理念和未來做點事。不過，我後來才體會到，論文寫作還是有協商的因素存在，與合作者的協調、與計畫主持人的溝通、與編輯和審閱者的答辯等等。</p>
<p>我想這些合作與協商是必要的，只是折磨之處在於，若討論不是基於事實與道理，而是訴諸權威或群眾等無關論文內容的事情，那麼我有點難克服下筆時的抗拒感。</p>
<h2 id="但我還是想記住好的"><a href="#但我還是想記住好的" class="headerlink" title="但我還是想記住好的"></a>但我還是想記住好的</h2><p>儘管如此，我其實是喜好寫作表達想法的，我覺得將自己的主張和論證陳述清楚，嘗試去說服別人的過程仍值得投入。</p>
<p>畢竟寫論文也是一種發聲管道，若渴望能依照這途徑去實踐或改變什麼，那是否要做下去也非取決於經驗的好壞，而是渴望的程度。</p>
<p>既然如此，傾聽內心裡較良善的聲音讓自己有動力做下去，我覺得會比被糟糕回憶困住半途而廢還來得有機會幫助自己達到目標。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜樹之歌</title>
    <url>/haskell-2017-the-songs-of-trees/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>歌，是有序的聲音；聲音，則是波動的一種形式。若沒有變動與交互作用，也就不會產生聲音。因此，聲音也是網路的一項性質。</p>
<p>Haskell 以樹木為觀察對象，描述樹木與雨水、風、動植物、微生物等事物互動發出的聲響，揭示了看似孤立的樹，實則串聯萬物的生命史，形成龐雜的生命網路。</p>
<span id="more"></span>

<p>除了科普生態與植物學知識，Haskell 亦借題簡介有關的生態議題，探討人類應抱持何種倫理觀點，看待因開發造成的生態破壞。究竟要把人類視為自然的一部份，而連帶將汙染與滅絕視為無須干預的現象？還是劃清人類與自然的界線，強調人類維護自然的責任？</p>
<p>Haskell 認為，前者會陷入虛無主義，後者則忽略了人的自然性。因此，真正的答案，或許得回歸生物網路之中，我們需要把自己放在自然網路的脈絡思考，而不是單用人類這物種的觀念看待自己。</p>
<p>畢竟，塑造我們的不只是這副軀體，還有環境、共棲微生物、作物和獵物等。所有的生命過程，都是網路中的一個節點和其他節點形成持續變動的關係。透過這是腳，我們能漸漸體會何者為美，何者為值得保護的東西，什麼又代表好，從而找出人類在全球變遷中該負起何種道義責任。</p>
<p>這本書讀起來，像帶有自然書寫風格的抒情文，用字遣詞華麗而浪漫。在此紀錄書中一些有趣的概念。</p>
<ul>
<li><strong>雨的語言</strong>：由於各地的空氣粒子組成不同，黏附著不同懸浮粒子的雨水也就蘊含著各自的語彙和文法。</li>
<li><strong>植物的記憶</strong>：植物雖然不像動物以電流傳遞訊號，但也會用化學留住事件的傷痕。我想，如果延伸「疤痕是種記憶」的想法，那麼因為河流侵蝕而留下的河谷，是不是也算得上大地的記憶了？</li>
<li><strong>歌的來源</strong>：書中提到克丘亞族相信，樹木與河流都是會唱歌的生命，族裡傳頌的歌曲都是從它們學來的。這點與《複眼人》的瓦憂瓦憂族一致！<br>瓦奧拉尼人：瓦奧拉尼人注重群體而輕視個體，個人的自主性和能力是建立於社群中。他們認為名字是關係的產物，若脫離既有社群，就得捨棄舊有的名稱。例如他們會以植物的用途或是植物與其他生物的關係來為植物命名。因此，同一種植物可能會有不同的名稱和描述，來表示植物與不同事物的關係。</li>
<li><strong>細胞特化</strong>：細胞特化除了增進效率，也避免了細胞擁有過多發展性而癌化。</li>
<li><strong>海洋微粒</strong>：海洋微粒會增加微生物可依附的表面積，從而改變海洋微生物群落組成。</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">David George Haskell. (2017) The songs of trees: stories from nature's great connectors. 台灣由商周翻譯並出版，《樹之歌：生物學家對宇宙萬物的哲學思索》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>hexo 部屬後網頁報錯 &quot;cannot get /&quot;</title>
    <url>/hexo-cannot-get-slash-error/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>新的一年好不容易提振精神來寫文章，想說先把文章的調整更新到網站上。不料，輸入完 <code>hexo clean &amp;&amp; hexo delopy</code> 之後，雖然 Github action 顯示部屬正常，但網頁卻無法瀏覽，分別顯示 “This is not the web page you are looking for” 以及 “There isn’t a GitHub Pages site here”</p>
<p><img src="https://i.stack.imgur.com/Hp57y.png" alt="This is not the web page you are looking for."></p>
<ul>
<li><a href="https://github.com/hexojs/hexo/issues/4098">404 There isn’t a GitHub Pages site here. #4098</a></li>
<li><a href="https://stackoverflow.com/questions/66569047/github-what-causes-gaps-in-issue-number-404-this-is-not">GitHub what causes gaps in issue #Number (404 This is Not…)</a></li>
</ul>
<p><strong>TL;DR: 如果你也碰到這情形，可能是 hexo 部屬工具不全或是，上網隨便找一篇教學，或參照以下指令把相關套件更新後再部屬看看。</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="環境設置"><a href="#環境設置" class="headerlink" title="環境設置"></a>環境設置</h1><p>忘了，只是想一寫文章啊，眼看元旦就要消失了，急著解問題沒記錄環境設置。不過這倒能衍伸出一項新年展望，下次碰到問題記得留意環境問題喔。</p>
<h1 id="調查過程"><a href="#調查過程" class="headerlink" title="調查過程"></a>調查過程</h1><p>使用 <code>hexo server</code> 檢查，發現網站根本起不來，只有一串的 <code>Cannot GET /</code> 掛在蒼白的網頁上。</p>
<p>通常，這項錯誤肇因於 <a href="https://blog.csdn.net/qq_45593330/article/details/116702792"><code>source/_posts</code> 沒有任何文章</a>，可是查看專案資料夾卻發現，所有文章都好端端留在那啊，究竟部屬的時候發生了什麼事？</p>
<p>回頭翻部屬訊息才注意到，哇乾，hexo 不知何故把 <code>gh-page</code> 大多數檔案移除（慘況可參考 repository 上的 <a href="https://github.com/5uperb0y/5uperb0y.github.io/commit/3929872560d5bb2db64fd0a68eb441cac377e355">commit 歷史</a>）。接下來我推測了各種可能性：</p>
<ul>
<li>token 過期等權限問題？但都能順利推上 github 了，先排除這項可能。</li>
<li>可能手賤刪除文章不自知？嘗試回到舊 commit 再部屬，問題依舊。</li>
<li>可能 <code>_config.yml</code> 的分支設錯？檢查設置檔，也確定 origin 分支了，問題依舊</li>
</ul>
<p>到了最後才懷疑套件可能安裝不全或有問題？找了這篇 <a href="https://feifacunzai.github.io/2020/06/29/Hexo-%E7%B4%80%E9%8C%84%E6%9B%B4%E6%96%B0%E9%81%8E%E7%A8%8B/">Hexo 紀錄更新過程</a>，照裡面講的步驟更新套件後再部屬後，網頁和文章都回來啦。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>人生難免碰到困難與障礙，有時並非個人不努力，而是大環境的問題。既然錯不在己，過度糾結也無濟於事，不如更新環境或給自己重新開機的機會，也許問題會迎刃而解呢。</p>
]]></content>
  </entry>
  <entry>
    <title>「天文」生物學：數量的緣故</title>
    <url>/history-of-astrobiology-naked-eyes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>國中時，剛看完《星艦迷航記VIII：戰鬥巡航》的我向學校裡最接近外星生物專家的生物老師詢問是否真有外星人，他告訴我地球外還有許多星球，如果沒有其他生命也太奇怪了。</p>
<p>如同我的生物老師所述，對於地外生命的信心有很大一部分是建立在數量上，既然宇宙已經誕生百餘億年，當中又充滿無數星系，很難想像當中不會有其他生命存在。</p>
<p>然而宇宙的尺度也是經學界漫長掙扎才逐漸變得清晰，早在人類只能以肉眼觀察世界的時候，滿天繁星已不計其數，甚至至今我們對於宇宙中有多少顆適居行星仍沒有精確的估計。</p>
<p>天文生物學的發展不只是事實的累積，也是世代人觀念轉變的結果。</p>
<span id="more"></span>

<h2 id="肉眼"><a href="#肉眼" class="headerlink" title="肉眼"></a>肉眼</h2><p>最初人類只能以肉眼觀察這個世界，其他的天體在天空化為一個小亮點，這些亮點的意義在不同人眼裡衍伸出不同的樣貌，這些推論與想像便成為天文生物學興起前，人們對地外生命的想像基礎。</p>
<p>對於無法觸及的天空，德膜克利特(Democritus, 410 - 380 BC) 等原子學派 (Atomists) 哲人認為，既然原子的隨機運動組成了世間萬物，天與地應遵循相同法則，形成地球的過程沒理由不能在天外形成其他世界，是以其後繼者伊比鳩魯在給希羅多德的信 (<a href="http://www.attalus.org/old/diogenes10b.html">Letter to Herodotus</a>) 中提到，</p>
<blockquote>
<p>We must not believe that all worlds necessarily have one identical form.  Let us also beware of thinking that animals are derived from the infinite; for there is no one who can prove that the seeds from which animals are born, and plants, and all the other objects which we contemplate, have been brought from the exterior in such a world, and that this same world would not have been able to produce them of itself. （我們絕對不能假設各個世界有一致的樣貌，……，因為沒有人能證明形成動物、植物和我們眼前一切的種子無法在這樣的世界萌生。）</p>
</blockquote>
<p>伊比鳩魯的門徒 Metrodorus（400 BC） 也對地外生命的可能留下更明確的評述。</p>
<blockquote>
<p>It is unnatural in a large field to have only one stalk of wheat, and in the infinite universe only one living world.（無垠宇宙僅有一個育有生命的世界和沃野千里卻只長出一束麥子一樣不尋常。）</p>
</blockquote>
<p>相較於原子學派，亞里斯多德學派哲人認為地球是唯一的世界，所以沒有為地外生命留下空間。</p>
<p>亞里斯多德以朝向&#x2F;背離中心的本性解釋火、水、土和空氣四種基本元素的運動現象，所以如果世界不只一個，那麼物質便喪失了明確的運動目標，維繫世界運作的基本原理將不復存在。透過這個規謬過程，四元素說結合地心說共同否定了多重世界的觀點。</p>
<p>此外，天與地也在亞里斯多德體系中割裂。有別於四元素，天空是由以太組成。太陽、月亮還有其他五顆行星就在層層嵌套的天球上緩緩繞著地球旋轉，而原子學派眼裡可能存在繽紛世界的星斗只是鑲在最外層恆星天上閃爍的光點。</p>
<p>同片天空不同的想像與推論，形成了不同的結論。</p>
<p>如今我們知道，原子學派哲人的想像比較接近當今學界對世界的認知，然而這不代表他們是天文生物學還是任何現代科學的根源。囿於當時的觀察手段，無論哪派哲人的思想都沒有嚴謹事實支持，即使有許多詞彙為後世研究者共用，其中的內涵也已發生很大的變化。</p>
<p>但另一方面，儘管只能取得有限的線索，希臘人仍試圖靠著理性與智力解釋世界，而不是將問題簡化為鬼、神、UFO 或我不知道。</p>
<p>亞里斯多德的學說在中世紀時期被阿奎納 (St. Thomas Aquinas, 1225-1274) 納入神學體系，此後單一世界的想法持續主宰著歐洲人的世界觀。然而關於「數量」的爭議並沒有就此定論，亞里斯多德體系在哥白尼掀起科學革命後逐漸衰落，現代科學興起後更多的科技與觀察手段逐漸揭示宇宙的樣貌。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
  </entry>
  <entry>
    <title>從碩班第一次專題課說起......</title>
    <url>/how-i-learn-from-seminars/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>讀碩班前，我其實不知道 seminar 到底要幹嘛，也不知道和我有什麼關係。所以如同曖昧、戀愛等陌生概念，所有關於 seminar 的知識都是PTT教我的。</p>
<p>然而在完成人生中第一次正式報告後，我發現生資所碩一的專題課跟想像中有些差距：老師在有限的檢討時間內傾向於引導同學發現邏輯錯誤，或是補充報告中值得大家學習的觀念，不曾直接指正學習態度、格式錯誤或邏輯謬誤。這點和以往聽聞前輩提到的「 seminar 被老師痛電」很不一樣，上一周報告結束後沒有被批評到一文不值，所以心裡有些不踏實。</p>
<p>不過我內心期望的只是被電的體驗嗎？不對。我渴望的是成長，批判不是成長的唯一途徑。我要從 seminar 中學習的不是接受批評或是習於挨罵，因為這種本領已在服役期間漸漸培養起來，我想從 seminar 獲得學者的素養。</p>
<span id="more"></span>

<h2 id="seminar-是什麼？"><a href="#seminar-是什麼？" class="headerlink" title="seminar 是什麼？"></a>seminar 是什麼？</h2><p>seminar 源於拉丁文的「seminar ium」（苗床），從字根可以看出教育者的期許是讓 seminar 成為新概念的苗床，希望學生在檢視新近研究成果之外，也能互相討論激盪出新的想法。另外，對學生而言，準備報告和參與討論的過程考驗彙整資料、傳達觀念及構思問題的能力，這樣的演練有助於奠立從事學術的基礎。</p>
<p>但是了解  seminar  的起源和目的有什麼幫助呢？</p>
<p>我認為如果可以辨識出課程用意，便能聚焦在學習的成效上，而非「有沒有被電？」、「什麼時候輪到我報告？」、「報告完了是否該吃一頓大餐？」、「同學幹嘛問機掰問題」等無關緊要的指標。</p>
<p>因此，為了學習到更多有價值的事物，我彙整了網路上蒐集到的資料，列舉應當要從課程中培養的能力，並提出可行的練習方式，以在往後的專題課中實踐。</p>
<ul>
<li>學會閱讀研究論文及其內涵</li>
<li>在有限時間內清晰地表達科學概念</li>
<li>能即時答覆聽眾的提問</li>
<li>學會「聽講」這種學習或交流方式</li>
<li>能於聽講過程中組織問題，並清楚地向講者提問</li>
</ul>
<p>雖然要培養的能力還可以找到一大堆，但要專題課的目標可以歸納為「學習扮演研究者、策畫者、講者和聽眾」。儘管還沒有實際投入研究，但學生可以鑽研論文來學習研究者怎麼從觀察中形成問題意識，找出疑點提出假說，最後設計實驗驗證之。</p>
<p>除了實驗結果，科學交流也是科研的一環，有效的溝通能讓他人接受你的主張，所以研讀論文後也要試著報告給其他人聽，學會結合腹稿、逐字稿、簡報呈現流暢的演說。</p>
<p>而且聽講是接受新穎資訊的最快方式，如果想跟上研究前沿，勢必要從研討會中有效接收想法，並累積新觀念。因此一門課不會在報告完就結束了，課程的不同時間點，都有要投注心力的事項和可以學習的地方。</p>
<h2 id="聽講筆記"><a href="#聽講筆記" class="headerlink" title="聽講筆記"></a>聽講筆記</h2><p>準備這次 seminar 的過程中，我累積了一些關於閱讀論文、製作簡報及練習演說的經驗和想法，學習怎麼當個好聽眾也是很重要的議題。</p>
<p>聽講是快速入門研究領域的方式，但成功的報告不只是講者的工作，也需要聽眾的努力。從這幾周的專題報告中我學到一個教訓，就是儘管一開始很認真想理解內容，卻可能因為一時分神或不解而和講者的節奏脫節。</p>
<p>由於時間有限，講者未必有機會頻繁停下腳步回顧內容。聽眾可以透過事先預習背景知識和研究骨幹來減少聽講當下的負擔。例如在報告前細讀書面報告或是瀏覽原始論文，再整理出簡單的筆記帶到會場。如此一來，對於報告內容就有比較明確的形象，即使自己一時分心或沒跟上講者的邏輯，也能靠著預先準備的筆記重新聚焦重點。</p>
<p>此外，由於簡報不像課本那麼詳盡，所以如果沒在演講中把握要點，回家後要複習就只能面對生硬的論文了。因此，如果能在歷次聽講中改善自己的筆記方法，便有助於演講後整理出完整的筆記，這些筆記配合講者的投影片和書面報告，就是往後複習的利器。</p>
<h2 id="練習發問"><a href="#練習發問" class="headerlink" title="練習發問"></a>練習發問</h2><p>如果只是單方面聽講，那麼聽眾與講者的念頭便沒有機會在互動中產生洞見。然而，我們的專題課討論風氣不盛，這可能源於「不敢問」及「不知道要問什麼」兩項障礙。</p>
<p>針對「不敢問」這項障礙，我覺得可以多多思考發問的好處。發問是聽眾在演講中展現主動權的行為，能釐清聽不懂的內容、反駁被曲解的觀念、探討湧起的靈感等，</p>
<p>但是問了蠢問題或有失水準的問題怎麼辦？會不會很丟臉？儘管指導老師總是說世上沒有蠢問題，有問題就要發問。然而，我一直覺得指導老師只是想是要鼓勵同學發言而非描述現況。因為，每次自己問出 google 能輕易解決、過於空泛而無明確或是邏輯不通的問題時，還是覺得自己挺低能的。這些問題對於旁人一點幫助也沒有，浪費其他人提問的寶貴時間，還展示了自己的無知與隨便，所以感到很丟臉。</p>
<p>只是，難道因為會丟臉就不問了嗎？不對啊，變強都來不及了，哪還管什麼丟臉。將相本無種，沒有跌倒幾次怎麼會有往後的好表現？ seminar 是學習與嘗試的好機會。班上有形形色色的同學，每次發問都能和不同的人交流，嘗試不同的提問方法，如此能累積經驗，更有信心面對更大的場合。</p>
<p>此外，每個人對聽講的期待或是議題的關注各不相同，他人對我們提問內容的評斷既無法控制也難以得知。若提出問題的初衷是「我」感到困惑，那麼只要發問可以解決自己的困惑，那麼我認為它就是有價值問題。</p>
<p>畢竟，seminar 都規劃了提問的環節，充分利用這個機會來解決自己的需求，我覺得其實也沒有什麼好丟臉的。如果還是很擔心緊張，也可以課前多花時間預習，聽講時寫好筆記，提問前整理好問題，這樣就不至於給自己太大的心理壓力。</p>
<p>至於「不知道要問什麼」的障礙，除了預習和寫筆記以理解內容外，可以參考平常老師或其他人發問的方式，整理出可以問的問題以及這些問題的特徵，然後依樣畫葫蘆問問題，多問、多想，遲早能問出可以獲得許多回饋的問題。</p>
<h2 id="寫回饋單"><a href="#寫回饋單" class="headerlink" title="寫回饋單"></a>寫回饋單</h2><p>有些學校的專題課會抽同學評論報告內容的優劣，提供意見讓講者更進步。不過如果沒有要求，總覺得這個工作還是交給老師吧。</p>
<p>儘管如此，還是能整理一份鑑賞筆記，用來提示自己或同學徵詢時給他當參考。獨立於報告內容的筆記，鑑賞筆記用於評斷報告的科學結構、內容品質、視覺設計和口語表達的優劣，解釋這場報告優秀或低劣的原因，找出可以學習的優點，紀錄要避免的錯誤。</p>
<p>模仿別人怎麼評論是學習鑑賞的快速方法，可以細聽老師們的回饋，這麼做一方面提醒自己，另一方面也蒐集了評論標的，成為下次聽講時觀察的重點。整理不同的評論內容後，還可以設計出一份回饋單，不僅能節省撰寫評論的時間，這份回饋單也可以作為報告練習時蒐集意見的工具。</p>
<p>在上台報告前通常需要內部演練，收集他人的意見以改進報告品質。事前提醒聽眾要留意的地方或發放回饋單有助於聽眾給出針對性的意見，也方便他們紀錄內容以免忘記，讓講者更有機會獲得明確且豐富的建議。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章是我第一次參加專題課後的心得，裏頭提到的心理障礙有許多仍是我現今要面對的問題。至於，過了這麼久，我對於參加研討會或 seminar 有什麼新的想法或轉變嗎？有啊，我漸漸不再把問問題當秀場了。</p>
<p>以往期待自己能像某些大神一樣，能提出讓講者與聽眾都陷入深思的犀利問題。回過頭來，我發現自己用問題的品質來衡量我的水準，才追逐著所謂「好問題」，試圖證明自己是有能力的人。</p>
<p>然而，一旦陷入這樣的心態，就會不自覺給問題貼上有價值的、沒價值的、令人訝異的、稀鬆平常的等標籤。於是，每次心中有疑惑時，便開始思考這問題有沒有價值。聽講到最後，往往因為覺得問題很平凡，而一個也沒有提。面對這種狀況，我有時還挺懊惱的，例如之前參加微生物生態學年會便有不少精彩的演講，明明有許多共鳴與想法卻不敢發言，錯失了學習的機會。</p>
<p>直到我參加了許多講座與會議，聽到了從基本、艱深到與講題毫無關聯的提問，才矯正了內心對偉大問題的期待。我意識到（或回想起）：「對啊，我就是因為不懂才問問題啊！」</p>
<p>至於能否問個犀利的問題，我蠻喜歡在 <a href="https://www.zhihu.com/question/36980830">知乎</a> 上看到的說法</p>
<blockquote>
<p>我覺得吧，聽講座也罷，看文章也好，讀教科書也算，更重要的不是去挑刺，而是一個更有建設性的問題</p>
</blockquote>
<p>簡言之，研究或開發本身就不是件易事，要從方法學或應用條件等方向去挑毛病真的太容易了。然而，除了指出漏洞並提出可能解決方式以外，另一種延伸想法的途徑是去思考，如果對方的結論是真的，那麼要如何利用這項結論，來幫助我的研究與問題？</p>
<p>透過這種方式思考問題，能延伸出許多跟自己相關的議題，也比較有動機向講者請教，還能拓展關於待解問題的深刻理解或有用猜想。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>tips &amp; tricks</category>
      </categories>
      <tags>
        <tag>communitcation</tag>
      </tags>
  </entry>
  <entry>
    <title>很久很久以前，自然用什麼盛裝生命？</title>
    <url>/how-nature-contains-life-in-early-earth/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1953年，在試管裡的雷鳴閃電與水氣蒸騰之後，米勒與尤里成功在模擬的早期地球環境中合成胺基酸，開啟了研究生命起源的先河。</p>
<p>隨著多種有機質在實驗室合成或於隕石中發現，研究人員逐漸了解生命的物質來源。然而，散落各處的有機質需要彼此接觸才有機會引發生化反應。在早期環境中，有什麼物質能夠形成容器，匯集生命形成所需的反應物？</p>
<span id="more"></span>

<p>現存生命被包覆在由磷脂組成的細胞膜內。磷脂膜的結構穩定且功能齊全，但其組成複雜，所以可能不是最早形成的容器。相較之下，脂肪酸不僅結構簡單，也能形成會膨大與分裂的囊泡。因此，脂質囊泡是構成原始細胞膜的可能選項。 </p>
<p>然而，脂質囊泡對酸鹼值與離子濃度敏感，可能難於多變的環境中穩定存在。是以，Jia等認為在磷脂膜或脂質囊泡形成前，其他容易形成的物質可能組成結構穩定的過渡容器，發揮匯集物質及促進反應的功能。 </p>
<p>為了檢驗這項假說，Jia等採取類似米勒與尤里的策略。Jia等發現，可能普遍存在早期地球的果酸可於模擬環境中形成微滴。這些微滴不僅耐受溫度、壓力和酸鹼值變動，也能吸納蛋白質和RNA等生物分子。</p>
<p>儘管目前無法確認生命是否透過果酸微滴形成，Jia等的研究成果仍支持了新的研究途徑：除了構成現存生命的大分子，存在早期地球的其他分子也可能形成過渡容器，在細胞膜出現前匯集生命形成所需的反應物。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jia et al. (2019). Membraneless polyester microdroplets as primordial compartments at the origins of life. <em>Proceedings of the National Academy of Sciences</em>, 116(32), 15830-15835.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>origins of life</category>
      </categories>
  </entry>
  <entry>
    <title>怎麼決定合併雙端序列時允許的錯配數量？</title>
    <url>/how-to-decide-max-mismatch-when-merging-paired-end-reads/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>illumina 的 Miseq 和 Hiseq 平台常用於定序 16S rRNA 基因特定變異區的增幅產物。因為這兩平台皆屬雙端定序 (paired-end sequencing)，所以每一條 DNA 都會獲得順向和逆向的序列（即定序結果）。在資料處理時，須比對這對序列的重疊區域，再基於重疊區域合併雙方，才能重建出代表該 DNA 的完整序列。</p>
<p>不管使用的軟體為 FLASH 、PEAR 還是 Usearch，合併雙端序列時都有許多參數可以設定。其中一個參數是合併時允許的錯配數量。這參數的必要性在於，即使順向和逆向序列都源於同一條 DNA，兩者的重疊區域仍會因為定序錯誤而略有差異。合併時允許少量的錯配數量能避免捨棄掉這些正確的序列。</p>
<p>然而，我們要怎麼知道洽當的錯配數量上限？使用預設值、反覆試誤、調查文獻都是常見的方法，不過我更想要知道能依照資料選定適用參數的策略。畢竟，如果能先推算出理論值，那麼測試時便有參考的基準，除了能縮減試誤時間，在寫論文或向他人解釋方法時也比較有依據。</p>
<p>因此，雖然在資料處理流程已成熟的今日，糾結參數設定可能被視為無關宏旨，我還是想以本文紀錄，自己思考這個問題的方向與看法。</p>
<span id="more"></span>

<p>首先，順逆向序列的重疊區只要有任一列發生定序錯誤便會發生錯配。由於 illumina 定序平台的逆向序列品質往往較順向序列品質低，假設不計兩序列同時出錯的狀況，重疊區的錯配數量可由逆向序列的預期鹼基錯誤數量估計。</p>
<p>由於 illumina 定序平台的逆向序列品質往往較順向序列低，而且重疊區任何一條序列發生定序錯誤便會造成錯配。假設不計兩序列於相同位點同時出錯的狀況，那麼重疊區的錯配數量上限，可以由逆向序列的預期鹼基錯誤數量估計：錯配數量 &lt; 逆向序列重疊區的預期鹼基錯誤數 * 2</p>
<p>舉例來說，若增幅和定序 16S rRNA 基因 V4 區域之後，獲得一對長度為 250 bp 的序列。由於 V4 區域大約只有 253 bp 長，所以這對序列的重疊區長達 247 bp，幾乎覆蓋了整個 V4 區域。</p>
<p>假設考慮最極端的狀況，即要在順向和逆向序列的每個鹼基都完全對應時，我們才肯相信合併後的序列源於同一條 DNA。那麼，在逆向序列平均品質分數為 20 的狀況下，重疊區的預期錯誤數量為 $0.99 * 247 &#x3D; 2.47$。</p>
<p>這意味著，即使是這對序列得自於同一條 DNA，平均而言也會出現 $2.47 * 2 &#x3D; 4.94$ 個錯配。因此至少要允許 5 個錯配，才能確保這些源於同一條 DNA 的正確序列能順利合併。</p>
<p>推廣來說，錯配數量上限取決於重疊區的長度與品質。隨著對重疊區長度的要求放寬，預期的鹼基錯誤數會跟著下降，允許的錯配數量也得調低，才能確保合併雙端序列的特異性和靈敏度平衡。</p>
<p>依照這個推論，在取得資料時，可以先思考「若這對序列沒有定序錯誤，要有多長的重疊序列，才肯相信它們得自於同一條DNA」。</p>
<p>接著，找到平均品質最差的那個樣本的逆向序列，計算其 3’ 端重疊區域的預期鹼基錯誤數（該段區域的定序錯誤率之和），得出數值的兩倍，應該可以當作測試雙端序列合併的參數的起始值。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
        <category>metagenomics</category>
      </categories>
      <tags>
        <tag>NGS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下載和安裝 RDP classifier</title>
    <url>/how-to-download-and-install-rdp-classifier/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RDP classifier 是基於 Naive Bayes 的物種分類器，常用於註解 16S rRNA 基因序列的分類資訊。除了使用內建的 RDP 資料庫以外，RDP classifier 也允許使用自訂資料庫來訓練分類器。除了內建的 RDP database，也支援以其他資料庫來訓練分類器。</p>
<p>目前，RDP classifier 的核心演算法已被整合到 Mothur 和 DADA2 等流程的副程式庫，所以只要有安裝這些流程軟體，即使沒有安裝 RDP classifier，也能以相同的演算法註解物種資訊。然而，若想要依據自訂或最新的資料庫註解序列，或是使用 copy number 校正等功能，仍有獨立使用 RDP classifier 的必要。</p>
<p>本文將介紹三種下載和安裝 RDP classifier 的方式。</p>
<span id="more"></span>

<h2 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h2><p>透過 conda 安裝的方式可參考 <a href="https://anaconda.org/bioconda/rdp_classifier">Anaconda 的教學</a>。目前，conda 與 RDP 官網提供的 classifier 皆為最新的 2.13 版。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c bioconda rdp_classifier</span><br><span class="line">conda install -c bioconda/label/cf201901 rdp_classifier</span><br></pre></td></tr></table></figure>

<h2 id="官方網站"><a href="#官方網站" class="headerlink" title="官方網站"></a>官方網站</h2><p>若不想要裝一堆附加的軟體或剛好 conda 沒有需要的版本，也可以直接到官網提供的<a href="https://sourceforge.net/projects/rdp-classifier/">連結</a>下載可執行檔。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/rdp-classifier/rdp-class</span><br><span class="line">ifier/rdp_classifier_2.13.zip</span><br><span class="line">unzip rdp_classifier_2.13.zip</span><br><span class="line"><span class="built_in">chmod</span> u+x path/to/rdp_classifier_2.13/dist/classifier.jar</span><br></pre></td></tr></table></figure>

<p>由於 RDP classifier 是依賴 JAVA 的軟體，所以執行時要輸入 .jar 的絕對路徑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar &lt;<span class="built_in">command</span>&gt;  </span><br><span class="line">&lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<p>為了簡化指令，可以創造名為 rdp_classifier 的腳本，並將腳本所在的目錄加入環境變數。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch rdp_classifier</span><br><span class="line">chmod u+x rdp_classifier</span><br><span class="line">vim rdp_classifier</span><br></pre></td></tr></table></figure>
<p>接著把落落長的指令放到腳本中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar $*</span><br></pre></td></tr></table></figure>
<p>如此一來，往後執行時就只需要輸入 rdp_classifier即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdp_classifier &lt;<span class="built_in">command</span>&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>若是 Ubuntu，則可以從套件庫安裝。只是相較於 conda，ubuntu 套件庫內的 RDP classifier 還<a href="https://packages.ubuntu.com/impish/rdp-classifier">停在 2.10 版</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install rdp-classifier</span><br></pre></td></tr></table></figure>
<p>除了前述方法，也能夠安裝集合了 RDP 團隊包含了 classifier 在內各種開發工具的 <a href="https://github.com/rdpstaff/RDPTools">RDPTools</a>。只是 RDPTools 是透過 make 和 makefile 來編譯與安裝。由於依賴的軟體和環境設定等問題，我到現在還沒成功過，暫時無法整理出相關的筆記。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
        <category>metagenomics</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>如何管理常用的 Command Line 指令？</title>
    <url>/how-to-manage-commands/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://imgs.xkcd.com/comics/tar_2x.png" alt="xkcd:tar (https://imgs.xkcd.com/comics/tar.png)"></p>
<p>有些指令很常用，但使用頻率不見得高到能讓人既起來。那麼，除了使用記事本以外，還有什麼方法能有效管理這些指令呢？</p>
<p>本文總結一些管理指令的經驗和訣竅，並且介紹好用的開源工具供參考。</p>
<span id="more"></span>

<h2 id="怎麼管理常用但不見得能記起來的指令？"><a href="#怎麼管理常用但不見得能記起來的指令？" class="headerlink" title="怎麼管理常用但不見得能記起來的指令？"></a>怎麼管理常用但不見得能記起來的指令？</h2><p>在初學程式的時候，我除了用 word，還會用紙本筆記紀錄程式碼和常用指令。這些紀錄就擺在我的電腦桌面和電腦桌面上，以便不時參閱。雖然有時會忘記指令放在電腦還是筆記本上，可是當時的內容不多，所以也沒特別感到困擾。大學畢業後，因為微軟的校園授權過期，我索性把所有筆記都搬遷到 Goolge Doc。由於 Google Doc 能是雲端應用程式，所以可以讓文件跨裝置讀取與保管，讓我能統一管理寫作、報告還是程式碼指令等多媒體文件。</p>
<p>除了文書編輯軟體，我也曾跟上筆記軟體的風潮，試著用 Evernote 和 Notion 等工具。這些軟體把筆記篇幅劃分為更小的單位，加入標籤、資料夾或是資料庫系統，提升了管理筆記的彈性；而它們通常也支持多媒體輸入，也內建全域搜尋系統，改善了許多維護與使用筆記的體驗。</p>
<p>筆記軟體、文書編輯軟體或紙本筆記本在紀錄筆記上各有千秋，不過據我的使用經驗，它們在管理指令上有共通的問題：查閱指令離使用指令的距離太遠了。讓我們以按鍵數量來衡量查閱與使用的距離，假設要解壓縮一份 <code>tar.gz</code> 檔，前述幾種方法要按上幾次鍵？打開瀏覽器&#x2F;軟體&#x2F;文件、啟動搜尋、鍵入關鍵字、複製指令、打開終端機、貼上指令，扣除搜索的成本，最少也要六次以上。</p>
<p>這聽起來很像個人 kimochi 的問題，不過如果你的職業正好是個厭世的軟體工程師，那麼想點辦法稍稍拯救一下上班的心情也是個好主意吧？屏除開發或維護的流暢性，若能確保筆記與應用場合貼近，也有助於即時更新筆記的內容。</p>
<p>綜合以上提及的因素，指令的良好管理方式至少具有統一管理、跨平臺存儲、貼近使用場合等特性，才能提升用戶維護與使用的流暢性。以 Command Line 指令為例，筆記最直觀的存放位置是伺服器或電腦本身，讓他們能透過 Github 備份與版本控管。由於幾乎沒有多媒體需求，使用 markdown 語法紀錄的純文本能兼具可讀性與標籤的功能性，還可在各平台讀取。此外，command line 的搜尋系統普遍比文書與筆記軟體強大，也降低了分類、標籤和重新排序的成本。</p>
<p>最後，還需要一些程式來銜接筆記與應用的落差，例如將搜尋到的指令直接貼到 command line，就不需要重複複製貼上。</p>
<h2 id="有哪些好用的工具？"><a href="#有哪些好用的工具？" class="headerlink" title="有哪些好用的工具？"></a>有哪些好用的工具？</h2><p>只要在 Github 主題搜尋 <code>snippet</code> 或 <code>oneliner</code> 便能找到許多指令管理工具可以參考。以下幾款都支援指令速查與調用，而 <code>navi</code> 和 <code>pet</code> 甚至能引導用戶交互式輸入指令所需的參數。以刪除特定的 Docker image 為例，<code>navi</code> 可以做到用快捷鍵搜尋刪除 image 的指令，再用快捷鍵搜尋 image 的名稱，自動回填到刪除指令的參數位置。</p>
<p>這些工具都允許用戶依照其規範的格式增補指令，有些還內建的指令庫，彙整了像是 <a href="https://github.com/tldr-pages/tldr">tldr</a> 這樣被開源社群維護的簡明指令手冊。</p>
<ul>
<li><a href="https://github.com/yuki-yano/zsh-fzf-snippet">zsh-fzf-snippet</a>：基於 fzf 且適用於 zsh 的輕量級指令管理工具，支援指令速查與執行。核心功能只含一支腳本以及紀錄指令的設置檔。</li>
<li><a href="https://github.com/babarot/easy-oneliner">easy-oneliner</a>：同樣基於 fzf 且適用於 zsh 的輕量級指令管理工具，只是指令的記錄格式與 <code>zsh-fzf-snippet</code> 不同。</li>
<li><a href="https://github.com/denisidoro/navi">navi</a>：基於 Python 語言的指令管理工具，彙整了 Github 著名的指令庫，除了指令速查與執行的功能外，也會交互式引導用戶輸入指令的參數。</li>
<li><a href="https://github.com/knqyf263/pet">pet</a>：基於 Go 語言的指令管理工具，定位與 <code>navi</code> 類似，同樣具有指令速查與交互式參數輸入功能。</li>
<li><a href="https://github.com/chubin/cheat.sh">cheat.sh</a>：彙整了 Github 著名的指令庫，只支援指令速查。有線上版本，所以不需要安裝也能使用。</li>
</ul>
<h2 id="如何自己寫一套指令管理工具？"><a href="#如何自己寫一套指令管理工具？" class="headerlink" title="如何自己寫一套指令管理工具？"></a>如何自己寫一套指令管理工具？</h2><p>由於這些工具的原理單純，所以如果對它們的使用方式與格式規範不滿意，DIY 一套適合自己業務需求的輕量級工具也是可行。觀察前述幾項工具之後，我們可歸納出實踐指令速查功能需要的部件，</p>
<ul>
<li>儲存格式：儲存指令的格式和語法，理想上要能滿足用戶瀏覽與程式編譯的需求。</li>
<li>搜尋介面：搜尋指令與自動補全的介面，包含搜尋、瀏覽與預覽功能。</li>
<li>指令輸出：選中指令後的反應，例如執行、印出或是啟動其他程式等。</li>
</ul>
<p>以我模仿 <code>zsh-fzf-snippet</code> 的 <a href="https://github.com/5uperb0y/fzf-oneliner-manager">fzf-oneliner-manager</a> 為例。我採用習慣的 markdown 來記錄指令，標題 (<code>#</code>)紀錄摘要，程式碼區塊(<code>``</code>)紀錄指令，無標記段落則作為補充說明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Print line number X of a file</span><br><span class="line">`head -n &lt;num&gt; &lt;file&gt; | tail -n 1`</span><br><span class="line">https://www.linuxquestions.org/questions/programming-9/print-line-number-x-of-a-file-in-shell-273849/</span><br><span class="line"></span><br><span class="line"># Remove duplicate lines from a file </span><br><span class="line">`awk &#x27;!seen[$0]++&#x27; &lt;file&gt;`</span><br><span class="line">https://linux.cn/article-6881-1.html</span><br></pre></td></tr></table></figure>

<p>我採用模糊搜索工具 <a href="https://github.com/junegunn/fzf">fzf</a> 來製作搜尋指令的介面。fzf 能依照部分匹配來搜索文字，所以能免除用正則表達式搜尋字串的負擔。除此之外，也提供了一套方便的介面供用戶搜尋和瀏覽文字檔。</p>
<p>當使用快捷鍵觸發指令速查時，<code>fzf-oneliner-manager</code> 會將指令文件整理成 TSV 檔，其中每一列都包含一條指令的標題、指令內容與補充說明，然後分別陳列標題與補充說明給用戶，讓他們能透過關鍵字或是方向鍵瀏覽要調用的指令。</p>
<p>一旦指令被選中，指令內容會被截取出來，黏貼到用戶的 command Line 上，只要再按下確認，即可觸發這條指令。這項功能有賴 bash 的 <code>bind -x</code> 指令與 <code>READLINE_LINE</code>&#x2F;<code>READLINE_POINT</code> 變項。</p>
<p><code>bind -x</code> 能重新映射按鍵以觸發指定的腳本或副程式，此處我把 <code>Ctrl + A</code> 設定成啟動指令速查的快捷鍵。<code>READLINE_LINE</code> 是啟動 <code>bind -x</code> 時，command Line 的內容；而 <code>READLINE_POINT</code> 則是游標所處的位置。換句話說，只要將選中的指令取代既有的 <code>READLINE_LINE</code>，並且把游標挪到指令字串的末端，便能在完成速查後將指令貼到 Command line 上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">READLINE_LINE=<span class="string">&quot;<span class="variable">$&#123;selected&#125;</span>&quot;</span>			<span class="comment"># 用選中的指令替換 command line 既有的內容</span></span><br><span class="line">READLINE_POINT=<span class="string">&quot;<span class="variable">$&#123;#READLINE_LINE&#125;</span>&quot;</span>	<span class="comment"># 移動游標到指令字串的末端</span></span><br></pre></td></tr></table></figure>

<p>因此，有了這樣的工具，管理指令的日子看起來就像這樣：</p>
<ol>
<li>「那個解壓縮的指令好像叫 tar 蝦米碗糕的？」，啟動速查。</li>
<li>找到指令，按下確認執行並解決問題。</li>
<li>沒找到指令，上網 Google 或是求救 chatgpt。</li>
<li>把查到的指令補充到指令文件內以便往後搜索。</li>
<li>無聊時可以打開指令文件緬懷自己的青春，「啊啦啊啦，我小時候可是用 word 紀錄管理 server 的程式碼呢！」。</li>
</ol>
<h2 id="結論：即使有-AI，"><a href="#結論：即使有-AI，" class="headerlink" title="結論：即使有 AI，"></a>結論：即使有 AI，</h2><p>不過現在 chatgpt 或 bing AI 那麼方便，指令速查工具還有用嗎？</p>
<p>我覺得兩者的定位不大一樣。雖然當今生成式 AI 的功能已相當全面，卻仍無法免除溝通的成本。對於陌生議題，獨自構思方法可能比實際解決問題費時，所以上網搜尋、求助他人或是詢問 AI 等借重既有經驗的方法都能縮短整體工時。</p>
<p>然而，隨著用戶熟悉方法，溝通成本便成為額外的負擔。呼應文首那幅四格漫畫，為了解壓縮一份 <code>tar.gz</code> 檔，你要先打關鍵字、按下搜索、點選網頁、複製&#x2F;貼上、執行，若你用 chatgpt，還得等他做些寒暄和反應的時間。在這種情況下，速查工具能做為很好的捷徑，方便用戶迅速取得常用指令，保持工作的流暢性。</p>
<p>這也是為什麼我覺得用戶要自己維護指令集，因為這樣內容才會符合每個人各自的頻率、需求和合適的搜索關鍵字。當然，等到哪天勞工不用為系統管理或是NGS分析，AI 能自動自發把事情做完的未來時，那又另當別論。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>莫莉的眼睛：《神經喚術士》的未來描寫</title>
    <url>/how-william-gibson-depict-the-future-in-neuromancer/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cyberspace 首見於威廉吉布森的著作，是指由可彼此互動的實體連結而成的網路空間，諸如物聯網、網際網路乃至生物體的訊息傳遞網路也可屬其範疇。</p>
<p>在《神經喚術士》(Neuromancer) 裡，吉布森為讀者描述了一個義體改造、意識研究與生化科技發達的世界。在這世界中，熱衷竊取情報與資訊的好手能透過面板將神經系統與網路連結，從而擺脫肉體束縛，讓意識遨遊在 cyberspace 之中。</p>
<p>顯然，故事中的 cyberspace 是至今尚未實現的概念，我們仍然仰賴鍵盤、滑鼠與螢幕等人機介面與網際網路的另一端互動。那麼，吉布森要怎麼描述意識連結到龐大而無遠弗屆的 cyberspace 時，會呈現什麼景象呢？</p>
<span id="more"></span>

<p>故事的主角凱斯因為竊取了雇主的情報而遭受私刑懲罰，雖然保住一命卻喪失了連網能力。在故事開端，神秘人物阿米提找到了凱斯，以治療其神經系統為條件，換取凱斯3以其卓越的駭客能力為他辦事。</p>
<p>當凱斯接受了先進醫療重獲連網能力後，他久違地再次進入 cyberspace，作者這樣描述：</p>
<blockquote>
<p>他閉上眼。<br>找到電源鈕凹凸不平的表面。<br>在他眼睛後方泛血光的黑暗中，銀色光幻視從空間邊緣翻騰湧入，入眠前的影像晃盪而過，彷彿以隨機畫面拼湊而成的電影。符號、人影、臉孔，一副模糊、破碎的視覺資訊曼陀羅。<br>拜託，他祈禱，現在──</p>
<p>一個灰色碟狀物，千葉天空的顏色。<br>現在──<br>灰碟開始旋轉，愈轉愈快，變成一個較淡灰色的球。漸漸膨脹──<br>接著湧動，為他而湧動；液態霓虹的摺紙戲法；他那無遠近的家、他的祖國逐漸開展，透明 3D 棋盤無間延展。東方沿海裂變管理局（Eastern Seaboard Fission Authority）那附階梯的猩紅金字塔在美國三菱銀行（Mitusbishis Bank of America）的綠色方塊後方發光，他張開內在之眼看著這座金字塔；而在非常高遠之處，他看見軍事系統的螺旋臂，他永遠無法觸及。</p>
<p>然後他在某處笑著，在一個白漆閣樓，遙遠的手指愛撫控制板，解脫的淚水從臉龐滑落。</p>
</blockquote>
<p>雖然術語的堆砌與連續不斷的描述可能造成閱讀的困難，然而陌生字眼和意識流般的描述正好塑造了資訊洪流湧入凱斯意識之中的感受。</p>
<p>因此，雖然初次閱讀時可能難以將這些詞彙轉化為清晰的形象與畫面，但這些敘述帶來的思覺負擔卻能體現出 cyberspace 的某些特質。這也是為什麼 cyberspace 也可被譯作「塞爆空間 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「塞爆」不只是音譯 (https://danjalin.blogspot.com/2008/07/blog-post_22.html)">1</span></a></sup>」，寓意著資訊流的氾濫與過載。<br>一般而言，名詞的堆砌和冗長不間段的描述會形成閱讀的阻礙，然而陌生的字眼、意識流似的描述卻在此處營造出 cyberspace 資訊洪流湧入凱斯意識中的感覺。</p>
<p>在 cyberspace 之外，《神經喚術士》則有許多篇幅較短而資訊較稀疏，卻絲毫不減其為未來世界帶來鮮明印象的段落。</p>
<p>阿米提治療了凱斯的神經系統時，也委託醫生替他更換了因嗑藥而幾近衰竭的肝臟，以免任務完成前病故途中。作者並沒有直接描述人工器官的先進或義體置換的複雜，而是透過手術後令人不快的後遺症來描述。</p>
<blockquote>
<p>「你在浪費時間，牛仔。」凱斯從外套口袋拿出一顆八角藥丸時，莫莉這麼說。<br>「怎麼說？要來一顆嗎？」他把藥丸遞給莫莉。<br>「你的新胰臟，凱斯，還有你肝臟上的插頭。阿米提讓它們繞過那些玩意兒。」她用一根勃根地指甲輕點藥丸，「你在生物化學上沒辦法享受安非他命或古柯鹼。」<br>「媽的。」他看著藥丸，然後看著她。<br>「吃啊，吃一打下去。什麼也不會發生。」<br>他吃了，真的什麼也沒有。</p>
</blockquote>
<p>我尤其喜歡書中對殺手莫莉的的眼睛的描述。莫莉與凱斯同樣受僱於阿米提，但她對阿米提的背景持有疑慮，因此與凱斯合作的過程也嘗試調查幕後真相。</p>
<p>當凱斯與莫莉初次見面時，他留意她的特殊之處：</p>
<blockquote>
<p>她搖頭。凱斯這才察覺那副眼鏡是以手術嵌入，封住了她的眼窩。銀色鏡片看似從顴骨上方平滑蒼白的肌膚長出來，框在蓬亂的黑髮下。</p>
</blockquote>
<p>這裡簡潔的敘述留給讀者需多想像空間，隨著劇情發展，透過凱斯對莫莉性格的逐步理解，她的外表與內在逐漸豐富。（關於這雙眼睛，可以在 google 查詢 「neuromance molly fan art」看看大家根據這些描述能畫出幾種版本的莫莉）</p>
<p>接著，他們有了更親密的肢體接觸：</p>
<blockquote>
<p>「沒關係，」她說，「我看得見。」剝下皮褲的聲音。她在他身旁扭動，掙脫皮褲後踢到一旁。她一腿跨過他，而他碰觸她的臉。植入鏡片意想不到地堅硬。「不要。」她說，「指印。」</p>
</blockquote>
<p>在執行任務途中，他們也談起改造後的生理感受：</p>
<blockquote>
<p>「我不哭，通常。」<br>「但妳會怎麼哭，如果有人把妳弄哭？」<br>「我吐口水。」她說，「淚腺牽到嘴裡。」”</p>
</blockquote>
<p>這種利用生活瑣事的不便與疙瘩感營造出的真實感，不僅讓未來世界更為具體，也豐富了角色的形象。</p>
<p>例如，在描寫凱斯透過終端與莫莉連接時，作者沒有說明意識共感的具體原理和操作方式，反而著重在莫莉與凱斯的互動：</p>
<blockquote>
<p>「目的是？」<br>「沒概念。只知道我要幫莫莉裝上播送裝置，所以你多半是要存取她的感覺中樞吧。」芬恩搔了搔下巴，「這下你可以弄清楚她的牛仔褲到底多貼身了，嗯？」</p>
</blockquote>
<blockquote>
<p>「感覺如何，凱斯？」他聽見字句，也感覺到她構句。她一隻手滑進口外套，一根指尖繞著溫暖絲綢下的乳頭打轉。那感覺令他屏住呼吸。她大笑，但這連結是單向的，他無法回應。</p>
</blockquote>
<p>類似的還有以下意識被數位化的描述，同樣沒有講清意識載體的外在形象，卻讓人對這項科技印象深刻。</p>
<blockquote>
<p>「你好嗎，迪西？」<br>「我死了，凱斯。在保坂裡待的時間足以想通這點。」<br>「感覺如何？」<br>「沒感覺。」<br>「困擾嗎？」<br>「困擾的是，沒東西讓我感到困擾。」<br>「怎麼說？」<br>「我有這麼一個夥伴先前在俄羅斯營區，西伯利亞，拇指凍傷了。軍醫來切掉拇指。一個月後，他整晚翻來覆去。愛羅伊，我說，你在煩什麼？該死的拇指癢死我了，他說。所以我告訴他，那抓一抓啊。麥考伊，他說，是另一隻天殺的拇指。」構體笑時顯現出來的是不一樣的東西，不是笑聲，而是從凱斯脊椎往下蔓延的一陣寒意。「幫個忙，老弟。」<br>「什麼忙，迪西？」<br>「你的這一局結束時，把這該死的東西刪除。」</p>
</blockquote>
<p>寫到這裡，驟然勾起我關於科技進展與感官變化的回憶。我的右手食指與中指間長著厚繭，所以持筆寫字時總是感到不舒服。我想這都得歸咎於以前看書時，往往不乖乖坐在桌前，而是靠在牆邊環抱雙臂，用一隻手比出剪刀姿勢夾住書脊把書頁支撐在視線處，試圖展現瀟灑氣質與俠客風範。</p>
<p>時至今日，我也不怎麼讀書了，倒是很常癱軟在椅上看著一則則短影片傻笑，絲毫不介意展現頹廢無為的作風。頂多偶爾因為耐不住手機重量，讓小指的第二指節有喘息的時間。</p>
<p>回到寫作的話題，要具體描述下一代人們裝酷耍廢或賴以為生的事物還真不容易。不過喀了嗨不起來的鬱卒、殺手罕見的眼淚、摸不著的困擾、指縫間的厚繭、小指節的痠疼感這類感受，這類根植於人類這物種的原始體驗或許能作為橋接人們想像與不存在事物的公約數吧。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「塞爆」不只是音譯 (<a href="https://danjalin.blogspot.com/2008/07/blog-post_22.html">https://danjalin.blogspot.com/2008/07/blog-post_22.html</a>)<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>sf</category>
      </categories>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, mVCF)</title>
    <url>/introduction-to-multiverse-variant-call-format/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假設在很久很久以後的未來，人類有能力偵測到發生在多重宇宙各時間線的事件，也有演算法來比較事件間的異同，從而彙整出能代表多數宇宙歷史的標準時間線。利用跨宇宙與跨時間線的全史資料，往後的史家能將蒐集的歷史資料與標準時間線比較，推測事件的偶然與必然，指引未來史的發展方向。</p>
<p>面對龐大歷史分歧資料，這些史家或許需要適當的格式與軟體來管理之。對於這個數萬年後才會出現的新興史學與其困境，我想聊聊一些衍伸自生物資訊經驗的想像和白日夢……</p>
<span id="more"></span>

<h1 id="什麼是-mVCF？跟-VCF-有什麼不同？"><a href="#什麼是-mVCF？跟-VCF-有什麼不同？" class="headerlink" title="什麼是 mVCF？跟 VCF 有什麼不同？"></a>什麼是 mVCF？跟 VCF 有什麼不同？</h1><p>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, 以下簡稱為 mVCF) 是一種純文字檔案格式，用於紀錄觀測事件在特定宇宙內各時間線的分歧（詳細內容可參考我寫的<a href="https://github.com/5uperb0y/mVCF/blob/main/mVCF-spec.md">格式規範</a>）</p>
<p>mVCF 的構想源於基因體學的 <a href="https://github.com/samtools/hts-specs/blob/master/VCFv4.3.pdf">VCF</a> (Varaint Call Format)。VCF 檔案紀錄了樣本基因體與參考基因體的 DNA 鹼基差異，這些差異被稱之為變異 (variant)。因為基因變異可能與生物的疾病、性狀與演化史相關，所以可作為臨床診斷、族群遺傳乃至生態演化的研究基礎。</p>
<p>由於 VCF 檔為純文字檔、排版友善、容易擴充又被辨識基因變異的軟體所重用，所以 VCF 已是生物資訊領域通用的格式。去年，VCF 已經更新至 v4.3 版本，除了少數鹼基的變動、插入與刪除外，也納入倒置、跨染色體合併或是大片段缺失等結構變異的表示法。</p>
<p>當我在一個百無聊賴的下午，讀著 VCFv4.3 格式細則時，萌生了一個想法：既然 VCF 能用來紀錄 DNA 變異，那能否描述同為線性結構的時間？更進一步地，我能否用 VCF 檔紀錄一則關於平行宇宙、時空跳躍與蝴蝶效應的懸疑故事？於是我模仿 VCF，著手設計能像描述基因變異一樣，描述各時間線歧異事件的 mVCF。</p>
<p>不過，基因體與時間線的性質顯然有許多差異，所以雖然能挪用 VCF 的格式規範，不過要留意指涉對象的含意。</p>
<ul>
<li><strong>樣本</strong>：樣本是研究母體的子集，其範疇與形象因研究目的而異。在基因體學裡，樣本可以是細胞、組織乃至一盆湖水；而史學裡，可能是個人、國家乃至某種文化與風潮。</li>
<li><strong>鹼基&#x2F;事件</strong>：基因體的基本單位是鹼基，而歷史的基本單位則是事件。然而，相較於離散基因，時間則是連續的。因此，研究事件時更需要定義其範圍與尺度，事件間的差異也不只是字串比對，還需要梳理事件來龍去脈。</li>
<li><strong>建庫&#x2F;考古</strong>：基因體研究始於採樣與抽取 DNA，而史學也需要蒐集考古材料與文獻。如同 DNA 建庫的手段多元，未來也許會發展出更多考古技術，能取得其他宇宙與時間線的文物或口述記錄，讓歷史事件的輪廓更加清晰。</li>
<li><strong>定序&#x2F;編年</strong>：DNA 需經定序解碼鹼基的順序與種類，其結果構成<em>樣本的基因體</em>（樣本DNA的集合）；而考古材料也需要編年與考證，確認事件的順序與可信度，其結果構成<em>樣本的時間線</em>（樣本事件的集合）。</li>
<li><strong>參考基因體&#x2F;標準時間線</strong>：參考基因體是特定物種基因體的整合；而標準時間線則是特定實體（個人、國家或文化等）時間線的整合。兩者都匯集了多樣本的結果，涵蓋較全面的鹼基定序或事件編年資訊，可作為研究與比較的基礎。</li>
<li><strong>染色體&#x2F;宇宙</strong>：每條染色體都乘載了特定的基因，在 VCF 檔裡也有各自的座標；而每個宇宙都有各自的宇宙常數與物理定律，有其獨特的歷史脈絡與事件變化。</li>
<li><strong>變異&#x2F;異變</strong>：基因變異是樣本基因體與參考基因體的歧異，事件異變則是樣本時間線與標準時間線的歧異。</li>
</ul>
<p>釐清 mVCF 和 VCF 的概念差異之後，讓我以《高堡奇人》的假想歷史為例，說明 mVCF 紀錄歷史分歧事件的方式。</p>
<h1 id="如何解讀-mVCF？"><a href="#如何解讀-mVCF？" class="headerlink" title="如何解讀 mVCF？"></a>如何解讀 mVCF？</h1><p>《高堡奇人》是菲利普狄克的假想歷史著作，描述了軸心國贏得二戰後的故事。小說世界與真實歷史的分歧始於 1933 年小羅斯福總統遇刺身亡，導致美國無法脫離經濟蕭條並於歐戰爆發時仍保持孤立。</p>
<p>由於美國的政治態度與國力衰退，孤立無援的英國與歐陸為納粹所征服，隨後太平洋戰爭也以日軍大捷作結。分歧的歷史中，二戰遲至納粹德國與日本帝國於 1947 年征服美國並瓜分世界才告終。</p>
<p>以下即是小說時間線比對真實歷史的 mVCF 範例。若曾接觸生物資訊的話，應該能留意到它的形式其實與 VCF 一致，只是紀錄項目因應歷史事件的特徵而有所調整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##fileformat=mVCFv0.1</span><br><span class="line">##fileDate=20240105</span><br><span class="line">##source=BiblioMapperv1.0.7</span><br><span class="line">##eventEncoding=CEES27</span><br><span class="line">##reference=file:///chronology/100000HumanHistory-pilot.tl</span><br><span class="line">##INFO=&lt;ID=EF,Number=A,Type=Float,Description=&quot;Alternative Event Frequency&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DP,Number=A,Type=Integer,Description=&quot;Read Depth, number of bibliography supporting alternate events&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DESCRIB,Number=R,Type=String,Description&quot;Event Description&quot;&gt;</span><br><span class="line">#COSMOS	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	MITHC</span><br><span class="line">U34	1933	.	P	ρ	.	.	EF=0.5;DP=1;DESCRIB=&quot;Mayor cermak is assassination&quot;,&quot;President Roosevelt is assassinated&quot;	.	.</span><br><span class="line">U34	1933	.	E	EEEEEEEE	.	.	EF=0.5;DP=1;DESCRIB=&quot;US Great Depression&quot;,&quot;US Great Depression&quot;	.	.</span><br><span class="line">U34	1945	.	W	WWW	.	.	EF=0.5;DP=1;DESCRIB=&quot;WWII&quot;,&quot;WWII&quot;	.	.</span><br><span class="line">U34	1945	.	P	.	.	.	EF=0.5;DP=1;DESCRIB=&quot;United Nations Founds&quot;	.	.</span><br></pre></td></tr></table></figure>

<p>每份 mVCF 依序分為三個部分：元資訊列 (meta-information line)、標題列 (header line)、資料列 (entry line)。</p>
<ul>
<li><strong>元資訊列</strong>：以 <code>##</code> 開頭，紀錄「如何讀懂這份檔案」的資訊，例如檔案格式、產出日期、縮寫含意等。</li>
<li><strong>標題列</strong>：以 <code>#</code> 開頭，紀錄資料列各欄的含意</li>
<li><strong>資料列</strong>：紀錄分歧事件所發生的宇宙、時間、性質、證據以及描述等資訊，每一列都表示某時間點發生的分歧事件。</li>
</ul>
<p>此處先忽略看起來更繁雜的元資訊列（這部分通常是不懂時查找用的），專注在假想歷史的第一項分歧「小羅斯福刺殺事件」。</p>
<table>
<thead>
<tr>
<th>#COSMOS</th>
<th>POS</th>
<th>ID</th>
<th>REF</th>
<th>ALT</th>
<th>QUAL</th>
<th>FILTER</th>
<th>INFO</th>
<th>FORMAT</th>
<th>MITHC</th>
</tr>
</thead>
<tbody><tr>
<td>U34</td>
<td>1933</td>
<td>.</td>
<td>P</td>
<td>ρ</td>
<td>.</td>
<td>.</td>
<td>EF&#x3D;0.5;DP&#x3D;1;DESCRIB&#x3D;”Mayor cermak is assassination”,”President Roosevelt is assassinated”</td>
<td>.</td>
<td>.</td>
</tr>
</tbody></table>
<ul>
<li><code>#COSMOS</code>：發生事件的宇宙（具有特定宇宙常數與物理定律的環境），用以規範時間線描述的範圍。<code>U34</code> 是我們所處宇宙的代號。</li>
<li><code>POS</code>：發生事件的時間點。由於時間尺度因事件而異，所以需參照元資訊列確認所用的時間單位。此處以日歷年為單位，符合二戰歷史的事件發生頻率和時長。</li>
<li><code>ID</code>：特定事件的辨識碼。通常在各宇宙與時間線普遍發生的重大事件，例如地球生命起源或宇宙爆發等，會被標註辨識碼供交流與研究用。</li>
<li><code>REF</code>：在標準時間線預期發生的事件代碼。標準時間線是全史學家採樣可探測宇宙各時間線所拼湊的歷史，便於後續研究察覺罕見分歧事件。為了記錄方便，事件通常會以單字符碼概括。各領域有其常用的編碼系統，此處採用 CEES27 系統，<code>P</code> 為重大政治事件 (“politics”)，即芝加哥市長 Cermak 遇刺事件。</li>
<li><code>ALT</code>：在觀測時間線實際發生的事件代碼，可稱之「分歧事件」或「異變」，比較 <code>REF</code> 和 <code>ALT</code> 即可了解事件在各時間線的差異。在《高堡奇人》的時間線中，遇刺死亡的人不是 Cermak 是小羅斯福總統。</li>
<li><code>QUAL</code>：分歧事件的可信程度。受限於跨時空探測技術以及殘存的文獻紀錄，並非所有發現的事件都那麼可靠，這項數值即反映了研究人員對分歧事件是否存在的信心。</li>
<li><code>FILTER</code>：分歧事件是否可靠，基於文獻品質、數量以及考古證據等資訊，判斷分歧事件的可信程度是否達所設定的標準。</li>
<li><code>INFO</code>：其餘關於事件本身、探測技術或是可信程度的補充資訊。例如 <code>DP=1</code> (Read Depth) 表示僅有一份文件佐證分歧事件的發生，而後續的 <code>DESCRIB</code> 則提供了事件的摘要。</li>
<li><code>FORMAT</code>：假設我們不只採樣《高堡奇人》小說版的時間線，也納入影集版本的時間線，那麼就需要標記各自與標準時間線的分歧。此欄規範了標記各觀測時間線的格式。</li>
<li><code>MITHC</code>：觀測時間線的辨識碼 (the Main in The High Castle, MITHC)。每份 mVCF 皆可含有多筆觀測紀錄（或稱「樣本」），屬於該觀測的紀錄規範在 <code>FORMAT</code> 之中。每個觀測皆獨立一欄，依序置於<code>FORMAT</code> 之後。</li>
</ul>
<p>綜合這些欄位的資訊，這條紀錄可解讀為「1933年，於我們所處宇宙的時間線發生政治事件分歧，小羅斯福取代 Cermak 死於 Giuseppe Zangara 刺殺事件。這項分歧可在一半的時間線中觀測到，但僅有一份文獻支持其存在。」，而接續幾列則陳述了在假想的歷史中，經濟蕭條 (E, Economy) 與二戰 (W, War) 拖延的比預期更久，聯合國也不曾成立。</p>
<p>至此，我已介紹了 mVCF 的雛型，但對於怎麼取得分歧事件資料，或說如何詮釋歷史分歧的影響等問題仍有許多討論空間。以下分別陳述我認為值得研究和改善的議題。</p>
<h1 id="目前-mVCF-還有什麼待解或研究議題？"><a href="#目前-mVCF-還有什麼待解或研究議題？" class="headerlink" title="目前 mVCF 還有什麼待解或研究議題？"></a>目前 mVCF 還有什麼待解或研究議題？</h1><h2 id="如何編碼事件？"><a href="#如何編碼事件？" class="headerlink" title="如何編碼事件？"></a>如何編碼事件？</h2><p>構成 DNA 和蛋白質的基本單元只有 24 個分子，所以使用 26 個英文字母便足以表示。然而，構成時間線的事件彼此之間在時空尺度、內容性質、牽涉對象可能大相逕庭。好比說，國際政治是十數年間的的合縱連橫，地質年代則是百萬年的板塊遷移；個人史涉及了數十人的愛恨情仇，但戰史卻攸關數萬人的生離死別。</p>
<p>換句話說，定義事件基本單位的方式會因領域而異 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。">1</span></a></sup>，無法像基因體學只用一套編碼描述各物種的遺傳變化。因此，若想模仿 VCF 或 FASTA 等格式以單字符描述基本單元，需要適當的編碼系統，依照事件屬性將之分門別類，賦予簡明的代號以利用戶判讀。</p>
<p>舉前述的《高堡奇人》為例，書中的國際關係事件便用以下系統化約少量的英文字母方便於表中呈現，其餘細節則補充在於 <code>INFO</code> 欄位供參照。</p>
<table>
<thead>
<tr>
<th>編碼</th>
<th>事件類型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>Political Changes</td>
<td>政權更迭或其他事件，例如政權更迭與當權者上位等</td>
</tr>
<tr>
<td>W</td>
<td>War and Conflict</td>
<td>戰爭或軍事衝突，例如歐戰與二戰</td>
</tr>
<tr>
<td>T</td>
<td>Technological and Scientific Breakthroughs</td>
<td>科學發現或科技發明，例如發明蒸汽機與發現核能</td>
</tr>
<tr>
<td>C</td>
<td>Cultural and Societal Shifts</td>
<td>社會變遷或文化風行，例如啟蒙思潮</td>
</tr>
<tr>
<td>E</td>
<td>Economic Shifts</td>
<td>經濟危機或發展，例如經濟大蕭條</td>
</tr>
<tr>
<td>X</td>
<td>Discovery and Exploration</td>
<td>開拓生存空間，例如發現新大陸與航路</td>
</tr>
<tr>
<td>D</td>
<td>Disasters and Catastrophes</td>
<td>天然或人為災難，例如西班牙大流感與南亞海嘯</td>
</tr>
</tbody></table>
<p>值得留意的是，編碼意味著篩選、歸納與簡化，所以不免捨棄部分資訊並引入主觀判斷。所以可預期每份 mVCF 的編碼系統都反映了記錄者的觀點，反映他們對驅動歷史的根本邏輯與關鍵動力的認知。這就像基因體學的 VCF 不只記錄了序列的差異，其實也蘊藏了識別變異的算法邏輯和假設。</p>
<p>是以，當我們討論 mVCF 所記錄的事件時，必須承認歷史的多元性與複雜性。歷史不僅由大事件構成，同時期也包含了眾多零星事件、個人故事或文化現象等。然而，實務上不一定要標記出所有事件的分歧，因為 mVCF 要涵蓋的事件內容可透過確定研究前提與範疇而聚焦。</p>
<h2 id="要記錄什麼事件？"><a href="#要記錄什麼事件？" class="headerlink" title="要記錄什麼事件？"></a>要記錄什麼事件？</h2><p>儘管目前沒有其他時間線的觀測報告，我們仍然可以從歷史策略遊戲的設計理念得到一些靈感。這些遊戲容許玩家參與特定時代，左右國家政權的發展，創造出與現實截然不同的歷史途徑<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考[维多利亚2（Victoria2）：历史的逻辑](https://necromanov.wordpress.com/2010/09/01/victoria2/)的總結">2</span></a></sup>。</p>
<p>以《世紀帝國》系列遊戲為例，玩家將選定特定文明，歷經黑暗、封建、城堡與帝王時代，逐步發展經濟與強化軍事，並以征服對手的文明為目標。在這種情況下，驅動事件的是勝負，遊戲機制維護的是玩家操作的合理性。</p>
<p>事件發展皆與取勝密切相關，例如生產村民、升級科技或建立軍隊等，玩家會因戰局的發展做出行動，而不是各項遊戲內的社會因素與事件長遠影響。 歷史在此處作為遊戲氛圍的點綴，其真實性與玩家舉動沒什麼關係，也可能出現與史實脫節的狀況。</p>
<p>而光榮的《三國誌》系列則展現了以人物為中心的敘事方式，讓玩家沉浸在大時代的故事中，挑戰歷史人物曾面臨的困境，實現他們曾立下的宏願。 基於這項設計，遊戲維護著歷史事件本身的獨特性。舉例來說，即使遊玩過程有別，赤壁之戰的劇本就該由曹操、劉備與孫權三方參與，才能營造出當代的氛圍。</p>
<p>即使是假想的劇情，也會遵循一條合適的劇本發展。由於驅動遊戲進行的是劇本，因此事件紀錄更為著重在決定劇本分歧的選擇，這些會成為往後重啟遊戲回顧的關鍵（例如嘗試失敗，就得回到存檔點再試一次）。</p>
<p>相比之下，由 paradox 公司出品的遊戲（例如《維多利亞》和《鋼鐵雄心》），更強調事件發生的合理性。在這種觀點下，遊戲機制維護的是事件發生的邏輯，而不是歷史事件本身。簡言之，參與事件的各方被抽象化，當各項參數合乎條件時，即可能觸發事件，然而因為國家環境與政治初始條件的影響，宏觀的歷史軌跡很可能相似，但在細節上可能會有差異。這類遊戲事件則更為複雜，紀錄的是影響參數的事件，例如革命事件可能會跟民生、外交與軍事等行為相關，從而影響民心之類的參數。</p>
<p>這類歷史模擬遊戲的假想時間線是三款之中較接近基因體學研究現況的，相較之下，世紀帝國系列的歷史發展更像遵循熱力學（在遊戲的情境中即是取得勝利）而隨機構成的聚合物，事件的前因後果較為鬆散；這類遊戲的假想歷史紀錄呈現明顯的歷史分岔和障壁，在特定檢查點的狀況會引領迥然不同的路線。</p>
<p>綜上所述，mVCF 紀錄的事件類型取決於紀錄者對歷史的看法。這些事件會與影響歷史的因素相關，從而允許我們從中歸納出歷史的必然和偶然。</p>
<h2 id="個案研究：星際移民史"><a href="#個案研究：星際移民史" class="headerlink" title="個案研究：星際移民史"></a>個案研究：星際移民史</h2><p>既然已經探討了事件類型與其編碼方法，不妨透過個案研究來加深理解。想像一下，如果我們打算研究某個文明在不同時間線上展開星際移民的可能性。考量跨星系移動所需的龐大能量，可從文明的利用效率來推斷其進行星際移民的可能性。在這樣的研究框架下，我們將關注那些直接影響能源應用效率和規模的關鍵事件；而相對地，社會文化或國際政治事件則較無關緊要。</p>
<p>為了有效編碼事件，我們可採用卡爾達肖夫指數 (<a href="https://en.wikipedia.org/wiki/Kardashev_scale">Kardashev scale</a>) 作為衡量標準，標記一個文明各時期所能利用的能量規模。假設該文明能在夠長的時間內維持可觀的能源利用，這表明該文明更有可能具備承擔星際旅行所需能源的能力；反之，這個文明也可能因為戰爭或自然災害而喪失先進的科技水準。雖然這種事件編碼方式省略了許多細節，但它依然能夠概括地呈現文明的發展軌跡。</p>
<p>在以下範例中，自然數代表卡爾達肖夫指數。在標準時間線中，可預期該文明將在四萬年後掌握恆星能源的應用。然而，在可觀測的眾多時間線裡，多數情況下 (99.99%) 文明會因某些事件而喪失這種能力。只有極為罕見的案例 (0.01%)，該文明的技術水準蕙突飛猛進，達到了能夠掌握並維持星系能源利用的階段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#COSMOS	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	MITHC</span><br><span class="line">U42	40000	.	2	2333333333333333333333333,20	.	.	EF=0.0001,0.9999;DP=1000,1000	.	.</span><br></pre></td></tr></table></figure>

<p>基於這項範例的觀察，星際交流可能非常罕見，因為在大多數時間線上都能觀察到科技衰退現象。這意味著或許存在某種過濾機制限制了文明的發展，這可以為人類文明的未來，或是解釋費米悖論指引一些研究方向。</p>
<h2 id="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"><a href="#什麼是異變（分歧事件），時間線的分歧又意味著什麼？" class="headerlink" title="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"></a>什麼是異變（分歧事件），時間線的分歧又意味著什麼？</h2><blockquote>
<p>異變或分歧事件在 mVCF 中指的是在不同時間線中發生的、與標準時間線不同的事件。這些分歧可以是小到一場戰役的結果不同，也可以是大到整個文明的興衰不同。這些分歧事件揭示了歷史的非線性和多變性，表明即使是微小的改變也可能引發巨大的連鎖反應。理解這些分歧有助於我們更深刻地認識決策的重要性以及歷史的複雜性。<br>基因變異與事件變異在性質上有顯著差異。基因變異通常局限於生物的物理屬性，而事件變異則涉及複雜的歷史語境。事件比對（類似於序列比對）涉及了事件的完整背景、因果關係和語境。例如，在科技發展史研究中，牛頓與萊布尼茲的微積分發明可能被視為同一事件，但在英德歷史研究中則被視為不同事件。這種比對可能需要更複雜的演算法或全面的人工智慧判斷。<br>在研究目的上，類似於基因變異的臨床檢驗、生態演化與族群遺傳，時間線分歧的研究可能專注於預測未來、判斷歷史驅動因素的必然性或偶然性，或是進行時間線間的比較研究。不同於基因變異影響衍生物，時間線的變異直接作用於其自身，這可能導致對歷史事件的解釋和影響分析更為複雜。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件異變與基因變異在本質上有顯著區別。基因變異影響的是生物體的物理特性，而事件異變則涉及更為複雜的歷史語境和因果關係。在分析事件異變時，我們需要考慮事件的整體背景、相互關聯和影響。例如，在科技發展史的研究中，牛頓和萊布尼茲各自發展的微積分可能被視為相同的事件，但在英國和德國的國家史中，則可能被視為不同的事件。這種事件比對比基因序列比對更為複雜，可能需要全面的人工智慧判斷或高度專業的人工分析。</span><br><span class="line"></span><br><span class="line">就研究目的而言，時間線分歧的分析可用於預測未來、判斷歷史驅動因素的必然性或偶然性，或進行不同時間線的比較研究。不同於基因變異影響生物體的衍生特性，時間線的變異直接作用於其自身，這可能對歷史事件的解釋和影響分析帶來更為複雜的挑戰。</span><br><span class="line">在處理事件異變時，我們需要的不僅是簡單的序列比對，而是對事件背景、動機、影響和連帶後果的全面分析。例如，科技發展史中的牛頓和萊布尼茲微積分的發明，雖然可以被視為相同的事件，但在英國和德國的國家史中，這兩件事就可能被視為不同事件。這需要比基因序列比對更複雜的演算法或全面的人工智慧判斷。</span><br><span class="line"></span><br><span class="line">比如，在臨床檢驗中，基因變異的研究可以幫助我們理解疾病的成因和治療方法。在歷史的脈絡中，分析事件的異變可以幫助我們理解特定決策或事件對歷史進程的影響。在生態演化中，基因變異的研究可以揭示生物多樣性和物種進化的機制；類似地，研究歷史事件的異變可以揭示文化和社會結構的演變。在族群遺傳學中，基因變異的研究有助於描繪人群遷徙和混合的歷史，而在mVCF的脈絡下，類似的分析可以揭示不同文化和政治力量如何塑造歷史的走向。</span><br></pre></td></tr></table></figure>
<p>怎麼樣才知道事件發生分歧？換句話說，在辨別分歧事件時，我們需要迥異於序列比對的手段。事件可能很類似，但他們有完全不一樣的語境，那能否視為。<br>例如牛頓發明微積分與萊布尼茲發明微積分在是否可歸類於相同事件，若</p>
<p>目前我還沒有比較明確的想法，但<br>在基因體學，偵測變異的原因不外乎歸納成因、<br>基因體與時間線其它差異在於：基因變異影響蛋白質與性狀，事件分歧則影響隨後的事件；基因變異作用在其衍生物，時間線發生分歧卻作用在其本身。</p>
<h1 id="如果還等不到來自其他時間線的招呼…"><a href="#如果還等不到來自其他時間線的招呼…" class="headerlink" title="如果還等不到來自其他時間線的招呼…"></a>如果還等不到來自其他時間線的招呼…</h1><p>最後談談發現多重宇宙與其他時間線之前，能利用 mVCF 做些什麼。</p>
<ul>
<li>文獻管理</li>
<li>完善格式</li>
</ul>
<blockquote>
<p>它可以作為一個強大的文獻管理工具，幫助研究者整理和分析涉及替代歷史或假想情境的文獻。</p>
</blockquote>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考<a href="https://necromanov.wordpress.com/2010/09/01/victoria2/">维多利亚2（Victoria2）：历史的逻辑</a>的總結<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
  </entry>
  <entry>
    <title>讀後感｜戲說統計</title>
    <url>/lee-2017-introduction-to-statistics-and-quantitative-analysis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知乎上有段軼聞可以很好地形容我讀《戲說統計》的心境：</p>
<blockquote>
<p>以前上新東方時候聽老師講的，說以前老俞還講課的時候，特別陶醉，做完題對答案，就問“有沒有人哪道題不懂啊？”要是有人提問題的話，老俞總是深情地看一眼題目，然後放下手中的教案，說：“同學們啊，這道題讓我想起了當初創業時候的的一件事，balabalabala”短短幾分鐘的就能把全班人講的如痴如醉，然後來一句“好的，大家還有哪道題不懂嗎？（阿冰，知乎）</p>
</blockquote>
<span id="more"></span>

<p>讀《戲說統計》是因為我很喜歡李連江老師的另一本書。教讀者怎麼走入和走好學術這條路的書有很多，例如讀《別鬧了，費曼先生》可以立志，讀《你和你的研究》讓人不忘摘星，讀《研究生完全求生手冊》則能學習踏實做事。</p>
<p>然而李老師的《在學術界謀生存》卻教讀者在了解自己是個平凡人後，怎麼面對期望落差，怎麼處理生涯焦慮，怎麼不負自己的使命與期待。因此，得知他還有一本既講統計也談學術生涯的著作時，便到圖書館借來看。</p>
<p>在經驗分享方面，《戲說統計》的立論與《在學術界謀生存》一致，皆勸勉讀者在看清事實後仍保持積極，追求自我的價值與肯定，例如：</p>
<blockquote>
<p>人生的智慧在於準確判斷自己，欣然接納自己。(144)</p>
</blockquote>
<blockquote>
<p>設立現實的目標，才能建立自信。(287)</p>
</blockquote>
<blockquote>
<p>看過，看不懂，很好！好在哪裡？好在創造了機會。看不懂，讓人不快，不憤不啟。(292)</p>
</blockquote>
<p>這些原則跟我讀了一些書、問了一些人而且親自碰一次壁後體會的想法一樣：多做事，少幹話；爭取機會，別找藉口；把握現在，不要懊悔過去；用指標衡量進展，但不要用指標定義自我價值。</p>
<p>至於描述統計的內容，對學過統計學的讀者而言可能較淺。作者用了許多篇幅討論詞彙的含意，也試圖澄清專有名詞的命名邏輯。例如 variable 應譯為變量還是變項？而 variable 的三層意義，即事實與反事實之別（因果推論）、個體屬性的日新月異（縱向研究）、屬性的因人而異（橫斷研究），為什麼攸關研究設計？</p>
<p>這些立論初學者讀來可能恍然大悟，但要應用於實務難題時恐怕無從發揮；而有經驗者讀來或許覺得有趣，但可能會發出「早點知道這種理解方法」的喟嘆，畢竟自己已度過瓶頸，如今不需要這樣的輔助才能理解抽象概念。</p>
<p>此外，書中多以比喻取代公式推導來解釋統計觀念，但能否理解作者的比喻與推理則見仁見智。例如作者雖然很用心講解樣本分布、抽樣分布和誤差分布的關係，但對這些觀念已經有定見的人來說，比喻與借代反而有可能阻礙讀者理解作者想傳達的意義。</p>
<p>總結對《戲說統計》的看法，我會說這本書是很私人的著作，是作者盡到傳承與坦率之義務的著作。</p>
<p>李老師（即作者）曾寫道：「最有效的誤導方法就是培養學術明星，製造學術天才，甚至奇才」，也在這本書提到「學者要盡到承傳的天職，對學生坦誠自己求學的辛苦是本分 (012)」。《戲說統計》記錄了李老師學習統計時遭遇的難點和克服這些困難的方式，未經歷這些困難的讀者可能覺得行文囉嗦，但有共鳴的讀者或會感到助益匪淺。</p>
<p>畢竟讀者很多元，一本著作有這樣兩極的評價也不是什麼問題。我覺得教育講究感同身受，即使是再簡單的問題，若有一位搞不懂的學生，便需要一位能讓學生搞懂的老師。假設不存在這樣的老師，那位學生自己搞懂以後能指導曾跟他一樣迷惘的學生，不也是一樁美事嗎？</p>
<p>書中還有一些有意思的句子摘錄如下：</p>
<blockquote>
<p>我認為教師的功勞不是教知識，而是鼓舞學生。知識可以教，但要靠學生自己刻苦研究才能學到；能力不能教，只能靠學生自己鍛鍊提高。學生學知識，長本領，出成就，都靠學生自己。教師起什麼作用呢？教師的責任主要是影響學生。用什麼影響？就是以書本上的知識為手段，幫助學生樹立自己的學習目標，激發學生的創造精神，鼓勵學生艱苦努力，幫助學生認識自己的潛力，促使學生把自己的潛力發揮出來。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師的主要功勞就是給學生偉大的刺激，偉大的鼓舞。教師要在課堂上把學生的學習精神、奮鬥精神鼓舞起來，教師的作用就是刺激和鼓舞，用敲鑼打鼓的方法振奮學生，讓學生努力。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>… 學生造就老師。老師的成就有學生的貢獻，不是教師自己本來就那麼優秀。必須有優秀的學生，教師才能進步，這是我堅信不疑的。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師刺激學生，學生就會跟教師研討，有研討，就能出成就。老師的智慧是學生敲出來的，學生很優秀，總是敲打教師，教師就進步了。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>在方法論中，術語歸根結蒂是「約定」。約定俗成，遊戲能玩下去，溝通有效，誤會不深，就沒有必要更改術語。(008)</p>
</blockquote>
<blockquote>
<p>不怕了，就是學會了；敢用了，就是學通了；用對了，就是學精了。(011)</p>
</blockquote>
<blockquote>
<p>琢磨怎樣化繁為簡，化平淡為有趣，化有趣為智慧，也是教書的樂趣。(012)</p>
</blockquote>
<blockquote>
<p>英國哲學家奧斯丁說，通常情況下，我們需要的不是被告知，而是被提醒。方法論的主要作用就是提醒我們注意思維的漏洞與陷阱，(027)</p>
</blockquote>
<blockquote>
<p>常是相對的，變是絕對的。常是異常，無常是常。常往往是希望的目標，不是研究對象。希望常，是因為害怕變；提倡常，是因為現實中有不可阻擋的變。所以，「天不變，道亦不變」是個訴諸虛幻奢望的討好建議，不是基於事實研究的明智建言。話說回來，因為變是常態，也因為變很難把握，所以保守是明智，求變是進取。(027)</p>
</blockquote>
<blockquote>
<p>對人生來說，日新月異之變是唯一能直接觀察的變。人生之所以難，之所以有趣，歸根結蒂是因為人能意識到這兩種變化，試圖打通這兩種變化。我們看到種種因人而異之變，自然會想到自己日新月異之變。問題在於，這兩者之間，只在很有限的程度上相通，而且我們很難準確知道到底在什麼程度上、在哪個方面相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的智慧與藝術，關鍵就是在正確的時候採納適當的價值觀。人生不能沒有希望，希望來自相信因人而異之變與日新月異之變相通；然而有希望必然有失望，失望來自二者經常並不相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的關鍵是發現和發揚正態分布對自己有利的屬性，躲避和弭補正態分布對自己不利的屬性。 (139)</p>
</blockquote>
<blockquote>
<p>… 最難判斷的就是我們的相對位置，而平均值和標準差可以幫我們確定自己的相對位置。在這個意義上，我們關注平均值和標準差，就是希望知道自己在這個世界上的位置，也是希望改變我們的地位。人生的苦悶在於，無論我們做什麼，都既糾結於平均值，也糾結於標準差。(141)</p>
</blockquote>
<blockquote>
<p>年輕時要努力奮鬥，因為自己的位置是不確定的，自己的潛力是未知的。但是一定要注意，人生的舞台有很多，人的能力有多面，千萬不要覺得人生只有一條路。你在這一條路上可能平平，在另一條路上卻可能優秀。一方面要堅韌不拔，另一方面要靈活機動，才能找到你最擅長做的事。(145)</p>
</blockquote>
<blockquote>
<p>研究生是學者最畏懼的讀者，他們會跟老師說，你把數據庫給我，我重複做一遍，跟你學。(185)</p>
</blockquote>
<blockquote>
<p>無論學什麼，都分兩個功夫：一個是投入時間學，另一個是用心琢磨怎麼學。又投入時間學，又用心想，就會慢慢找出一個適合自己的方法。哪一天你找到適合自己的方法了，你就學會了。(262)</p>
</blockquote>
<p>[^*] 李連江 (2017)《戲說統計：文科生的量化方法》，中國政法大學出版社。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜太空生物學</title>
    <url>/lee-2017-astrobiology/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>李炎的太空生物學是台灣少見的天文生物學專著，不過內容卻虛實參半。前半段摘錄新聞網或部落格報導的奇聞軼事，補充維基百科的條目說明，加上一些感想湊成討論生命起源和地外生命的篇章。然而，參考資料似乎不限於期刊論文，好比「墨西哥人發現外星人寶寶」之類的農場新聞也直接收錄，並沒有加以解釋或編輯。</p>
<span id="more"></span>
<p>中段改編自美國國家太空生物研究中心發表的《人類在太空的生理學》(Human Physiology in Space)，這是太空生物學(Space biology)的一環，雖然和字面上的涵義和天文生物學(Astrobiology)相似，但是前者研究太空環境對既有生物的影響，後者探討生命是怎麼來的。</p>
<p>太空生物學有許多實用價值，例如若能了解動物的生理變化將有助於設計太空人的健康維護措施，而掌握植物的太空生理學知識也能應用在太空農業上。至於微生物生長繁殖的狀況，則與天文生物學息息相關。由於各行星可能因隕石衝擊而把表土拋向太空，假如土中的微生物能捱過最初的撞擊，並在微重力、高輻射的極端環境存活，便有機會把生命播種到其他星球。</p>
<p>此書各章節較為零碎，例如第一部分看起來像鄉野奇談、第二部分讀起來像人體生理學課本，較難看出與主題的關聯。此書末以幾篇應用藍菌淨化代謝廢物的實驗報告作結。查詢了作者與其研究生的論文，發現原文僅提到可處理畜牧業或廚餘廢水，沒說明是否能應用在太空船的維生系統，因此這部分內容可能是作者自行延伸而來。</p>
<p>這部分有點可惜的是，作者用很大的篇幅（幾乎把整份論文貼了上來）來強調藍菌具有生物淨化的潛力。可是，閱讀以太空生物學為題的作品時，會期待能了解太空與畜牧環境差異，以及應用時會碰上的困難，但是作者較少著墨這些問題。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李炎 (2017)《太空生物學》，漢珍數位圖書股份有限公司。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1. Two Sum</title>
    <url>/leetcode-1-two-sum/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
</blockquote>
<p>求數列內，和為目標值的兩數之座標</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,2,4], target &#x3D; 6<br>Output: [1,2]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code>：數列長度介於 2 至 104 之間</li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code>：數列各項可能有負值</li>
<li><code>-109 &lt;= target &lt;= 109</code>：目標值可能為負值</li>
<li>Only one valid answer exists.：僅有一組解</li>
</ul>
<span id="more"></span>

<p><strong>知識點</strong><br>hash table</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題最直觀的解法是將數列各項兩兩相加，最遲到比對所有組合後才找到題解。然而，目標值在這算法裡僅作為判斷結果的依據，沒有充分利用其提供的資訊。</p>
<p>為了充分利用目標值，可以各項與目標值之差為 keys，各項座標為 values，建立 hash table 存儲讀過的數字。</p>
<p>若現在的數字為先前出現過的數字與目標值之差，則回傳這兩數字的座標即為題解；若否，則新增現在的數字與目標值之差到 hash table 內。由於題目設計保證有唯一解，所以最遲遍歷整個數列即可找到題解。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = &#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record.keys() :</span><br><span class="line">                <span class="keyword">return</span>([record[nums[i]], i])</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                record[diff] = i</span><br></pre></td></tr></table></figure>
<ul>
<li>此以 python dict 實踐 hash table 的功能。</li>
<li><code>record.keys()</code> 可寫成 <code>record</code>，但標出來比較清楚</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1480. Running Sum of 1d Array</title>
    <url>/leetcode-1480-running-sum-of-1d-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>計算數列逐項的累積和 (runningSum)</p>
<span id="more"></span>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array nums. We define a running sum of an array as runningSum[i] &#x3D; sum(nums[0]…nums[i]).<br>Return the running sum of nums.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,4]<br>Output: [1,3,6,10]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array  </p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題應該算是 for loop 練習，我覺得要留意 (1) indices out of range 以及 (2) len(nums) &#x3D;&#x3D; 1 的狀況。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[n] = nums[n - <span class="number">1</span>] + nums[n]</span><br><span class="line">        <span class="keyword">return</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜153. Find Minimum in Rotated Sorted Array</title>
    <url>/leetcode-153-find-minimum-in-rotated-sorted-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given the sorted rotated<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]">1</span></a></sup> array <code>nums</code> of unique elements, return the <em>minimum element of this array</em>.</p>
</blockquote>
<p>平移一嚴格遞增數列各項 n 單位後，求此數列的最小值</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,4,5,1,2]<br>Output: 1</p>
</blockquote>
<p><em>須留意幾個樣例：數列只含一項、數列只含兩項、平移後與原數列相同、最小值位於數列尾部</em></p>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li><code>n == nums.length</code>：數列長度為 n</li>
<li><code>1 &lt;= n &lt;= 5000</code>：數列長度介於 1 至 5000 項</li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code>：數列各項介於 -5000 至 5000，因此兩項相加不至於超出整數大小的上下界</li>
<li>All the integers of <code>nums</code> are <strong>unique</strong>：數列各項唯一</li>
<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times：數列已排序，且至多平移 n 次，最少平移 1 次</li>
<li>You must write an algorithm that runs in <code>O(log n)</code> time：此題有時間複雜度限制</li>
</ul>
<p><strong>知識點</strong><br>binary search</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題的關鍵在於判斷最小值，並使用二分搜尋法簡化找尋最小值的步驟。</p>
<p>由於數列已由小到大排序，所以如果某項數值在平移後小於前一項，該項即為數列的最小值。依照這項原則，可以先定義 <code>left</code>、<code>mid</code>、<code>right</code> 三個指標，其中 <code>mid</code> 是 <code>left</code> 與 <code>right</code> 的中間值。</p>
<p>若 <code>nums[mid]</code> 小於其前一項，則 <code>nums[mid]</code> 為最小值，即可中斷迴圈並回傳題解。若尚未找到最小值，則可比較 <code>nums[mid]</code> 與 <code>nums[right]</code>，選定下一個搜索標的。</p>
<p>假設 <code>nums[right]</code> &gt; <code>nums[mid]</code>，表示數列於 <code>mid</code> 至 <code>right</code> 之間嚴格遞增，表示原數列的首尾交接處不在此區間，所以可以縮小搜索範圍到 <code>left</code> 至 <code>mid - 1</code> 之間。反之，則表示數列於 <code>left</code> 至 <code>mid</code> 之間嚴格遞增，則可縮小搜索範圍至 <code>mid + 1</code> 至 <code>right</code> 之間。</p>
<p>由於嚴格遞增數列一定有唯一的最小值，所以最遲在 <code>left</code> 與 <code>right</code> 指向同一座標時，會找到數列最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = right - (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>(nums[mid])</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="mid-的定義方式"><a href="#mid-的定義方式" class="headerlink" title="mid 的定義方式"></a><code>mid</code> 的定義方式</h3><p><code>mid</code> 亦可定義為 <code>(left + right)//2</code>，但聽同事討論，若兩數的數值極大，則有數值超出整數範圍的風險。以相減的方式撰寫則一定不會超出範圍。</p>
<h3 id="判斷首尾交界處的方式"><a href="#判斷首尾交界處的方式" class="headerlink" title="判斷首尾交界處的方式"></a>判斷首尾交界處的方式</h3><p>有看過同事在比較時，不比對 <code>nums[right]</code>，而是比對 <code>nums[-1]</code>，有一樣的效果。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜217. Contains Duplicate</title>
    <url>/leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p>
</blockquote>
<p>(給定一整數陣列，判斷其中是否含重複的數字。)</p>
<p>Example:</p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,1]<br>Output: true</p>
</blockquote>
<span id="more"></span>

<h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>若 array 含重複數字，則有以下特性：</p>
<ul>
<li>數字重複出現</li>
<li>array 長度大於其中數字種類數</li>
<li>若將 array 排序，則重複的數字比鄰出現</li>
</ul>
<p>根據第一種特性，可用 hash table 存儲讀過的數字，再判斷讀入的數字是否已存在 hash table 中。此處，我以 python 的 <code>dict</code> 充作 hash table 來實踐這個想法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        occur = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> occur.keys():</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                occur[n] = n</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">由於計算時間和空間需求都隨陣列大小線性增長，所以時間與空間複雜度都是 $O(n)$</span><br><span class="line"></span><br><span class="line">除了 `<span class="built_in">dict</span>`，python 的 `<span class="built_in">set</span>` 也能體現 <span class="built_in">hash</span> table 的特性。`<span class="built_in">set</span>` 可想像為僅有 key 的 `<span class="built_in">dict</span>`，由於 `<span class="built_in">set</span>` 的元素皆獨一無二，故可將 array 轉為 `<span class="built_in">set</span>`，再比較兩者的長度。若 `<span class="built_in">set</span>` 長度小於 array，則表示 array 含重複值。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>至於先排序，再比較數值兩側是否有重複值的做法，可參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a></p>
<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><ul>
<li><p>使用 list, dict, set 存讀過的數字有什麼差異？（參考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448">廖雪峰的官方網站：使用dict和set</a>）</p>
</li>
<li><p>python 是怎麼體現 <code>set</code> 的概念？（參考：<a href="https://stackoverflow.com/questions/3949310/how-is-set-implemented">How is set() implemented?</a>）</p>
</li>
<li><p>排序算法跟 hash table 算法相比有什麼優點？（參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a>）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜53. Maximum Subarray</title>
    <url>/leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an integer array nums, find the subarray which has the largest sum and return its sum.</p>
</blockquote>
<p>給一整數數列，求其子數列級數的最大值。</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6</p>
</blockquote>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li>$1$$\leq$ nums.length $\leq$$10^5$：數列長度介於 $1$ 至 $10^5$ 間</li>
<li>$-10^4$$\leq$ nums[i] $\leq$$10^4$：數值介於 $-10^4$ 至 $10^4$ 間</li>
</ul>
<p><strong>知識點</strong></p>
<ul>
<li>dynamic programming</li>
<li>Kadane’s Algorithm</li>
</ul>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>這題常見的作法是 Kadane’s algorithm，我在解題時並不知道這套演算法，所以一開始是用極端情形勾勒 function 的輪廓，再透過更多樣例「擬合」出可能的解法，最後才整合為提交的答案。</p>
<ul>
<li><strong>數列僅包含一個數字</strong>：解為該項數字，表示即使只有一個數字也能回傳</li>
<li><strong>數列全為正值</strong>：解為數列各項之和，所以程式碼內含有累加操作</li>
<li><strong>數列全為負值</strong>：解為數列最大的一項數字，所以程式碼內含有暫存最大值的變項與比較數值的判斷式</li>
</ul>
<p>由此分析可知問題癥結在於，累加的級數在碰到負數時要如何處置？</p>
<ul>
<li>若級數於累加後增加，則將這些數字納入計算。例如 [2, -1, -3, 5]，由於 5 &gt; -1 + -3，所以仍有涵蓋這兩個負數的價值。</li>
<li>若級數於累加後減少，則跳過這些數字，從新的位置開始計算。例如 [2, -1, -4, 1]，累加新的數字無法抵銷兩個負數值，所以不如跳過。</li>
</ul>
<p>至此，我雖然對計算方式有個概念，但還是經過了一連串測試，才歸納出以下算法。依序累加數列各項，每次累加後 (1) 若累加後級數沒增加，則從當前項重新計算級數；(2) 更新當前級數的最大值。</p>
<p>遍歷整條數列後，當前級數的最大值即為題解。只須走一趟循環，空間用量也固定，所以時間複雜度和空間複雜度分別為 $O(n)$ 與 $O(1)$。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        maxVal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sums += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &lt; nums[i]:</span><br><span class="line">                sums = nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; maxVal:</span><br><span class="line">                maxVal = sums</span><br><span class="line">        <span class="keyword">return</span>(maxVal)</span><br></pre></td></tr></table></figure>
<p><em>當初以為要回傳子數列的位置，所以才使用 index 取值</em></p>
<ul>
<li><code>sums</code>：紀錄當前累加值</li>
<li><code>maxVal</code>：紀錄當前累加的最大值</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜724. Find Pivot Index</title>
    <url>/leetcode-724-find-pivot-index/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>若數列某項兩側各數字的總和相同，則該項為數列的樞紐 (pivot)。給定一整數數列，判斷其是否含樞紐項。若有，求樞紐之索引值；若無，則回傳 <code>-1</code>。</p>
<span id="more"></span>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers <code>nums</code>, calculate the pivot index of this array.<br>The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right.<br><strong>If the index is on the left edge of the array, then the left sum is <code>0</code></strong> because there are no elements to the left. This also applies to the right edge of the array.<br>Return the leftmost pivot index. If no such index exists, return <code>-1</code>.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,7,3,6,5,6]<br>Output: 3</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,-1,-1,0]<br>Output: 2</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,0,1,1]<br>Output: 0</p>
</blockquote>
<p><em>留意負數項、樞紐位於數列首尾、數列只含一項或兩項的案例</em></p>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code>：留意負數項</li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此處借鑑<a href="https://leetcode.com/problems/find-pivot-index/solutions/127676/find-pivot-index/">官方解法</a>。首先計算數列的級數 (<code>S</code>)，接著依序讀過數列，並計算讀過數字之和 (<code>leftSum</code>，即當前項左側的子數列總和)。</p>
<p>由於已算過 <code>S</code>，所以當前項右側的子數列總和可透過 <code>S - nums[i] - leftSum</code> 得知。</p>
<p>若當前項左右兩側的子數列總和一致，表示當前項為樞紐，其索引值便為題解；若總和不一致，則累計 <code>leftSum</code> 的值。若遍歷數列仍未求得樞紐，即可確認此數列無樞紐，依題目要求回傳 <code>-1</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        S = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> leftSum == S - nums[i] - leftSum:</span><br><span class="line">                <span class="keyword">return</span>(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                leftSum += nums[i]</span><br><span class="line">        <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="曾嘗試但失敗的解法"><a href="#曾嘗試但失敗的解法" class="headerlink" title="曾嘗試但失敗的解法"></a>曾嘗試但失敗的解法</h3><p>我原先的想法是定義兩個指標，在一次迴圈中從數列兩側夾擠，同時計算 <code>leftSum</code> 和 <code>rightSum</code>。當兩指標重合，且左右數列總和一致時，指標的位置即為樞紐的索引值；反之，則表示此數列沒有樞紐。</p>
<p>這種方法的關鍵在於判斷何時要調動兩側的指標，所以在程式碼中間我寫了不少判斷式。然而，當數列正負數穿插的時候，判斷式便會很難寫。</p>
<p>舉下方的程式碼為例，碰到 <code>[-1,-1,-1,0,1,1]</code> 和 <code>[-1,-1,-1,0,1,1,0]</code> 這兩個案例時，右側指標會在循環中不斷往左側移動，直接錯過樞紐的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        leftSum = nums[l]</span><br><span class="line">        rightSum = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span>  <span class="built_in">abs</span>(leftSum) &lt; <span class="built_in">abs</span>(rightSum):</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                leftSum += nums[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                rightSum += nums[r]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftSum == rightSum:</span><br><span class="line">            <span class="keyword">return</span>(l)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="練習題目時，適合使用程式語言定義好的-function-嗎？"><a href="#練習題目時，適合使用程式語言定義好的-function-嗎？" class="headerlink" title="練習題目時，適合使用程式語言定義好的 function 嗎？"></a>練習題目時，適合使用程式語言定義好的 function 嗎？</h3><p>我覺得這算是我其中一種心態糾結，即「為了打好基礎，必須手刻所有功能」。不過追根究柢，做題的目的是透過題目學習該題相關知識。</p>
<p>以這題為例，<code>sum</code>並非解題的關鍵，也不是這題的核心知識，如果使用這個 function 能改善程式碼的可讀性和簡潔性，那麼我覺得使用程式語言定義好的 function 也不錯。</p>
]]></content>
      <categories>
        <category>programming</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>All-Species Living Tree Project (LTP) 物種資訊的訂正和維護</title>
    <url>/living-tree-project-database-curation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>All-Species Living Tree Project (LTP)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="All-Species Living Tree Project (LTP)  相關文獻，Yarza & Munoz. (2014). The all-species living tree project. *In Methods in Microbiology* (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. *Systematic and applied microbiology*, 31(4), 241-250.">1</span></a></sup> 旨在維護所有已知古菌和細菌 type strain 的 16S rRNA 基因序列，並基於這些序列，建立古菌和細菌的譜系樹。</p>
<p>LTP 主要由四個單位參與</p>
<ul>
<li>LPSN 提供分類與命名資訊 (<a href="https://www.bacterio.net/">https://www.bacterio.net/</a>)</li>
<li>ARB 支援譜系樹建立與分類 (<a href="http://www.arb-home.de/">http://www.arb-home.de/</a>)</li>
<li>Ribocon 則負責資料庫的管理 (<a href="https://www.ribocon.com/">https://www.ribocon.com/</a>)</li>
<li>SILVA 則提供序列資料庫、計算資源與網頁介面 (<a href="https://www.arb-silva.de/">https://www.arb-silva.de/</a>)</li>
</ul>
<p>（自 2020 年起，LTP 的遷出 SILVA，獨立為一個網頁：<a href="https://imedea.uib-csic.es/mmg/ltp/%EF%BC%89">https://imedea.uib-csic.es/mmg/ltp/）</a></p>
<p>LTP 的資料常用於 16S rRNA 基因增幅序列的物種註解，而基於其收錄序列所構建的譜系樹，也能作為 Phylogenetic placement 的基礎<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. *Msystems*, 3(3), e00021-18.">2</span></a></sup>。</p>
<p>另外，由於 LTP與 RDP training set 都只收錄了 type strain 的序列資料，所以相較於透過序列預測建立的資料庫，LTP 的序列資料較為可靠，能避免在物種註釋時，要在分類錯誤之外面臨資料庫錯誤的問題。</p>
<p>儘管 LTP 已是人工維護且品質好的資料庫，但目前版本 ( LTP_01_2022) 的部分物種資訊仍有誤騰的狀況。在官方修正這些問題之前，資料庫的使用者得自己訂正這些錯誤。</p>
<span id="more"></span>

<h1 id="分類階層間少了分隔符"><a href="#分類階層間少了分隔符" class="headerlink" title="分類階層間少了分隔符"></a>分類階層間少了分隔符</h1><p>若使用 “;” 來分割這樣的字串，會得到較短的列表。</p>
<blockquote>
<p>AF251436 Ferrimicrobium acidiphilum Bacteria;ActinomycetotaAcidimicrobiia;Acidimicrobiales;Acidimicrobiaceae;Ferrimicrobium</p>
</blockquote>
<h1 id="分類名稱出現額外符號"><a href="#分類名稱出現額外符號" class="headerlink" title="分類名稱出現額外符號"></a>分類名稱出現額外符號</h1><p>文字前後出現空格、引號和句號等，可能會因字串不同而高估該分類階層的分類群數量，也可能在資料處理造成意外麻煩。</p>
<h2 id="額外的雙引號"><a href="#額外的雙引號" class="headerlink" title="額外的雙引號"></a>額外的雙引號</h2><blockquote>
<p>AY102612 Caedibacter taeniospiralis “Bacteria;Pseudomonadota;Alphaproteobacteria;Holosporales;””Caedimonadaceae””;Caedibacter </p>
</blockquote>
<h2 id="額外的句號"><a href="#額外的句號" class="headerlink" title="額外的句號"></a>額外的句號</h2><blockquote>
<p>LC552068 Conexivisphaera calida Archaea;Crenarchaeota;Conexivisphaeria;Conexivisphaerales;Conexivisphaeraceae;Conexivisphaera.</p>
</blockquote>
<h2 id="額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）"><a href="#額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）" class="headerlink" title="額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）"></a>額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）</h2><blockquote>
<p>KF863150 Hyphomonas adhaerens Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p>
</blockquote>
<h1 id="分類名稱間有額外的分隔符"><a href="#分類名稱間有額外的分隔符" class="headerlink" title="分類名稱間有額外的分隔符"></a>分類名稱間有額外的分隔符</h1><p>會導致該紀錄多一個分類階層 </p>
<blockquote>
<p>HQ223108 Thermoleophilum minutum Bacteria;Actinomycetota;;Thermoleophilia;Thermoleophilales;Thermoleophilaceae;Thermoleophilum</p>
</blockquote>
<h1 id="重複出現的分類名稱"><a href="#重複出現的分類名稱" class="headerlink" title="重複出現的分類名稱"></a>重複出現的分類名稱</h1><p>例如同樣的分類寫兩遍，或是整個條目寫了兩遍，會導致該紀錄增加多個分類階層</p>
<h2 id="門名重複出現"><a href="#門名重複出現" class="headerlink" title="門名重複出現"></a>門名重複出現</h2><blockquote>
<p>AJ288899 Bacteriovorax stolpii Bacteria;Bdellovibrionota;Bdellovibrionota;Bacteriovoracia;Bacteriovoracales;Bacteriovoracaceae;Bacteriovorax</p>
</blockquote>
<h2 id="整串分類名稱重複出現"><a href="#整串分類名稱重複出現" class="headerlink" title="整串分類名稱重複出現"></a>整串分類名稱重複出現</h2><blockquote>
<p>“AF082795 Hyphomonas rosenbergii Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p>
</blockquote>
<h1 id="誤植分類名稱"><a href="#誤植分類名稱" class="headerlink" title="誤植分類名稱"></a>誤植分類名稱</h1><p>在此例中，屬名 Amnimonas 被誤謄為 Aminomonas（這是另一個屬）例如因為形似而寫成其他分類名、打錯字，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p>
<h2 id="誤植-Aminomonas-→-Amnimonas"><a href="#誤植-Aminomonas-→-Amnimonas" class="headerlink" title="誤植 (Aminomonas → Amnimonas)"></a>誤植 (Aminomonas → Amnimonas)</h2><blockquote>
<p>MF682432 Amnimonas aquatica Bacteria;Pseudomonadota;Gammaproteobacteria;Moraxellales;Moraxellaceae;Aminomonas</p>
</blockquote>
<h2 id="錯字-Jatrophihabitantaless→Jatrophihabitantales"><a href="#錯字-Jatrophihabitantaless→Jatrophihabitantales" class="headerlink" title="錯字 (Jatrophihabitantaless→Jatrophihabitantales)"></a>錯字 (Jatrophihabitantaless→Jatrophihabitantales)</h2><blockquote>
<p>LC323105 Jatrophihabitans telluris Bacteria;Actinomycetota;Actinobacteria;Jatrophihabitantaless;Jatrophihabitantaceae;Jatrophihabitans</p>
</blockquote>
<h1 id="異名"><a href="#異名" class="headerlink" title="異名"></a>異名</h1><p>即條目間使用該分類群的不同名稱，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p>
<h2 id="異名-1"><a href="#異名-1" class="headerlink" title="異名"></a>異名</h2><blockquote>
<p>(Bdellovibrionia [synonym] → Oligoflexia [correct name])</p>
</blockquote>
<h2 id="俗名"><a href="#俗名" class="headerlink" title="俗名"></a>俗名</h2><blockquote>
<p>(Bdellovibrionota [not validly published] → Bdellovibrionota [correct name]) HM038000 Vampirovibrio chlorellavorus Bacteria;Bdellovibrionota;Oligoflexia;Bdellovibrionales;Bdellovibrionaceae;Vampirovibrio AJ292759 Bdellovibrio bacteriovorus Bacteria;Bdellovibrionota;Bdellovibrionia;Bdellovibrionales;Bdellovibrionaceae;Bdellovibrio</p>
</blockquote>
<h1 id="欠缺完整分類階層"><a href="#欠缺完整分類階層" class="headerlink" title="欠缺完整分類階層"></a>欠缺完整分類階層</h1><p>比其它條目少了一個分類階層 </p>
<blockquote>
<p> # Lack information at Genus level (Ulvibacterium)<br> KF303137 Aestuariibaculum scopimerae Bacteria;Bacteroidota;Flavobacteriia;Flavobacteriales;Flavobacteriaceae</p>
</blockquote>
<h1 id="檢查方式以及我們的義務"><a href="#檢查方式以及我們的義務" class="headerlink" title="檢查方式以及我們的義務"></a>檢查方式以及我們的義務</h1><p>這些問題的模式紛亂，其實不容易找到有效的偵測方法，以下枚舉幾個我曾用過的策略，</p>
<ul>
<li>以分隔符切割字串，檢查輸出字串列表當中，長度異常的條目</li>
<li>下載 LPSN 物種資訊，檢查未出現在 LPSN 的條目</li>
<li>檢查出現分號、括號、空格以外的符號的條目</li>
<li>利用這些方法檢查完畢後，就順道把自己的發現寄給他們，當作對資料庫維護團隊的感謝吧。</li>
</ul>
<p>最後，分享一個我原本以為是因為以下原因而產生的 typo …..</p>
<blockquote>
<p>VIFM01000001 Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis Bacteria;Myxococcota;Myxococcia;Myxococcales;Myxococcaceae;Myxococcus</p>
</blockquote>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_ptt.png?raw=true" alt="這難道不是因為某個老梗產生的物種名稱嗎......"></p>
<p>拿去 Goolge 才知道，還真的有名字這麼長的生物<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. *Genome biology and evolution*, 12(12), 2289-2302.">3</span></a></sup>，長到維基百科側欄都破圖了。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_wiki.png?raw=true" alt="名字太長了，網頁都破圖囉。"></p>
<p>Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis 命名自其被分離的地點，位於威爾斯安格爾西島的 Llanfair­pwll­gwyn­gyll­go­gery­chwyrn­drobwll­llan­tysilio­gogo­goch 小鎮，分離地點附近還有一間四星級飯店😮。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_map.png?raw=true" alt="分離地點附近有間四星級飯店"></p>
<p>註</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">All-Species Living Tree Project (LTP)  相關文獻，Yarza &amp; Munoz. (2014). The all-species living tree project. <em>In Methods in Microbiology</em> (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. <em>Systematic and applied microbiology</em>, 31(4), 241-250.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. <em>Msystems</em>, 3(3), e00021-18.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. <em>Genome biology and evolution</em>, 12(12), 2289-2302.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>microbial ecology</category>
        <category>microbiota</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>假如事物遵循 80/20 法則，對我們的決策與行動有什麼影響？</title>
    <url>/mayer-2023-the-art-of-clean-code-80-20-principle/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>The principle says that the majority of effects come from the minority of causes.</p>
</blockquote>
<p>本文是<a href="https://www.books.com.tw/products/0010959955">《精通無瑕程式碼：工程師也能斷捨離》</a> 其中一章的心得。</p>
<p>80&#x2F;20 法則是指少數變項左右了多數結果，它既不是能預測結果的物理定律，也不是行事時得遵循的規範。精確來說，80&#x2F;20 法則是一項觀察，它可以讓我們思考，假設自己在乎的事情遵循這種分布，對我們的決策和努力方向有什麼影響。</p>
<p>雖然這原則對近代的讀者而言應該是耳熟能詳，但我覺得作者 Mayer 的解讀引人入勝。文中除了實際案例也有簡單計算來佐證為什麼基於 80&#x2F;20 法則，我們要投資成本在抉擇、必須保持專注、要關心核心的指標等等。因此，我覺得蠻值得寫一則心得來記錄。</p>
<span id="more"></span>

<h1 id="關鍵事物的影響超乎想像"><a href="#關鍵事物的影響超乎想像" class="headerlink" title="關鍵事物的影響超乎想像"></a>關鍵事物的影響超乎想像</h1><p>多數結果是建立在少數因素上，假設這項觀察或原則適用在多數情境，那麼有兩方面的暗示。 首先，在一個領域中，少數人員能佔有多數資源或成果，例如少數人發表了多數的論文，少數人賺進了多數的錢。</p>
<p>其次，在成就這現象的行為中，也只有關鍵的行為與成就有關。 換句話說，若目標是在某領與取得一定的成績，那麼若能夠辨識並投注心力在事物的關鍵環節，便不需要搞得筋疲力盡，也能維持一定成績。</p>
<p>從效益的角度來看，關鍵環節與其他環節的差異更加明顯。假設兩成的努力造就八成的結果，那麼每一成努力造就四成結果，相較之下，在非關鍵事物的投注僅造就四分之一的成果。單位投入下，關鍵事物造就的效益是非關鍵事物的十六倍。那這種比例的差異在實際情形中可能更加懸殊，例如在生物體方面，少數基因轉變主宰了大多數的變化，這些基因的影響力是其他基因的數千倍以上。</p>
<h1 id="選擇能反映結果並指引方向的指標"><a href="#選擇能反映結果並指引方向的指標" class="headerlink" title="選擇能反映結果並指引方向的指標"></a>選擇能反映結果並指引方向的指標</h1><p>當然，除了原則背後的機制以外，作者也解釋了要怎麼透過這些原則指引行動，讓自己在有限的資源，更有效率達成目標，從而有餘裕去完成或享受其他事情。</p>
<p>這涉及了 80&#x2F;20 法則的另一項暗示，除了大部分資源為少數人所佔據，多數的進展也取決於少數的行為。而辨識關鍵行為的重點則是選擇適當的指標來衡量行為效益。</p>
<p>舉例來說，如果目標是擁有健美體態，那麼各式各樣的飲食法與健身菜單都是潛在的選項，而體重、體脂肪、身體測量值都是衡量判斷行為對目標影響的指標。</p>
<p>然而，不是所有指標都能忠實反映行為的影響或指引往後的行為。好比說，他人對身材的稱讚的確能反映此人的體態，不過這些讚美反映的是過往投入成本的效益，而非當下行為的影響。此外，他人評價又受長相、穿搭或其他難以捉摸的因素，未必能從中檢討出能讓自己體態變好的方向。</p>
<p>另一方面，體脂與肌肉尺寸則是反映行為結果忠實的指標，但很難在每次訓練中即時回饋自己到底做了多好。相較之下，訓練量（負重乘以次數）即是其中一個能及時反應行為的指標，肌肉量與耐力提昇就能提升更多訓練量，也能從當下行為反應到成效。</p>
<p>以作者用語總結，假如體態是衡量成功的依據，讚美並不是衡量進展的指標，體脂和肌肉量是呈現過往投資的 lagging indicator。而我們要關注的則是能反映當下行為影響的 leading indicator，後者能指引我們做有效的努力以達成目標，也能幫助我們在出錯時檢討問題所在。</p>
<h1 id="透過學習減少摸索與排序指標的成本"><a href="#透過學習減少摸索與排序指標的成本" class="headerlink" title="透過學習減少摸索與排序指標的成本"></a>透過學習減少摸索與排序指標的成本</h1><p>然而，排序任務、選定指標、標記價值、學習技術也需要成本（想想看演算法課裏頭那些時間複雜度不一的排序方法），這些成本有可能攤平投資在關鍵行為與項目的效益。</p>
<p>因此，需要借重他人的經驗來減少摸索與排序的成本。在此書中，作者舉了寫作和寫程式兩個案例供讀者參考。對於作家而言，最重要的行為是寫作，而衡量寫作的指標則是「寫了多少句子&#x2F;幾本書&#x2F;幾個故事」；而對程式設計師而言，最重要的行為是寫程式，衡量寫程式的指標則是「寫了多少行程式碼&#x2F;提出多少修訂&#x2F;完成多少專案」</p>
<p>雖然這些指標看起來有點簡化，但簡化不代表單調或沒意義。相反地，越少原則表示越容易追蹤與遵循，即使是盲目地寫程式和寫作，也起碼有以下好處：</p>
<ul>
<li>你能把自己的觀點、意見、想法、風格與巧思等所有你存在過、活過、學習過的證據儲存在可交流的媒介</li>
<li>有了資訊，便能做為籌碼與他人交流，用以兌換經驗</li>
<li>即使不算精通，持續寫起碼能造就熟練，讓你能更快完成同樣或類似的任務</li>
<li>經驗節省的時間能反過來投資寫作和寫程式，或是物色更好的方法</li>
</ul>
<h1 id="保持專注"><a href="#保持專注" class="headerlink" title="保持專注"></a>保持專注</h1><blockquote>
<p>a critical strategy for moving up the Pareto curve is to stay in the game longer while participating in fewer games</p>
</blockquote>
<p>值得注意的是，前述好處的前提是專注。假設各項領域皆呈 80&#x2F;20 法則的分布，那麼投注與報酬呈指數關係。若將投注分散在不同領域，則綜合成長幅度會少於全數投資在單一領域的成長幅度。</p>
<p>畢竟 80&#x2F;20 法則是指多數取決於少數，若這項原則適用各領域，那麼因為分布不均，要懂得取捨；由於輕重不一，得學會排序。取捨與排序又需要經驗累積，這有賴持之以恆的專注。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>作者在這章最後有提幾項老生常的建議，我覺得最值得提醒自己的是這個：</p>
<blockquote>
<p>Don’t do things that reduce value.  These are things like smoking, eating unhealthily, sleeping little, drinking alcohol, and watching too much Netflix. Avoiding things that drag you down is one of your biggest leverage points. If you skip doing things that harm you, you’ll become healthier, happier, and more successful.  And you’ll have more time and money to enjoy the good things in life: relationships, nature, and positive experiences.</p>
</blockquote>
<p>他提到的行為是否有害見仁見智，可是不惹自己麻煩卻是很好的主意。畢竟我們不會每次能做出有效的投資，避開風險能保留更多選擇或資源以把握下次機會。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>不道德教育講座</title>
    <url>/mishima-1958-lectures-on-immoral-education/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1958年，三島由紀夫在《明星週刊》連載不道德教育講座，針對當代日本的文化、事件與風俗，提出有違常人價值觀的看法，例如「應該盡量說謊」、「要打從心底瞧不起老師」、還倡議「千萬不要遵守諾言」。</p>
<p>據他所述，老掉牙的說教作品無趣又矯情，與其重述時下倡導的道德教育，不如談些大逆不道的誇張故事還來得有趣。畢竟，讀者在看了這些荒謬情節之後，沒有產生群起效法的念頭，反倒被激起高尚的品德也說不定。</p>
<p>坦白講，讀過三島由紀夫其他詞藻華美、情節扭曲的小說之後，很難想像這些專欄文章出自同一人之手。《不道德教育講座》裡頭雖然有些看法引人深思，但也充滿反串、強詞奪理、偏見和誇飾的論述，簡直就像是穿越回二十世紀中葉的 PTT 八卦版鄉民。</p>
<span id="more"></span>

<p>舉例來說，三島由紀夫在此書鼓勵讀者盡早擺脫處男，畢竟沒性經驗的男生滿腦子猥褻想法，根本純潔不起來。他也鼓吹喝湯時要發出聲響干擾別人，因為這些奇怪規範是出自於盲從的社會羊群，「傲然的孤郎無須起而效尤」。</p>
<p>在〈應該由文弱陰柔當道〉當中，他諷刺日本人表面崇尚陰柔氣質，骨子裡還是被陽剛氣概所吸引。文末說道自己現在練了一身肌肉，即使收到徵兵單也無所謂畏懼，但好家在他的年紀已經收不到兵單了。這是什麼「還好我退了」的發言啊？</p>
<p>另一篇〈偷盜的奇妙功效〉則批評那些貪圖物質利益、手段又拙劣的小偷根本在丟盜賊的臉，鼓勵大家即使作奸犯科也要有宏大目標與卓越手段。三島由紀夫還以身作則，講了一則他巧妙偷走陌生人昂貴鋼筆的小故事，最後在那邊靠北：「呵呵，你看到這篇文章，我也不會還給你喔！」</p>
<p>除了這些驚世駭俗的言論與觀點，這選集還可以看到表面上是要問卦或討論什麼嚴肅議題，結果只是三島由紀夫想要曬貓：</p>
<blockquote>
<p>我是個愛貓成癡的人。因為，貓這種傢伙實在有點自私又忘恩，還有大部分的貓都只是忘恩之徒，而不會像卑劣人類會恩將仇報。</p>
</blockquote>
<blockquote>
<p>我立刻聯想到，人類最應該像貓看齊。因為再沒有比貓更冷淡、更無情、更韌性，並且絕不任由人類擺弄的動物了！牠恐怕也是最不容易被催眠成功的動物吧。因此，我也想要模仿貓，盡量讓自己變得冷淡、薄情、麻木不仁、自主獨立……。而且，只在想吃魚的時候，才願意發出撒嬌的喵喵聲。</p>
</blockquote>
<blockquote>
<p>比如，有隻貓剛從廚房偷吃了一條魚，來到簷廊下曬太陽，接著若無其事地擦抹乾淨，就是「Who knows?」的最佳體現。</p>
</blockquote>
<p>此書選錄的文章裏頭，我最喜歡的是「應當打從心底瞧不起老師」、「應當追隨流行」和「肉體的無常」這三則對教育、流行和健身的討論。</p>
<h2 id="應當打從心底瞧不起老師"><a href="#應當打從心底瞧不起老師" class="headerlink" title="應當打從心底瞧不起老師"></a>應當打從心底瞧不起老師</h2><p>由於尊師重道的觀念以及教師與學生間年齡、地位與知識的落差，學生面對老師時，不免產生崇敬、害怕或依靠等感受。若這層關係僅止於知識的傳授也罷，可是某些教師的控制欲可能干預了學生的價值觀與人生抉擇，蔑視了個體決定自我前途的責任與權利。</p>
<p>老師在知識上未必全面，在情感上脫離青春期太遠，未必能設身處地體會學生的困擾。其次，決策的後果無論利弊都得由個人承受，老師作為局外人不須擔負選擇的重量，所作所為也不見得貼近學生的需求。因此，對於人生，老師的位置似乎不適合多做什麼，他們可以傳授知識和了解學生，但各自的人生還是得放手讓學生去面對。</p>
<p>而學生這方，也不能期待老師有能力或義務理解自己。畢竟，無論大人或小孩，各年齡層皆有各自的煩惱，都需要費很多心力來解決。因此，不只不該依賴老師，還要有超越老師的鬥志才行。不管老師表現出輕視的態度還是關愛的態度也好，都可以盡情睥睨他們，只要盡可能從課堂中撈取知識油水就夠了。至於其他奇奇怪怪的刁難或干涉，可以當作往後人生的預習，畢竟這些老師可能是那些惡質成年人當中最容易對付的。</p>
<h2 id="應當追隨流行"><a href="#應當追隨流行" class="headerlink" title="應當追隨流行"></a>應當追隨流行</h2><p>流行的事物往往被貼上膚淺、易逝和俗套等標籤，三島由紀夫在這篇討論了上流階層輕視流行的現象，並且指出流行的可貴正是這些「不去思考本質」的特性。誠然，流行的事物之所以能迅速普及，正是因為其通俗易懂而沒有深度；之所以短暫亦逝也是因為其輕佻膚淺。</p>
<p>然而，比起引發了區域衝突甚至世界大戰的各式意識形態，這些膚淺的文化反而保留了更多人類美好的回憶片段。流行的循環性也會讓它在短暫的生命以後，以全新的樣貌出現在人們的生活中，意外地延續流行的壽命。</p>
<h2 id="肉體的無常"><a href="#肉體的無常" class="headerlink" title="肉體的無常"></a>肉體的無常</h2><p>由於我自己也有在健身，所以很好奇三島由紀夫對健身的看法。三島由紀夫自小體格矮小且單薄，直到在三十歲後讀到健美雜誌了解到這項運動後才開始健身。從網路上可取得的寫真照看來，在那個營養和運動科學才逐漸發展，大眾健身尚不普及的年代，其實也算練得有模有樣了。</p>
<p>曾想像「如果自己強壯起來，那麼或許……」的人，在慘澹的街燈下走回家，看著自己透過店面玻璃映出的單薄身影時，難免會懷疑自己到底在幹嘛吧？肉體總有一天會衰老、練壯了可還長同一副臉、何況現在也沒練很壯、蛋白質好貴、吃掉的東西怎麼全都變成熱逸散在大氣中……之類的。</p>
<p>然而，這些懷疑不構成輕視自己肉體的理由。相反地，當你流著汗走回家時，應該要對自己更有自信一點，因為健壯體格短暫無常的特性，反映了人類這種生物荒謬的存在。我們只有一次人生，每分每秒每次呼吸都是絕無僅有，不管活得漂亮瀟灑還是醜陋掙扎，最終同樣要塵歸塵土歸土，隨宇宙熱寂而默然。</p>
<p>這點跟肌肉一樣。體格是與生俱來，有的人骨架好，有的人長肉快，但所有人都需要經過刻苦訓練與飲食自律才能練出健壯的體魄。沒有人能夠永遠維持精壯，每一次臥推和深蹲都是用力活在當下的證據，都是努力延長「現在」的嘗試。</p>
<p>因此，三島由紀夫才說「在現代社會裡，肌肉發達不過是可憐又滑稽的東西。可也因為如此，我才會對積極鍛鍊出強健的體魄不遺餘力。」</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以前是從楯之會的維基百科條目了解三島由紀夫的生平，在還沒讀過其作時，已對其人有一堆印象。直到最近被討論串的<a href="https://www.ptt.cc/bbs/Gossiping/M.1677326783.A.D04.html">留言</a>（「 20多年前看過《潮騷》，青春純愛故事，字裡行間聞得到海的味道」）打動，才開始接觸他的作品。</p>
<p>由於我是從三島由紀夫的娛樂小說和散文作品入門，所以有機會認識這位作家別於外人給定標籤的一面。雖然不是每本書都看得懂，至少這本書我是看得蠻開心的。像讀〈應當打從心底瞧不起老師〉的時候，會想要是早點讀到就好了；但也有像〈肉體的無常〉那樣親身經歷才能體會的感動。最後要坦白，我其實也抄了一些講話很靠北的段落，但那屬於適合自娛的陰暗笑點，就不放上來了 :)</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>三島由紀夫書信教室</title>
    <url>/mishima-1968-yukio-mishima-letter-classroom/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這本書是由五個角色書信往來所構成的故事，他們分別是厭惡市儈作風的文藝青年炎丈流、故意寫英文情書來評價心儀對象的美艷寡婦冰真間子、收藏著五百條領帶和收養五隻貓的風流男士山鳶夫、對工作毫無熱誠只等著嫁人的粉領族空美津子，以及執著於奶油蛋糕和彩色電視機的丸虎一。</p>
<span id="more"></span>

<p>炎丈流與空美津子因通信來往而萌生情愫。眼見情侶倆關係日漸密切，暗戀炎丈流的空美津子找上損友山鳶夫，想寫封黑函來拆散這對情侶。不料，山鳶夫亦在彼此閒談與奚落的互動中，愛上了空美津子。於是基於一番妒意，暗中幫助炎丈流與空美津子，替他們向雙方的家長說情，促成這對情侶的婚事。</p>
<p>得知消息的空美津子，寫了封信大罵山鳶夫，還斷言要與之絕交。所幸，丸虎一在無意間勸和兩人，讓故事的結局兩對情侶皆成眷屬，而丸虎一也如願得到他想要的彩色電視和奶油蛋糕。</p>
<p>雖然作者對感情的見解有趣以及對損友關係的描述恰到好處，但這本書最大的看點還是丸虎一那充滿現代感的垃圾話，喜歡到我幾乎把他寫的每封信都抄了下來。</p>
<p>好比說，他因為借不到錢（向冰真間子）買彩色電視機又被對方揶揄一番，憤而威脅對方要到處宣傳她的學生英文很爛。</p>
<blockquote>
<p>要是不願意請客，我會在東京到處宣傳您英文補習班的每一個學生英文都很糟糕。</p>
</blockquote>
<p>又因看不到彩色節目，憂鬱纏身，寫了封信邀請冰真間子陪他殉情，只因對方老得無法作為戀愛與結婚對象：</p>
<blockquote>
<p>不光如此，我每看一個鐘頭節目，必定會吃掉一包奶油花生，也就是同時進行「看、寫、吃」這三件事，這樣一來，我相當於活了別人的三輩子。<br>不過，悲慘的現實卻是我只能觀看黑白節目，連一台彩色電視機都買不起。既然已經活了別人的三輩子，不如趁著青春年華好時光，在眾人的惋惜之下離開人——今晚忽然如此有感而發，倍覺空虛，於是選中了您陪我殉情。</p>
</blockquote>
<p>或是最終替朋友出氣的方式也令人拍案叫絕：</p>
<blockquote>
<p>最近收到一封冰真間子女式的信，信裡寫道「山鳶夫實在惹人厭，一想到他就讓人反胃！你遇到那個傢伙時，記得代我朝他吐口水」，可是這陣子沒機會見到您，又不好拖延真間子女士的交代，所以隨信附上一張沾有我口水的紙，請您把它放在臉上抹一抹。</p>
</blockquote>
<p>三島由紀夫說他們的通信內容「既可視為書信格式，也可當成寫作範本」。然而，當代人的情感生活往往比小說人物單純，我們觀念也相對開放，所以要用到這些信件的場合不多。諸如「力邀殉情的信」和「已非處子之身的坦白信」可能已充滿時代感。</p>
<p>不過，三島由紀夫在最後一章給讀者的信中，還是總結了寫信的要點：</p>
<blockquote>
<p>寫信時一定要先了解一個前提條件，那就是收信人根本不在乎寫信人的一切。這是最重要的關鍵。<br>一個洞悉世態者深知人們對其他人毫不在意，唯有攸關自身利害得失的時候才會產生興趣，儘管這是一種苦澀的人生哲學。<br>直到你深切體悟，世上的每一個人只顧朝著自私自利的目標邁進、除了極少數的例外幾乎不會在意其他人，這時你的文字才有躍然紙上的力量，能夠寫出撼動人心的書信。</p>
</blockquote>
<p>我覺得這道理無論哪個時代或哪種通訊媒介，只要人類仍是人類便依然適用。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>MiTalk 2022：在講台上</title>
    <url>/mitalk-6-thu-2022/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>兩年前，我曾以聽眾的身分報名 MiTalk，如今總算有點結果可以參加口頭報告。趁著記憶猶新，我想紀錄此次工作坊的所見所得，並且借題敘述一些尚未獨立成篇的想法。</p>
<p>其中一個感悟是，以報告者的身分參加會議能增加聽講的敏感度和觀察面向。當聽眾時，關注的項目往往是相關研究或新奇題材。而經歷了準備報告的過程後，即使對講題不感興趣，也會留意講者的投影片設計、敘事結構、肢體語言和危機處理。</p>
<p>這些是準備報告的共同課題，所以每次聽講也能從多樣的示範中學習適合自己的解決辦法。</p>
<span id="more"></span>

<h2 id="談談口頭報告的緊張感"><a href="#談談口頭報告的緊張感" class="headerlink" title="談談口頭報告的緊張感"></a>談談口頭報告的緊張感</h2><p>坦白講，因為緊張和焦慮，我幾乎無法專心在其他人的報告內容。不過，雖然這次聽講人數較多，可是我覺得報告的緊張感比以前輕微，所以想花點篇幅來整理自己做了什麼來緩解緊張情緒。</p>
<h3 id="剖析緊張的根源"><a href="#剖析緊張的根源" class="headerlink" title="剖析緊張的根源"></a>剖析緊張的根源</h3><p>「講得不好怎麼辦？」、「被發現不是個咖怎麼辦？」、「講錯怎麼辦？」，我覺得，這些焦慮和維護個人價值的渴望有關。當我們把行為、評價與個人價值掛勾，便會擔憂行為失當是否影響個人價值，開始想像一些可怕的圖景，讓自己在事情發生前變得緊張不安。這種擔憂會因注意到自己無法控制他人想法而加劇，導致自己的決策受他人的想法擺布，也為了滿足全數人的期待而疲憊不堪。</p>
<h3 id="嘗試認知轉換"><a href="#嘗試認知轉換" class="headerlink" title="嘗試認知轉換"></a>嘗試認知轉換</h3><p>既然很多心理掙扎源於認知與行動的不協調，所以改變認知的模式是有機會緩解報告的不安感。首先，可以嘗試讓口頭報告與他人評價脫鉤。我的老師常提醒我，口頭報告（或是發表期刊論文）固然有宣傳和證明自己等作用，但除了功利價值，「發表」既是對前人的感謝也是對來者的祝福。</p>
<p>畢竟，無論我們基於什麼目的從事科學，都需要閱讀大量文獻。當我們從前人的心血獲得發現與見解，從而滿足研究的動機以後，將結果發表出來就是最好的回饋，表達我們從過去得到什麼靈感，並發展出可以給未來的東西。因此，再微不足道的發現與努力，再笨拙的傳達方式，都無損一個人表達感謝的誠意與熱情。</p>
<p>其次，也可以學著讓他人評價與個人價值脫鉤。由於評價是建立在對價值的判斷，兩者的關係也因人而異。每次報告，聽眾的背景和期待都不一樣，即使是同樣的內容也可能激起不同迴響。若透過他人評價來穩固個人價值，等於把定義自我的自由讓給這些無法控制的變項。</p>
<p>那要如何爭取定義自我的自由呢？可行的策略是在準備報告時，先為自己設立幾個目標，避免被他人評價牽著走。這些目標反映了個人最在乎的事情，所以達成目標的過程也是自我實踐與定義的過程。例如這次我給自己設定的目標有，</p>
<ul>
<li><strong>健康</strong>：不管準備得怎麼樣都不熬夜</li>
<li><strong>情緒</strong>：即使當下緊張或焦慮，也要專注於當下，不要為了未來而恐慌或為過去懊悔</li>
<li><strong>科學</strong>：用「如果往後有更完整的資料，我也能把握機會」的心態去分析資料</li>
<li><strong>報告</strong>：嘗試用新的簡報版型、敘事結構和陳述方式</li>
</ul>
<p>列了目標以後，我會提醒自己，不管別人怎麼想，只要達成預先設定的目標就是我的勝利。另外，在報告前，我也透過和朋友聊天、在附近走走、穿上不同風格的衣服或與民宿老闆閒聊等策略，提醒自己具有多元面貌，不只是一個在台上報告的人。</p>
<p>至於犯錯、出糗或聽到批評等，我則將之聯想為 bug 和 warning。寫程式的時候，警告訊息往往用紅色字體呈現，但要注意的是字裡行間的訊息，而不是色彩給我們的原始感受。對於生活中碰到的 bug 和 warning，我試著用這樣的聯想，讓自己能跟寫程式的時候一樣勇敢按下 Run，從錯誤訊息提供的線索，找到克服困難的途徑。</p>
<h3 id="緩解即刻的感受"><a href="#緩解即刻的感受" class="headerlink" title="緩解即刻的感受"></a>緩解即刻的感受</h3><p>認知轉換需要時間練習，上台前即時湧起的感受仍需要一些精神勝利法或不理性的敘事結構來克服。以下列幾個我用過的手段，這些方法通常能穩定心情一段時間，讓我能更專注在準備報告。</p>
<ul>
<li><strong>「呼~」</strong>：呼吸，然後什麼都不要想，專注體會當下所有情緒感受，不做任何評價。這方式的假設是，儘管每個人擁有的時間有限，但我們能提升對生活的意識來增加經驗的厚度。由於每次情緒波動都是別於平常的經驗。因此，不管接下來發生什麼事，透過調整呼吸來品味當下的感受，都能為我們賺來生活的體驗。</li>
<li><strong>「反正我們都會死」</strong>：反正我們都會死，現場所有人的掙扎與聲嘶力竭都會風化在歷史，隨太陽燃盡，最後在宇宙熱寂裡靜默。所以目光放遠一點，我們在台上不是對著觀眾還是南瓜什麼的呢喃，而是面對一座座顫抖的墓碑自白。現在發生什麼事也無所謂，反正再過$10^{150}$年，我們都會分解成孤單的光子，平均散佈在宇宙中，再沒機會碰到彼此。</li>
<li><strong>「就這十分鐘而已」</strong>：這招從國小用到大，伴我對抗打手心、罰站、訓斥等麻煩。簡言之，就是不斷提醒自己任何感受都會消退，也提醒自己要發生的事情根本很快就過了。像報告只有十分鐘，就算支支吾吾了十分鐘也會過去，而十分鐘有多短？短到課堂間睡個覺都不夠呢。（不過應用此方法時，盡量別想像棒式之類的經驗。）</li>
<li><strong>「宇宙某處正在發生生死存亡的戰爭」</strong>：這是一種珍惜的心態。想像宇宙某處正在發生星系間的戰爭，下一秒銀河系可能要被當作質量兵器砸毀在其他星系群了，這或許是最後一次報告，不管怎樣都要好好地享受。即使幸免於難，對於自己能在地球上安穩穩地站著，活在重力常數為 $6.67 \times 10^{-11}m^{3}kg^{-1}s^{-2}$ 的宇宙中也是感激不盡。</li>
<li><strong>「輪我了」</strong>：求學過程有碰過多堂枯燥的課程，每次聽課都覺得折磨，又不能不出席。被荼毒多年，如今終於輪到我上台報仇，難得有老師待在台下機會，應該要大方講，以洩先前當學生之恨。</li>
<li>最後再補充一個比較積極的方法，這也是我覺得最有效的方式：想像想傾訴的對象坐在台下，然後把這場演講獻給他們。當自己總算做出點什麼時，往往忍不住想對著某些人說「你看！」吧？</li>
</ul>
<p>如果曾支持自己的人坐在台下，我會想讓他們知道，多虧了他們的關懷與支持，我才有辦法做出東西來。我覺得，這種想像讓我更能以分享與交流的心態去演講，而不會總擔憂自己做得不好而裹足不前。</p>
<h2 id="如何回答自己不熟悉的問題？"><a href="#如何回答自己不熟悉的問題？" class="headerlink" title="如何回答自己不熟悉的問題？"></a>如何回答自己不熟悉的問題？</h2><p>回答問題時，除了能簡要答覆自己熟悉的部分，若對問題不熟悉，也要盡可能回饋對方自己的見解，才能彼此互惠。這次 MiTalk ，我對自己回答問題的方式不太滿意，所以留意了各講者答覆不熟悉議題的策略（就是講者會停頓一下、發出「摁～」聲音或眼睛朝右上方看的那種問題），期待自己往後能預先準備，不會因為緊張而妨礙與聽眾交流的機會。</p>
<h3 id="Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉"><a href="#Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉" class="headerlink" title="Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉"></a>Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉</h3><ol>
<li>承認對 A 不熟悉</li>
<li>承諾可從 B 方面解釋</li>
<li>提出 B 方面的見解</li>
</ol>
<h3 id="Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"><a href="#Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法" class="headerlink" title="Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"></a>Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法</h3><ol>
<li>解釋數據的統計與數理意義</li>
<li>坦白目前仍在思考生物解釋</li>
<li>表示此問題值得探討，說明可能的探討方向</li>
</ol>
<h3 id="Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性"><a href="#Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性" class="headerlink" title="Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性"></a>Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性</h3><ol>
<li>坦白該部分並非專長</li>
<li>說明已知的資訊</li>
<li>承認目前專注的部分</li>
<li>承諾往後可能怎麼做</li>
</ol>
<h3 id="Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"><a href="#Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制" class="headerlink" title="Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"></a>Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制</h3><ol>
<li>承認該限制暫時無法克服</li>
<li>提出即使存在限制，在部分資料或條件下仍表現關注的現象</li>
<li>承諾未來可能怎麼解決之</li>
</ol>
<h3 id="Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"><a href="#Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節" class="headerlink" title="Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"></a>Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節</h3><ol>
<li>概略回答問題</li>
<li>承認沒有詳記所有資訊</li>
<li>提供參考資料給聽眾</li>
</ol>
<h3 id="Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"><a href="#Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現" class="headerlink" title="Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"></a>Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現</h3><ol>
<li>承認自己僅探討了感興趣的項目</li>
<li>依照自己理解推論該細節可能跟研究現象有何關係</li>
<li>感謝對方提出這方面的見解</li>
<li>承諾會回到實驗室思考對方的問題</li>
</ol>
<h3 id="Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"><a href="#Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究" class="headerlink" title="Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"></a>Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究</h3><p>若只回答：「自己沒有細究」會很可惜。畢竟，如果聽眾對研究題材沒興趣的話，也不會浪費時間提問了。既然講者是在場對主題最熟悉的人，即使沒做過相關研究，聽眾也會期待講者的閱歷和經驗能對延伸問題給出什麼新奇想法。因此，可以大膽依照自己的知識做有理據的猜測。</p>
<h2 id="After-phD-PI-or-Boss"><a href="#After-phD-PI-or-Boss" class="headerlink" title="After phD: PI or Boss?"></a>After phD: PI or Boss?</h2><p>這節主辦單位邀情王永福博士、張瑞仁博士、曾景鴻博士介紹他們的公司以及分享在博士後踏入創業之路的動機。</p>
<p>如果重來，會選擇創業還是當PI？<br>別人不會端著錢要你做沒意義的事情。</p>
<p>我覺得這個問題相當於比較產業與學術的職業特質。 先前讀過 Vincent Vanhoucke 的分析，他指出，當工程師和當研究員需要不一樣的心態。相較於工程師，研究員要面對未知是否有解的難題。很多時候，研究結果無法指向解答，只生出更多疑問。這意味著，科研的進展不代表應用的進展，投注整個生涯若能促成概念轉換已相當傑出，更多的研究只在概念上延伸微小的範圍，甚至沒有一絲漣漪地沉澱在歷史長河。</p>
<p>面對意義的喪失，有些人離開學界。例如，王博士即認為他仍會選擇創業，因為學術研究的回饋感較低，很常在實驗室沒日沒夜，卻對自己究竟解決了什麼重要問題感到困惑。相較之下，業界處理的是具體而且迫切的問題，每次都有明確的目標和衡量標準。此外，王博士也認為創業能獲得資金自由，從而保障研究自由，可以自己決定研究方向，不必靠計畫維繫實驗室運作。而張博士則認為只有產業才能與實務問題接軌，因為學術發現局限於文獻，規模、可行性與市場潛能都未經檢驗，若要實踐理想，仍得踏入產業界。</p>
<p>然而，也有些人選擇留在學界，嘗試增加與產業的連結來賦予職涯意義。例如陸永祥老師在擔任助理教授時意識到，自己雖然有許多期刊發表，但這些研究僅圍繞在自己創造出來的問題，並沒有解決這世界面臨的任何難題。因此，陸老師決定踏入產業界，在各大商業發表會中擷取靈感，了解當前社會的需求，藉此引導研究計畫開展，從而結合了研究志業與實務意義。</p>
<p>這幾個例子也呼應曾博士所述，創業與學術的抉擇跟個性有關，你的個性會決定你怎麼選擇職業，怎麼在職涯中追尋意義、成就與滿足。</p>
<h3 id="phD-的訓練對創業有幫助嗎？"><a href="#phD-的訓練對創業有幫助嗎？" class="headerlink" title="phD 的訓練對創業有幫助嗎？"></a>phD 的訓練對創業有幫助嗎？</h3><p>三位講者的共識是，phD 對專業技術與抽象思考有幫助，但對經營面的幫助有限。創業要管理的財務和人事問題比經營實驗室更為複雜，這些都不是就讀博士班容易接觸的事情。因此，張博士認為，創業與否的關鍵在商機，商機比起主題、決心和學位更重要。如果時機對了，對商機感興趣便能主動出擊。畢竟，培育 phD 和培育老闆要注重的素養有別，花費大量時間攻讀學位後，仍需要從頭累積經營經驗，此時無論商機或是能力都可能過時了。</p>
<p>所以三位講者建議，若有良好的機會（例如家庭背景、產業需求、新穎技術、貴人等），要抓住時機創業；若境況太差（資金不足、對產業陌生、能力不足等），需要累積點什麼，這時就讀 phD 或進入欲創業的領域，才對往後創業有幫助。換句話說，為了創業而就讀博士班不是好理由。因此，王博士也希望大家思考繼續進修的動機是什麼，並期許大家不要為了趕上別人而莽撞地決定讀博士班。</p>
<h3 id="為什麼選擇創業這條辛苦的路？"><a href="#為什麼選擇創業這條辛苦的路？" class="headerlink" title="為什麼選擇創業這條辛苦的路？"></a>為什麼選擇創業這條辛苦的路？</h3><p>我覺得張博士的答覆很有趣：「找不到方向或沒機會創業的人更辛苦吧？」</p>
<h3 id="業界研究人力和業務人力的比例為何"><a href="#業界研究人力和業務人力的比例為何" class="headerlink" title="業界研究人力和業務人力的比例為何"></a>業界研究人力和業務人力的比例為何</h3><p>曾博士提供了一個經驗法則，公司最高齡員工的年紀與業務人員的比例正相關。</p>
<h2 id="小型工作坊"><a href="#小型工作坊" class="headerlink" title="小型工作坊"></a>小型工作坊</h2><h3 id="Networking-and-Ecosystem"><a href="#Networking-and-Ecosystem" class="headerlink" title="Networking and Ecosystem"></a>Networking and Ecosystem</h3><p>講者：謝志豪老師 &amp; 吳育瑋老師</p>
<p>共現網路不等於交互作用網路，而交互關係也會隨著規律事件或突發事件而變動。謝老師的工作是利用時間序列資料，推論交互作用隨時間變化的網路。</p>
<p>然而，時間序列分析對採樣頻率有一定要求，一項研究至少數十到數百個樣本才夠。然而受限於經費，往往沒有辦法獲得那麼龐大的資料，所以主持人便詢問是否有克服採樣量不足的方法，而謝老師的答覆則是：「沒有，你還是得去採樣。」</p>
<p>這答覆挺實際的，理論強如克卜勒和牛頓也需要第谷和佛蘭斯蒂德。雖然現在分析工具很多，但沒資料仍是寸步難行。若想解決科學問題卻受經費限制，那只能拉長時間，例如謝老師創建浮游生物資料庫的期許是在「30年後」能為人所用，而不是現在就生出大量樣本，或用少數樣本配合數據模型獲得驚人結果。</p>
<p>因為先前摸過時間序列資料，所以我想了解不同的時間尺度怎麼影響網路推論，也想了解採樣時間不一的問題要怎麼克服。謝老師回覆，時間尺度跟關切的問題有關，不同尺度得出的交互作用網路也有別，無法彼此推論。</p>
<p>至於採樣時間不一的問題是目前時間序列分析的限制，常見的手段是利用內插法來推論特定時間的測量值，但不是每個狀況都適合使用內插法。因此，如果時間差異很大，採用較大的時間尺度還有可能應用此演算法。</p>
<p>而吳老師則簡介他在應用網路分析的心得，例如網路指標的用途不止是簡化數據，也是為了不讓分析者被資料視覺化的形式欺瞞。另外，他也推薦我們讀 Faust. (2021). Open challenges for microbial network construction and analysis. The ISME Journal, 1-8. 了解目前生物網路分析面臨的挑戰（不過謝老師補充，其實有數則問題已經被他解決了）。</p>
<h3 id="Probiotics"><a href="#Probiotics" class="headerlink" title="Probiotics"></a>Probiotics</h3><p>講者：徐瑋萱老師、李保宏老師、陳彥伯老師 </p>
<p>人體益生菌的進展分為消化、免疫、代謝與神經益生菌等世代。目前，台灣業界著重消化與免疫益生菌，但國外正積極發展第三、四代益生菌的市場。不過，益生菌的應用場合也不只人體，還可應用於寵物皮膚炎治療、牲畜疾病防治、土壤改良與環境工程（carbon sink，改善二氧化碳濃度飆升的問題）。此外，益生菌的形式亦未必要為活菌，死菌不僅較容易保存，也能避免他人竊取菌株私自培養。</p>
<p>在益生菌發展中，徐老師有個有趣發現：益生菌可能透過胞泌體影響其他微生物的生理過程，從而降低病原菌的毒性或生長能力。這現象的潛力在於，針對發炎性腸炎的疾病，也許不需透過菌群移植或單菌接種來改善群落結構，只要改變群落的功能就可以達到治療疾病的效果。</p>
<p>此外，益生菌的胞泌體還可能透過神經或其他組織運輸到其他部位，影響遠端部位的生理機能，例如遷移到腦部可能改善精神狀況或記憶相關疾病等。不過關於這些胞泌體的專一性和作用機制都仍不明朗，還需要許多研究確認之。</p>
<p>不過，目前益生菌的研究手段和方向受限於法規，例如基因改造技術便不得用於食品級的益生菌。而透過誘導突變再篩選菌株等菌種改良方式雖可用於食品，但無法獲取有機認證。</p>
<h2 id="邀請演講"><a href="#邀請演講" class="headerlink" title="邀請演講"></a>邀請演講</h2><h3 id="陳可萱老師與林宛柔老師：植物共棲真菌"><a href="#陳可萱老師與林宛柔老師：植物共棲真菌" class="headerlink" title="陳可萱老師與林宛柔老師：植物共棲真菌"></a>陳可萱老師與林宛柔老師：植物共棲真菌</h3><p>陳老師的研究主題是苔類真菌相。苔類受注目的理由除了能於極端環境生存以外，也跟苔類欠缺其他植物常見的菌根菌有關。儘管欠缺近似菌根菌的結構，苔類仍有許多共棲真菌。這些共棲真菌與苔類的關係是陳老師的研究焦點，例如判斷共棲真菌是長在死掉的植物（腐生）還是長在活的植物（共生、內生、寄生），或是了解真菌與苔類共棲於組織內或組織周圍等。</p>
<p>由於苔類從新生到死亡等不同生長階段的組織會出現在同一株當中（Senescence gradient，衰老梯度），所以可以做為探討真菌不同食性的研究題材。其中一種研究食性的方式是，透過C&#x2F;N穩定同位素技術，判斷真菌和植物間是否有營養交換。假如兩者有互換碳與氮，那可能兩者為共生關係；若真菌單方面擷取碳，但植物沒有獲得氮，則可能真菌寄生在植物上。</p>
<p>除了演化與生態應用，由於苔類與共棲生物密切相關，既然苔類能耐受極端環境，其上的生物應該也有相當的耐受性，所以苔類可能作為搜索極端環境生物的標的。其次，苔類可容納各種生物生存，所以或許可以利用這種特性，將苔類作為媒介，把生物接種到不同環境中。</p>
<p>相較於自營性植物共棲真菌，林老師的研究題材是水晶蘭和阿里山水晶蘭等異營性植物的共棲真菌。完全異營性植物只仰賴共棲真菌提供的營養，所以植物與真菌的關係更為密切。這種營養的依賴性可能反映在異營植物與其共棲真菌的演化歷史上。</p>
<p>由於水晶蘭和阿里山水晶蘭型態相近，生存環境也類似，所以林老師想探討兩植物的親緣關係，並了解共棲真菌是否跟兩種植物的分野有關。而研究結果發現，相較於水晶蘭，阿里山水晶蘭與錫杖花的親緣關係較密切。即使生存於相同環境，水晶蘭和阿里山水晶蘭的共棲真菌組成在屬的分類階層仍大不相同，暗示著水晶蘭與阿里山水晶蘭的分野可能跟共棲真菌有關。</p>
<h3 id="張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性"><a href="#張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性" class="headerlink" title="張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性"></a>張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性</h3><p>張博士的研究探討多樣性與群落功能性的關聯。群落的功能性是指各族群的代謝與生理功能之集合，可用生物量、呼吸率和物質消耗率等方式估計。目前已知，α diversity 和 γ diversity 與功能性正相關，但 β diversity 與功能性的關係則尚未明朗。</p>
<p>此研究的假說是分化生態棲位的決定性篩選會增加 β diversity，使得群落的功能多樣性隨分類組成分化而增加。相較於低功能多樣性的群落，高功能多樣性的群落更能應用環境中的不同資源，代謝共通產物也會越多。根據此假說，分化棲位的決定性群落構建過程會加強 β diversity 與功能性的正相關性。 （推理方式：deterministic heterogenize selection→niche diversification→β diversity↑→functional diversity↑→exploit resources→function effects ↑→function indices ↑）</p>
<p>為了探討此假說，張博士使用 Bray-Curtis dissimilarity 度量 β diversity，用 β mean pairwise taxa index (bea-MPTI) 評估決定性分化過程，以 biomass 評估功能性，來檢驗 β diversity、deterministic processes 和 functioning 三者的關聯。</p>
<p>我對此研究很感興趣，也有一些猜想。首先，我會想了解正相關性是否只出現在某種尺度內，例如：(1) 資源有限的情況下，群落多樣性增加應該也不會增加functioning，(2) 功能多樣性隨群落多樣性增加的幅度飽和，應該也會讓functioning 增長的趨勢停滯。其次，如果假設 niche diversification 導致功能性上升，也許使用採計親緣關係的 UniFrac 也能獲得類似的結果。</p>
<p>最後，在 α 和 γ diversity 和 functioning 正相關的情況下，β diversity 還能跟 functioning 呈負相關嗎？依照我的理解，α diversity 、β diversity 和 γ diversity 三者有關，當metacommunities 間 β diversity 為零，那 γ diversity 就等於 α diversity；若 metacommunities 間的 β diversity 為一，那 γ diveristy 應該是 α diversity 之和。按照這層關係，在 α diversity 固定的情況下，γ diversity 上升會伴隨 β diversity 上升，所以當 γ diversity 跟功能性正相關時，β diversity 也會跟功能性正相關。</p>
<p>我在想 β diversity 和 functioning 呈負相關的一個可能是，α diversity 和 β diversity 呈負相關。換句話說，若某種生態過程會使得群落間組成逐漸相似，但最大化單一棲地的多樣性，那麼就可能觀察到 β diversity 和 functioning 呈負相關。例如說在 local dispersal limitation 微弱的初級演替環境，頻繁的遷移雖然會讓各族群的組成逐漸相似 (β diversity↓)，也會增加各群落的族群數 (α diversity↑)，提升 metacommunity 的 functioning。</p>
<p>按照這想法推測，隨著各群落的規模觸及環境負荷極限，可能出現heterogeneous selection，例如發生 lottery competition，各群落的優勢族群取決於隨機事件，增加了 β diversity。又或發生 homogeneous selection，例如先前遷入的族群造成 priority effects，限制了後續能於各區域生存的族群多樣性，使得 β diversity 下降。在沒有更多遷入族群的情況下，這兩種情況都使得 α diversity 下降，但後者降低 γ diversity，降低 metacommunity 的 functioning，於是 β diversity 又和 functioning 正相關了。</p>
<h3 id="其他印象深刻的內容"><a href="#其他印象深刻的內容" class="headerlink" title="其他印象深刻的內容"></a>其他印象深刻的內容</h3><ul>
<li><strong>何攖寧老師</strong>：雖然獨立於培養的方法可以普查環境微生物，但為了驗證假說、生產應用和探索功能等需求，仍有培養細菌的需求。而冰河溶解、大地震、工業汙染等突發事件造成的菌群變化，更強調現地即時指引樣本微生物培養的重要性，畢竟突發事件相當罕見，時間過了就沒辦法研究了。</li>
<li><strong>邱名鍾博士</strong>：邱博士提到隨寄生蟲感染而上&#x2F;下調的宿主基因非常多，這些基因不僅反映了宿主受影響的生理功能和途徑，也反映了寄生蟲和宿主軍備競賽的過程。</li>
<li><strong>林玉儒老師</strong>：林老師講了「鬼花飄香」的故事，研究人員從已滅絕的魏氏岳槿之植物標本取得核酸，再找出產生香味的關鍵基因，將這段基因插入酵母菌生產香味分子以重現魏氏岳槿的氣味（完整故事可見科學人報導）。</li>
<li><strong>陳彥伯老師</strong>：「這項研究很感謝在行政院農委會任職的學妹協助，本來跟學妹約好要在台上 cue 她的，但今天學妹卻沒來。」</li>
<li><strong>陳立賢老師</strong>：「我們以蔥根製作的面膜並不會有蔥油餅敷在臉上的油膩感。」</li>
<li><strong>汪碧涵老師</strong>：「我們每次 reject，都往點數更高的期刊投。」</li>
<li><strong>謝志豪老師</strong>：「這裡不解釋，若對network感興趣，可以去讀書。」</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>兩年前參加 MiTalk 時，碩班研究正好碰到瓶頸。當時聽了許多老師討論他們的求學經歷，卻仍然困惑自己是否適合做研究。於是，我期許自己能透過研討會增廣見聞，在跟人討論的過程中激勵自己。如今帶著一點結果再次參加 MiTalk，算是朝當時立下的目標稍稍前進一步了。</p>
<p>我現在覺得不具備做好某件事的特質，不是放棄的理由。我很喜歡《原子習慣》提倡的概念，要成為怎樣的人取決於動機和行動，這實在是很 existentialism。確實，研究了未必有明確結果，報告後的回饋也不一定如預期，考到什麼學校也不保證能讀到畢業，當到計畫主持人或工廠老闆還是可能有多種麻煩要應對。</p>
<p>然而，這些行動無論成敗都是定義自己的過程。當你為了瞭解 metagenomics，在 compiler 輸入 print(“Hello world”) 那刻，就成了生物資訊學家；當你為了解釋群落演替，在紙上畫了數個方格模擬動物遷徙的時候，就成了理論生態學家；當你開始反思自己的研究，為了某個癥結輾轉難眠，你也已經是個學者了。</p>
<p>至於能在生物資訊、理論生態或是學者的路走去哪、走多遠或走出什麼道路，端看每次行動的抉擇。但我想在這個過程需要時間琢磨。因此，我現在對自己的期許是要有耐心，漸漸不再擔憂自己欠缺什麼條件，而是想辦法做到當下能做到的事情，剩下交給時間。</p>
]]></content>
      <categories>
        <category>microbial ecology</category>
        <category>microbiota</category>
      </categories>
      <tags>
        <tag>communication</tag>
        <tag>career</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜嘗試修改 Vimium 來關閉網頁 pop-up</title>
    <url>/modify-vimium-to-label-and-close-pop-up/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>彈出視窗是以鍵盤瀏覽網頁的最大阻礙。這些視窗的內容不外乎會員邀請、推薦連結、蓋板廣告與網站公告等，是網站而定，通常沒辦法以 tab 來點擊，之前介紹的 Vimium 功能也沒辦法為這些視窗上的連結打標籤。由於彈出視窗並非廣告，所以下載 adblock 也無法阻擋之。所以往往只能乖乖移動滑鼠關閉之。</p>
<p>因為這些彈出視窗設計有別於html 內建的元素，所以有些更糟糕的案例是連關閉按鈕都沒有顯示在頁面上，強迫使用這點開網頁才能關閉之。</p>
<p>在得知 Vimium 點擊連結的方便之後，我嘗試修改 Vimium 的程式碼，讓他可以為原先沒辦法點擊的連結標註標籤</p>
<span id="more"></span>

<h1 id="想法與策略"><a href="#想法與策略" class="headerlink" title="想法與策略"></a>想法與策略</h1><p>Vimium 能為網頁中可點擊的元素標註標籤，讓用戶得以用這些標籤的快捷鍵點開連結，不用經手滑鼠或用tab 遍歷。其原理是透過html元素，辨識可能可點擊的元素，例如連結、按鈕等。</p>
<p>然而，網頁中仍能有自訂元素，這些元素的名稱和行為未必與 html 原生元素一致，所以 Vimium 只能嘗試搜索可能可點擊的元素名稱，例如 buttom 或是 link，間接推論這些元素可點擊。不過實際的網頁往往不會使用這麼直白的名稱，可能使用縮寫或是帶好來命名這些元素，導致 vimium 無法標註這些元素。</p>
<p>讀了<a href="https://ithelp.ithome.com.tw/articles/10091999">Vimium 介紹與支持 Plurk (噗浪)</a>之後，覺得最直觀的想法是 修改 Vimium 程式碼的判斷式，看能不能找到彈出視窗共同的特徵，例如名稱、類別或是辨識碼等，拓展 Vimium 能辨識的元素，讓程式也能夠為彈出視窗標記快捷鍵。</p>
<p>不過這篇文章距今已十年，Vimium 也經歷多次改版，所以可能要找一下 github page 找到辨識網頁元素的區域在何處。所幸在<a href="https://stackoverflow.com/questions/53918093/how-can-i-make-my-element-clickable-for-vimium">這篇文章</a>找到了一些參考。</p>
<p>我嘗試各大新聞網都失敗，只有知乎成功，因此以下會用知乎為例，說明要怎麼修改程式碼讓 Vimium 可以關閉彈出連結。<br><img src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_before.png?raw=true" alt="Vimium 無法辨識知乎登入視窗的關閉符號"></p>
<h1 id="調查彈出視窗是否有共同的特徵"><a href="#調查彈出視窗是否有共同的特徵" class="headerlink" title="調查彈出視窗是否有共同的特徵"></a>調查彈出視窗是否有共同的特徵</h1><p>下一步是觀察彈出視窗的網頁元素的構建方式，歸納出彈出視窗的共通特徵，以便讓 Vimium 辨識。首先，在瀏覽器按 <code>F12</code> 開啟開發人員視窗來檢視網頁原始碼，接著於彈出視窗依序點擊右鍵和檢查，即可鎖定對應位置的網頁原始碼。</p>
<p>我檢查了幾個網站後發現，每個網頁的彈出視窗設計都不一樣，例如元素的組成、對應的滑鼠行為(e.g. hover or click)，乃至於元素的 class 與 id 也因網頁而異。這意味著，也許沒有共通的值可以辨識這些自訂元素，只能針對常用的網頁來做修改。<br><img src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_check.png?raw=true"></p>
<h1 id="下載擴充套件程式碼"><a href="#下載擴充套件程式碼" class="headerlink" title="下載擴充套件程式碼"></a>下載擴充套件程式碼</h1><p>下載擴充套件的方式可參考<a href="https://stackoverflow.com/questions/16680682/how-to-modify-an-extension-from-the-chrome-web-store">此文</a></p>
<ol>
<li>安裝 <a href="https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin">Chrome extension source viewer</a></li>
<li>點開 Vimium 頁面</li>
<li>點擊 “Chrome extension source viewer”</li>
<li>點擊 “Download as zip”<br><img src="https://lh3.googleusercontent.com/dCvSGp9T3LZP6PLfzgxNpxlX5qxizpjKN8g9R3eNKTg98e4MfAEDc5IRVFGr5O4VtC4nq62HNKpGxkNaDLscK1VXLw=w640-h400-e365-rj-sc0x00ffffff" alt="於擴充套件頁面點擊 &quot;CRX&quot; 即可下載套件原始碼（圖：Chrome extension source viewer 頁面）"></li>
</ol>
<h1 id="修改程式碼並套用於瀏覽器"><a href="#修改程式碼並套用於瀏覽器" class="headerlink" title="修改程式碼並套用於瀏覽器"></a>修改程式碼並套用於瀏覽器</h1><p>解壓縮後，接著點開，在這段加入<br><a href="https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992">https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isClickable &amp;&amp; className &amp;&amp; className.<span class="title function_">toLowerCase</span>().<span class="title function_">includes</span>(<span class="string">&quot;zdi&quot;</span>))</span><br><span class="line">  possibleFalsePositive = isClickable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>開啟 Chrome，點選工具列的擴充功能圖示</li>
<li>點選「管理擴充管理」</li>
<li>點選「載入未封裝項目」</li>
<li>重新整理頁面，查看是否順利修改</li>
</ol>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_after.png?raw=true" alt="修改 Vimium 的程式碼後，關閉視窗的符號被標上標籤了。"></p>
<h1 id="困難與限制"><a href="#困難與限制" class="headerlink" title="困難與限制"></a>困難與限制</h1><p>實作之後才發現，許多網站不是用 Html 既有物件來構建彈出視窗，而是自訂許多 class 與 id，再透過 Javascript 控制。這些自定義物件的行為由 Javascript 控制，每個網頁的命名、行為與能見度都不一樣，所以 Vimium 也無法一次搞定所有可能性。</p>
<p>換句話說，本文陳述的嘗試只適用於常用的網站，好比說常看的新聞網或社群論壇等，不能一勞永逸地克服所有彈出視窗。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>目前，彈出視窗仍是鍵盤瀏覽網頁的最大阻礙，原因是彈出是往往是自訂元素。，諸如 Vimium 等擴充套件也不易辨識多樣的自訂元素。鍵盤的可及性受限於網頁元素的設計共識，所以政府對於無障礙網頁設計才有相關的規範與建議吧。</p>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>網際牛仔與無障礙空間（上）：如何以鍵盤瀏覽網頁？</title>
    <url>/navigate-websites-with-keyboard/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為什麼想以鍵盤瀏覽網頁？滑鼠是為簡化繁瑣的鍵入指令而生，也與圖形介面的發展相輔相成。因此，當代網頁本來就適合以滑鼠瀏覽，純靠瀏覽器有限的快捷鍵反倒綁手綁腳。</p>
<p>然而，有時擁有自己的風格比起事情做的有效率還重要。本文就是我對於「用鍵盤瀏覽網頁」這項風格的探索與總結。</p>
<blockquote>
<p>Style over Substance. It doesn’t matter how well you do something, as long as you look good doing it. （格調重於成效，只要你作風有形，事情幹得怎麼樣並不要緊。） </p>
<p style="text-align:right" > The core rulebook for Cyberpunk 2020 </p>
</blockquote>
<span id="more"></span>

<h1 id="「覺得酷」的學習成本有多高？"><a href="#「覺得酷」的學習成本有多高？" class="headerlink" title="「覺得酷」的學習成本有多高？"></a>「覺得酷」的學習成本有多高？</h1><p>就我的使用經驗，是否要用鍵盤瀏覽網頁是風格問題而不是效率問題。因為瀏覽網頁不像編輯文件一樣要頻繁移動游標，點擊和拖曳等行為的頻率也較低，所以沒那麼講究要降低手部位移的幅度。畢竟，有時網頁看一半，漱杯飲料或嗑片餅乾的移動幅度，都比單手改持滑鼠的移動幅度還要大。</p>
<p>儘管如此，我認為除了營造風格以外，善用快捷鍵能減少滑鼠在精密操作時的磨耗感，例如開啟狹窄的右鍵選單、滾動長頁面或點擊尺寸很小的按鈕，這些瑣碎操作不見得會影響瀏覽網頁的效率，但會大幅降低查找資料的心情（對，就是 kimochi 問題）。</p>
<p>更重要的是，體驗鍵盤瀏覽網頁的成本極低，只要學會以下三組快捷鍵，就能流暢地逛平常習慣的網頁了。本文也將以這三組快捷鍵為主軸，簡介如何利用 Windows 系統、Chrome 瀏覽器與 Vimium 套件的快捷鍵，以鍵盤瀏覽網頁。</p>
<ol>
<li>設定開啟瀏覽器的快捷鍵</li>
<li>學會開分頁(<code>Ctrl</code> + <code>T</code>)、關分頁 (<code>Ctrl</code> + <code>W</code>)、切換分頁 (<code>Ctrl</code> + <code>Tab</code>)</li>
<li>安裝 Vimium 或其他 Vim-like 瀏覽器套件</li>
<li>學會用 Vim-like 套件的功能點擊連結 (<code>f</code> + <code>&lt;index&gt;</code>)</li>
</ol>
<p>既然要用鍵盤瀏覽網頁，那首要的目標自然是透過鍵盤開啟瀏覽器。然而，Chrome 與 Windows 雖然有不少快捷鍵，卻似乎沒有能開啟瀏覽器的快捷鍵。幸好，Windows 支援用戶為檔案或程式建立捷徑 (Shortcut) 和設定快捷鍵 (Shortcut key)，所以能在需要時快速開啟檔案或程式，不必再移動到它們（或其捷徑）的所在目錄。</p>
<p>瀏覽器的捷徑可從執行檔自行建立（<strong>chrome.exe - Shortcut</strong>），或是使用安裝時自動建立的捷徑（ <strong>Google Chrome</strong>）。建立瀏覽器的捷徑之後，便能為其設定快捷鍵。</p>
<ol>
<li>右鍵點擊「捷徑」</li>
<li>點選「內容 (Properties)」</li>
<li>點選「快捷鍵」</li>
<li>按下自訂快捷鍵，例如 <code>Ctrl</code> + <code>Alt</code> + <code>C</code></li>
<li>點選「確定」套用設定</li>
</ol>
<h1 id="暢遊-Google-search"><a href="#暢遊-Google-search" class="headerlink" title="暢遊 Google search"></a>暢遊 Google search</h1><p>Chrome 完整的快捷鍵列表可參考<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hant&co=GENIE.Platform=Desktop">google 說明</a>。以下我嘗試從用戶角度，說明有哪些常用快捷鍵值得留意，而這些快捷鍵又有哪些使用的情境。</p>
<h2 id="如何透過搜尋引擎查找關鍵字？"><a href="#如何透過搜尋引擎查找關鍵字？" class="headerlink" title="如何透過搜尋引擎查找關鍵字？"></a>如何透過搜尋引擎查找關鍵字？</h2><p>假設今天想查詢某項資訊，可考慮以下三種方式來輸入關鍵字，再點擊 <code>Enter</code> 執行搜索：</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>開啟新分頁並移至新分頁的網址列</strong></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>移至網址列</td>
<td><code>Alt</code> + <code>D</code> or <code>Ctrl</code> + <code>L</code> or <code>F6</code></td>
</tr>
<tr>
<td>於網址列搜尋 Google</td>
<td><code>Ctrl</code> + <code>E</code> or <code>Ctrl</code> + <code>K</code></td>
</tr>
</tbody></table>
<p>由於以上方法皆透過網址列搜尋關鍵字，一旦網頁跳轉到搜索結果，該列便會轉變為網址。此時若想修正錯字或更改關鍵字，可以使用 <code>/</code> 切換到 Google search box，在該位置編輯關鍵字，就不用重新輸入一遍或編輯藏在長串網址當中的關鍵字。</p>
<p>跳轉到搜索結果後，便能使用以下快捷鍵滑動或跳動網頁，尋找自己需要的資訊。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>連續滑動網頁</td>
<td><code>↑</code> and <code>↓</code></td>
</tr>
<tr>
<td>向下跳數列</td>
<td><code>Space</code> or <code>PageDown</code></td>
</tr>
<tr>
<td>向上跳數列</td>
<td><code>Shift</code> + <code>Space</code> or <code>PageUp</code></td>
</tr>
<tr>
<td>移動至網頁最上端</td>
<td><code>Home</code></td>
</tr>
<tr>
<td>移動至網頁最底端</td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="如何開啟特定連結？"><a href="#如何開啟特定連結？" class="headerlink" title="如何開啟特定連結？"></a>如何開啟特定連結？</h2><p>假如你已找到感興趣的結果，接下來得移動游標到連結位置才能開啟。Chrome 預設以 <code>Tab</code> 和　<code>Shift + Tab</code> 在連結間切換。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移動至下一個連結</td>
<td><code>Tab</code></td>
</tr>
<tr>
<td>移動至上一個連結</td>
<td><code>Shift</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<p>另一種方式是啟用無障礙設定裡的「使用文字游標瀏覽頁面」。在這模式裡，用戶能以 <code>←</code>、<code>↑</code>、<code>↓</code>、<code>→</code> 操作文字游標，讓網頁能像文檔一樣瀏覽。</p>
<ol>
<li><code>Alt</code> + <code>E</code> ，開啟瀏覽器設定選單</li>
<li><code>S</code>，選取「設定」</li>
<li><code>/</code>，進入搜索框</li>
<li>查詢「無障礙設定」</li>
<li>使用 <code>Tab</code> 移動到游標瀏覽功能開關</li>
<li><code>Enter</code>，開啟或關閉功能</li>
</ol>
<p><em>(或是以 <code>F7</code>快速切換文字游標瀏覽模式。記得關掉提醒通知，往後啟用模式才不用一再確認。）</em></p>
<p>當游標移動到連結位置，即可使用以下快捷鍵，決定要於哪個分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟連結</td>
<td><code>Enter</code></td>
</tr>
<tr>
<td><strong>於新分頁開啟連結</strong></td>
<td><code>Ctrl</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新分頁開啟連結並移至新分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新視窗開啟連結並移至新視窗</td>
<td><code>Shift</code> + <code>Enter</code></td>
</tr>
</tbody></table>
<h2 id="如果我還沒找到滿意的結果，要怎麼前往下一頁？"><a href="#如果我還沒找到滿意的結果，要怎麼前往下一頁？" class="headerlink" title="如果我還沒找到滿意的結果，要怎麼前往下一頁？"></a>如果我還沒找到滿意的結果，要怎麼前往下一頁？</h2><p>很遺憾的，目前 Chrome 或 Google Search <strong>沒有直達下一頁的快捷鍵</strong>，只能持續押著 <code>Tab</code> 直到頁面底部。那使用 <code>Shift</code> + <code>Tab</code> 從頁面底部開始找起呢？可行，但不見得比較快，因為頁面底部除了「下一頁」與「上一頁」按鈕外，還有隱私權、服務條款、活動紀錄與地理位置等連結要通過。</p>
<p>開啟連結是使用鍵盤瀏覽網頁的最大障礙，因為用戶必須先滑動視窗找到對應的連結，再移動游標通過一樣內容到該連結的位置。換句話說，用戶至少要跑兩次迴圈才能找到並打開連結。</p>
<p>既然如此，那為什麼不一開始就使用 <code>Tab</code> 來逛網頁呢？其實可以，但非常惱人。</p>
<p>首先，游標移動不若視窗滑動迅速。其次，連結在網頁上的順序未必與游標移動的順序一致，使得用戶無法預期瀏覽的方向。以 Google search 為例，一則搜尋條目在視覺上的結構為頁庫存檔選項、翻譯選項與連結文字。然而，游標移動的順序卻是連結文字、頁庫存檔選項、翻譯選項，導致需要連續按三次 <code>Tab</code> 才能移動到下一個連結。</p>
<blockquote>
<p><a href="https://5uperb0y.com/">https://5uperb0y.com</a> ▼ 翻譯這個網頁<br>5uperb0y’s blog</p>
</blockquote>
<p>第三，不是每個網頁都會醒目標示游標的位置，以至於用戶不僅無法確認游標移動的順序，還可能找不到游標的位置。就拿我這個網站為例，可以試試使用 <code>Tab</code> 來找到任一文章的連結，我相信按了十幾下可能都還沒辦法確認游標位置，所以也很難開啟特定連結。</p>
<p>在本文其他節，我會介紹能迴避這些問題的取巧手段和擴充套件。但在此處，我們先假設所有搜索都能在第一頁找到答案，並繼續了解如何透過快捷鍵管理分頁與視窗。</p>
<h2 id="如何管理瀏覽器分頁？"><a href="#如何管理瀏覽器分頁？" class="headerlink" title="如何管理瀏覽器分頁？"></a>如何管理瀏覽器分頁？</h2><p>如今我們已經會使用快捷鍵搜尋和瀏覽網頁，然而隨著點擊而累積的分頁又該如何管理呢？雖然列出了許多選項，但我常用的僅有粗體標示者。</p>
<h3 id="開啟與關閉分頁"><a href="#開啟與關閉分頁" class="headerlink" title="開啟與關閉分頁"></a>開啟與關閉分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>shortcut</th>
</tr>
</thead>
<tbody><tr>
<td>開啟新分頁並移至新分頁</td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td><strong>關閉當前分頁</strong></td>
<td><code>Ctrl</code> + <code>W</code> or <code>Ctrl</code> + <code>F4</code></td>
</tr>
<tr>
<td>依關閉順序，重新開啟已關閉之分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td>
</tr>
</tbody></table>
<h3 id="切換與移動分頁"><a href="#切換與移動分頁" class="headerlink" title="切換與移動分頁"></a>切換與移動分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至指定分頁</td>
<td><code>Ctrl</code> + <code>[1-8]</code></td>
</tr>
<tr>
<td>移至最後分頁</td>
<td><code>Ctrl</code> + <code>9</code></td>
</tr>
<tr>
<td><strong>移至下一分頁</strong></td>
<td><code>Ctrl</code> + <code>PageDown</code> or <code>Ctrl</code> + <code>Tab</code></td>
</tr>
<tr>
<td>移至上一分頁</td>
<td><code>Ctrl</code> + <code>PageUp</code> or <code>Ctrl</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>後挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageDown</code></td>
</tr>
<tr>
<td>前挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageUp</code></td>
</tr>
<tr>
<td>挪動分頁為獨立視窗</td>
<td><code>Shift</code> + <code>W</code></td>
</tr>
</tbody></table>
<h3 id="搜索或開啟曾瀏覽的網頁"><a href="#搜索或開啟曾瀏覽的網頁" class="headerlink" title="搜索或開啟曾瀏覽的網頁"></a>搜索或開啟曾瀏覽的網頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>上一頁</strong></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>開啟搜尋歷史</td>
<td><code>Ctrl</code> + <code>H</code></td>
</tr>
</tbody></table>
<h2 id="如何管理瀏覽器視窗？"><a href="#如何管理瀏覽器視窗？" class="headerlink" title="如何管理瀏覽器視窗？"></a>如何管理瀏覽器視窗？</h2><p>除了分頁，Chrome 亦支援以快捷鍵開啟視窗或調整視窗大小。不過這些快捷鍵我也不常用到，頂多會用無痕視窗查詢特殊關鍵字或測試 SEO 和網頁有沒有問題。值得留意的是，<code>ALT</code> + <code>Space</code> 是開啟視窗右鍵選單的快捷鍵，所以縮小或放大都有提示，不須記憶。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>開新視窗</td>
<td><code>Ctrl</code> + <code>N</code></td>
<td>寫作時參照文件</td>
</tr>
<tr>
<td>開新無痕視窗</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td>
<td>查詢關鍵字、測試網頁</td>
</tr>
<tr>
<td>將當前視窗縮至最小</td>
<td><code>ALT</code> + <code>Space</code>, then <code>N</code></td>
<td>操作桌面的檔案或軟體</td>
</tr>
<tr>
<td>將當前視窗開至最大</td>
<td><code>ALT</code> + <code>Space</code>, then <code>X</code></td>
<td>很少用</td>
</tr>
</tbody></table>
<p>相較於 Chrome，Windows 提供了更多調整視窗尺寸的途徑。因此有助於在寫程式或編輯文件時，雙開文件並分配視窗在螢幕上的位置，以便邊參閱資料邊修改文件。下圖是視窗間的關係，點擊 <code>Win</code> 與下圖的方向鍵，即可在不同形式的視窗間切換。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           上半視窗（點選 ↓ 會回到原始視窗）</span><br><span class="line">              ↑</span><br><span class="line">左半視窗 ←  最大視窗 → 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">左半視窗 ⇆ 原始視窗 ⇆ 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">           最小視窗          </span><br></pre></td></tr></table></figure>

<p>至於要在視窗間切換或取回縮小的視窗，可以使用 <code>Alt</code> + <code>Tab</code> 進入選單，再配合方向鍵選取。</p>
<h1 id="快捷鍵組合技"><a href="#快捷鍵組合技" class="headerlink" title="快捷鍵組合技"></a>快捷鍵組合技</h1><p>前一節介紹了 Chrome 內建的快捷鍵，但諸如好手氣、右鍵搜索、於無痕視窗開啟等功能都沒有對應的快捷鍵。因此，這一節要介紹如何組合基本的快捷鍵，實踐這些方便功能。</p>
<h2 id="「透過-Google-搜尋」"><a href="#「透過-Google-搜尋」" class="headerlink" title="「透過 Google 搜尋」"></a>「透過 Google 搜尋」</h2><p><strong>方法一：透過「開新分頁」</strong></p>
<ol>
<li>標示 (highlight) 欲搜索的字串</li>
<li><code>Ctrl</code> + <code>C</code>，複製字串</li>
<li><code>Ctrl</code> + <code>T</code>，開啟並移動游標至新分頁的網址列</li>
<li><code>Ctrl</code> + <code>V</code>，貼上字串至網址列</li>
<li><code>Enter</code>，執行搜尋</li>
</ol>
<p>若要在同一分頁搜尋，可以使用 <code>Ctrl</code> + <code>E</code>&#x2F;<code>K</code>&#x2F;<code>L</code> 取代 <code>Ctrl</code> + <code>T</code>。</p>
<p><strong>方法二：透過「右鍵選單」</strong><br>若使用 windows 電腦，可使用選單鍵開啟右鍵選單，執行相關功能。</p>
<ol>
<li>標示欲搜索的字串</li>
<li><code>☰</code>，透過選單鍵(menu key)開啟選單</li>
<li><code>S</code>，執行「透過 Google 搜尋」</li>
</ol>
<h2 id="「好手氣」"><a href="#「好手氣」" class="headerlink" title="「好手氣」"></a>「好手氣」</h2><p>Google search 首頁有個好手氣的按鈕，能直接進入第一個搜尋的網頁。我們可以使用 Google search 的無障礙連結來達到類似目的。</p>
<ol>
<li>輸入搜尋內容</li>
<li><code>Tab</code>，開啟無障礙輔助提示，此時應該會停在「跳至主內容」</li>
<li><code>Enter</code>，確認跳至「主內容」，通常會直接將游標移動到第一個連結</li>
<li><code>Enter</code>，進入第一個連結</li>
</ol>
<p>由於 Google 有時會在第一則搜尋條目前安插精選摘要、廣告或是錯字提醒的窗格，所以這招並非總是見效。儘管如此，仍比遍歷 Google search 的功能窗格更為便捷。</p>
<h2 id="「在無痕視窗中開啟連結」"><a href="#「在無痕視窗中開啟連結」" class="headerlink" title="「在無痕視窗中開啟連結」"></a>「在無痕視窗中開啟連結」</h2><p>Chrome 介紹了各種開啟連結的方式，唯獨不支援在無痕視窗開啟連結的方式，所以此處同樣要利用選單鍵的來開啟右鍵選單。</p>
<ol>
<li>移動游標至連結</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>G</code>，執行「在無痕視窗中開啟連結」</li>
</ol>
<h2 id="「另存為圖片」"><a href="#「另存為圖片」" class="headerlink" title="「另存為圖片」"></a>「另存為圖片」</h2><p><strong>方法一：透過「另存網頁」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code>，開啟圖片於新分頁並切換至新分頁</li>
<li><code>Ctrl</code> + <code>S</code>，另存新檔</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<p><strong>方法二：透過「右鍵選單」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>V</code>，執行「另存為圖片」</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<h2 id="拖曳當前分頁為獨立視窗"><a href="#拖曳當前分頁為獨立視窗" class="headerlink" title="拖曳當前分頁為獨立視窗"></a>拖曳當前分頁為獨立視窗</h2><p>Chrome 沒有相關的快捷鍵，不過我們可以透過「於新視窗開啟分頁」的快捷鍵來模擬。然而與滑鼠拖曳最大的差別在於，重啟後不會保留已填入的資料，也不會刪除舊的分頁。</p>
<ol>
<li><code>Ctrl</code> + <code>L</code> (or <code>Alt</code> + <code>D</code>)，移至網址列</li>
<li><code>Shift</code> + <code>Enter</code>，於新視窗開啟連結</li>
</ol>
<h1 id="以取巧的方式迴避點擊連結的障礙？"><a href="#以取巧的方式迴避點擊連結的障礙？" class="headerlink" title="以取巧的方式迴避點擊連結的障礙？"></a>以取巧的方式迴避點擊連結的障礙？</h1><p>本文前半部曾提到，點擊連結是用鍵盤瀏覽網頁最大的困難。在這一節，我嘗試用瀏覽器搜尋功能（<code>Ctrl</code>+<code>F</code>）可以迅速跳轉位置的特性，解決游標移動效率不彰的問題。</p>
<h2 id="如何直達特定連結？"><a href="#如何直達特定連結？" class="headerlink" title="如何直達特定連結？"></a>如何直達特定連結？</h2><p>直達特定連結有以下五個步驟：</p>
<ol>
<li>辨識：目視想要開啟的連結</li>
<li>編碼：觀察連結文字或網址，從中挑選獨一無二的子字串作為頁內搜尋的關鍵字。</li>
<li>搜尋：<code>Ctrl</code>+<code>F</code>，搜尋關鍵字以找到連結位置</li>
<li>跳轉：若選對關鍵字，游標會直接移動到連結。若否，則使用 <code>Enter</code> 和 <code>Shift</code> + <code>Enter</code>前後查詢連結</li>
<li>開啟：<code>Enter</code>，開啟連結（若想要在新分頁開啟連結，可以先　<code>Esc</code> 退出，再執行開分頁搜索的行為）</li>
</ol>
<p>為連結編碼（或說選用關鍵字）時，可挑選網域的子字串。由於網域通常會採用較獨特的名稱，所以較不容易與其它連結衝突，能避免查詢時無法一步到位。此外，Google search 會將來自相同網站的相似內容以巢狀結構編排，不會讓單一網站的內容佔滿搜尋結果。這項特性讓頁內搜索時不會一次出現很多結果，同樣提升了搜尋的精準度。</p>
<h2 id="如何前往下一頁？"><a href="#如何前往下一頁？" class="headerlink" title="如何前往下一頁？"></a>如何前往下一頁？</h2><p>頁內搜索的訣竅同樣能運用於前往下一頁。Google search 最下方的結果分頁有兩個潛在標的，第一個是「下一頁」本身，這個詞彙相當獨特，所以搜尋時不容易被結果條目干擾。然而它的長度較長（若以注音輸入法要按九個按鈕），所以可能要先複製字串或是用<a href="https://key.chtouch.com/cv.aspx?p=3120">window使用者造詞</a>將這些代表「下一頁」的關鍵字存為快捷鍵，減少輸入時間。（使用者造詞可以降低到只要按四個按鈕）</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋 <code>下一頁</code></li>
<li><code>Ctrl</code> + <code>Enter</code></li>
</ol>
<p>第二個搜索標的則是表示頁數的數字，原則上這些數字會是整個頁面最後一個數字，所以我們可以從頁面底部反向搜索這些數字來直達連結。只是 Chrome 的最後一列可能顯示用戶地址資訊，其中郵遞區號會影響查詢。目前，我還沒找到關閉這些訊息顯示的方法。</p>
<ol>
<li><code>Ctrl</code>+ <code>F</code>，搜尋任意數字</li>
<li><code>Shift</code> + <code>Enter</code>，往回找到最後一個搜尋結果，最差要往回查兩次才能越過郵遞區號到達頁面數字</li>
<li><code>Ctrl</code> + <code>Enter</code>，開啟下一頁</li>
</ol>
<p>由於不是每個網頁都有前往下一頁的對應按鈕，所以 Chrome 沒有下一頁的關鍵字也蠻合理的。不過我猜這項特性也跟搜尋引擎的理念有關。假設在關鍵字正確的情況下，Google Search 總是能推薦最佳的內容。那麼，只要用戶下對關鍵字，就能從第一個連結取得想要的結果。</p>
<p>若第一頁沒出現想要的結果，表示下錯關鍵字或議題太冷門，再怎麼瀏覽都很難找到想要的資訊。因此，基於對搜尋演算法的信任，下一頁的需求其實不高，這項缺陷算是變相鼓勵用戶改善搜索的效率而非瀏覽的效率。</p>
<h2 id="如何複製文字？"><a href="#如何複製文字？" class="headerlink" title="如何複製文字？"></a>如何複製文字？</h2><p>較費時的做法是啟用文字游標瀏覽模式，再移動游標至目標文句，再使用 <code>Shift</code> + 方向鍵選取並複製。搜尋快捷鍵則能節省游標移動的時間，</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋目標文句</li>
<li><code>Esc</code>，脫離頁內搜尋窗格</li>
<li><code>Shift</code> + 方向鍵，選取要複製的文句</li>
<li><code>Ctrl</code> + <code>V</code>，複製</li>
</ol>
<p>如果要複製的文字篇幅較長，這方法甚至會比滑鼠來得有效且可靠，因為使用滑鼠選取時，要同時壓著鼠鍵並滑過狹長的文字區域，這過程有如遊玩電流急急棒一樣。相較之下，使用上下鍵卻可以一次複製一整列，還不用擔心手滑取消掉選取的區域。但如果目標文句較短的話，輸入搜尋關鍵字的時間都足以重新打字一遍了，這方法便顯得沒什麼效率。</p>
<h1 id="使用-Vimium-解放鍵盤的潛能"><a href="#使用-Vimium-解放鍵盤的潛能" class="headerlink" title="使用 Vimium 解放鍵盤的潛能"></a>使用 Vimium 解放鍵盤的潛能</h1><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的擴充套件，借鑒了 Vim 編輯器的操作邏輯與鍵位設置，大幅改善了在 Chrome 的鍵盤瀏覽體驗。</p>
<h2 id="為什麼-Vim-的功能改善鍵盤瀏覽體驗？"><a href="#為什麼-Vim-的功能改善鍵盤瀏覽體驗？" class="headerlink" title="為什麼 Vim 的功能改善鍵盤瀏覽體驗？"></a>為什麼 Vim 的功能改善鍵盤瀏覽體驗？</h2><p>從鍵盤輸入電腦的訊號不外乎指令（例如開分頁、複製、下一頁)和文字（例如中文、英文與符號），由於指令數量遠大於按鈕的數量，若要確保鍵盤尺寸在雙手便於敲擊的範圍，勢必得存在兼具兩種定位的按鈕。而專為鍵盤設計的 Vim 與 Windows 與 Chrome 等仰賴鍵鼠相輔者的差異正體現在讓電腦區分鍵入訊號的方式。</p>
<p>鍵鼠相輔的圖形介面保留了文字鍵的獨立性，讓滑鼠與功能選單取代部分指令（例如游標移動），而且只有在一併輸入 <code>Ctrl</code>、<code>Alt</code>、<code>Home</code> 等特殊控制鍵時，這些文字鍵才會發揮指令的功能。然而，這些特殊控制鍵分布於鍵盤兩側，編輯複雜文件時，雙手往往要在滑鼠、文字鍵區與控制鍵等區域間來回移動。</p>
<p>與之相對，Vim 則透過切換模式來區分鍵入訊號。文字鍵在 Insert 模式用於輸入內容，在 Normal 模式則用於下達指令，所以無論要鍵入指令還是文字，所有操作都圍繞在 f 與 j 那列按鍵 (home row)，降低了操作時雙手位移的幅度。</p>
<p>但是，Vim 的這些特性為什麼可以改善用鍵盤瀏覽網頁的體驗？</p>
<p>Vim 的 Normal 模式有許多便於移動與跳轉指標的指令，這些有用的指令在鍵鼠系統裡多被滑鼠取代，導致鍵盤不足以支持瀏覽網頁的需求。然而，除了輸入關鍵字外，瀏覽網頁時其實少有編輯文字的需求，也就沒有下達指令與輸入文字的衝突。這種情況可以類比為 Vim 的 Normal 模式，如果能透過 vimium 之類的套件，移植 Vim 好用的指令到這些閒置的文字鍵，便能充分發會鍵盤的潛能。</p>
<h2 id="Vimium-解決了鍵盤開啟連結的麻煩"><a href="#Vimium-解決了鍵盤開啟連結的麻煩" class="headerlink" title="Vimium 解決了鍵盤開啟連結的麻煩"></a>Vimium 解決了鍵盤開啟連結的麻煩</h2><p>雖然 Vimium 還有許多功能（這些功能可透過輸入 <code>?</code> 查詢），但我覺得在改善瀏覽網頁方面，快速開啟連結是最方便也最重要的功能。</p>
<p>若使用 Chrome 內建的快捷鍵，必須透過遍歷或是搜尋來找到連結。當網站連結編排不友善時，遍歷的時間會延長非常多。相較之下，Vimium 引進了 Vim Easymotion 功能，用戶只要鍵入 <code>f</code>，Vimium 便會自動為連結標記關鍵字，只要輸入關鍵字就能直接開啟標註的連結。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="按下 `f` 即可自動標註連結，再按下標註的字母即可開啟連結。由於每個連結至多標註兩個字母，所以視窗內的連結都可以在輸入三個鍵以內開啟。"></p>
<p>學會以 Vimium 開啟連結，再配合 Windows 與 Chrome 內建直觀的快捷鍵，其實就足以查資料、逛論壇或是到社群平台串門子了。若對於效率有要求，還可以再讀 Vimium 的說明，學習以 home row 為核心的鍵盤操作。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>網頁瀏覽是少量文字編輯，加上大量查詢、瀏覽、點擊與切換等指令的循環。鍵鼠系統已能流暢地瀏覽網頁，所以是否要單用鍵盤瀏覽網頁是風格問題，我對此議題的總結如下，</p>
<ul>
<li><strong>格調重於成效</strong>：「社會組織是一部大型機器，每個人都是維繫機器運作必要的鏍絲釘。」雖然必要，但無可避免被取代。有時小小的不一樣，可以讓自己多少脫離被束縛與異化的感受。</li>
<li><strong>搜索取代遍歷</strong>：鍵盤操作較不直覺，但很精準，行為可以直接反映想法，不用經過滑鼠拖曳或是<code>Tab</code>切換的過程。</li>
<li><strong>自訂創造風格</strong>：按鍵數量有限，但可透過模式切換、特殊控制鍵、輸入順序、指令組合等方式來擴充可容納的指令。儘管擁有選項，卻不存在預設值，若想使用鍵盤就得思考和選擇，決定什麼才適合現今的自己。</li>
</ul>
<p>在實務上，只要學習 Vimium 的快搜鍵 <code>f</code> 加上瀏覽器內建按鍵（例如方向鍵），就可以應對網頁瀏覽的多數需求了。</p>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tips and tricks</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜如何為輸入的資料建立辨識碼</title>
    <url>/nextflow-combine-data-into-a-tuple-with-key/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Nextflow 的框架，channel 媒介了 process 間的資料傳遞。雖然資料進出 channel 遵循先進先出 (first-in, first out, FIFO) 原則，但隨後 nextflow 會平行處理這些資料，所以 process 釋出資料的順序取決於執行速率，而不是原先輸入的順序（見下例）。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demoEmitOrder.nf</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val num</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;num&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    nums = channel.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    nums.view()</span><br><span class="line">    A(nums).view() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoEmitOrder.nf</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Nextflow 這項特性使得輸入彼此相依的資料時要格外留意，因為可能在定序產物品管時，發生不同樣本的順逆序列（例如：a_r1.fa 與 b_r2.fa 合併）的狀況；又或是使用 GATK 這類需要參考基因體的工具時，無法為 <code>.fasta</code> 找到對應 <code>.dict</code> 和 <code>.fai</code> 檔的情形。</p>
<p>因此，本文將介紹如何將想要一起輸入的檔案以及其辨識碼組合成 tuple （例如：<code>[&quot;ID&quot;, &quot;ID_r1.fastq&quot;, &quot;ID_r2.fastq&quot;]</code>），確保成對資料同進同出，還能透過辨識碼與其它資料合併。</p>
<span id="more"></span>

<h1 id="準備測試資料"><a href="#準備測試資料" class="headerlink" title="準備測試資料"></a>準備測試資料</h1><p>首先建立雙端定序產物與人體基因體序列的測試資料，用以示範成對資料和多筆資料各自要如何組合成 tuple。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> data</span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;_r&#123;1,2&#125;.fq           <span class="comment"># 示範成對資料</span></span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;.&#123;fasta,dict,fai&#125;    <span class="comment"># 示範多筆資料</span></span><br></pre></td></tr></table></figure>

<p>接著，在 nextflow script (<code>*.nf</code>) 定義這些資料以建立 input channel。此處這麼做是為了簡便，但其實也可以將資料路徑寫到 JSON 檔，在執行 nextflow script 時，透過 <code>-c</code> 或 <code>-params-file</code> 讀入。要留意的是，欲組合在一起的資料於 nextflow 變項的順序要一致，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">inDir = <span class="string">&quot;/path/to/data&quot;</span></span><br><span class="line">id = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">fq1 = [<span class="string">&quot;$inDir/a_r1.fq&quot;</span>, <span class="string">&quot;$inDir/b_r1.fq&quot;</span>, <span class="string">&quot;$inDir/c_r1.fq&quot;</span>]</span><br><span class="line">fq2 = [<span class="string">&quot;$inDir/a_r2.fq&quot;</span>, <span class="string">&quot;$inDir/b_r2.fq&quot;</span>, <span class="string">&quot;$inDir/c_r2.fq&quot;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="透過-nextflow-operator"><a href="#透過-nextflow-operator" class="headerlink" title="透過 nextflow operator"></a>透過 nextflow operator</h1><p>假設已經把辨識碼與輸入資料定義成前一節的形式，而且要組合在一起的資料於 nextflow 各變項內的順序也相同，那麼可以先建立包含全數資料的 tuple，再使用 <code>transpose</code> operator 轉置。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.of([id, fq1, fq2]).transpose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/5uperb0y/blog-media/blob/main/combine-data-into-a-tuple-with-key_transpose.png?raw=true" alt="`transpose` 能轉置 channel 的組成。"></p>
<p>由於 channel 遵循 FIFO 原則，所以使用 <code>view()</code> 瀏覽結果時，確認資料釋出與輸入順序一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure>
<h1 id="透過-bash-in-process"><a href="#透過-bash-in-process" class="headerlink" title="透過 bash in process"></a>透過 bash in process</h1><p>假設辨識碼為檔名的一部份，那麼也可以用 bash script 擷取字串，並在 output channel 將擷取到的辨識碼與輸入的資料組合成 <code>tuple</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process addID &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path fq1</span><br><span class="line">        path fq2</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        tuple env(id), path(fq1), path(fq2)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        id=\$(basename -s _r1.fq $&#123;fq1&#125;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    addID(channel.fromPath(fq1), channel.fromPath(fq2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於經 process 處理，資料釋出順序已偏離輸入順序，紀錄的路徑也轉移到 process 的工作目錄了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r1.fq, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r2.fq]  </span><br><span class="line">[c, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r1.fq, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r2.fq]  </span><br><span class="line">[b, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r1.fq, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r2.fq]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="透過-channel-factory-限定成對資料"><a href="#透過-channel-factory-限定成對資料" class="headerlink" title="透過 channel factory (限定成對資料)"></a>透過 channel factory (限定成對資料)</h1><p>如果辨識碼是檔名的一部份，而且資料又如雙端定序產物兩兩一組，那麼也可以使用 <code>fromFilePairs</code> 建立 <code>tuple</code>。簡言之，nextflow 會搜尋指定目錄下含有成對詞綴的檔案（此例為 <code>_r1.fq</code> 與 <code>_r2.fq</code>），擷取詞綴前的字串，將成對資料組合成帶有辨識碼的 <code>tuple</code>。</p>
<p>預設是組合成 <code>[&quot;id&quot;, [&quot;path 1&quot;, &quot;path 2&quot;]]</code> 形式，所以此處使用 <code>flat:true</code> 攤平巢狀結構。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromFilePairs(<span class="string">&quot;$inDir/*_r&#123;1,2&#125;.fq&quot;</span>, <span class="attr">flat:</span><span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure>
<h1 id="結合-channel-operator-和-groovy-closure"><a href="#結合-channel-operator-和-groovy-closure" class="headerlink" title="結合 channel operator 和 groovy closure"></a>結合 channel operator 和 groovy closure</h1><p><code>fromFilePairs</code> 僅適用成對資料，若是多筆資料則要組合 nextflow operator 和 groovy closure 來完成。</p>
<ol>
<li>以 <code>fromPath</code> 建立 channel 時，搜尋不同詞綴的檔案</li>
<li>以 groovy <em>getBaseName</em> 擷取檔名，再用 nextflow <code>map</code> 將檔名與檔案路徑組合成 tuple（例如：<code>a.fasta</code>→<code>［&quot;a&quot;, &quot;a.fasta&quot;]</code>）</li>
<li>以 <code>groupTuple</code> 組合含有相同辨識碼的 tuple（例如：<code>[&quot;a&quot;, &quot;a.fasta&quot;]</code> 與 <code>[&quot;a&quot;, &quot;a.dict&quot;]</code> 組合成 <code>[&quot;a&quot;, [&quot;a.fasta&quot;, &quot;a.dict&quot;]]</code>）</li>
<li>以 <code>map</code> 配合 groovy <em>flatten</em> 攤開巢狀 <code>tuple</code></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromPath([<span class="string">&quot;$inDir/*.dict&quot;</span>, <span class="string">&quot;$inDir/*.fasta&quot;</span>, <span class="string">&quot;$inDir/*.fai&quot;</span>])</span><br><span class="line">        .map&#123;it -&gt; tuple(it.getBaseName(), it)&#125;</span><br><span class="line">        .groupTuple()</span><br><span class="line">        .map&#123;it -&gt; it.flatten()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此處假設檔名等同辨識碼，若辨識碼是檔名的子字串或其它組合，那就要參考 groovy 的字串處理方式。這裡使用 groovy 是為了要在 nextflow script 完成任務，若不限此條件，那也可以新增 process，改用熟悉的腳本語言來處理字串（參考 bash script 的方法）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a.fasta, /path/to/data/a.dict, /path/to/data/a.fai]</span><br><span class="line">[b, /path/to/data/b.fasta, /path/to/data/b.dict, /path/to/data/b.fai]</span><br><span class="line">[c, /path/to/data/c.fasta, /path/to/data/c.dict, /path/to/data/c.fai]</span><br></pre></td></tr></table></figure>

<h1 id="怎麼讀取資料"><a href="#怎麼讀取資料" class="headerlink" title="怎麼讀取資料"></a>怎麼讀取資料</h1><p>前述建立的 <code>tuple</code> 可用以下方式讀入 process，也可以用 <code>join</code> 組合，確保成對或多筆資料能夠在 process 同進同出。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process readInput &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        tuple val(id), path(fq1), path(fq2)</span><br><span class="line">        tuple val(id), path(fasta), path(dict), path(fai)</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fq1&#125;, $&#123;fq2&#125;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fasta&#125;, $&#123;dict&#125;, $&#123;fai&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>最後使用一張表總結將資料組合為 <code>tuple</code> 的方法。</p>
<table>
<thead>
<tr>
<th>比較項目</th>
<th>operator</th>
<th>bash in process</th>
<th>fromFilePairs</th>
<th>operator &amp; closure</th>
</tr>
</thead>
<tbody><tr>
<td>檔案數</td>
<td>不限</td>
<td>不限</td>
<td>兩筆</td>
<td>不限</td>
</tr>
<tr>
<td>定義</td>
<td>需定義檔案路徑</td>
<td>需定義檔案路徑</td>
<td>檔案存放路徑</td>
<td>檔案存放路徑</td>
</tr>
<tr>
<td>釋出順序</td>
<td>輸入順序</td>
<td>完成順序</td>
<td>輸入順序</td>
<td>輸入順序</td>
</tr>
<tr>
<td>檔案位置</td>
<td>輸入路徑</td>
<td>工作目錄</td>
<td>輸入路徑</td>
<td>輸入路徑</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜程式碼區塊的跳脫符號 (escape characters)</title>
    <url>/nextflow-escape-characters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹程式碼定義變項的符號與 nextflow 內建語法衝突時，有哪些選項可以解決之。</p>
<span id="more"></span>
<h2 id="Nextflow-管理程式的單位"><a href="#Nextflow-管理程式的單位" class="headerlink" title="Nextflow 管理程式的單位"></a>Nextflow 管理程式的單位</h2><p>Process 是 Nextflow 管理程式的單位，其中必然包含 script 區塊來定義想執行的程式。除了 script 區塊，還有 directives（環境設置）、inputs（輸入資料）、outputs（輸出資料）等非必要但有助流程控管的區塊。</p>
<p>在執行程式前，Nextflow 會解讀 script 區塊帶有 <code>$</code> 前綴的變項，代入 inputs、parameters 或 config files 的對應內容。<br>以 process fastQC 為例，nextflow 將 <code>fq</code> (input) 的內容代入 <code>$&#123;fq&#125;</code> (script) 後才執行程式，再將輸出結果透過 <code>fqc</code>(output) 傳遞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process fastQC &#123;</span><br><span class="line">    publishDir &quot;$&#123;params.outdir&#125;/qc&quot;, mode: &#x27;copy&#x27;, overwrite: true</span><br><span class="line">    input:</span><br><span class="line">        path fq</span><br><span class="line">    output:</span><br><span class="line">        path &quot;*_fastqc.&#123;zip,html&#125;&quot; into fqc</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fastqc --nogroup -q $&#123;fq&#125;</span><br><span class="line">    &quot;&quot;&quot;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程式碼與nextflow-語法衝突"><a href="#程式碼與nextflow-語法衝突" class="headerlink" title="程式碼與nextflow 語法衝突"></a>程式碼與nextflow 語法衝突</h2><p>值得留意的是，perl 或 bash 等語言也使用 <code>$</code> 標記變項（例如：<code>$i</code>、<code>$path</code>）。Nextflow 無法區分以 <code>$</code> 為前綴的變項是定義在 script 內（script 變項），還是得自於 inputs, parameters 或 config files（nextflow 變項）。</p>
<p>因此，如果程式碼出現以 <code>$</code> 定義或呼叫的 script 變項 ，nextflow 便有可能因為無法在 inputs、parameters 或 config files 找到對應內容而報錯。</p>
<p>舉以下案例來說，<code>title</code>&#x2F;<code>$title</code> 是使用 bash 定義的 script 變項。然而，nextflow 卻誤判該變項的來源，以至於找不到其內容（<code>No such variable</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># printPath.nf</span><br><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title=&quot;The current directory is,&quot;</span><br><span class="line">    echo &quot;$title \n $PWD&quot;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    printDir().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run printPath.nf</span><br><span class="line">Error executing process &gt; &#x27;printDir&#x27;</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">    No such variable: title -- Check script &#x27;printDir.nf&#x27; at line: 4</span><br></pre></td></tr></table></figure>

<p>對於這個問題，主要的解法是透過更換標記符號來區分 script 變項和 nextflow 變項。</p>
<h2 id="更換-nextflow-變項的標記符號"><a href="#更換-nextflow-變項的標記符號" class="headerlink" title="更換 nextflow 變項的標記符號"></a>更換 nextflow 變項的標記符號</h2><p>第一種方法是改以三個單引號夾註程式碼，提示 nextflow 改以 <code>！&#123;&#125;</code> 標記 nextflow 變項。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更換-跳脫-script-變項的標記符號"><a href="#更換-跳脫-script-變項的標記符號" class="headerlink" title="更換 (跳脫) script 變項的標記符號"></a>更換 (跳脫) script 變項的標記符號</h2><p>若 script 變項不多，也可以在 <code>＄</code> 前面加上反斜線(<code>\$</code>)，提示 nextflow 忽略 <code>$</code> 符號。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;\$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更動跳脫字元"><a href="#更動跳脫字元" class="headerlink" title="更動跳脫字元"></a>更動跳脫字元</h2><p>由於 nextflow 的底層是 groovy，所以除了 script 與 nextflow 的語法衝突，也可能碰到 script 與 groovy 語法衝突的狀況。</p>
<p>以下兩個案例都在 script 區塊使用反斜線來編輯文字。由於反斜線是 groovy 預設的跳脫符號，所以執行這些 processes 時也可能發生編譯錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sepReplace.nf</span><br><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    sepReplace().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run sepReplace.nf</span><br><span class="line">(skip)</span><br><span class="line">Command error:</span><br><span class="line">    .command.sh line3: unexpected EOF while looking for matching `&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>或是<a href="https://github.com/nextflow-io/nextflow/issues/67">這個案例</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># strRemove.nf</span><br><span class="line">process strRemove &#123;</span><br><span class="line">    outpur:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    echo &quot;Hello lg:en&quot; | sed &quot;s/.*lg:\(.*\).*/\1/&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    strRemove().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run strRemove.nf</span><br><span class="line">Script compilation error</span><br><span class="line">- file : /path/to/workdir/strRemove.nf</span><br><span class="line">- cause: Unexpected character: &#x27;\&#x27;&#x27; @ line 4, column 7.</span><br><span class="line">       &#x27;&#x27;&#x27;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure>

<p>碰到這種情形，首先要使用 <code>$/</code> 和 <code>/$</code> 夾註程式碼，提示 groovy 改以 <code>$</code> 作為跳脫符號，以區分 script 和 groovy 語法。</p>
<p>接著，在 script 變項的 <code>$</code> 前面再加一個 <code>$</code> (<code>$$</code>)，提示 nextflow 忽略 <code>$</code> 符號，以區分 script 和 nextflow 語法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    $/</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    /$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封裝為腳本"><a href="#封裝為腳本" class="headerlink" title="封裝為腳本"></a>封裝為腳本</h2><p>不過，如果程式碼用到大量變項，前述方法會讓程式碼顯得囉嗦又不易讀。此時，可以考慮將程式碼封裝為腳本，再從 script 區塊呼叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># sepReplace.sh</span><br><span class="line">str=&quot;A,B,C&quot;</span><br><span class="line">echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    $baseDir/sepReplace.sh</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為 nextflow、bash、perl 都以 <code>$</code> 標記變項，所以執行 process 時可能會無法正確辨識 script 區塊內的變項來源而報錯。可能的解決途徑如下，</p>
<ul>
<li><strong>nextflow 變項少</strong>：以三個單引號夾註程式碼，再以 <code>！&#123;&#125;</code> 標記 nextflow 變項</li>
<li><strong>script 變項少</strong>：以 <code>\</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>出現反斜線</strong>：以 <code>$/</code> 和 <code>/$</code> 夾註程式碼，再以 <code>$</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>程式碼龐雜</strong>：將程式碼封裝為腳本，再從 process 呼叫腳本</li>
</ul>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜資料是怎麼在 Process 間傳遞？</title>
    <url>/nextflow-how-data-is-passed-between-processes-through-channels/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Process 是 nextflow 管理分析流程的基本單位，可包含能在 linux shell 執行的程式碼（例如 linux command, python code）、腳本（例如自訂的 hello-world.sh）與軟體（例如 GATK 或 FastQC）。 Process 之間彼此獨立，各有各的工作目錄，也可以分別設定其執行環境（例如 docker container 或 conda environment）。</p>
<p>Channel 則媒介了 process 間的資料交流，若不透過 channels 串接，process 間的檔案或變項無法共享。舉凡字串、數值、檔案路徑乃至標準輸出等，皆有對應的 qualifier 讓 nextflow 知道怎麼處理得自於 channel 的各式資料。</p>
<span id="more"></span>
<p>在以下案例，我在 process A 定義了兩條字串，並透過不同途徑傳遞給 process B。</p>
<p>首先，string 1 被寫入檔案 (<code>str.txt</code>)，再以 path qualifier 告訴 Nextflow，把檔案路徑用軟連結 (symbolic link) 掛到 process B 的工作目錄。至於 string 2 則被定義為變項 (strAsEnv, a bash variable)，再以 env qualifier 告訴 nextflow 把變項寫到 process A 工作目錄內的 <code>.command.env</code>。</p>
<p>接著，分別以 strInFile 及 strAsEnv 命名由 process A 輸出 channel，傳遞給 process B 印出。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供 process B 所需的字串</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;str.txt&quot;</span>, <span class="attr">emit:</span> strInFile</span><br><span class="line">        env strAsEnv, <span class="attr">emit:</span> strAsEnv</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;string 1&quot; &gt; &quot;str.txt&quot;</span></span><br><span class="line"><span class="string">        strAsEnv=&quot;string 2&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 印出 process A 提供的字串</span></span><br><span class="line">process B &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path strInFile</span><br><span class="line">        val strAsEnv </span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;\$(cat $&#123;strInFile&#125;) is retrieved from a file passed by a queue channel&quot;</span></span><br><span class="line"><span class="string">        echo &quot;$&#123;strAsEnv&#125; is retrieved from a environment variable passed by a value channel&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 執行 process A &amp; B</span></span><br><span class="line">workflow &#123;</span><br><span class="line">    A()</span><br><span class="line">    B(A.out.strInFile, A.out.strAsEnv).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoChannel.nf </span><br><span class="line">Launching `demoChannel.nf` [compassionate_shannon] - revision: 319cfe997a</span><br><span class="line">executor &gt;  <span class="built_in">local</span> (2)</span><br><span class="line">[f3/e5a365] process &gt; A [100%] 1 of 1 ✔</span><br><span class="line">[b0/f79f8e] process &gt; B [100%] 1 of 1 ✔</span><br><span class="line">string 1 is retrieved from a file passed by a queue channel</span><br><span class="line">string 2 is retrieved from a environment variable passed by a value channel</span><br></pre></td></tr></table></figure>
<p>各 process 的工作目錄預設建立在執行路徑下的<code>work</code>，直接觀察工作目錄內的暫存檔有助於了解 path 與 env 兩種資料傳遞方式的差異<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案">1</span></a></sup>。</p>
<p>在 process A 的工作目錄 ([f3&#x2F;e5a365]) 裡，除了輸出的 str.txt，還有 <code>.command.env</code>。Nextflow 在執行時會將所有用 env qualifier 標記的變項定義式（即　<code>var=value</code> 這種格式）寫入 <code>.command.env</code>，以利隨後可輸出到其它 process。（可查看 <code>.command.sh</code> 查看寫入變項定義式的程式碼）</p>
<p>目前，只有 bash 變項才能透過 env qualifier 輸出，其它語言的變項只能透過某些方式存成檔案輸出（例如 R 的 RDS 檔）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /work/f3/e5a365e3bb7b645cf4e13cf15eb235</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">-rw-r--r-- 1 user group   18 Jan  5 22:26 .command.env      <span class="comment"># environment variables of process A</span></span><br><span class="line">-rw-r--r-- 1 user group  146 Jan  5 22:26 .command.sh       <span class="comment"># commands to execute process A</span></span><br><span class="line">-rw-r--r-- 1 user group    9 Jan  5 22:26 str.txt           <span class="comment"># output of process A</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.env</span><br><span class="line">strAsEnv=string 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.sh　 <span class="comment"># nextflow 執行 process 的腳本，只擷取跟 `.command.env` 相關的部分</span></span><br><span class="line"><span class="comment"># capture process environment</span></span><br><span class="line"><span class="built_in">set</span> +u</span><br><span class="line"><span class="built_in">echo</span> strAsEnv=<span class="variable">$&#123;strAsEnv[@]&#125;</span> &gt; .command.env</span><br></pre></td></tr></table></figure>

<p>而在 process B 的工作目錄可留意到 str.txt 的資料型別為 <code>l</code> (link)，檔案名稱也標示了來源。值得留意的是，如果使用 <code>cat</code> 或 <code>cp</code> 等指令通常不會有什麼問題，但如果用 <code>ls</code> 顯示檔案大小時，要注意預設顯示的是軟連結的大小，而非原檔的大小。相似的狀況也可能發生在使用 <code>find</code> 搜尋時，因為限制了搜索標的為檔案而意外地排除軟連結的情形。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/work/b0/f79f8e550a4e1af11e2b03af8b4aa4$ <span class="built_in">ls</span> -al</span><br><span class="line">lrw-r--r-- 1 user group   62 Jan  5 22:26 str.txt -&gt; /work/f3/e5a365e3bb7b645cf4e13cf15eb235/str.txt</span><br></pre></td></tr></table></figure>

<p>綜上所述，要怎麼利用 channel 傳遞資料端視資料型別而異。無論想傳遞表格、文檔還是變項，都可以將其寫入檔案，再以 path qualifier 讓 nextflow 依據檔案路徑在下游 process 的工作目錄建立軟連結。若想傳遞的是 bash 變項，那還可以使用 env qualifier 將變項定義式記錄在當前 process 的工作目錄供後續取用。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜如何改善用戶的命令列使用體驗</title>
    <url>/nextflow-improve-user-experience-on-cli/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 的命令列介面對開發者而言已相當全面，但對一般用戶而言，仍有可以改善的空間。本文介紹一些 Nextflow 的內建功能，可以因應不同的專案結構，改善用戶的命令列使用體驗。</p>
<span id="more"></span>
<h1 id="如何執行-Nextflow-腳本？"><a href="#如何執行-Nextflow-腳本？" class="headerlink" title="如何執行 Nextflow 腳本？"></a>如何執行 Nextflow 腳本？</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run /path/to/workflow.nf\</span><br><span class="line">		 -c  /path/to/params.config\</span><br><span class="line">		 -params-file /path/to/params.json\</span><br><span class="line">		 [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>
<p>Nextflow 的命令包含幾個關鍵選項，</p>
<ul>
<li><code>run</code>：啟動腳本的選項，用於執行特定的 Nextflow 腳本</li>
<li><code>-c</code>：pipeline 的設置檔案，可調整運算環境、計算資源和日誌檔等 pipeline 相關參數，也能批次導入腳本中以 <code>params</code>定義的參數</li>
<li><code>-params-file</code>：參數批次檔，經由 <code>-params-file</code> 導入的參數優先於 <code>-c</code> 導入的參數。</li>
<li><code>--something</code>：由命令列輸入的參數，可滿足特定的運算需求，具最高優先度。</li>
</ul>
<h1 id="可能的改進空間"><a href="#可能的改進空間" class="headerlink" title="可能的改進空間"></a>可能的改進空間</h1><p>Nextflow 的命令列設計對開發者而言相當全面，但從一般用戶的角度來說，仍有一些使用上的挑戰。這些挑戰中，最明顯的是腳本與設置檔的選擇問題。對於只包含單一腳本與配置檔案的專案而言，清楚的使用說明與文件標示足以確保腳本正確使用。然而，一旦涉及多個腳本與配置檔案，容易造成使用者困惑，尤其是在必須針對不同計算環境或分析場域選擇適當設置檔的情境。</p>
<p>其次，雖然 <code>-params-file</code> 提供了參數輸入的靈活性，允許用戶批次輸入樣本並且自訂 pipeline 的參數，但這同時也將 pipeline 的核心參數和樣本相關的參數混合在一起，有可能會造成一定程度的混淆。</p>
<p>再者，自定義參數檔需要以 JSON 格式輸入，可能對一些用戶不夠友善。</p>
<h1 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h1><h2 id="預設設置檔"><a href="#預設設置檔" class="headerlink" title="預設設置檔"></a>預設設置檔</h2><p>為了簡化設置檔的指定過程，可善用 Nextflow <a href="https://www.nextflow.io/docs/latest/config.html#configuration-file">讀取參數的機制</a>，將預設參數寫在腳本內部，或是存放在腳本同層目錄下的 <code>nextflow.config</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。">1</span></a></sup>。 如此一來，若用戶未使用 <code>-c</code> 指定，Nextflow 會自動讀取這兩個參數來源以執行腳本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workflows</span><br><span class="line">|- main.nf</span><br><span class="line">|- nextflow.config</span><br></pre></td></tr></table></figure>


<h2 id="管理多元設置"><a href="#管理多元設置" class="headerlink" title="管理多元設置"></a>管理多元設置</h2><p>跨平台與情境的設置檔可以透過 Nextflow 的 <a href="https://www.nextflow.io/docs/latest/config.html#config-profiles">Configuration Profile</a> 來管理，從而避免因少量參數異動而建立多個設置檔。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiles &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        process.executor = &#x27;docker&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    k8s &#123;</span><br><span class="line">        process.executor = &#x27;k8s&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用時，可以在命令列指定相應的 profile 切換執行環境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf -profile <span class="string">&quot;k8s&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="採用表格輸入"><a href="#採用表格輸入" class="headerlink" title="採用表格輸入"></a>採用表格輸入</h2><p>為了改善輸入檔案與 pipeline 參數的管理，可以考慮使用表格形式紀錄輸入檔案的資訊，將 pipeline 相關參數另外以命令列傳入，達到區分樣本相關資訊與 pipeline 核心參數的效果。</p>
<p>讀入表格資料的方式可參考 <a href="https://nextflow-io.github.io/patterns/process-per-csv-record/">Process per CSV record</a>。假設有批定序資料要分析，其檔案路徑記錄在 <code>input.csv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;uuid&quot;,&quot;fq1&quot;,&quot;fq2&quot;</span><br><span class="line">&quot;smp1&quot;,&quot;/path/to/smp1_r1.fq&quot;,&quot;/path/to/smp1_r2.fq&quot;</span><br><span class="line">&quot;smp2&quot;,&quot;/path/to/smp2_r1.fq&quot;,&quot;/path/to/smp2_r2.fq&quot;</span><br></pre></td></tr></table></figure>
<p>則讀取方式可寫作：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">input_ch = Channel.fromPath(params.input) |</span><br><span class="line">	| splitCsv(<span class="attr">header:</span><span class="literal">true</span>) \</span><br><span class="line">	| map &#123; row -&gt; tuple(row.uuid, file(row.fq1), file(row.fq2)) &#125;</span><br></pre></td></tr></table></figure>
<p>用戶便能透過 CSV 格式管理批次輸入的資料，並透過命令列指定其餘參數。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf --input input.csv --output /path/to/output</span><br></pre></td></tr></table></figure>

<h2 id="使用入口腳本"><a href="#使用入口腳本" class="headerlink" title="使用入口腳本"></a>使用入口腳本</h2><p>在包含多個 pipeline 的專案中，可以在專案根目錄新增 <code>main.nf</code> 腳本。在這個入口腳本中，可以編寫一些幫助函數，協助用戶了解所有可用的 pipeline，或是讓用戶透過別名來快速呼叫特定的 pipeline，實踐各式各樣的客製功能。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (params.help) &#123;</span><br><span class="line">	<span class="comment">// print help messages</span></span><br><span class="line">	<span class="comment">// select pipeline to run by user-input key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣做的好處是，用戶可以用統一的名字呼叫 pipeline，不用記憶各支腳本的路徑。而且，用戶可以使用 <code>--help</code> 等參數來了解專案中各 pipeline 的用途與使用方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>綜合以上的改進方案後，用戶可以在不深入研究專案目錄結構的情況下，了解該專案能提供的分析及其使用方式，免除指定設置檔的負擔，並且以慣用的表格來管理輸入檔案。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run project --workflow &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>

<p>若需要額外的封裝和彈性，也能在 Nextflow 框架之外，開發一個能包裝其 API 的軟體，進一步簡化用戶的操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wapper &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜模仿 docstring 來註解 process and workflow</title>
    <url>/nextflow-extract-docstring-from-a-module/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹使用 docstring 的好處，並且探討如何在 Nextflow 使用多行註解模仿 python 的 docstring，從而改善撰寫與維護開發文件的流暢性。</p>
<span id="more"></span>

<p>python 的 docstring 是 function 的強大特性，能讓開發者在參數類別之外，補充關於 function 的用途、假設條件以及運作原理等額外資訊。透過 <code>__doc__</code> 屬性，docstring 能夠被其他程式讀取，實現開發文檔自動化等功能。</p>
<p>更重要的是，docstring 位於 function 內部，這讓開發者更動程式碼後，能夠輕易地同步更新文檔，減少文檔與程式碼不一致的情形。</p>
<p>然而，Nextflow 目前並不支援 docstring 功能。不過，我們可使用多行註解（即介於 <code>/*</code> 與 <code>*/</code> 之間的文字）來模仿 docstring 的效果。這對於協助開發者了解當前的 module（無論是 process 或 workflow）都很有幫助。</p>
<p>鑒於 Nextflow 的註解無法像 python docstring 那樣透過物件方法呼叫，我寫了一支小腳本來<a href="https://github.com/5uperb0y/nf-tools/tree/main/src/get_docstring">節錄這些資訊</a>。</p>
<p>簡言之，我將位於 module 名稱與 directive 之間的多行註解定義為 Nextflow 的 docstring，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process &lt;name&gt; &#123;</span><br><span class="line">	<span class="comment">/* your comments */</span></span><br><span class="line">	directives</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	your code</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這支腳本運用正則表達式（感謝 chatgpt 幫忙想出裏頭可怕的正則表達式）來抓取 docstring，將其與 module 類型（即 workflow 或 process）和名稱一併輸出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python get_docstring.py workflow.nf</span><br><span class="line">process FASTQC</span><br><span class="line">this text is from FASTQC</span><br><span class="line">workflow VARIANT_CALLING</span><br><span class="line">this text is from VARIANT_CALLING</span><br></pre></td></tr></table></figure>
<p>如此一來，我們就能取得 docstring 的內容，不僅方便瀏覽 module 功能，也便於自動生成文檔。</p>
<p>雖然目前功能還蠻陽春的，但之後也許可以新增其他實用功能，例如支援以名稱篩遠 docstring，或是使用 groovy 開發，使之能在 Nextflow 內部調用。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜輸入 empty channel 會發生什麼事？</title>
    <url>/nextflow-input-with-an-empty-channel/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上週碰到一個離奇的 bug，有支 nextflow 腳本可以順利執行，但會無聲無息地略過其中一個 process。該腳本執行後於終端吐出的訊息類似以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf</span><br><span class="line">[3c/9ab742] process &gt; a1 [100%] 1 of 1 ✔</span><br><span class="line">[8e/4eg429] process &gt; a2 [100%] 1 of 1 ✔</span><br><span class="line">[-        ] process &gt; b1</span><br><span class="line">[2f/0c0b71] process &gt; c1 [100%] 1 of 1 ✔</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><code>a1</code> 與 <code>a2</code> 輸出的 channel 經 <code>join</code> 之後輸入 <code>b1</code>，而 <code>c1</code> 則獨立於其他三個 process。</li>
<li>nextflow 沒有任何錯誤訊息（即終端看不到紅色的字）</li>
<li>nextflow 沒有為 <code>b1</code> 開啟工作目錄，所以也無從查看 <code>.command.log/err/out</code> 等與腳本執行相關的資訊</li>
<li>查看 <code>.nextflow.log</code> 只能找到啟動 <code>b1</code> 的訊息：<code>[main] DEBUG nextflow.processor.TaskProcessor - Starting process &gt; b1</code>，但沒有其他執行細節。</li>
</ul>
<h1 id="解決策略"><a href="#解決策略" class="headerlink" title="解決策略"></a>解決策略</h1><p>由於 nextflow 幾乎沒有給出任何提示，所以只能自己想辦法在腳本內安排中斷點印出 channel 的內容。當時的策略是先不用 <code>join</code>，而是單獨輸入 <code>a1</code> 與 <code>a2</code> 的輸出，以便用 <code>stdout</code> 和 <code>view()</code>檢查各個 channel 是否與我們預期相同。</p>
<p>結果問題還真的出在 channel 的合併，原來 <code>a1</code> 與 <code>a2</code> 的輸出結果沒有共同的 key，所以執行 <code>join</code> 操作後會生成一個 empty channel。</p>
<h1 id="Empty-channel"><a href="#Empty-channel" class="headerlink" title="Empty channel"></a>Empty channel</h1><p>在 Nextflow 裏頭，可使用 <code>channel.empty()</code>建立 empty channel，其作用相當於對 process 傳遞終止訊號（參考 <a href="https://javadoc.io/static/io.nextflow/nextflow/0.28.2/nextflow/Channel.html">Nextflow Channel Class 的說明</a>）。</p>
<p>舉例來說，以下這支 nextflow 腳本會依序印出同一時間輸入的數對。雖然 <code>a_ch</code> 含有四項數字，但因為 <code>b_ch</code> 其中一項為 empty channel 的終止訊號，所以這個 process 只遞交並執行了三次<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="執行腳本時，nextflow 會先以 `nextflow.processor.TaskProcessor` 啟動 process，透過 `nextflow.executor.LocalHandler` 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 `.nextflow.log`。">1</span></a></sup>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demoEmptyChannel.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($&#123;a&#125;, $&#123;b&#125;)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>, <span class="string">&quot;a4&quot;</span>)</span><br><span class="line">    b_ch = channel.of(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>).concat(channel.empty()).concat(channel.of(<span class="string">&quot;b4&quot;</span>)) <span class="comment">// append items with concat() and channel.of()</span></span><br><span class="line">    p(a_ch, b_ch).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoEmptyChannel.nf</span><br><span class="line">[a8/4b2c55] process &gt; p (3) [100%] 3 of 3 ✔</span><br><span class="line">(a3, b4)</span><br><span class="line">(a2, b2)</span><br><span class="line">(a1, b1)</span><br></pre></td></tr></table></figure>

<h1 id="使用-ifEmpty-為輸入-channel-設定預設值"><a href="#使用-ifEmpty-為輸入-channel-設定預設值" class="headerlink" title="使用 ifEmpty 為輸入 channel 設定預設值"></a>使用 <code>ifEmpty</code> 為輸入 channel 設定預設值</h1><p>為了避免 process 被跳過或是沒有執行的狀況，<a href="https://www.nextflow.io/docs/latest/operator.html#operator-ifempty">nextflow 官方文件</a>建議以 <code>ifEmpty</code> 為 channel 設定預設值。如以下案例，由於 <code>b_ch</code> 為 empty channel，經 <code>ifEmpty</code> operator 賦予預設值，使得 process 能順利運行。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demoIfEmpty.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($a, $b)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>&#125;</span><br><span class="line">workflow &#123;   </span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>)</span><br><span class="line">    <span class="comment">// &lt;defalut value&gt; if ch.isempty() else ch</span></span><br><span class="line">    b_ch = channel.empty()</span><br><span class="line">    p(a_ch, b_ch.ifEmpty(<span class="string">&quot;b_default&quot;</span>)).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoIfEmpty.nf</span><br><span class="line">[47/459729] process &gt; p (1) [100%] 1 of 1 ✔</span><br><span class="line">(a1, b_default)</span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 的 process 會跳過含有 empty channel 的任務，若想避免這種狀況在非預期的情形發生（例如 <code>join</code> 失敗），可使用 <code>ifEmpty</code> 為 process 的輸入 channel 設定預設值。</p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href="https://stackoverflow.com/questions/70888844/nextflow-how-to-fail-if-channel-is-empty-ifempty">NextFlow: How to fail if channel is empty ( .ifEmpty() )</a></li>
<li><a href="https://stackoverflow.com/questions/64042860/check-if-nextflow-channel-is-empty">check if nextflow channel is empty</a>)</li>
<li><a href="https://github.com/nextflow-io/nf-hack18/blob/master/asciidocs/07_processes.adoc">Nextflow Workshop Hackaton 2018: 07_processes</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">執行腳本時，nextflow 會先以 <code>nextflow.processor.TaskProcessor</code> 啟動 process，透過 <code>nextflow.executor.LocalHandler</code> 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 <code>.nextflow.log</code>。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜怎麼從運行中的腳本取回參數？</title>
    <url>/nextflow-retrieve-configuration-when-workflow-runs/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在執行腳本前，Nextflow 會讀取設置檔 (configuration files) 中的參數，將之代入腳本的對應位置後再執行程式。這項特性有助於使用者管理複雜流程的輸入值與環境設定，也將具體數值從流程邏輯抽離，讓開發者專注於流程的梳理與串接。</p>
<p>然而，隨著流程腳本改版，設置檔的內容也可能跟著改變，是否有方法能記錄執行流程時使用的設置檔，以利往後重現分析或追蹤歷次設定？</p>
<p>在這篇文中，我首先介紹了 nextflow 導入參數的方式，再陳述取回參數的可行策略，並附上這些策略的最簡範例供參考。</p>
<span id="more"></span>

<h2 id="Nextflow-導入參數的方式"><a href="#Nextflow-導入參數的方式" class="headerlink" title="Nextflow 導入參數的方式"></a>Nextflow 導入參數的方式</h2><p>以下是 nextflow 導入參數的常見方式，若一參數被多種方式定義，則會以順位較小者為準。</p>
<table>
<thead>
<tr>
<th>順位</th>
<th>方式</th>
<th>範例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>於命令列輸入</td>
<td><code>nextflow run workflow.nf --something value</code></td>
</tr>
<tr>
<td>2</td>
<td>以 <code>-params-file</code> 導入</td>
<td><code>nextflow run workflow.nf -params-file params.json</code></td>
</tr>
<tr>
<td>3</td>
<td>以 <code>-c</code> 導入</td>
<td><code>nextflow run workflow.nf -c params.config</code></td>
</tr>
<tr>
<td>4</td>
<td>於 nextflow 腳本內宣告</td>
<td><code>params.something = value</code></td>
</tr>
</tbody></table>
<h2 id="使用-params-取回參數"><a href="#使用-params-取回參數" class="headerlink" title="使用 params 取回參數"></a>使用 <code>params</code> 取回參數</h2><p>其中一個方法是讀取 <code>params</code> 的內容，<code>params</code>是 nextflow 的<a href="https://www.nextflow.io/docs/latest/script.html?highlight=implicit#implicit-variables">隱變項</a>，採用 <code>[key1:value1, key2:value2,...]</code>格式存儲以不同方式導入的參數。</p>
<h3 id="params-json"><a href="#params-json" class="headerlink" title="params.json"></a>params.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;paramsDerivedConfig&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;provided using the -params-file option&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="params-config"><a href="#params-config" class="headerlink" title="params.config"></a>params.config</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">params &#123;</span><br><span class="line">    configDerivedConfig = <span class="string">&quot;specified using the -c option&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getConfig-nf"><a href="#getConfig-nf" class="headerlink" title="getConfig.nf"></a>getConfig.nf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">params.inScriptConfig = <span class="string">&quot;defined within the script itself&quot;</span></span><br><span class="line">process retrieveConfigFromParams &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$params&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf --commandSpecifiedConfig <span class="string">&quot;specified on the command line&quot;</span> -params-file params.json -c params.config</span><br><span class="line">[configDerivedConfig:specified using the -c option, config-derived-config:specified using the -c option, paramsDerivedConfig:provided using the -params-file option, params-derived-config:provided using the -params-file option, commandSpecifiedConfig:specified on the <span class="built_in">command</span> line, command-specified-config:specified on the <span class="built_in">command</span> line, inScriptConfig:defined within the script itself, in-script-config:defined within the script itself]</span><br></pre></td></tr></table></figure>

<h2 id="從輸入路徑取回參數"><a href="#從輸入路徑取回參數" class="headerlink" title="從輸入路徑取回參數"></a>從輸入路徑取回參數</h2><p>然而，前述方法只能取回以 <code>params</code> 存儲的參數，若想取得 <code>process</code>, <code>docker</code>, <code>report</code> 等<a href="https://www.nextflow.io/docs/latest/config.html?highlight=params#config-scopes">其它設置 (configuration scope)</a>，可以讀取位於 <code>$launchDir</code> 的 <code>.nextflow.log</code>，從中獲得當初執行腳本時輸入的 <code>*.config</code> 路徑，再將設置擋複製出來。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">process getConfig &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    shell:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    str=$(grep &quot;User config file:&quot; &quot;!&#123;launchDir&#125;/.nextflow.log&quot;)</span></span><br><span class="line"><span class="string">    config=$&#123;str##*:&#125;</span></span><br><span class="line"><span class="string">    echo $&#123;config&#125;</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf -c params.config</span><br><span class="line">/home/user/workflow/params.config</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>若能從運行中的 nextflow 腳本取回輸入參數，將有助於往後重現分析或追蹤設置。目前，nextflow 有兩個隱變項能協助我們達成這項任務，</p>
<ul>
<li><code>params</code>：記錄了不同管道導入的參數，可以在 <code>*.nf</code> 檔各處呼叫以取得書入的參數和設定。</li>
<li><code>launchDir</code>：雖然本身與參數無關，但此變項記錄了腳本執行位置，其中的 <code>.nextflow.log</code> 記錄了 <code>*.config</code> 路徑。讀取該檔即可獲取輸入的參數和設定。</li>
</ul>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜利用 `publishDir` 匯出分析檔案</title>
    <url>/nextflow-the-mode-of-publishdir/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 透過 channel 媒介 process 間的檔案傳遞，讓輸出入檔案以軟連結集中到 process 的工作目錄。不過若想從工作目錄取出分析的最終結果，有賴 <code>publishDir</code> directive 的協助。</p>
<span id="more"></span>

<p><code>publishDir</code> 能匯出 process 輸出檔案到指定目錄，其語法與注意事項如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process demoPub &#123;</span><br><span class="line">    publishDir <span class="string">&quot;/path/to/output&quot;</span></span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;example.txt&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    touch &quot;example.txt&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    demoPub()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有且僅有定義在 output channel 的檔案會匯出到指定目錄</li>
<li><code>publishDir</code> 應使用絕對路徑 </li>
<li>預設會在指定目錄建立輸出檔案的軟連結</li>
<li></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt -&gt; /project/work/workdir    </span><br></pre></td></tr></table></figure>

<h1 id="修改-publishDir-匯出檔案的方式"><a href="#修改-publishDir-匯出檔案的方式" class="headerlink" title="修改 publishDir 匯出檔案的方式"></a>修改 <code>publishDir</code> 匯出檔案的方式</h1><p>若想修改預設模式可以寫成</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">mode:</span> <span class="string">&quot;copy&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt</span><br></pre></td></tr></table></figure>
<p>除了 “copy”，nextflow 亦有其它匯出檔案的方式，它們分別對應了 linux 的 symbolic link, copy, 與 hard link。詳情可參考軟連結、硬連結與複製的差異，此處僅列出與使用檔案較為相關的特性。</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>symlink</th>
<th>copy</th>
<th>link</th>
</tr>
</thead>
<tbody><tr>
<td>linux指令</td>
<td>symbolic link</td>
<td>copy</td>
<td>hard link</td>
</tr>
<tr>
<td>適用對象</td>
<td>檔案與目錄</td>
<td>檔案與目錄</td>
<td>檔案</td>
</tr>
<tr>
<td>原檔更新</td>
<td>隨之更新</td>
<td>不隨之更新</td>
<td>隨之更新</td>
</tr>
<tr>
<td>容量大小</td>
<td>連結大小</td>
<td>與原檔一致</td>
<td>與原檔一致</td>
</tr>
<tr>
<td>刪除原檔</td>
<td>連結遺失</td>
<td>不受影響</td>
<td>不受影響</td>
</tr>
</tbody></table>
<h1 id="篩選輸出的檔案"><a href="#篩選輸出的檔案" class="headerlink" title="篩選輸出的檔案"></a>篩選輸出的檔案</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.txt&quot;</span></span><br><span class="line">publishDir <span class="string">&quot;path/to/backup&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.md&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>pattern</code> 篩選，可以達到分流輸出檔案的目的。</p>
<h1 id="更動輸出名稱"><a href="#更動輸出名稱" class="headerlink" title="更動輸出名稱"></a>更動輸出名稱</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">saveAs:</span> <span class="string">&quot;new_name&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>saveAs</code> 重新命名，可用於重新命名、依照檔名調整輸出目錄等。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 最大的特色是以 channel 傳遞資料，process 是從前一步驟的工作目錄獲得資料，而非讀取輸出目錄的資料夾。換句話說，無論建立 output channel 還是匯出檔案到 publishDir，nextflow 都是以 process 的工作目錄為中心。由於每批次處理都會新建工作目錄，所以也確保了 process 輸出的檔案不會彼此覆寫，減少命名中間檔和管理暫存目錄的勞力（這些都由 nextflow 代勞了）。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜背景執行 workflow 的方法</title>
    <url>/nextflow-run-in-background/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般而言，若想要背景執行 linux 指令，可在指令末端添加 <code>&amp;</code>，或是透過 <code>ctrl + z</code> 配合 <code>bg %n</code> 將執行中的指令挪到背景執行。然而，nextflow 腳本卻不適用這種做法（version &gt;&#x3D; 21.10.6），指令挪到背景後會陷入停止狀態。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf &amp;</span><br><span class="line">[1] 533</span><br><span class="line">Launching `workflow.nf` [sick_waddington] - revision: 123b1ec198</span><br><span class="line">[2]+  Stopped                 nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<p>一旦陷入停止狀態，會變得異常難清，要用 <code>kill %n &amp;&amp; fg</code> 才能一次清掉（參考<a href="https://gitter.im/nextflow-io/nextflow/archives/2020/09/16">論壇的討論</a>）。</p>
<span id="more"></span>
<h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>即使透過 <code>.sh</code> 來執行 nextflow 腳本也會遭遇相同的狀況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># run_workflow.sh</span><br><span class="line">nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./run_workflow.sh &amp;</span><br><span class="line">N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [trusting_hamilton] - revision: 936bafe285</span><br><span class="line">[1]-  Stopped                 <span class="built_in">nohup</span> nextflow run paramInput.nf</span><br><span class="line">[2]+  Stopped                 ./run_workflow.sh</span><br></pre></td></tr></table></figure>

<h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>此時，若要背景執行 nextflow 腳本，可在指令或是腳本內添加 nextflow 內建的 <code>-bg</code> 選項。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -<span class="built_in">bg</span></span><br><span class="line"> N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [furious_kowalevski] - revision: 936bafe285</span><br><span class="line">[8b/21d003] Submitted process &gt; sayHi</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure>

<p>這選項觸發的行為類似 <code>nohup</code>，能確保用戶退出 terminal 後仍能持續執行 nextflow 腳本（可參考官方<a href="https://www.nextflow.io/docs/latest/cli.html#execution-as-a-background-job">文件</a>及<a href="https://www.nextflow.io/blog/2021/5-more-tips-for-nextflow-user-on-hpc.html">部落格</a>）。</p>
<p>除此之外，添加 <code>-bg</code> 也會輸出 <code>.nextflow.pid</code> 檔，紀錄此指令的 pid，以便用戶追蹤 nextflow 腳本的執行狀況。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>若隨時將指令切到前台，並且用 <code>jobs</code> 查看執行狀態，也可以在指令末端補 <code>&amp;</code>。只是這樣退出 terminal 後，nextflow 腳本也跟著結束了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf -<span class="built_in">bg</span> &gt; log.txt &amp;</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>至於為什麼 nextflow 有這特性，我仍沒有頭緒。我試著比較添加 <code>-bg</code> 前後，<code>.nextflow.log</code> 和 <code>.command.run</code> 等檔案的內容，卻沒有發現相關差異。</p>
<p>另外，雖然官方說明 <code>-bg</code> 的行為類似 <code>nohup</code>，但卻無法用 <code>nohup</code> 達到同樣效果。可能還需要對 nextflow 和 linux 有更深的理解才能解釋吧。</p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>卡西尼號與行星保護</title>
    <url>/planetary-protection-rules-and-the-end-of-cassini-probe/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>歷經20年的太空旅行，美國航太總署（NASA）的卡西尼號（Cassini）太空船今天將最後的訊號傳回地球後，高速衝撞土星，以分解蒸發的壯烈方式，結束13年的土星任務。</p>
</blockquote>
<p>卡西尼號是艘軌道探測船，任務結束後沒有能量脫離行星軌道，所以不能像飛掠探測器一樣（航海家 II）飛向深空。它會留在土星系統中，最終因為故障或其他緣故減速而失控墜入土星或其他衛星。</p>
<p>然而土星的衛星中有幾個可能有生命存在（尤其是土衛六泰坦），所以主動讓卡西尼號墜入較無生命可能的土星中，以免滅菌不徹底的機體造成汙染。不過，這種壯烈的自殺已經不是第一次了，2003 年伽利略探測船也為保護木衛二歐羅巴而撞入木星濃厚的大氣層中。</p>
<p>雖然這邊只提到墜毀階段，其實所有的太空任務都有防止生物汙染其他天體的措施，不過依照天體性質和任務類別可以分為五類。此處，我把重點聚焦在分類的依據和理由，而不是防範措施（詳細作法可以在厚厚的行星保護指導手冊中找到。）</p>
<h2 id="第一類任務"><a href="#第一類任務" class="headerlink" title="第一類任務"></a>第一類任務</h2><p>第一類任務是飛掠、繞行或登陸月球、水星和多數小行星，這些天體沒有足夠的液態水維持生命，所以除了例行消毒外，探測船並不需特別處理。</p>
<h2 id="第二類任務"><a href="#第二類任務" class="headerlink" title="第二類任務"></a>第二類任務</h2><p>第二類任務則涉及那些可能沒有生物，但是對於生命起源研究有重要參考價值的天體。例如：土衛六、金星、類木行星和彗星。</p>
<p>2014年羅賽塔號登陸彗星就是第二類任務。那次任務檢測到了胺基酸、醇類等有機物，它們很可能透過彗星撞擊為早期地球帶來形成生命的必要分子。（這些有機物質可能是彗星經過星際塵埃時沾上，或是經過恆星附近起反應形成的。順道一提，首次在星際中發現胺基酸的是師大的管一政教授喔！）</p>
<p>雖然金星現在因為失控的溫室效應已經成為高溫煉獄，但是在太陽還沒今天熾熱、溫室效應也沒失控前可能存在一段宜居的時候。另外金星大氣層中有個溫度合宜，且有硫化物補給的區間，若當初有生命誕生，也許能在此續命。相關任務有 2015 年 ESA 的金星快車（繞行任務）和先前蘇聯因大氣壓扁而早夭的登陸任務。</p>
<p>土衛六和土星因為可能有液態水、有機物存在所以同屬二類，但是土衛六多了可棲息的表面以及大氣層中的有機反應，所以研究價值還好過土星。本次墜毀的卡西尼號曾在 2005 年釋放惠更斯探測器登陸土衛六，可惜登陸不久便失聯了，所幸有留下空降時和登陸當下的照片，大家可以找看看，我覺得看起像是乾涸的水庫……</p>
<h2 id="第三類任務和第四類任務"><a href="#第三類任務和第四類任務" class="headerlink" title="第三類任務和第四類任務"></a>第三類任務和第四類任務</h2><p>第三類是火星和歐羅巴（木衛二）的「繞行」、「飛掠」任務，這兩天體是太陽系內最有可能找到地外生命證據（無論死活）的地方，執行第三類任務的太空船都要經過嚴密滅菌才行。</p>
<p>火星過去可能有水流、磁場和大氣層，這些都是利於生命誕生維持的要素；即便是今日，生物也可能在岩石與冰層間的夾縫中生存。另一個誘人的證據是1984年找到的火星隕石 ALH84001，上頭有疑似細菌化石、生物代謝排遺。</p>
<p>歐羅巴冰層下可能有液態水層，這些水層不僅和岩層接觸促進物質互動（而土衛六可能是隔絕水層），也能隔絕致命輻射保護生命體。</p>
<p>由於這兩顆天體可居，即便沒有原生種，也擔心地球生物在上頭大肆繁殖影響後續監控，所以火星與歐羅巴的「登陸」升級為第四類任務。</p>
<p>雖然我們猜測火星很可能有生物，可是1976年的海盜I&#x2F;II登陸任務卻沒有發現關鍵證據。因為第四類任務的預備很麻煩，所以為了往後探測任務方便，又把它分為三個子類，滅菌等級漸增：非適居區登陸（防止地球細菌汙染火星）、生命探測任務（防止地球細菌干擾實驗）、適居區登陸（防止雙向汙染）。</p>
<h2 id="第五類任務"><a href="#第五類任務" class="headerlink" title="第五類任務"></a>第五類任務</h2><p>至於第五類則是所有回收太空船到地月系統的任務，涵蓋月球是因為它是將來重點開發區域，若受到地外生物汙染，登陸月球會升級到二三類任務，太空船多了一堆滅菌要求會讓開發變得十分不方便。前陣子 NASA 招募的行星保護官就是要專職這種任務的調查工作。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後提一提行星保護的規範。最早是寫在聯合國於 1967 年制定的《關於各國探索和利用包括月球和其他天體在內外層空間活動的原則條約》當中的第九條：<br>各締約國從事研究、探索外層空間（包括月球和其他天體）時，應避免使其遭受有害的污染，以及地球以外的物質，使地球環境發生不利的變化。<br>詳細指導方針則由國際科學理事會下轄的太空研究委員會負責負責。</p>
<p>由於當時台灣還沒退出聯合國所以也簽了這條約，想看詳細內容可以去網路上查中文的手寫文本。雖然台灣至今仍沒有進行任何登陸任務，不過得知我們也曾籌畫整個宇宙開發的小小部分，仍有莫名的參與感。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>life in the universe</category>
      </categories>
  </entry>
  <entry>
    <title>Nextflow｜調整工作目錄的路徑</title>
    <url>/nextflow-change-path-to-work-directory/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 會為分析流程的每一步建立工作目錄，再以工作目錄為中心接收資料、儲存暫存檔和匯出結果。工作目錄預設在 nextflow 腳本執行路徑下的 <code>work/</code>，可透過添加執行選項、調整參數設定、設置環境變項等三種方式自訂工作目錄的路徑。</p>
<span id="more"></span>

<h1 id="添加執行選項"><a href="#添加執行選項" class="headerlink" title="添加執行選項"></a>添加執行選項</h1><p>執行 Nextflow 腳本時，加上 <code>-w</code> 便能指定工作目錄的存放路徑與名稱，是優先度最高的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -w <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="調整參數設定"><a href="#調整參數設定" class="headerlink" title="調整參數設定"></a>調整參數設定</h1><p>其次，也能在<a href="https://www.nextflow.io/docs/latest/config.html">設置檔內定義工作目錄</a>，再使用 <code>-c</code> 導入設置檔。（除此之外，使用 <code>-params-file</code> 導入參數或是直接將<code>workDir</code> 定義在 nextflow 腳本內都是無效的手法。）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.json</span></span><br><span class="line">workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -c config.json</span><br></pre></td></tr></table></figure>

<p>要留意的是，雖然在設置檔內常使用 <code>params.var</code> 的方式來定義變項，但 <code>workDir</code> 不等同 <code>params.workDir</code>，因此以下兩種寫法都無法調整工作目錄的存放路徑。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">params.workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line">params <span class="punctuation">&#123;</span></span><br><span class="line">    workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="設置環境變項"><a href="#設置環境變項" class="headerlink" title="設置環境變項"></a>設置環境變項</h1><p>第三種方法則是在 nextflow 的執行環境重設環境變數，是優先度最低的方式。（Nextflow 相關的環境變項可參照 <a href="https://www.nextflow.io/docs/latest/metadata.html">Workflow introspection</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> NXF_WORK=<span class="string">&quot;/path/to/workdir/&quot;</span></span><br><span class="line">$ nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>工作目錄的內容有助於追蹤程式錯誤，為了管理方便，可透過執行指令、內製變項和環境變項來調整工作目錄的路徑。</p>
<p>除了工作目錄外，或許也有人想調整 <code>.nextflow</code> 等暫存目錄的位置，但根據<a href="https://github.com/nextflow-io/nextflow/issues/1747">開發者所述</a>，目前應該是無法更動。</p>
<blockquote>
<p>The <code>.nextflow</code> has to be in the launching directory to properly maintain the history of the executions.</p>
</blockquote>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>PSYCHO-PASS 心靈判官</title>
    <url>/psycho-pass-anime-and-novel/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《PSYCHO-PASS 心靈判官》系列包含電視版一／二季、劇場版、改編漫畫與小說（台灣僅代理本傳和標本事件前傳。），以下是電視、劇場版和本傳小說的心得。</p>
<span id="more"></span>

<h1 id="小說"><a href="#小說" class="headerlink" title="小說"></a>小說</h1><p>雖然融合了cyberpunk和動作元素，《心靈判官》的本質仍是反烏托邦小說，透過虛構一個由電腦系統主宰民眾職業、婚配甚至罪刑的究極官僚社會，再描述當中發生的種種矛盾以彰顯個人意志對人類的重要性。</p>
<p>故事背景是世界陷入經濟崩潰和政府解體的２２世紀，唯有採用希貝兒系統的日本倖免。希貝兒是由強化大腦連結成的平行運算系統（以下簡稱「系統」），挑選不受既有規範、情感、交際影響的超常人格者為成員，利用人類優於機械的圖像、氣質、……等判斷直覺，替代電腦執行判斷。</p>
<p>其宗旨是促成大多數國民的最大幸福，幸福在此定義成「不須面對抉擇」，由希貝兒代替人民作出最佳選擇。系統愈健全，裁決就愈精準，離理想社會也將更進一步。要讓民眾放心地接受系統裁示得先讓他們信任系統，所以為達成目的，它必須完善系統運作，甚至不擇手段提升效能。</p>
<p>然而追求完美並不可行，較實際的作法是掩飾失敗，讓人民誤以為完美。用虛擬顯影建立都市整潔形象，或隱匿不利資訊（其他可能的社會體制、存在免罪體質者），把反動分子和低層民眾驅趕到刻意留下的廢墟區，冠上汙名轉移市民焦點。對於無法處置或隱瞞的案例，如免罪體質罪犯，則納入系統周延判斷能力，同時消滅之。</p>
<p>儘管書中沒直接提到，但穩定的秩序也應是順利運作的前提。系統藉由監控全體國民精神狀況，揪出潛在犯案者處置，危害小者收容治療，無根治希望者就地處決。由此可知系統沒有定義什麼是「邪惡」、「正義」、「罪愆」與「懲戒」，維持治安就像免疫系統排除病原一樣，不論犯行，端看有無害處。刑警們是向百姓展示維安實力的棋子，他們辦理的案件也只是須優先解決的病灶。</p>
<p>角色和系統的認知落差即故事展開處。主角群由具潛在犯身分的執行官和監督前者的監視官組成，隸屬系統底下的刑事局，負責追查案件，並依系統判斷處置人犯。這些執行官是體制的受害者，因種種原因被剝奪正常人生和從前的生存態度，本作藉由他們質疑系統正當性和討論社會議題。例如前刑警征陸仍抱有舊時代的正義觀，對於以心靈指數定罪卻輕視證據的態度不以為然；前監視官狡齒則不忘殺死對方的是自己而非系統的指示。</p>
<p>各角色多少有表達異議，但最重要的提問者卻是反派槙島聖護，他在幕後策畫一連串案件，藉此質問人民一味聽從指示的扭曲社會中，是否仍存在個人意志和主體性。就像用案件發表一場演說，首先在金原祐治案中展示他的手段：不直接參與犯案，而是給予具有強烈動機的普通人超越法律或倫理的力量，觀察人們會不會基於自我意識越矩行動。<br>　　接著協助病態粉絲御堂將剛殺死偶像篡奪虛擬形象，可是御堂沒有善用這些理想形象，反而滿足於成為他人，在眾多虛假的面貌中迷失自我。另外，被殺掉的偶像能被粉絲取代，這不意味著「……每個人都是空虛的，不再有人需要他人，不論是什麼才能都能找到替代品，任何人都是替代者的替代者，……」那一個人還有什麼獨特性嗎？　</p>
<p>「刺激會帶來活力，那是與死毗鄰的危險報酬」、「……不知道絕望，就不會有希望。」王陵瑠華子支解屍體為素材，模仿父親的畫作，繼承其警惕世人的意志；泉宮寺豐久策畫人類狩獵，想在生死交關中強烈地感受到活著。槙島藉兩起案件拋出這議題：危險和壓力固然是痛苦的根源，但它們也是生存的證據；認知現實的晦暗與殘忍能喚醒理性與良知。用藥物控管心理狀況，紓解壓力並排除所有不良因子的同時，是不是也抹煞了生命？</p>
<p>泉宮寺豐久被處決後，槙島出現在主角常守朱面前，作勢要殺了她朋友。由於槙島是免罪體質者，心理指數不因犯案提升，所以常守朱不能用主宰者制裁，得用傳統火器擊斃他。但用其他武器的含意不只是違反規定，還代表她不能把殺人的責任推給制度，得獨自扛下。</p>
<p>「……，人只有在基於自我意志行動時才有價值。」</p>
<p>這就是槙島最後的提問：自主的個體得親自選擇未來並為此煩惱，同時承擔選擇的後果，害怕背負責任與風險而將之推給社會、推給希貝兒系統的民眾還稱得上人嗎？<br>　　<br>情節至此，已完整陳述這世界的矛盾，後半段則要揭露系統真相，指出其不得不為的理由，並且讓成長的常守朱從中得出最終結論。</p>
<p>槙島綁架常守朱的朋友是想觀察她會不會為了救人而自願背負不義，但是常守朱心中顯然還有其他顧慮：開了槍就等於破壞至今穩固社會的體制。然而她還是閉著眼睛開槍，似乎在逃避什麼，和狡齒的對話也曾提過「殺死對手的不是主宰者，而是我的殺意……」，所以推測初次面對矛盾狀況的她比較接近不敢攻擊。</p>
<p>事件過後她才漸漸堅定信念。她肯定體制的成效和必要，但不贊同其功利價值觀，想從中找回正義的理念；她亦承認反派對系統的質疑，但不認同視人命為草芥的態度，即便在系統支配的社會生存，人類仍然有寶貴的價值。</p>
<p>人們並非被動地活在規範中，如結尾所述：「不是法律守護人，而是人民要守護法律。」「我們憎恨罪惡，尋求正確人生的心情累積形成的就是法律。那不是條文，不是系統，而是存在於任何人心中，脆弱卻有無可替代的心情。相較於憤怒或憎恨的力量，可說是無比脆弱、極易碎裂。因此，為了不讓過去所有想創造出更美好世界者的祈禱變得毫無意義，我們必須堅守法律，不可輕言放棄。」常守朱想在全面破壞與死守體制兩種瘋狂之中，試著走出實際的路，所以她要阻止狡齒復仇，以免破壞體制，也主張加開法庭審理以維護法治。</p>
<p>從建立世界觀，點出爭議，到最終和解，《PSYCHO-PASS 心靈判官》已進行了一次漂亮的論辯。然而有些美中不足的是，因為以警察劇為軸，所以結尾只做出關於正義與法律的思辨，但角色的提問還涵蓋很多東西：自小被系統決定人生的騰秀星有選擇的自由嗎？「盲從系統決定的適性，滿足於被強加的幸褔」還可以保有夢想嗎？在系統呵護下，不需合作也能達成目標，彼此連結是否變得無關緊要？</p>
<p>這些議題也許會持續出現在往後的續作中，只是受限於主角的身分和性格，應該永遠都不會提出解答。</p>
<h1 id="電視版第一季"><a href="#電視版第一季" class="headerlink" title="電視版第一季"></a>電視版第一季</h1><p>我先看了電視版才補完小說，《PSYCHO-PASS心靈判官》的動畫節奏拿捏得很好，每集都斷在令人在意的地方，數集描述一個事件，同時也逐步醞釀最後的大陰謀。人設吸引人、配樂又好聽，雖然動作戲不多，但是懸疑推理的氛圍看得也很過癮。</p>
<p>小說和電視版最大的差異在於小說比較積極營造反烏托邦氣氛，一開頭就說明日本在系統治理下成了「理想的社會」，並且提到廢墟區的功能、人們依適性選擇職業、參考電腦配對發展婚姻（電視版要到第二季才提到。）。另外刪除六合塚來歷以及國營企業命案兩個支線，並且加入番外篇描述其他成員間的關係。</p>
<p>小說把角色心理描寫得更細，亦補充說明一些電視版較含糊的地方，例如「為什麼不拘捕犯人追查共犯？」、「霜月明明認為王陵琉華子很可疑卻推好友入火坑？」、「全身義體化的泉宮寺豐久還測得到心靈指數嗎？」、「為什麼用人腦而不是用電腦當主機？」</p>
<p>其他零零碎碎的相異處還很多。我印象比較深刻的是介紹標本事件時，電視版的六合塚在吃泡麵，可是小說中卻在喝能量飲料，沒有提到六合塚喜歡更變態的東西。</p>
<h1 id="電視版第二季"><a href="#電視版第二季" class="headerlink" title="電視版第二季"></a>電視版第二季</h1><p>在希貝兒系統建立前，日本政府曾打算藉由監控人民行動和經濟活動預測犯罪，設施完成後在交通網路試作。然而這項建設卻被厚生省蓄意干擾，使得監控系統失靈，導致嚴重交通事故頻傳，最終棄置原先計畫轉而採納厚生省支持的希貝兒先知系統。反派鹿矛圍桐斗正是其中一場意外的倖存者，但他並非一個體，而是由罹難者的遺體和大腦拼湊成的集合體。</p>
<p>因為系統自知的其心理指數超標，若採計集體心理指數將不得不審視自己的統治合法性，故默認集合體的心理指數為空，讓自己可不受監督，維護體制完整，可是這麼做也使他們無法監測同為集合體的鹿矛圍，對其舉動束手無策。</p>
<p>鹿矛圍的目的是逼迫系統計算集體心理指數，將系統自身列為制裁的對象，然後用主宰者毀滅之；另一方面，也能藉此得知自己的心理指數是多少。他利用降低心理指數的技術，培養出一批接近免罪體質的犯罪者，由於系統無法透過收編他們解決問題，又不能坐視動亂不管，只能選擇對付鹿矛圍。</p>
<p>倘若循體制內作法，會危及執法的正當性；若無視規則私下解決，便間接承認系統侷限，同樣會重挫民眾信心，動搖社會的基礎。面臨兩難的系統分為兩派：東金母子黨打算越過程序殺人滅口，凌虐小朱祖母嫁禍鹿矛圍，想激怒常守朱除掉他。其餘成員則採納常守朱的建議：承認集體心理指數的同時，自主汰除不良分子，讓心理指數穩定在正常範圍內。</p>
<p>最終東金母子挫敗，鹿矛圍雖然戰死但成功迫使系統納入監督體制。系統暫時度過危機，卻也種下新危機的種子：個體和集體心理指數不一定一致，純淨的心可能聚集成混濁墮落的組織，純淨的群體也可能由罪大惡極者組成，為了制裁一個團體，要傷害其中無辜的個人。目前仍無法計算社會的集體心理指數，一旦社會心理量化的那天來臨，或許會因此引發更大的混亂。</p>
<p>第二季的野心很大，試圖討論集體與個體心靈指數關係以及執法者的統治正當性，只是劇情安排和人物刻劃搞砸導致風評很差，但這是和第一季相比的結果，單獨看的話其實還可以。</p>
<p>剛看完時覺得這回的反派不夠有力，雖然鹿矛圍立意明確、計畫縝密，但和槙島聖護「英雄式預言者式的氣質，創造愉快交談空間的能力，對任何事物都能抒發己見的智力」的領袖氣質相比，還有很大落差。</p>
<p>從犯案動機來看，鹿矛圍是純粹功能導向的。首先挾持酒酒井監視官測試自己可否操作主宰者，於藥局人質事件中驗證監視官一樣會被制裁，繼而引誘刑事局落入埋伏奪取主宰者，最後藉由濫發主宰者造成運算負荷，推算出系統核心位置，帶領一批人發動總攻擊。完美、精準而且確實，但少了槙島那種質問世人的戲劇性。</p>
<p>而且槙島在第一季有很多表達意見的場合，除了主線另有狡齒的私仇這條支線；可是鹿矛圍似乎礙於篇幅沒辦法充分表現，只能作為被追捕的對象成為角色間的話題。</p>
<p>不只反派，其他人物也刻畫不足。加入和常守朱意見相左的霜月監視官可能是想營造觀念衝突，但霜月不管做什麼都被打臉，僅成了為主角實力背書的祭品（還有觀眾唾棄的對象）。而犯罪指數史上最高的東金執行官，剛開始似乎有填狡齒缺的氣勢，但劇情跑到最後被證明只是一個病態的嬤控。至於六合塚和新人物雛河翔則沒什麼存在感，默默地做事默默地被淡忘。</p>
<p>再來提主角常守朱。先前宜野座、征陸、狡齒各司其職，但這一季宜野座被削弱得比較圓滑，其他人物又沒什麼影響力，所以前一季的所有屬性都灌到常守朱身上，化解觀念衝突也減少了劇情張力，最後看起來就像她一個人在東京開無雙。</p>
<p>要挑毛病的話，還可以從犯案方法、追捕手段、……等找瑕疵，但覺得點到為止即可，若不是寫心得比較兩季動畫，我根本不會看得這麼細，音樂播放、槍戰開始的時候我就陷在故事裏了。僅提一點之前覺得是bug，但後來覺得沒問題的地方：最後對峙時，系統排除惡性成員降低心理指數，讓鹿矛圍無法攻擊它。可是若鹿矛圍真想瓦解系統，為何不用其他冷兵器攻擊？</p>
<p>我想一想，鹿矛圍不是單純想毀掉系統，他要讓系統自毀，也就是毀於自己的審判機制，這樣才能強調他的訴求「執法者也要被監督」。</p>
<h1 id="劇場版心得"><a href="#劇場版心得" class="headerlink" title="劇場版心得"></a>劇場版心得</h1><p>劇場版時間點接在第二季後，但可以獨立觀看。這次的舞台在海外，東南亞聯合政府打算從日本引進希貝兒系統，借重其監控設施和無人武裝弭平內亂。刑事局一課逮捕來自該國的恐怖分子後，發現逃亡的前執行官狡齒涉入動亂，於是派遣常守朱前往調查。</p>
<p>在調查中意外揭發東南亞聯合政府軍方隱匿己方異常的犯罪指數，濫用系統鎮壓反對派。東窗事發後，政府方早一步捉拿常守朱欲除之後快，所幸來自刑事一課在危急時趕上，一舉掃蕩軍中的潛在犯。原來，這一切都在系統的策畫中，為了平定鬥爭局面需要利用政府軍的力量，故先前刻意縱容，一旦時局較穩定則解決這些惡徒，收回控制權。</p>
<p>雖然劇場版也有要討論的議題，例如統治的合法性、動亂國家的悲哀、手段正當性……等，但都沒辦法充分展開推論。另外人物塑造不深刻，前頭把反抗軍首領講得很重要，很能鼓舞人心，後頭卻草草地收了他。政府軍上校看起來是個有故事的人，卻什麼主張都沒有提就被殺了。</p>
<p>所以這部的重點還是小朱和狡齒重逢、宜野座與狡齒的man talk以及滿滿的武打駁火吧，至於劇情深度和合理性就其次了。</p>
<p>明年的三部劇場版分別以霜月／宜野座（罪與罰）、征陸／須鄉（Frist Guardian）、狡齒（恩仇的彼端）為主軸。征陸的故事應該會描述系統建立前的社會景況，而霜月那部正好補充這角色先前不足的形象。希望不只是單純動作戲，也能從不同角度考察希貝兒治理的世界，畢竟心靈判官的設定其實有很多題材可以發揮啊！</p>
]]></content>
      <categories>
        <category>sf</category>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>R/Rstudio console 的指令長度限制</title>
    <url>/r-console-upper-limit-on-the-string-length/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>TL:DR：輸入 R&#x2F;Rstudio console 的指令之容量上限為 4095 bytes。若超出上限，console 會忽略超出的部分，顯示 + 提醒使用者補完剩餘指令。</p>
<span id="more"></span>

<p>今天測試定序前處理的 pipeline 時，發現總是無法順利讀檔。為了 debug，我把所有檔案的輸入路徑存為一個字串，並複製到 R console，重跑其中一個 function。結果 console 上印出一個 + 號，function 仍無法運作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> parse_path<span class="punctuation">(</span><span class="string">&quot;....&quot;</span><span class="punctuation">)</span> <span class="comment"># 這是長度約三千多個字符的字串</span></span><br><span class="line"><span class="operator">+</span></span><br></pre></td></tr></table></figure>
<p>我第一個反應是檢查括弧的數量和位置是否正確，接著仔細看檔案路徑中有沒有跳脫字符。然而，怎麼檢查都沒有留意到語法錯誤，於是開始丟各種長度和內容的字串測試。</p>
<p>後來，我發現只要刪除部分字串，function 又可以順利執行了，所以我猜 R 的字串可能有長度上限？循著這猜想，我在網路上找到不少面臨相似問題的人，例如：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28399710/storing-long-strings-dna-sequence-in-r">storing long strings (DNA sequence) in R</a></li>
<li><a href="https://stackoverflow.com/questions/54974996/how-to-bypass-rstudio-console-upper-limit-on-character-string-length">How to bypass RStudio console upper limit on character string length?</a></li>
</ul>
<p>最終，我才在<a href="https://community.rstudio.com/t/does-console-impose-an-upper-limit-on-the-length-of-strings/12872">這則問題</a>找到答案：輸入的字串被刪節確實是因為其大小超出限制，但並非超出 character 存儲上限，而是超出 R&#x2F;Rstudio console 的上限。</p>
<p>舉例來說，我們可以用 paste0 和 rep 建立長字串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>再使用 nchar 統計字串長度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span>seq<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure>
<p>然而，若把字串印出，再完整貼到 console 裏執行。由於字串大小超出 console 上限，所以 nchar 便無法順利運作了。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span> <span class="string">&quot;ABCDEFGABCDEFGABCDEFG......&quot;</span> <span class="punctuation">)</span></span><br><span class="line"><span class="operator">+</span> </span><br></pre></td></tr></table></figure>

<p>當然，字串也有其容量上限，這上限應該是取決於記憶體容量。這狀況，R 會直接告訴我們容量不足，而不是顯示讓人困惑的 +。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">100000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error<span class="operator">:</span> cannot allocate vector of size <span class="number">745058.1</span> Gb</span><br></pre></td></tr></table></figure>
<p>有趣的是，數字再大一點時數字會以科學記號表示，不符合 rep 的輸入規範，也會顯示錯誤。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000000000000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error <span class="keyword">in</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1e+21</span><span class="punctuation">)</span> <span class="operator">:</span> invalid <span class="string">&#x27;times&#x27;</span> argument</span><br></pre></td></tr></table></figure>
<p>這些道理我都懂，可是，我的 pipeline 是以腳本執行啊，怎麼還會碰到這問題？經過一番苦思，發現 bug 出在我的程式邏輯上，跟本文提到的限制一點關係都沒有。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/r-console-upper-limit-on-the-string-length.png?raw=true" alt="meme, it&#39;s my fault, not R&#39;s"></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 鴿子為什麼那麼大？</title>
    <url>/schrodinger-1944-what-is-life-chapter-1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>七十九年前，薛丁格在都柏林三一學院的系列演講為鴿子尺寸提供了光學以外的解釋。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》">1</span></a></sup></p>
<span id="more"></span>

<h2 id="「鴿子為什麼那麼大？」"><a href="#「鴿子為什麼那麼大？」" class="headerlink" title="「鴿子為什麼那麼大？」"></a>「鴿子為什麼那麼大？」</h2><p>這問題乍聽之下或許令人詫異，但其實許多洞見都是從這樣怪誕或荒唐的問題萌發。</p>
<p>日常生活中，大或小的概念是建立在比較的基礎上。在這問題中，真正的目的或許不在了解鴿子的尺寸，而是想知道事物間為何存在懸殊的尺寸差異。事物尺度與其性質的關係是物理學重要的研究方向，而肉眼可見的巨觀層次和原子尺度的微觀層次則是其中的兩個極端。統計物理解釋了這兩大體系之間的關係，為巨觀現象提供微觀尺度的解釋。因此，若以此角度出發，我們可以把問題精確地重塑為：相較於原子，為什麼鴿子那麼大呢？<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」">2</span></a></sup></p>
<p>確實，相較於原子，一隻鴿子的體積非常大。成鴿的平均體重為 0.5 公斤，其組織器官則由碳、氫、氧、氮、硫、磷和其它微量元素構成。假設鴿子僅由氫原子或硫原子組成，可推知一隻成鴿含有的原子數量約在 $10^26$ 到 $10^28$ 之間，這數量遠超過當今對恆星數量的估計值($3 \times 10^{23}$)<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Dokkum & Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.">3</span></a></sup>。</p>
<p>由於鴿子與原子的懸殊比例，鴿子既無法察覺個別原子的動靜，也不受其碰撞、震盪或旋轉影響。這表示，作用於鴿子的原理和作用於原子的原理可能有很大的差異。但這樣的尺度差異對有機體究竟有什麼意義？又為什麼非得如此，才能維持鴿子的存在？</p>
<h2 id="有機體的運作仰賴精確的物理和化學定律"><a href="#有機體的運作仰賴精確的物理和化學定律" class="headerlink" title="有機體的運作仰賴精確的物理和化學定律"></a>有機體的運作仰賴精確的物理和化學定律</h2><p>有機體的運作無處不仰賴事物間精確的配合。以感知和運動為例，有機體要能靈敏接收刺激，同時不失真地傳遞訊息。這些訊息得正確抵達中樞，在歷經複雜決策後，循另一條途徑輸出，以驅動目標肌肉收縮。這個過程的順利，不只需要事件層序分明，也仰賴組織構造的規律。無論是感覺&#x2F;中樞&#x2F;運動神經的緊密連結，粗肌絲與細肌絲的間隔排列，還是細胞內訊息傳遞分子的聚攏，都是完成一項行為的要件。</p>
<p>即使是最簡單的膝跳反射，也需要器官、組織乃至細胞間的緊密配合，更遑論思考、決策與想像等複雜行為對秩序的需求。這意味著，無論生理還是結構層面，維繫有機體的各項事件皆需要相當的精確性；而外在系統對有機體的影響，也要有與之對應的精確性才會發生作用。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」">4</span></a></sup></p>
<h2 id="物理和化學定律的精確性奠基於大量原子參與"><a href="#物理和化學定律的精確性奠基於大量原子參與" class="headerlink" title="物理和化學定律的精確性奠基於大量原子參與"></a>物理和化學定律的精確性奠基於大量原子參與</h2><p>然而，少量原子無法支持有機體所需的精確性。在微觀尺度，個別原子持續進行隨機的熱運動，其移動、震盪和旋轉皆無法測量與追蹤。不過隨著系統內的原子數量增加，原子狀態（例如速度、方向、電荷等）的多樣性也隨之增加。一旦數量夠多，大量原子的平均狀態，便會呈現為巨觀層次可觀察到的方向性或規律性。</p>
<p>以順磁性為例，石英管中的氧氣雖然會因置於磁場而磁化，可是並非所有氧分子的方向皆與磁場一致。在局部，個別分子的方向其實會隨熱運動不斷轉變，所以沒有固定一致的排列方式。儘管個別分子的方向無法預期，但隨著磁場增強，石英管內順磁性分子與逆磁性分子的數量差距會逐漸增加，使得多數的氧分子與磁場方向一致，共同產生可觀測的磁化現象。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。">5</span></a></sup></p>
<p>另一項案例是布朗運動與擴散現象。在微觀尺度，單一微粒會受水分子碰撞而隨機運動，其移往各方向的機率與溶液濃度無關。不過，因為溶液中高&#x2F;低濃度區域的微粒數量有別，由高往低濃度移動的微粒自然比由低往高濃度移動的微粒多，於是微粒在巨觀層次表現出隨重力沉降或隨濃度梯度擴散等現象。</p>
<p>反之，若組成系統的原子數越小，隨機偏差的幅度就越大。這關係可以測量精確度的極限說明。扭秤是測量作用力強度重要的工具。為了偵測到更微弱的作用力，往往會替扭秤選用更輕盈的槓桿與絲線。不過，隨著扭秤尺寸縮小，原子熱運動對扭秤的影響也隨之增加，使得原子碰撞和待測作用力造成的擺幅難以區分。在這種尺度下，單次測量的意義有限，得靠多次測量來消除隨機偏差的影響。</p>
<h2 id="有機體需要足夠的原子才能受益於定律的精確性"><a href="#有機體需要足夠的原子才能受益於定律的精確性" class="headerlink" title="有機體需要足夠的原子才能受益於定律的精確性"></a>有機體需要足夠的原子才能受益於定律的精確性</h2><p>綜上所述，系統在巨觀尺度的屬性是相異狀態之原子的數量分布不均所致。系統內的原子數越多，數量不均的狀況就越容易與隨機運動區別，呈現的集體現象也就越明確。原子數量與定律精確性的關係可用 $\sqrt{n}$ 法則描述。 $\sqrt{n}$ 法則是指，對一個含有 n 個原子的系統而言，物理或化學定律的誤差範圍約在 $\sqrt{n}$ 內。式子中的平方根意味著，隨著系統含有的原子增加，作用在此系統定律的相對誤差就愈低。</p>
<p>讓我們回到文章開頭提到的問題，為何鴿子那麼大？或說，為什麼鴿子就不能像寡糖或Omega-3一樣小？這是因為，有機體的遺傳、發育和行為等生命特徵需要足夠數量的原子，才有辦法忽視個別原子的隨機運動，表現出統計物理上的宏觀秩序。</p>
<p>讓我們想像一種僅由 100 個原子組成的迷你鴿子。根據 $\sqrt{n}$ 法則，發生在迷你鴿子體內的擴散、催化、接合等反應皆有 10 個原子的不確定性，即有 10% 的相對誤差。</p>
<p>在這尺度，影響鴿子的不再是氣流、重力和光線等巨觀現象，而是電荷、碰撞、量子穿隧等微觀現象。僅僅一個離子，就可能破壞迷你鴿子的結構；即使是少量原子刺激，都會影響鴿子的感官，以致於不能辨明關鍵的環境訊號。既然無法維繫體內運作和對外互動，這樣的生命也就不會是我們定義的「鴿子」了。</p>
<h2 id="古典物理無法解釋遺傳的分子機制"><a href="#古典物理無法解釋遺傳的分子機制" class="headerlink" title="古典物理無法解釋遺傳的分子機制"></a>古典物理無法解釋遺傳的分子機制</h2><p>儘管統計物理似乎為有機體的尺存給出了圓滿的解釋，但此處的議論實為楔子：依照前述討論，有機體的秩序仰賴大量原子參與。不過就當時所知，基因很可能僅由少量原子組成，那麼基因是怎麼表現出遺傳、突變與分裂等在巨觀層次可觀測到的高度秩序？薛丁格主張，這個矛盾或許可用量子力學的概念解釋。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Dokkum &amp; Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。<a href="#fnref:5" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 如何推論基因的尺寸？</title>
    <url>/schrodinger-1944-what-is-life-chapter-2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>依照<a href="./schrodinger-1944-what-is-life-chapter-1.md">第一章</a>的推理，生物及其生理過程有賴大量原子參與，來抵銷個別原子的隨機行為，以維持生存所需的宏觀秩序。</p>
<p>乍看之下，這項推論似乎符合當代多數的生物學觀察。畢竟個體由無數細胞組成，而細胞又由多樣的園子、分子和聚合物構築。即使是維繫生存最基本的呼吸作用，也需要大量的分子參與。這些園子的數量大小，吻合統計物理的要求，能讓物理和化學過程順利運作。</p>
<p>然而，在這章當中，我們可以看到維繫遺傳的關鍵因素，基因，相較於其穩定性，卻令人訝異地有著幾乎無法維持嚴格統計定律的數量。</p>
<span id="more"></span>

<h2 id="基因相當穩定"><a href="#基因相當穩定" class="headerlink" title="基因相當穩定"></a>基因相當穩定</h2><p>相較於紙張、磁碟片、或是塗鴉在牆上的紀錄，基因在保存事務上的能力相當穩定。基因的穩定型從色盲、鐮刀行貧血、乃至於哈布斯堡家族鮮明的戽斗等遺傳行疾病更為顯著，即使經過了上千年，這些性狀仍仍能忠實地在世代間傳遞，以致於當今的社會仍要為其奮鬥。</p>
<p>考量其穩定性，究竟需要多少原子才能讓基因維持這樣的穩定性呢？</p>
<h2 id="以染色體影像估算基因的最大尺寸"><a href="#以染色體影像估算基因的最大尺寸" class="headerlink" title="以染色體影像估算基因的最大尺寸"></a>以染色體影像估算基因的最大尺寸</h2><p>一種直觀的估算方法是透過細胞學的觀察為依據。果蠅唾腺細胞的染色體在分裂時會凝聚成顯微鏡可見的棒狀物，這些染色體上有深淺間格的調帶，假設這些條帶是基因的性向，那麼可以ˇ用染色惡體的體積，再除以調代的數量，那麼即可推論基因的尺寸。</p>
<h2 id="以遺傳圖譜估算基因的最大尺寸"><a href="#以遺傳圖譜估算基因的最大尺寸" class="headerlink" title="以遺傳圖譜估算基因的最大尺寸"></a>以遺傳圖譜估算基因的最大尺寸</h2><p>另一種迂迴但是巧妙的手法是透過遺傳方法，推論基因的數量。生物形成配子時，會先行減數分裂。減數分裂過程，同源染色體間的片段可能彼此互換，導致原先坐落相同染色體的性狀，被置換到對偶染色體上。互換會導致子代性狀的機率分布脫離孟德爾的假設，因此透過育種雜交實驗，可從子代性狀的分布推論互換的機率。</p>
<p>假設染色體各處發生互換的機率一致，若性狀間距越大，當中也有較多位點可能發生互換，也表示兩者互換的機率也越高（因為兩者之間有較多位置可能發生互換），反之則表示兩者互換機率愈高，則間距越大。基於這項假設，可以從性狀間的互換率，推論性狀在染色體上的相對位置與距離。</p>
<p>這項任務有助於在遺傳學上譜出基因的相對位置，其在推論基因尺寸的用途則在於。若我們定義基因為乘載性狀的基本單位，若一項性狀能隨互換而遷移，表示這段區域至少包含了能獨立展現性狀的基因。因此，基因的最大尺寸可由染色體的體積，除以可互換而分離的性狀數量來估計。（由於）</p>
<h2 id="基因具有令人訝異的穩定性"><a href="#基因具有令人訝異的穩定性" class="headerlink" title="基因具有令人訝異的穩定性"></a>基因具有令人訝異的穩定性</h2><p>無論透過何種方式推論，原子的最大體積約為 300 Å,而單一原子的尺寸約為 1 Å，這意味著基因所含的原子數頂多在數百萬個之間。透過前一章所推論的，這樣的尺寸顯然過少了。那麼究竟有什麼使得基因能以保有如此問訂的特性</p>
]]></content>
      <categories>
        <category>astrobiology</category>
        <category>what is life</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>尋找太陽系外的行星：天文學家莎拉．西格的愛與探索</title>
    <url>/seager-2021-the-smallest-lights-in-the-universe-a-memoir/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>莎拉．西格教授任職於麻省理工學院，她因在系外行星探測的理論與實踐上的傑出貢獻，於 2014 年獲頒麥克阿瑟獎。我第一次看到她的名字是在《五十億年的孤寂》一書中，此書訪談了第一線天文學家，介紹學界在尋找地外生命的嘗試、成功與挫敗，描繪出天文生物學的發展軌跡。書中不僅多次提到尋找地外生命的挑戰，還討論了社會支持對科研突破的影響。</p>
<p>全書以莎拉的訪談作結（由於書不在手，我只能大略描述），描繪了喪偶莎拉在黎明前拖著獨木舟航向一個對於她自己，或是地外生命探索而言都同樣晦暗不明的未來。</p>
<p>相較於《五十億年的孤寂》，這本書則是莎拉的人生回顧，讓我們得以從她的視角，看到一位科研人員如何因憧憬而投身科研，為什麼堅持下去，以及科研之外的事件如何影響個人的信念和觀點？</p>
<span id="more"></span>

<p>德雷克曾提出一條公式 (Drake Equation) 來估計銀河系內可能存在的外星文明數量，這公式將左右生命起源與演化的各種宏觀因素相乘。因此，對於每個因素的估計，都大大地影響了我們對於地外生命是否存在的信心。</p>
<p>系外行星的數量是公式其中一個變項。在 1960 年代，美國與瑞士的科學團隊分別宣稱透過徑向速度法發現系外行星，飛馬座 51。他們並未直接拍攝到行星公轉的影像，而是透過潛在天體對恆星運動軌跡的影響，來推測行星的存在。簡言之，行星繞行恆星時，恆星其實也繞著彼此的質心運動，導致其與地球的距離週期變化。這種距離變化引發的都普勒效應能在光譜上觀測到，成為支持行星存在的證據。</p>
<p>然而，學界對於這項發現的看法分歧，一方面有人質疑結果的解釋，另一方面則有人認為影響光譜的是其他天體而非行星。換句話說，在二十世紀中葉系外行星是否存在仍有許多爭議，這意味著即使生命可以輕易在一攤有機物濃湯裡萌發，除了地球外可能沒有合適的地方安放這些原料。觀測系外行星的限制在於沒有辦法直接看見它們，即使是當時最好的望遠鏡也只能捕捉到遙遠恆星甚至整個星系散發的微弱光亮。</p>
<p>如今，已有數千顆系外行星被發現，觀測方法也不限逕向運動法，還擴展到凌日法或重力透鏡法等手段。不過，在莎拉決定研究系外行星及其可能性的時候，這領域還處在手段闕如，連研究標的是否存在都還不明朗的階段。究竟是什麼樣的啟發和經歷，讓莎拉被系外行星的研究吸引，從而決定探索宇宙這個人類最大的未知領域？</p>
<p>理由得追溯到她十六歲的時候，擺脫了在派對、嗑藥、溜冰、還有嘉年華的夏季裡格格不入的日子，用打工買下的天文望遠鏡，顫抖地透過鏡片，在寒冷的天空看見木星的那一刻。此後，即使父親強力建議她就讀醫學系，莎拉始終不以為然，打算好好讀書進大學，看一輩子的星星。</p>
<p>隨後，莎拉於多倫多大學取得數學與物理學士學位，打算在進入哈佛大學進修前的長假走一趟獨木舟之旅。在籌備過程中，她結識了生命最重要的伴侶麥克，他們一同規劃行程、練習泛舟並且想像旅途中的景象。莎拉發現他們彼此能自在相處共享某種孤單，於是邀請麥克偕行。他們一路通過陌生的湖泊、湍流還在森林大火中死裡逃生。旅途之後，麥可隨莎拉在波士頓定居，並在莎拉離開哈佛前結婚。她是這麼描述他們的生活與關係：</p>
<blockquote>
<p>我把麥可和我想成宇宙裡的兩個天體，彼此相距遙遠，卻有一種無形的力量將我們綁在一起。我們就像是火星的兩個衛星：佛勃斯和戴摩斯，這兩顆衛星按照不同的軌道運行，彼此的關係卻異常和諧，就像希臘神祉阿瑞斯和阿芙柔黛蒂的雙胞胎兒子一樣，所以才這麼命名。</p>
</blockquote>
<p>她與麥可成婚不久後育有兩子，並獲麻省理工學院的教職。儘管職涯和生活皆有相當的進展，但她的光芒背後仍然伴隨著一些陰影，包含了對研究意義的質疑、與研究夥伴的決裂、意外告終的類地行星搜索計劃、寵物與父親的逝世。</p>
<p>而其中最大陰影，幾乎籠罩生命一切光明的，是她的丈夫麥可在壯年之際罹患癌症。莎拉不得不看著伴侶逐漸衰弱最終病故。麥可的離去不只是情感上的打擊，也破壞了她的生活平衡。以往麥可負責打理家務，讓莎拉能全神貫注在研究項目。如今，她不得不一肩扛起家庭重擔，還要照顧兩位年幼的孩子，又不能落後科研進展。</p>
<p>在這樣的壓力下，莎拉只好聘僱保母與家管協助，雖然這些幫助大幅減輕家務的負擔，卻無法撫平麥可逝世帶來的哀傷。這些困境和學術行政對身兼家務的學者的不友善態度，使得她一度想要放棄。所幸，寡婦俱樂部的朋友陪伴她度過失去丈夫後的春夏秋冬，研究單位的同仁也在她經濟最險峻的情況下大方支持她，讓她沒有放棄學術研究，熬到因研究成果卓越獲獎，獲得一筆足以支持她研究與生活的獎金。</p>
<p>幾年後，莎拉再度結識一位能交心的對象，查爾斯。他意外地走進了她的生活，陪伴莎拉走過生涯最低谷的日子。在書末，年過半百的查爾斯放棄繼承家族事業，與莎拉結為連理並搬入她的家。</p>
<p>莎拉的一生，恰好與她最著名的科研成果──蔽星板計劃──的意象契合。蔽星板是一種輔助觀測系外行星的裝置，它能遮蔽恆星光芒，讓儀器有辦法偵測到周圍行星反射出的微弱光訊號。在莎拉這輩子的追求中，喪夫無疑是巨大的黑暗，但在這片陰影邊緣，微弱的光芒仍引導她看見另一種可能性，如同她對自己踏上天文學的動機的回顧：</p>
<blockquote>
<p>當我想到星星，我幾乎可以感受到一股實質的拉力。我想只是看星星，我想要認識它們，每一顆星星，多如海沙的星星。銀河裡的數億顆恆星照亮了不可勝數的天空，而我想要沐浴在它們的光亮裡。對我來說，星星代表的不只是虛無飄渺的可能性，而是可能實現的機率。在地球上的機率對我可能不利，但你的所在之處可以改變一切。自古至今，每顆星星都代表了另一個機會，能讓我置身於另一個人類從未造訪過的地方。</p>
</blockquote>
<p>讀過幾本研究人員的回憶錄之後，我覺得莎拉．西格這本書的特色在於真實。雖然書腰文案強調了她獲得麥克阿瑟「天才獎」的不凡成就，好像在她經歷了一系列凌亂無章的現實生活和機會渺茫的大膽追求之後，終於得到應有的認可。不過實際上莎拉在接獲得獎消息時，第一個反應是她終於獲得一筆救命財，可以支應單親職業婦女的許多開銷，甚至有時間慢慢喜歡上自己不擅長的家庭瑣事上。</p>
<p>另外，也許是好萊塢影視、又或不明來歷的勵志著作、還是義務教育輔導課營造的印象，凡提起研究人員，總帶有獻身的意味在，好似這些人在某種神啟之後，便下定決心穿著白袍透過望遠鏡或顯微鏡窺探宏觀到至微的宇宙。然而，實際上人們從事什麼職業，又在哪個領域卓越是諸多因素綜合的結果。</p>
<p>相較於其他人，莎拉既有才能也早早立定志向，但她求學也曾經驗了只能透過程式碼觀測星空，與憧憬的生活有巨幅落差的時候；任教過程中遭遇的家庭與事業打擊更是讓她幾度萌生退意。科學家不是像媒體或大眾想像得那樣總是理性自若，同樣會經歷情緒崩潰與歇斯底里。</p>
<p>這本書沒有像其他傳記那樣仔細描述科學發現的過程，而是忠實地呈現了科學家作為人的一面，畢竟，愛恨情仇以及無數說不出的煩惱，無一例外地困擾著追尋星辰的科學家以及其他行業的人們。</p>
]]></content>
      <categories>
        <category>astrobiology</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜Vimium，學習 Vim 的新途徑</title>
    <url>/start-learning-vim-from-vimium/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的一款擴充套件，它借鑒了 Vim 的鍵位設計與操作邏輯，讓用戶只需要鍵盤便能執行分頁管理、連結點擊與頁面瀏覽等操作。</p>
<p>由於瀏覽器終究不等同編輯器，所以 Vimium 並沒有移植 Vim 所有的功能與指令。然而，即使只納入 Vim 的部分性質，Vimium 仍顯著改善了 Chrome 的鍵盤瀏覽體驗。以點擊連結為例，Chrome 的預設作法是<a href="https://5uperb0y.com/navigate-websites-with-keyboard/">慢慢用 <code>Tab</code> 切到連結位置</a>；Vimium 則會自動標記視窗內的連結，用戶只要鍵入標記字符即可開啟連結。因為最多輸入三個字即可開啟連結，所以有時甚至比滑鼠點擊還迅速。</p>
<p>對於習慣鍵鼠操作卻有心學習 Vim 的用戶而言，一時要以 Vim 取代既有的工作流程，可能是繁瑣且費時的過程。若先從 Vimium 著手，在體驗鍵盤瀏覽網頁的流暢感之餘，也能讓 Vim 操作的抽象性質融入日常生活（例如：查資料與逛論壇）。待初探了 Vim 的設計緣由，再逐步精進其他操作模式，也不失為一種學習 Vim 的可行策略。</p>
<span id="more"></span>

<h1 id="能從-Vimium"><a href="#能從-Vimium" class="headerlink" title="能從 Vimium"></a>能從 Vimium</h1><p>借鑒了 Vim 鍵位設計與操作邏輯，無論是管理分頁、點擊連結或瀏覽頁面都能夠只憑鍵盤操作。</p>
<ul>
<li><strong>習慣在 normal 模式瀏覽文件的方式</strong>：</li>
<li><strong>理解以 home row 為核心的鍵位安排</strong>：Vim 的鍵位設計以 home row（<code>f</code> 和 <code>j</code> 那列）為核心，不用為了點選特殊控制鍵而過度伸展手指（例如：<code>Shift</code> + <code>Alt</code> + <code>F</code>），所有操作都不超過字母鍵盤，減少了手部位移的距離。</li>
<li><strong>學習 vim 實用功能的邏輯與效果</strong>：Vimium 移植了</li>
<li><strong>了解自訂快捷鍵的意義</strong>：相較於滑鼠，快捷鍵操作有更多空間能夠因應個人的需求調整。</li>
<li></li>
<li>能夠更為習慣 normal mode 的瀏覽方式j，</li>
<li>體會以 home row 為中心的指令鍵位安排</li>
<li>習慣使用垂直移動游標，例如 <code>j</code> &amp; <code>k</code></li>
<li>了解 Vim easymotion 跳轉的邏輯與效果</li>
<li>學會使用 <code>/</code> 搜尋文字</li>
<li>體驗指令組合的效果</li>
<li>依據需求自訂快捷鍵</li>
<li>使用書籤功能</li>
</ul>
<h1 id="學會-Vimium-只要三分鐘"><a href="#學會-Vimium-只要三分鐘" class="headerlink" title="學會 Vimium 只要三分鐘"></a>學會 Vimium 只要三分鐘</h1><blockquote>
<p>Press <code>f</code> to master Vimium (and navigate internet without a mouse.)</p>
</blockquote>
<p>Vimium 最大的特色是能透過「標記與跳轉」的模式開啟連結。一旦按下 <code>f</code>，Vimium 便會為視窗內所有可互動的項目（例如連結、欄位與按鈕）標註辨識碼，接著只要輸入辨識碼即可開啟連結。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="鍵入 `f` 後, Vimium 會為視窗內的可互動物件標記辨識碼，鍵入辨識碼即可開啟連結（使用 Vimium 操作 Google search)"></p>
<ul>
<li><code>L</code>：開啟「Vimium」</li>
<li><code>SK</code>：開啟「工具」，透過 Vimium 的連結辨識碼，免除網頁設定欄位快捷鍵的負擔</li>
<li><code>SA</code>：切換至「搜尋列」，可以編輯搜尋內容</li>
</ul>
<p>雖然 Vimium 有一套基於 home row 指令，Chrome 與 Windows 內建快捷鍵已能直觀地管理分頁（例如 <code>Ctrl</code> + <code>T</code>）與滑動視窗（例如方向鍵與空白鍵），要配合瀏覽網頁的需求是綽綽有餘。例如Vimium 配合特殊控制鍵，即可在不同分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟</td>
<td><code>f</code>, then ID</td>
</tr>
<tr>
<td>於新分頁開啟</td>
<td><code>f</code>, then <code>Shift</code> + ID</td>
</tr>
<tr>
<td>於新分頁開啟並切換至新分頁</td>
<td><code>f</code>, then <code>Ctrl</code> + ID</td>
</tr>
</tbody></table>
<h1 id="以-Vim-style-瀏覽網頁"><a href="#以-Vim-style-瀏覽網頁" class="headerlink" title="以 Vim style 瀏覽網頁"></a>以 Vim style 瀏覽網頁</h1><p>鍵鼠操作以 <code>Ctrl</code>、<code>Home</code>、<code>PageUp</code> 等控制鍵，</p>
<h2 id="移動游標的方式"><a href="#移動游標的方式" class="headerlink" title="移動游標的方式"></a>移動游標的方式</h2><table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 快捷鍵</th>
<th>Vim 快捷鍵</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至頂部</td>
<td><code>gg</code></td>
<td><code>gg</code></td>
<td><code>Home</code></td>
</tr>
<tr>
<td>向上移動半個視窗</td>
<td><code>u</code></td>
<td><code>Ctrl</code> + <code>u</code></td>
<td>-</td>
</tr>
<tr>
<td>向上移動一列</td>
<td><code>k</code></td>
<td><code>k</code></td>
<td><code>↑</code></td>
</tr>
<tr>
<td>向下移動一列</td>
<td><code>j</code></td>
<td><code>j</code></td>
<td><code>↓</code></td>
</tr>
<tr>
<td>向下移動半個視窗</td>
<td><code>d</code></td>
<td><code>Ctrl</code> + <code>d</code></td>
<td>-</td>
</tr>
<tr>
<td>移至底部</td>
<td><code>G</code></td>
<td><code>G</code></td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h2><p>分頁管理是網頁瀏覽的特殊需求，所以 Vimium 就沒有照搬 Vim 的快捷鍵，而是將那些負責編輯或是功能與其他移動指令相近的按紐分配給分頁管理。<br><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_tab-operation.png?raw=true" alt="Vimium 分頁管理與頁面瀏覽的快捷鍵"><br>比對 Vimium 指令與 Chrome 快捷鍵會發現，後者需要用 <code>Ctrl</code> 和 <code>Alt</code> 等特殊控制鍵去定義。此外，觀察鍵盤位置分布可得知，Chrome 快捷鍵位置集中在兩側，似乎也是為了因應特殊控制鍵的分布以及持滑鼠的手的擺放位置。然而，瀏覽網頁時其實沒有文字輸入的需求，所以文字區塊的鍵盤等於閒置了。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 指令</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>開新分頁</td>
<td><code>t</code></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>關閉分頁</td>
<td><code>x</code></td>
<td><code>Ctrl</code> + <code>W</code></td>
</tr>
<tr>
<td>上一頁</td>
<td><code>H</code></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>L</code></td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>直達分頁</td>
<td><code>#g0</code></td>
<td><code>Ctrl</code> + <code>#</code></td>
</tr>
<tr>
<td>上一分頁</td>
<td><code>J</code></td>
<td><code>Alt</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>下一分頁</td>
<td><code>K</code></td>
<td><code>Alt</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<h2 id="數值參數"><a href="#數值參數" class="headerlink" title="數值參數"></a>數值參數</h2><p>就目前使用下來的想法，為什麼稱呼 Vimium 的行為為「指令」，而chrome的操作為「快捷鍵」，這是因為 Vimium 移植了 Vim 的機制，視每次操作為單元指令，指令可彼此疊加與重複創造出更複雜的行為。Vim 指令的行為分為 motion, replication factor, and operator。前述提及的所有指令都可算是 motion，亦即移動游標數個單位，例如一個視窗、一列、整個頁面等。這些指令都可以再前面冠上 replication factor 來增加執行次數 <replication factor> <motion>。</p>
<p>而 operator 則是對文字的編輯，這包含了 c (change)、y (yank拖)、d(delete)等，<br>Vimium 保留了 Vim 重複計數 (repeat count or replication factor) 的機制，用戶只要在命令前加上數字，便能指定命令的重複執行次數。</p>
<ul>
<li><code>4t</code>：開啟四個分頁</li>
<li><code>3x</code>：關閉前三個分頁</li>
<li><code>2d</code>：下移一個視窗(半個視窗 * 2)</li>
<li><code>3g0</code>：直達第三個分頁</li>
</ul>
<h2 id="頁面書籤"><a href="#頁面書籤" class="headerlink" title="頁面書籤"></a>頁面書籤</h2><ol>
<li><code>mc</code>，建立分頁內標記，<code>c</code> 可替換為其他小寫字母</li>
<li><code>mC</code>，建立跨分頁標記，<code>C</code> 可替換為其他大寫字母</li>
<li>&#96;&#96;c&#96;，跳轉至標記的位置</li>
</ol>
<h2 id="mode-切換"><a href="#mode-切換" class="headerlink" title="mode 切換"></a>mode 切換</h2><p>其實 Vimium 也有 insert 與 visual 模式，但相當罕用，原因如下：</p>
<ol>
<li>網頁瀏覽唯一的編輯機會是調整網址</li>
<li>若有大量編輯需求，也是在 google doc 或 Rstudio 這種瀏覽器編輯器編輯，裏頭應該有對應的 vim 套件才對</li>
<li>調整網址或更新關鍵字幾乎沒有重複操作或複雜編輯的需求</li>
</ol>
<p>Vimium 的 insert 模式與其說是用於編輯文字，不如說是為了暫時脫離 Vimium 指令模式。Normal 模式的指令與快捷鍵在 Insert 模式無效，在 youtube, gmail 等內建快捷鍵相當完善的網頁時，使用 insert mode 就能用網頁預設的快捷鍵，避免衝突。</p>
<h1 id="設計自己專屬的快捷鍵組合"><a href="#設計自己專屬的快捷鍵組合" class="headerlink" title="設計自己專屬的快捷鍵組合"></a>設計自己專屬的快捷鍵組合</h1><p>鼓勵用戶，Vimium 支援了自訂以下項目的功能，</p>
<p>首先鍵入 <code>?</code> 開啟 “Vimium Help”，再點選 “Options” 進入設定面板，即能看到以下設定</p>
<h2 id="“Excluded-URLs-and-keys”"><a href="#“Excluded-URLs-and-keys”" class="headerlink" title="“Excluded URLs and keys”"></a>“Excluded URLs and keys”</h2><p>這設定能限定特定網域適用的 Vimium 快捷鍵，以避免其覆蓋網頁或瀏覽器預設的快捷鍵。舉例來說，Vimium 的 <code>/</code>（搜尋頁內文字）會覆蓋 Google search 的 <code>/</code>（重返搜尋列）。</p>
<p>如果我已經很習慣使用 <code>Ctrl</code> + <code>F</code> 來查找頁內文字或是使用 <code>/</code> 來編輯搜索關鍵字，可以透過編輯 “Patterns” 和 “Keys”，讓 Vimium 的 <code>/</code> 設定不套用在 Google search 上。</p>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_excluded-urls.png?raw=true" alt="編輯 &quot;Excluded URLs and keys&quot; 來設定 Vimium 快捷鍵的適用範圍（Keys 預設是禁用全數快捷鍵，而 Patterns 可用正則表達式編寫規則）"></p>
<h2 id="“Custom-key-mapping”"><a href="#“Custom-key-mapping”" class="headerlink" title="“Custom key mapping”"></a>“Custom key mapping”</h2><p>這設定能調整預設的快捷鍵以符合用戶的使用習慣。好比說，如果不習慣 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 的操作，可以透過以下方式改成動作遊戲常用的 <code>a</code> <code>s</code> <code>w</code> <code>d</code> (<code>map &lt;key&gt; &lt;command&gt;</code>)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改以 wasd 配置移動視窗</span></span><br><span class="line">map a scrollLeft </span><br><span class="line">map s scrollDown</span><br><span class="line">map w scrollUp</span><br><span class="line">map d scrollRight</span><br></pre></td></tr></table></figure>
<p>進階一點也能為常用網址設置快捷鍵 (<code>map &lt;key&gt; createTab &lt;url&gt;</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鍵入 @tl 以開啟 Google 翻譯</span></span><br><span class="line">map @tl createTab https://translate.google.com.tw/?hl=zh-TW</span><br></pre></td></tr></table></figure>

<h2 id="“Previous-patterns-and-Next-patterns”"><a href="#“Previous-patterns-and-Next-patterns”" class="headerlink" title="“Previous patterns and Next patterns”"></a>“Previous patterns and Next patterns”</h2><p>輸入 <code>[[</code>（上一頁）或 <code>]]</code>（下一頁）之後，Vimium 會搜尋並開啟頁面內含「上一頁」或「下一頁」的連結。這功能完全解決了 Google search 無法迅速跳轉到下一頁搜索結果的問題。然而 Vimium 預設是辨識英文和箭頭符號，所以要應用於中文網站時得自行添加搜索標的。</p>
<ol>
<li>點選 “Show Advanced Options”</li>
<li>編輯 “Previous patterns” 與 “Next patterns” </li>
<li>依照自己常用的網頁添加搜索標的（例如：Google search，上一頁&#x2F;下一頁；ptt.cc，&lt;&#x2F;&gt;；巴哈姆特，◄&#x2F;►）</li>
</ol>
<p><img src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_page-navigation.png?raw=true" alt="可以檢查常用網站的上一頁/下一頁來調整快捷鍵偵測的字串"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>《原子習慣》，這些訣竅也適用於學習新事物。</p>
<ol>
<li>善用 <code>f</code> 點擊連結</li>
<li>維持原本的瀏覽網頁</li>
<li>透過 <code>?</code> 查詢指令</li>
<li>學習使用 vim-like 指令瀏覽與管理分頁</li>
<li>配合習慣，自訂適合自己的快捷鍵組合</li>
</ol>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>微國家：獨立建國的簡易操作手冊</title>
    <url>/strauss-2008-how-to-start-your-own-country/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這套書由方法篇和實踐篇組成，作者在方法篇中分析五種可行的建國方式，繼而討論該用何種體制經營之，再列舉許多歷史案例，評論其成敗關鍵，最後探討個人建國的前景。實踐篇則是台灣出版社彙編的建國案例以及兩篇專訪，補充已不再更新的原著。</p>
<span id="more"></span>

<p>微國家並非梵諦岡或安道爾之類主權獨立但領土狹小的國家，也不同於我們這樣陷入爭議但確實存在的政治實體，微國家維基中將之解釋成任何欲取代、模仿或與既有國家共存的政治體，但僅單方面宣稱獨立，不受國際組織或其他國家承認。</p>
<p>雖然因現實條件限制，其規模通常不大且得立足於既有國家的主權範圍內，卻仍表現出構成國家的部分要素，例如公民、政府等，甚至有些微國家會發行自己的貨幣與郵票。顯然前述定義還是難以涵蓋多樣的微國家形式，不過原書其實沒有強調這名詞，其主題是無權無勢的市井小民該如何創建自己的國家，「微國家」只是暫時狀態而非追求的目標。</p>
<p>儘管作者著重於介紹手段，沒有談論建國動機，但是從訪談和議論中可以推測：建立國家的用意不全然是對抗政府，很大一部分是在反思既有的權力結構。當今多數國家仍依循民族主義的想法以共同的語言、風俗和歷史等要素凝聚國民，可是即便在同樣民族之下，國民間仍有許多歧異，各自代表不同的利益和價值觀，然而政府依舊積極地營造認同感，讓人民甘於滿足偽裝成國族的特定受益者（不一定是人民自身），不自覺地背負無關的責任與義務。</p>
<p>於是建立微國家就成為伸張個人主權的行動，表達對個人特質的擁護、對政府體制的懷疑和對隱私財產的堅持。即便無法動搖現狀，在自己的臥室經營模型國家也能起到轉變視角的作用，能從「外國」的視角審視政府以大眾為號召施政的用意和合理性，衡量自己（外國）會受到什麼衝擊，並採取適當行動。</p>
<p>目前建立國家的最大阻力來自既有國家壓迫，弱勢方不僅沒有容身的根據地，也無可靠的武力對抗傳統軍事動員，所以作者建議從依附強權的小國發跡，一方面只須和單一國家交涉減少複雜狀況，另一方面也能藉強國排除其他國家介入，或者與小國競爭強國支持。</p>
<p>不過作者推論這種情況會在幾世紀後隨著大規模殺傷性武器成本下降以及星際殖民普及有所改變，外太空將成為待開拓的新天地，大規模毀滅武器也會削弱倚恃傳統武力的國家之優勢。無法承受破壞的政府將因此妥協，於是愈來愈多野心家投入，掀起建立新國家的浪潮，最終導致民族國家式微。</p>
<p>這推論的前提是大國懾於威脅而向建國者妥協，因此建國者不僅要避免武器被破壞，也得讓大國相信他們擁有相應的報復能力和決心。這當中牽涉到不可捉摸的心理因素，若雙方情報量不對等或是具有同樣決心時，嚇阻的效力就會降低，此時相較於建國者，大國多了輿論操作、傳統兵力、諜報組織等行動自由，故就這點而言對建國者是很不利的。</p>
<p>此外，建國者不只要面對大國，還得與己方派系或其他建國者鬥爭，由於雙方皆不能承受核攻擊，唯一勝算是先發制人，當競爭者數量達到一定程度時，極可能出現莽撞動手的一方，所以即便已與大國達成協議，建國者間還未必能維持平衡。況且武力不是決定國家存續的僅有條件，微型國家的資源、人力和產業規模仍不及傳統國家，能否捱過經濟壓力仍是未知數。</p>
<p>當然，除了用武力當基礎的傳統國家，作者也提出了幾個克服領地或主權問題的建國方案，例如先宣稱獨立再和政府打官司的訴訟途徑，仿效吉普賽人擺脫政府管制的離群索居生活，抑或掛著獅子山及賴比瑞亞的船旗馳騁大海，雖不完整但仍擁有構成國家的部分要件。<br>　<br>最後，不管是採用常規還是非典型方式建立國家都不意味著能隱於世俗擺脫其他國家騷擾，建國是向世人表示自我的存在，因此從草創時期到後續經營都會面臨許多既有利益者挑戰。若不想受人擺布，就得主動排除外在干涉，處理內部爭端，在混亂的世局中掙扎求生。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>在 Window 上使用 VSCode 建立 Tabletop simulator 的 Lua 腳本開發環境</title>
    <url>/tabletop-simulator-lua-vscode-development-environment-building/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tabletop-simulator-VSCode-開發環境設定"><a href="#tabletop-simulator-VSCode-開發環境設定" class="headerlink" title="tabletop simulator VSCode 開發環境設定"></a>tabletop simulator VSCode 開發環境設定</h1><p>Tabletop Simulator 是一款多人桌遊模擬器，提供強大的 Lua 腳本支援，讓玩家可以開發自訂遊戲。</p>
<p>然而，遊戲內建的腳本編輯器比記事本還難用，所以如果想要編輯複雜的腳本，仍有必要使用外部編輯器。鑒於網路上的資源稀少，我想在本文分享一下建立開發環境的經驗和總結。</p>
<span id="more"></span>

<h1 id="必要軟體安裝與設定"><a href="#必要軟體安裝與設定" class="headerlink" title="必要軟體安裝與設定"></a>必要軟體安裝與設定</h1><p>首先，我們要完成必要軟體的安裝與設定。</p>
<ol>
<li>安裝 Steam 並購買 <a href="https://store.steampowered.com/app/286160/Tabletop_Simulator/">Tabletop simulator</a>。</li>
<li>安裝 <a href="https://code.visualstudio.com/">VSCode</a>。雖然官方推薦的 Lua 開發環境是 Atom，但 VSCode 的功能更加強大，近幾年也比較廣泛被使用（參考 <a href="https://github.blog/2022-06-08-sunsetting-atom/">Github 停止支援 ATOM IDE 的新聞</a>）。</li>
<li>在 VSCode 當中安裝 <a href="https://marketplace.visualstudio.com/items?itemName=rolandostar.tabletopsimulator-lua">Tabletop Simulator Lua</a> 套件。這款套件能從遊戲儲存檔擷取 Tabletop Simulator 的 Lua 腳本，讓我們直接能在 VSCode 中開發，並享有自動補全、檔案瀏覽以及其他擴充套件的功能。</li>
</ol>
<h1 id="連結遊戲與編輯器"><a href="#連結遊戲與編輯器" class="headerlink" title="連結遊戲與編輯器"></a>連結遊戲與編輯器</h1><p>接著要設定遊戲與編輯器的連結</p>
<ol>
<li>在 Steam 中啟動 Tabletop Simulator，並開啟任意一款遊戲（步驟為：<code>Create</code>、<code>Singleplayer</code>、<code>Classic/DLC/Workshop</code>、挑選遊戲）。</li>
<li>打開 VSCode 時，Tabletop Simulator Lua 套件會自動辨識遊戲所在的資料夾（在 Windows 預設為 <code>%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</code>），將遊戲腳本 (<code>*.lua</code>)和設置檔 (<code>.xml</code>) 從遊戲儲存檔 (<code>*.json</code>) 獨立出來，並且放置到暫存資料夾中（預設為 <code>%UserProfile%\AppData\Local\Temp\TabletopSimulator\Tabletop Simulator Lua</code>。</li>
<li>如果套件沒有自動更新或是想要更換其他遊戲時，可以鍵入 <code>Ctrl</code>+<code>Alt</code>+<code>L</code> 更新連結。</li>
</ol>
<h1 id="編輯遊戲腳本"><a href="#編輯遊戲腳本" class="headerlink" title="編輯遊戲腳本"></a>編輯遊戲腳本</h1><p>現在，我們已經可以在 VSCode 當中編輯遊戲腳本了。Lua 腳本是遊戲儲存檔的一部份，而遊戲儲存檔則是一個 <code>JSON</code> 檔，記錄了啟動遊戲所需的所有元素。Tabletop Simulator Lua 的功能即是從儲存檔中擷取 Lua 腳本，並且轉換為適合閱讀與編輯的格式。</p>
<p>編輯完成後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 儲存並重啟腳本。此時，Tabletop Simulator 會將腳本變動更新到遊戲儲存檔，讓遊戲呈現腳本所做的變動。</p>
<p>如果希望在編輯腳本的同時能觀察遊戲畫面，有兩種方式可以達成：</p>
<p>首先，將 Tabletop Simulator 設定為視窗模式（<code>Menu</code>、<code>Configuration</code>、<code>Graphics</code>、取消勾選 <code>Fullscreen</code>）。</p>
<ul>
<li>使用 Windows 視窗分割功能 （<code>Win</code> + <code>←</code>&#x2F;<code>→</code>&#x2F;<code>↑</code>），同時陳列編輯器與遊戲視窗。</li>
<li>下載 Windows PowerToys，這是一個功能強大的 Windows 工具集，其中包含了能將遊戲視窗固定在螢幕上的功能。(<a href="https://learn.microsoft.com/en-us/windows/powertoys/always-on-top">always on top feature</a>)</li>
</ul>
<h1 id="建立專案資料夾"><a href="#建立專案資料夾" class="headerlink" title="建立專案資料夾"></a>建立專案資料夾</h1><p>由於無法指定 Tabletop Simulator 遊戲儲存檔的存放位置，所以想要進行版本控管或專案管理時需要一些權變措施。</p>
<ol>
<li>首先，建立一個新的專案資料夾，例如命名為 <code>project/</code>。專案資料夾的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br></pre></td></tr></table></figure></li>
<li>再次開啟 Tabletop Simulator，選擇任意遊戲並儲存。遊戲會自動建立包含遊戲所有設定與資訊的 JSON 儲存檔 (<code>TS_Save_*.json</code>)，並附上一張遊戲截圖 (<code>TS_Save_*.jpg</code>)。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>由於 Tabletop Simulator 並未提供選擇遊戲儲存檔位置的選項，我們可以先將儲存檔和截圖檔案移至專案資料夾，以便之後進行版本控管。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>接下來，在 Tabletop Simulator 的資料夾內建立一個指向專案資料夾的軟連結，以確保儲存檔可以在遊戲的載入遊戲清單中被找到。由於軟連結會連結到原始檔案，因此我們可以透過軟連結對原始檔案進行修改，並將變動同步到遊戲中。（Windows 系統在 cmd 當中使用 <a href="https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/mklink">mklink 建立軟連結</a>） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- project/ -&gt; /path/to/project/</span><br></pre></td></tr></table></figure></li>
<li>再次開啟 VSCode 並啟動 Tabletop Simulator Lua 套件。此時 VSCode 的探索欄應該會出現 Tabletop Simulator Lua 資料夾以及由套件從遊戲儲存檔中提取出來的 Lua 腳本。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br></pre></td></tr></table></figure></li>
<li>將專案資料夾加入 VSCode 的工作空間：選擇 <code>File</code> → <code>Add Folder to Workspace</code>，然後選擇專案資料夾。此時，探索欄的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>在專案資料夾中建立需要的檔案或資料夾，例如 <code>src/</code>（用來儲存遊戲腳本）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br><span class="line">|- src\</span><br><span class="line">    |- script1.lua</span><br><span class="line">    |- script2.lua</span><br></pre></td></tr></table></figure></li>
<li>接著開啟 <code>Global.-*.lua</code>，加入以下命令以指定要導入的腳本。由於套件會自動在工作空間的資料夾尋找副檔名為 <code>.ttslua</code>和<code>.lua</code> 的檔案，所以呼叫時就不需要加入副檔名了。 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script1&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script2&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>現在，已經成功設定 Tabletop Simulator 的 Lua 開發環境，也將遊戲依照專案資料夾的規劃納入版本控管，可以按照自己的習慣開發遊戲腳本了。</p>
<p>只是要記得在修改腳本或遊戲設定後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 以同步變動到遊戲儲存檔中，也不要忘記在新增腳本時更新導入的指令。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://tts-vscode.rolandostar.com/">TTS VSCode Docs</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/27">Require and Path</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/21">Best way to commit the main json file?</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/20">Get&#x2F;Send LUA scripts to&#x2F;from workspace folder</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>The Door into Astrobiology | 天文生物學入門資源</title>
    <url>/the-door-into-astrobiology/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>天文生物學（Astrobiology）是研究生命在宇宙中形成、演化和分布的跨領域學科。由於至今只在地球上發現生物，所以眼下課題就是釐清形成地球生命的機制與先決條件，欲達成這目標不僅得追溯組成生物的原料來源，還需了解有哪些因素影響適居環境的構成，並從演化和地質證據推敲無機物轉變為生物的過程。</p>
<p>利用前述知識，研究者得以探討太陽系其他天體存在生命的可能，當今最具希望者無疑是我們的鄰居火星，不過類木行星的衛星，例如歐羅巴、泰坦，也有孕育生命的潛力。倘若能在這些迥異的環境中發現生命，它將成為地球生命的對照組，有助於釐清「生命是什麼？」這類問題，也會擴張對生命起源條件的想像。目前歐洲和美國太空總署皆有探索生命跡象的太空任務，至於迄今人類科技水準仍無法到達的遙遠恆星系統，則有賴天文觀測及光譜分析技術去尋找生命存在的間接證據。</p>
<p>總而言之，天文生物學不只是天文學加上生物學，它集結了宇宙學、演化學、地球科學、資訊科學、生物化學、比較行星學、分子生物學……等等無數學科，研究對象從五微米大的細胞到十萬光年長的星河，從宇宙爆發到生命誕生。因此，無論喜歡哪種尺度、身懷哪種學術專業，只要想探索生命起源的終極問題，總能在其中找到安身立命的地方。</p>
<p>本文整理了有關天文生物學（Astrobiology）的書籍、線上課、演講等學習資源，並依其內容劃分為通論、生命起源、搜索地外生命、科學史四類，歡迎大家留言補充。</p>
<span id="more"></span>
<h1 id="科普書籍"><a href="#科普書籍" class="headerlink" title="科普書籍"></a>科普書籍</h1><h2 id="通論"><a href="#通論" class="headerlink" title="通論"></a>通論</h2><ul>
<li>田村元秀 (2023) [《天文生物學超入門》] (<a href="https://www.books.com.tw/products/0010968407?sloc=main">https://www.books.com.tw/products/0010968407?sloc=main</a>) [台灣東販]</li>
<li>Jeffrey Bennett &amp; Seth Shostak (2016)：<a href="https://www.books.com.tw/products/CN11331116">《宇宙中的生命》</a> [機械工業]（簡）</li>
<li>Gerda Horneck &amp; 莊逢源 (2010)：<a href="https://www.books.com.tw/products/CN10159991">《宇宙生物學》</a> [中國宇航]（簡）</li>
<li>Peter D. Ward &amp; Donald Brownlee (2017)：<a href="https://www.books.com.tw/products/0010741618">《寂寞的地球：宇宙唯一有複雜生命的行星》</a> [貓頭鷹]</li>
<li>Michael William Ovenden (1964)：<a href="https://www.amazon.com/Universe-Science-Study-Michael-Ovenden/dp/0435550292">《宇宙中的生命》</a> [徐氏]</li>
</ul>
<h2 id="生命起源"><a href="#生命起源" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Sir Paul Nurse (2021)：<a href="https://www.books.com.tw/products/0010909520?sloc=main">《生命之鑰》</a> [三采]</li>
<li>Addy Pross (2018)：<a href="https://www.books.com.tw/products/CN11604089">《生命是什麼：40億年生命史詩的開端》</a> [中信]（簡）</li>
<li>王立銘 (2018)：<a href="https://www.books.com.tw/products/CN11599405">《生命是什麼》</a> [人民郵電]（簡）</li>
<li>Freeman Dyson (2017)：<a href="https://www.sanmin.com.tw/product/index/006310600">《生命的起源》</a> [浙江大學]（簡）</li>
<li>Nick Lane (2016)：<a href="https://www.books.com.tw/products/0010730616">《生命之源：能量、演化與複雜生命的起源》</a> [貓頭鷹]</li>
<li>Erwin Schrodinger (2016)：<a href="https://www.books.com.tw/products/0010708022">《薛丁格生命物理學講義：生命是什麼？》</a>[貓頭鷹]</li>
<li>Christian de Duve (2011)：<a href="https://www.books.com.tw/products/0010516325">《生物決定論：人類一定會出現在地球上嗎？》</a> [左岸文化]</li>
<li>李杰信 (2008)：<a href="https://www.sanmin.com.tw/Product/Index/000791958">《生命的起始點：談生命起源》</a> [科學普及]（簡）</li>
<li>A.G.Cairns-Smith (1995)：<a href="https://www.books.com.tw/products/CN10041905">《生命起源的七條線索》</a> [中國對外翻譯]（簡）</li>
<li>Francis Crick (1993)：<a href="https://book.douban.com/subject/2420069/">《生命：起源和本質》</a> [科學普及]（簡）</li>
</ul>
<h2 id="尋找地外生命"><a href="#尋找地外生命" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Dara Oacute; Briain (2023)： <a href="https://www.books.com.tw/products/CN11895285">《真的有外星人嗎》</a> [中國紡織]（簡）</li>
<li>Ben Miller (2022)： <a href="https://www.sanmin.com.tw/product/index/010759160">《外星人來了？》</a> [中國友誼]（簡）</li>
<li>瀧澤美奈子 (2021)：<a href="https://www.sanmin.com.tw/product/index/010419542">《當天文學遇上生物學》</a> [機械工業]（簡）</li>
<li>Lewis Dartnell (2021)：<a href="https://www.sanmin.com.tw/product/index/010408023">《人人都該懂的地外生命》</a> [浙江教育]（簡）</li>
<li>李傑信 (2021)：<a href="http://《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》">《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》</a>[三民書局]</li>
<li>Jon Willis (2018)：<a href="https://www.books.com.tw/products/CN11579783">《群星都是你們的世界》</a> [中信]（簡）</li>
<li>Димитър Д. Съселов (2017)：<a href="https://www.books.com.tw/products/CN11465684">《超級地球上的生命》</a> [上海科學技術]（簡）</li>
<li>Louisa Preston (2017)：<a href="https://www.books.com.tw/products/CN11440032">《地外生命探索之旅》</a> [中國計量]（簡）</li>
<li>李炎 (2016)：<a href="https://www.sanmin.com.tw/product/index/006090615">《太空生物學》</a> [漢珍]</li>
<li>Bignami G. (2013)：<a href="https://www.books.com.tw/products/CN11062152">《我們就是火星人：尋找宇宙中的地外生命》</a> [科學]（簡）</li>
<li>李冰 (2011)：<a href="https://www.sanmin.com.tw/product/index/001680995">《尋找外星人》</a> [北京師大]（簡）</li>
<li>Donald Goldsmith &amp; Tobias Owen (1999)：<a href="https://www.amazon.co.jp/-/en/Donald-Goldsmith/dp/0201569493">《尋找宇宙生命》</a> [朗文]</li>
</ul>
<h2 id="科學史"><a href="#科學史" class="headerlink" title="科學史"></a>科學史</h2><ul>
<li>Sara Seager (2021)：<a href="https://www.books.com.tw/products/0010882271">《尋找太陽系外的行星：天文學家莎拉．西格的愛與探索》</a>[天下文化]</li>
<li>Ron Miller (2018)：<a href="https://www.books.com.tw/products/CN11600118">《外星生命簡史：人類400年地外生命探索與想象全記錄》</a> [北京聯合]（簡）</li>
<li>Bill Mesler &amp; H. James Cleaves II (2017)：<a href="https://www.books.com.tw/products/CN11438003">《生命的誕生——我們究竟來自哪裡》</a> [人民郵電]（簡體）</li>
<li>Lee Billings (2017)：<a href="https://www.books.com.tw/products/0010741343">《五十億年的孤寂：繁星間尋找生命》</a> [八旗文化]</li>
<li>汪洁 (2017)：<a href="https://www.sanmin.com.tw/Product/index/006841620">《億萬年的孤獨：地外文明探尋史話》</a> [北京時代華文書局]（簡）</li>
</ul>
<h1 id="線上課程"><a href="#線上課程" class="headerlink" title="線上課程"></a>線上課程</h1><h2 id="通論-1"><a href="#通論-1" class="headerlink" title="通論"></a>通論</h2><ul>
<li><a href="https://www.acoea.com/?utm_campaign=6647bde1-a2ee-4363-adb3-ecaa2466dff5&utm_source=so&utm_medium=mail&cid=ab330e43-978b-4e52-8b2a-7347df1555d3">“Introduction to Astrobiology”</a> [Amity University]（Centre of Excellence in Astrobiology）</li>
<li><a href="https://astrobiovideo.com/en/">“Online Courses in Astrobiology”</a> [ International Astronomical Unio]</li>
</ul>
<h2 id="生命起源-1"><a href="#生命起源-1" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Bruce W. Fouke，<a href="https://www.coursera.org/learn/emergence-of-life">“Emergence of Life”</a> [The University of Illinois]（coursera）</li>
<li>Jack Szostak，<a href="https://www.ibiology.org/speakers/jack-szostak/">“The Origin of Life on Earth”</a>（iBiology）</li>
<li>Sarah Maurer &amp; Chris Kempes，<a href="https://www.complexityexplorer.org/courses/103-origins-of-life">“Origins Of Life”</a> [Santa fe institute]（Complexity Explorer）</li>
</ul>
<h2 id="尋找地外生命-1"><a href="#尋找地外生命-1" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Charles Cockell，<a href="https://www.coursera.org/learn/astrobiology">“Astrobiology and the Search for Extraterrestrial Life”</a> [The University of Edinburgh]（coursera）</li>
<li>Charles Cockell， <a href="https://www.youtube.com/channel/UCBTwJSnAqZZczK7stBaYq5w/playlists">“Life in the Universe – the pandemic series”</a>（Youtube）</li>
<li>Chris Impey，<a href="https://www.coursera.org/learn/astrobiology-exploring-other-worlds#syllabus">“Astrobiology: Exploring Other Worlds”</a> [The University of Arizona]（coursera）</li>
<li>David Spergel，<a href="https://www.coursera.org/learn/life-on-other-planets">“Imagining Other Earths”</a> [Princeton University]（coursera）</li>
<li>Lynn Rothschild，<a href="https://cosmolearning.org/courses/astrobiology-and-space-exploration">“Astrobiology and Space Exploration”</a> [Stanford University]（CosmoLearning）</li>
<li>Димитър Д. Съселов，<a href="https://www.edx.org/course/super-earths-and-life">“Super-Earths and Life”</a> [Harvard University]（edX）</li>
</ul>
<h1 id="演講"><a href="#演講" class="headerlink" title="演講"></a>演講</h1><h2 id="通論-2"><a href="#通論-2" class="headerlink" title="通論"></a>通論</h2><p>待補</p>
<h2 id="生命起源-2"><a href="#生命起源-2" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Christoph Adami，<a href="https://www.ted.com/talks/christophe_adami_finding_life_we_can_t_imagine?language=zh-tw">〈尋找難以想像的生命〉</a>[TEDxUIUC]</li>
<li>Lee Cronin，<a href="https://www.ted.com/talks/lee_cronin_making_matter_come_alive?language=zh-tw">〈讓物質變活〉</a>[TEDGlobal]</li>
<li>Martin Hanczyc，<a href="https://www.ted.com/talks/martin_hanczyc_the_line_between_life_and_not_life?language=zh-tw">〈生命與非生命的界線〉</a>[TEDSalon London]</li>
<li>Nathalie Cabrol，<a href="https://www.ted.com/talks/nathalie_cabrol_how_mars_might_hold_the_secret_to_the_origin_of_life?language=zh-tw">〈探秘火星，解開地球生命之謎〉</a>[TED]</li>
</ul>
<h2 id="尋找地外生命-2"><a href="#尋找地外生命-2" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Aomawa Shields，<a href="https://www.ted.com/talks/aomawa_shields_how_we_ll_find_life_on_other_planets?language=zh-tw">〈我們如何尋找存在於另一顆行星上的生命〉</a>[TED]</li>
<li>Carolyn Porco，<a href="https://www.ted.com/talks/carolyn_porco_could_a_saturn_moon_harbor_life?language=zh-tw">〈土星的衛星可能有生命存在嗎？〉</a>[TED]</li>
<li>Dave Brain，<a href="https://www.ted.com/talks/dave_brain_what_a_planet_needs_to_sustain_life/transcript?language=zh-tw">〈行星維持生命存在的要素〉</a>[TEDxBoulder]</li>
<li>Freeman Dyson，<a href="https://www.ted.com/talks/freeman_dyson_says_let_s_look_for_life_in_the_outer_solar_system?language=zh-tw">〈在太陽系外圍找尋生命〉</a>[TED]</li>
<li>Garik Israelian，<a href="https://www.ted.com/talks/garik_israelian_what_s_inside_a_star">〈How spectroscopy could reveal alien life〉</a>[TEDGlobal]</li>
<li>James Green，<a href="https://www.ted.com/talks/james_green_3_moons_and_a_planet_that_could_have_alien_life?language=zh-tw">〈可能有生命存在的一個行星和三個衛星〉</a>[TED Talks Live]</li>
<li>Lucianne Walkowicz，<a href="https://www.ted.com/talks/lucianne_walkowicz_finding_planets_around_other_stars">〈Finding planets around other stars〉</a>[TEDGlobal]</li>
<li>Penelope Boston，<a href="https://www.ted.com/talks/penelope_boston?language=zh-tw">〈火星可能有生命存在〉</a>[TED]</li>
<li>Sara Seager，<a href="https://www.ted.com/talks/sara_seager_the_search_for_planets_beyond_our_solar_system/transcript?language=zh-tw">〈尋找太陽系外的行星〉</a>[TED]</li>
<li>Seth Shostak，<a href="https://www.ted.com/talks/seth_shostak_et_is_probably_out_there_get_ready?language=zh-tw">〈準備好，ET (可能) 就在那裡〉</a>[TEDxSanJoseCA]</li>
<li>Tabetha Boyajian，<a href="https://www.ted.com/talks/tabetha_boyajian_the_most_mysterious_star_in_the_universe?language=zh-tw">〈宇宙中最神秘的一顆星〉</a>[TED]</li>
<li>Димитър Д. Съселов，<a href="https://www.ted.com/talks/dimitar_sasselov_how_we_found_hundreds_of_potential_earth_like_planets/transcript?language=zh-tw">〈發現數百顆類似地球的行星〉</a>[TEDGlobal]</li>
</ul>
<h2 id="科學史-1"><a href="#科學史-1" class="headerlink" title="科學史"></a>科學史</h2><ul>
<li>Jill Tarter，<a href="https://www.ted.com/talks/jill_tarter_s_call_to_join_the_seti_search/transcript?language=zh-tw">〈加入SETI計劃〉</a>[TED]</li>
</ul>
<h1 id="知識普及網站"><a href="#知識普及網站" class="headerlink" title="知識普及網站"></a>知識普及網站</h1><ul>
<li><a href="https://www.facebook.com/Abiogenesis-262675454086715/">Abiogenesis</a></li>
<li><a href="https://www.facebook.com/Abiogenesis-Hall-of-Fame-138681233223461/">Abiogenesis Hall of Fame</a></li>
<li><a href="https://www.astrobio.net/">Astrobiology Magazine</a></li>
<li><a href="http://astrobiology.com/">Astrobiology Web</a></li>
<li><a href="https://www.facebook.com/Life-the-Origin-of-245683669160907/">Life, the Origin of</a></li>
<li><a href="https://www.facebook.com/Origin-of-Life-293514407692658/">Origin of Life</a></li>
<li><a href="https://www.zhihu.com/column/gswxzt">古生物新聞</a></li>
</ul>
<h1 id="學術機構"><a href="#學術機構" class="headerlink" title="學術機構"></a>學術機構</h1><h2 id="研究單位"><a href="#研究單位" class="headerlink" title="研究單位"></a>研究單位</h2><ul>
<li><a href="https://www.bmsis.org/">Blue Marble Space Institute of Science</a></li>
<li><a href="https://cool.gatech.edu/">Center for the Origin Of Life</a> [Georgia Institute of Technology]</li>
<li><a href="http://www.elsi.jp/en/">Earth-Life Science Institute</a> [Tokyo Institute of Technology]</li>
<li><a href="https://www.emergence-of-life.de/index.html">Emergence of Life</a></li>
<li><a href="https://www.originscenter.nl/">Origins Center</a> [University of Groningen]</li>
<li><a href="https://origins.harvard.edu/">Origins of Life Initiative</a> [Harvard University]</li>
<li><a href="https://www.simonsfoundation.org/life-sciences/origins-of-life/simons-collaboration-on-the-origins-of-life/">The Simons Collaboration on the Origins of Life</a> [Simons Foundation]</li>
</ul>
<h2 id="社群與學會"><a href="#社群與學會" class="headerlink" title="社群與學會"></a>社群與學會</h2><ul>
<li><a href="https://www.facebook.com/groups/2221810485/">Astrobiology Club</a> [Facebook club]</li>
<li><a href="https://astrobiologysociety.org/">Astrobiology Society of Britain</a></li>
<li><a href="https://saganet.ning.com/">Social Action for a Grassroots Astrobiology Network (SAGANet)</a></li>
<li><a href="http://issol.org/">International Society for the Study of the Origin of Life (ISSOL)</a></li>
<li><a href="https://www.facebook.com/groups/515811491814739/">Virtual Astrobiology Society</a> [Facebook club]</li>
</ul>
<h2 id="研討會"><a href="#研討會" class="headerlink" title="研討會"></a>研討會</h2><ul>
<li><a href="https://www.abgradcon.org/">Astrobiology Graduate Conference</a></li>
<li><a href="https://connect.agu.org/abscicon/home">Astrobiology Science Conference</a></li>
<li>Biennial European Astrobiology Conference</li>
<li><a href="https://issol.org/meetings/">International Conference on the Origin of Life</a></li>
<li><a href="https://www.grc.org/origins-of-life-conference/">Origins of Life Gordon Research Conference</a></li>
<li><a href="https://indico.physik.uni-muenchen.de/event/63/">Molecular Origins of Life</a>, Munich</li>
</ul>
<h1 id="研究中心與學術合作網路"><a href="#研究中心與學術合作網路" class="headerlink" title="研究中心與學術合作網路"></a>研究中心與學術合作網路</h1><h2 id="亞洲及大洋洲"><a href="#亞洲及大洋洲" class="headerlink" title="亞洲及大洋洲"></a>亞洲及大洋洲</h2><ul>
<li><a href="https://www.aca.unsw.edu.au/">Australian Centre for Astrobiology</a></li>
<li><a href="http://abc-nins.jp/en/">Astrobiology Center</a> (in Japan)</li>
<li><a href="https://astrobiologyindia.in/">Astrobiology India</a></li>
<li><a href="https://www.facebook.com/AstrobioPak/">Astrobiology Network of Pakistan</a></li>
<li><a href="https://www.acoea.com/">Centre of Excellence in Astrobiology</a> (in India)</li>
<li><a href="https://logos.ls.toyaku.ac.jp/~astrobiology-japan/en/">Japan Astrobiology Network</a></li>
</ul>
<h2 id="美洲"><a href="#美洲" class="headerlink" title="美洲"></a>美洲</h2><ul>
<li><a href="https://astrobiology.nasa.gov/">Astrobiology at NASA</a></li>
</ul>
<h2 id="歐洲"><a href="#歐洲" class="headerlink" title="歐洲"></a>歐洲</h2><ul>
<li><a href="http://www.eana-net.eu/">European Astrobiology Network Association (EANA)</a></li>
<li><a href="http://life-origins.com/">life-origins.com</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://oolen.org/">Origin of Life Early-career Network (OoLEN)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>科學溝通能力的重要性</title>
    <url>/the-importance-of-science-communication/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>科學溝通能力究竟有什麼重要性，為何值得投注心力練習？</p>
<p>溝通是學術的一環。科學的進展大抵可以分為「發現新知」和「傳播新知」兩個部分。發覺問題、建立假說，最後設計實驗證明的過程，仰賴研究能力；將新發現以具體而且可信的論證方式傳遞給他人，則仰賴表達能力。</p>
<p>越是非凡的發現，越需要清晰的語言才能充分闡明。因此，除了研究的本領，科學溝通的能力也值得重視。</p>
<span id="more"></span>

<p>在學界內最普及的溝通方式就是撰寫論文，論文不僅是傳達和保留研究成果的媒介，也是評斷個人成就的標準。在論文以外，還有研討會或學者間的非正式交流，讓研究者得以接觸學界前沿的狀況。</p>
<p>除了和他人溝通，研究者在探索問題的途中也得不斷和自己對話，例如撰寫計劃書安排研究進度，或是時時回顧實驗記錄，藉此鞏固概念及引導思考以順利完成研究。</p>
<p>最後，隨著科學的進展，研究成果的影響不會只限於學術圈，而會漸漸擴及社會。然而知識在傳播中可能被誤解，混淆的觀念恐怕扭曲大眾對科研的看法，導致恐慌及失當的決策。這些問題有賴研究者、媒體和社會間有效的溝通才能解決。</p>
<p>換句話說，社會支持著學術圈，學術圈則讓個人有立足空間，個人再反過來影響學界與社會。溝通參與了個人、學術乃至於社會三方面的發展，這也是為什麼值得投入心力在科學溝通能力養成的原因。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>軟體開發文件管理的簡單數學</title>
    <url>/the-simple-math-of-document-management-in-software-development/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>伊藤潤二在其短篇漫畫《藏書幻影》中，描述了一位因為恐懼藏書遺失而決定將家中數十萬本書籍默記在心的書迷。不料，他記住所有藏書的內容後，卻沒有留下絲毫空間給自己的回憶與判斷力，只能終日在書堆中，眼神空洞地翻閱書頁、喃喃自語。</p>
<p>在軟體開發領域，我們同樣面臨對於遺忘的擔憂。需求分析、風險評估與架構決策等資訊，在開發過程中逐步累積，既是團隊經驗的傳承，也是產品應稽的依據。因此，各企業透過各式各樣的文件，紀錄程式碼以外稍縱即逝的寶貴思想與知識；對於醫療檢測產品，政府單位也提供了文件撰寫指引，詳細列出文件應具備的項目，以確保產品的安全性。</p>
<p>然而，市場變化與需求異動帶來的時程壓力，也使得團隊陷入開發延宕的恐慌。長期看來，文件固然能提供產品與團隊價值，但是撰寫文件往往是吃力不討好的工作，一方面它不直接改進產品功能，另一方面撰寫文件的努力不亞於軟體開發本身。因此，在迫切需要功能實現或障礙排除時，文件往往是首先被犧牲的項目。</p>
<p>依照我的經驗，對於如何撰寫文件的倡議，往往基於對內容的保障，未必會考量到維護齊全文件的成本。於是，團隊因為文件與開發的衝突，在棘手的情境間左右為難：要不因為害怕遺漏資訊而導致開發遲滯，又或憂懼逾期交付而造成紀錄不全。</p>
<p>因此，在這篇文章中，我嘗試跳脫基於儲存資訊的文件框架，加入一些專案管理的觀點，來思考解決兩者衝突的策略，從而避免過時、錯誤或不全等貶損文件價值的不利因素。</p>
<span id="more"></span>

<p>無論目標是應對稽核還是與用戶&#x2F;開發者溝通，考量到文件與軟體相輔相成的作用，宜將文件視為產品的一部份，並且在規劃專案時程時，將更新文件的成本納入考慮。</p>
<p>根據軟體的用途和文件的性質，每個軟體迭代所需更新的文件類型和數量也會有所不同。在個人主導的開源專案中，每次軟體發布可能只涉及 README.md 和 CHANGELOG.md 的修改；但若打算申請美國 FDA 的 IVD 認證，即使是簡單的功能升級，也需要維護近十份文件（例如需求、風險、設計、測試和架構等），而且這些文件的更新必須遵循法規程序，額外增加不少行政成本。</p>
<p>如果團隊能在指定時間內順利完成軟體與文件更新，則可確保兩者內容及時；反之，則必有一方與進度脫節。為了避免文件過時，我們可以列出以下不等式：</p>
<p>$$ n \cdot t_{doc} + T_{dev} \leq T_{iter} $$</p>
<ul>
<li>$t_{doc}$：更新一份文件所需要的時間</li>
<li>$n$：軟體每次迭代需要更新的文件數量</li>
<li>$T_{dev}$：軟體該次迭代的開發總時數</li>
<li>$T_{iter}$：軟體迭代週期</li>
</ul>
<p>依據此不等式，每次軟體迭代維護文件所需的時間取決於更新的成本與頻率。假設固定迭代週期與開發時數，那麼低頻率的更新可以容忍較高的更新成本，而低成本的更新可以配合高頻率的更新。</p>
<p>撰寫文件的成本補僅與內容相關，也涉及過程中的調查、驗收與調整的成本；若是法規文件，還涉及更多的審查、簽核和文檔管理等手續。而文件更新的頻率則取決於其精細度，內容愈是詳細且貼近軟體底層的運作，愈有可能因為局部的變動而需要更新；反之，內容愈是抽象且概括描述軟體的架構，則能承受較多次的軟體變更。</p>
<p>我們可以依據這項關係來評估撰寫文件的尺度與範圍。以下是一個假想專案每次軟體迭代各層級物件的更新頻率：</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>API Change Frequency</th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td>100</td>
</tr>
<tr>
<td>Class</td>
<td>10</td>
</tr>
<tr>
<td>Structure</td>
<td>1</td>
</tr>
</tbody></table>
<p>假設這專案的迭代週期為 20 單位時間，開發費時 10 單位時間，每份文件更新需要 1 單位時間。那麼依據不等式，這軟體的文件最多能承受的更新頻率為 10 次。比照更新頻率表，若要避免文件過時，文件的內容最細只能寫到 Class 層級，而 function 層級就超出能力範圍外了。</p>
<p>$$ n &#x3D; \frac{T_{iter} - T_{dev}}{t_{doc}}$$</p>
<p>透過這方法，我們可以根據軟體與團隊的特性，調整文件內容的細緻程度，來配合軟體開發的進度。然而，若文件的抽象程度越高，也意味著犧牲了一定程度的細節。在這種情況下，若仍想保留足夠的細節供往後參考該怎麼做？</p>
<p>原則上，文件內容是否充分取決於當下的品質與隨後的更新。首先，在開發期間透過文件指引、校稿檢查表與同儕審查等方法，可以確保文件具備必要內容並且符合團隊規範；其次，即使發現撰寫當下沒發現的錯誤，之後若能及時修正，也能補充欠缺的資訊。</p>
<p>這意味著文件完整性與更新文件的成本呈負相關。成本愈低，則容許修改文件的頻率也愈高，文件修訂的機會越多，改善其品質的可能性也越大。換句話說，若我們想在有限的時間內，保障文件的內容及時且完整，就需要容許較高的修訂頻率。我們可以考慮改變文件撰寫的媒介或流程，來降低不等式當中的 $t_{doc}$。</p>
<p>不過，將彼此相關的資訊記錄在不同的媒介可能會提升文件間的耦合程度。關聯文件越多，每次修改涉及的文件數也越多，這一方面可能增加忘記更新的機率，另一方面，也會增加每次更新時要盤查的文件數量，從而增加文件更新的成本。目前我尚未對此問題得出結論，不過可以考慮使用修改成本較低的索引文件來串接關聯文件，藉此降低主要文件的更新頻率，又能透過索引文件得知要修改的其他文件。</p>
<p>綜上所述，在專案時程壓力下，團隊往往面臨軟體開發與文件撰寫的衝突。若能再考慮文件應該具備的內容之餘，考量更新文件的頻率和成本，則有機會設計出能配合開發節奏的文件，避免文件過時、錯誤與不全等風險。原則上，若能降低更新文件的成本，便能承受較多次文件更新，間接確保文件的品質與完整性；若更新文件的成本較高，可以考慮調整文件撰寫的尺度，降低更新頻率，以免文件跟不上軟體開發的進度。</p>
]]></content>
  </entry>
  <entry>
    <title>科學論文的結構與撰寫 (Zen of Scientific Writing)</title>
    <url>/the-zen-of-scientific-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這學期我選修了蔡東湖老師的「科學論文的結構與撰寫」。經過三個月洗禮，雖然研究進度一籌莫展，卻對發表 SCI 論文充滿自信。</p>
<p>我在這篇文章整理了課堂和講義提及的重要原則，但寫作能力其實要在實作中磨練。所以蔡老師建議我們以後閱讀論文，除了科學內涵以外，也要學著提煉文章的結構，收集常用的句型，畢竟：「寫 paper 沒那麼難，你看個五篇就會寫了。」</p>
<p>（科學論文的文章架構和句型模板可以參考廖柏森老師的著作。） </p>
<span id="more"></span>

<h1 id="如何撰寫及發表學術論文"><a href="#如何撰寫及發表學術論文" class="headerlink" title="如何撰寫及發表學術論文"></a>如何撰寫及發表學術論文</h1><p>發表學術論文包含三件事：英文（論文）、科學（學術）和投稿（發表）。</p>
<h2 id="不要讓語言阻撓你的科學"><a href="#不要讓語言阻撓你的科學" class="headerlink" title="不要讓語言阻撓你的科學"></a>不要讓語言阻撓你的科學</h2><ul>
<li>科學家不只要會想、會做還要會寫。重點不是你不會做實驗，你很會做實驗，但不會寫 paper。</li>
<li>語言和科學要分開，我們 focus 在科學，不要被英文困擾。我們要做科學家而不是文學家。</li>
<li>各位一定要相信，自己的英文能力寫兩三篇 SCI paper 足足有餘。</li>
<li>英文的問題，我們 consult English editor。如果要錢，就給他嘛。</li>
</ul>
<h2 id="科學不問對錯，只問合理"><a href="#科學不問對錯，只問合理" class="headerlink" title="科學不問對錯，只問合理"></a>科學不問對錯，只問合理</h2><ul>
<li>科學沒有對或錯，只有合理不合理。所以不要在實驗室追求真理，要追求證據。</li>
<li>拿到 PhD 不代表你有多厲害，那張紙證明的是你的熱情</li>
<li>書是讀越多越厲害，不是讀越久越厲害。</li>
</ul>
<h2 id="投稿是科研的一部份"><a href="#投稿是科研的一部份" class="headerlink" title="投稿是科研的一部份"></a>投稿是科研的一部份</h2><ul>
<li>做研究要有正確的心態，做完實驗朝發表 paper 的方向走。沒發表等於沒做，甚至比沒做更糟糕。想想花了多少時間，死了多少老鼠，辛苦做好久無論如何都要發表。</li>
<li>沒有賣不出去的房子，只有還沒找到的買家和賣多少錢而已。</li>
<li>發表了 research article，代表你對那個領域很熟悉，所以再補一篇 review article。</li>
<li>一邊整理學位論文，一邊準備投稿。你論文都寫出來了，為什麼不寫成 paper？很多事只欠缺堅持。</li>
<li>實驗我做，論文我寫，那沒做的人審什麼？合理性和你的邏輯。</li>
<li>Return 沒有看科學性，要 reject 才有檢視科學。而 revision 是投稿的重頭戲，我們的目標就是朝被接受的方向走，所以感謝 reviewer，在回覆裡面狗腿一下又怎樣。</li>
<li>Paper 被接受不是最高興的，自己的被接受，別人被 reject 更高興。</li>
</ul>
<h1 id="寫作準備"><a href="#寫作準備" class="headerlink" title="寫作準備"></a>寫作準備</h1><blockquote>
<p>Writing is easy. All you do is stare at a blank sheet of paper until drops of blood form on your forehead.（寫作也沒什麼難的，不過是盯著一張白紙直到額頭滲出血來罷了）<br>by Gene Fowler</p>
</blockquote>
<h2 id="挑選期刊"><a href="#挑選期刊" class="headerlink" title="挑選期刊"></a>挑選期刊</h2><ul>
<li>及早決定投稿期刊，及早按照規範寫，省得往後修改的麻煩。</li>
<li>選錯期刊要不被編輯 reject，要不得不到良性回饋，要不接受了卻沒人看。</li>
<li>挑期刊時看看引用過的文獻、查查領域內的排名、找找類似主題的論文。通常，學會期刊是最穩的。</li>
</ul>
<h2 id="不是寫論文，是修改論文"><a href="#不是寫論文，是修改論文" class="headerlink" title="不是寫論文，是修改論文"></a>不是寫論文，是修改論文</h2><ul>
<li>把章節列出來，現在就開始寫，再慢慢修改，一定可以改。</li>
<li>你不可能一口氣寫完一篇論文，一定會改很多次。寫論文修改三十到五十次，稀鬆平常。現在開始寫，改個五十次就一篇 paper 出來，為什麼不寫呢？</li>
<li>每次寫完前要草記接下來你要寫什麼，方便下一次延續你的思路。</li>
</ul>
<h2 id="安排寫作計畫"><a href="#安排寫作計畫" class="headerlink" title="安排寫作計畫"></a>安排寫作計畫</h2><ul>
<li>所謂寫作，就是空出時間寫作。</li>
<li>從何處開始寫都行，至少是個開始。</li>
<li>寫作要設定截止日，留下前置量，管理專注力，維持自律，保持流暢。</li>
<li>只是草稿的文章不要投。然而沒有文章是完美的，盡力修改後就投稿。</li>
</ul>
<h1 id="論文架構"><a href="#論文架構" class="headerlink" title="論文架構"></a>論文架構</h1><blockquote>
<p>All scientists have an unwritten contract with their contemporaries and those whose work will follow to provide observations honestly obtained, recorded, and published. （科學家和當代人與繼承者有個約定，他們將提供正當取得、誠實記錄和嚴謹發表的結果。）<br>CBE Style Manual Committee</p>
</blockquote>
<h2 id="IMRAD-體系"><a href="#IMRAD-體系" class="headerlink" title="IMRAD 體系"></a>IMRAD 體系</h2><p>科學論文遵照 IMRAD 體系，Introduction &#x3D; WHY，Materials and Methods &#x3D; HOW，Results &#x3D; WHAT，Discussion &#x3D; WHAT。</p>
<ul>
<li>WHY：Why did the experiment? What question (problem) was studied?</li>
<li>HOW：How was the problem studied?</li>
<li>WHAT：What were the findings?</li>
<li>WHAT：What do these findings mean?</li>
</ul>
<p>方法與結果成對，簡介與討論配對。簡介要提出問題，討論應回答問題。</p>
<h2 id="論文的類型"><a href="#論文的類型" class="headerlink" title="論文的類型"></a>論文的類型</h2><ul>
<li>科學論文是經同儕審查的論文。不要看人家在大會上報告很威風，會議論文的壽命只有一天，沒有同儕審查都是 non qualified。</li>
<li>但同儕是誰？老師和同學是你的 colleague，不是你的 peer。只有研究相同題目的人才是 peer。</li>
<li>好的科學家會重視研究的整體性，不會把一篇 paper 拆成好幾篇。一篇好的 original article 可以抵五篇 short communication，科學本來就是這麼無情。</li>
<li>什麼都沒有的時候，搬一台電腦到圖書館就可以寫 review paper，所以一定要會寫review。</li>
<li>不知道敵人在哪所以要小心點。會議論文我都亂寫，以免哪天被當重複投稿，要命。</li>
<li>如果你有很厲害的點子，也許能得到諾貝爾獎那種，要盡快用任何形式發表。</li>
<li>筆離開紙就留下版權，你不需要申告，但是需要舉證。</li>
</ul>
<h2 id="撰寫科學論文不是寫小說或散文"><a href="#撰寫科學論文不是寫小說或散文" class="headerlink" title="撰寫科學論文不是寫小說或散文"></a>撰寫科學論文不是寫小說或散文</h2><ul>
<li>自己做的用過去式，別人做的用過去式。所以摘要、結果與方法用過去式，簡介用現在式，討論視情況而定。</li>
<li>科學論文寫得艱澀又冗長就只有一命運，reject。</li>
<li>想要避免抄襲的話，寫筆記要紀錄引用來源，寫論文時別參考文獻。文獻等核對內容的時候才拿出檢查。</li>
</ul>
<h1 id="作者序、標題與摘要"><a href="#作者序、標題與摘要" class="headerlink" title="作者序、標題與摘要"></a>作者序、標題與摘要</h1><h2 id="決定作者序不是小事"><a href="#決定作者序不是小事" class="headerlink" title="決定作者序不是小事"></a>決定作者序不是小事</h2><ul>
<li>作者順序，自己放在第一個，學長姊其次，老師放最後面。研究生無論如何一定要 keep 自己是 first auther。</li>
<li>要怎麼 keep？把文章寫出來，idea 我出的，實驗我做的，paper 我寫的，誰是老大？</li>
<li>不要說沒人會寄信給你，論文作者的地址是辨識身分的途徑。</li>
<li>不要讓無關的人掛名，稀釋你對論文的貢獻；也不要隨便找人掛名，損害自己的名譽。</li>
<li>簽了名，就要負責。</li>
<li>出點子的、給想法的、設計實驗的放作者；執行的、借器材的、諮詢的放致謝。</li>
<li>作者的順序要在做實驗之前就講好，論文發表時也要所有的作者同意，否則朋友可能變敵人。</li>
</ul>
<h2 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h2><ul>
<li>Title should be sexy（標題必須性感），review 才適合寫大題目。</li>
<li>Keyword 可以補充文章沒出現過的字。</li>
<li>要假設你的論文會被不同時代、不同知識背景、不同閱讀媒介的專業讀者閱讀，所以有時效性的不要寫、艱澀難懂的術語不要寫、縮寫不要寫、廢話不要寫。</li>
<li>然後，不要裝可愛。</li>
</ul>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>摘要就是迷你論文，全文的 README (IMRAD)。</li>
<li>摘要獨立於論文，網路檢索往往只看得到摘要，因此要self contained。</li>
<li>不只要學會寫摘要，也要會畫圖，圖畫得好，一副要被人引用的樣子。不過賣得出去就好，管他不漂亮。</li>
<li>標題是標籤，不需要是完整的句子，所以標題用字和字序很重要。</li>
<li>結論可以在標題講一次、摘要講一次、簡介講一次、討論講一次。</li>
<li>沒做的實驗不要寫進摘要。</li>
</ul>
<h1 id="簡介與討論"><a href="#簡介與討論" class="headerlink" title="簡介與討論"></a>簡介與討論</h1><p>方法和結果是死的，Introduction 和 Discussion 才是重頭戲</p>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><ul>
<li><p>Introduction 的目標是 introduce 這篇論文。</p>
</li>
<li><p>撰寫 introduction 的重點在擺放概念的位置，還有提醒讀者「要來了」的轉折詞。</p>
</li>
<li><p>如果你不曾寫過論文，那就寫成漏斗狀：(1) 概述主題，(2) 依照時間順序描述前人的工作，(3) 解釋既有不足和研究問題，(4) 提出假說、研究目的和原創性。</p>
</li>
<li><p>文獻回顧：如果你對主題比 reviewer 還清楚，他還敢給你 reject 嗎？</p>
</li>
<li><p>原創性：如果不確定有沒有人做過，就寫出你找了多少文獻，讓 reviewer 幫你補充。</p>
</li>
<li><p>研究問題：提出的問題要合理要可被理解否則讀者不會有興趣。</p>
</li>
<li><p>研究目的：研究目的其實就是結論。</p>
</li>
</ul>
<h2 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h2><ul>
<li>好的 data 若沒有好的討論也會被退稿。</li>
<li>討論的目的是回答 Introduction 提出的問題，不要節外生枝產生更多困惑。</li>
<li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li>
<li>不要讓讀者讀完了有種「又怎樣」的想法。</li>
<li>討論不理想結果的句型要記住，為討論而討論的內容雖然不切題，但也討論了啊。</li>
<li>要把例外和限制講清楚，不要蒙混過關或睜眼說瞎話。</li>
<li>不要羞於討論結果的理論含意或應用價值，因為那是你的遠見和貢獻。</li>
<li>分清楚 future work（希望）、comming work（即將）和 upcomming work（已經）。</li>
</ul>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul>
<li>作者要為每個結論簡述證據，所以結論不要下得像宇宙那麼大，不然會讓研究被質疑。</li>
<li>實驗沒做過的不要放進結論，也不要過度延伸結果 ，那沒有你的事。</li>
<li>你能做的是在一個地方聚焦事實。</li>
</ul>
<h1 id="方法與結果"><a href="#方法與結果" class="headerlink" title="方法與結果"></a>方法與結果</h1><blockquote>
<p>The greatest invention of the nineteenth century was the invention of the method of invention.（十九世紀最偉大的發明是創造了發明的方法。）<br>A. N. Whitehead</p>
</blockquote>
<h2 id="實驗記錄"><a href="#實驗記錄" class="headerlink" title="實驗記錄"></a>實驗記錄</h2><ul>
<li>做錯做慢都 OK，千萬不能造假。</li>
<li>筆記包含自己寫的內容 (print materials) 和引用的內容 (quoted meterials)。</li>
<li>不要相信人的記憶力。東西還在，記憶猶新，實驗邊做，paper 邊寫。</li>
<li>做研究時的想法要記錄，寫論文時才有底稿和素材。</li>
<li>可重複 (Repeatability) 是同個人使用相同方法和器材得到相同結果 ；可再現 (Reproducibility) 是不同人使用相同方法和不同器材得到相同結果。</li>
<li>實驗記錄要讓自己能重複，論文的方法要讓別人能重現。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>相較於藝術和玄學，科學的價值是可以被重現。所以方法被認為無法重複或重現就會被退稿。</li>
<li>方法可以出現在實驗記錄、論文的簡介和論文的方法中。你要在 Introduction 裡陳述並捍衛自己的實驗設計，在 Materials and Methods 給出細節，讓潛在的競爭對手可以重複。</li>
<li>方法的架構是：大處依照時間順序排列，小處依照方法類型分區，說明採用的方法後簡述原理。</li>
<li>舊方法要引用，新方法要詳述，改良的方法除了引用也要稍微解釋。</li>
<li>不管怎麼樣，以第三人稱描述方法最保險。</li>
<li>石器時代結束了，但石頭一顆也沒少。High tech depends on low tech.</li>
</ul>
<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><ul>
<li>如果方法和討論寫得好，結果應該是最短的 section。</li>
<li>科學論文不精簡，那只會得到一個字，redundancy，也只有一個命運，rejection。</li>
<li>撰寫結果只有三個原則：簡述實驗、呈現數據、時態用過去式。</li>
<li>數據得整理，文、圖、表擇一，方法結果要對應，確保行文一致性。</li>
<li>圖表沒有對錯，只有合適不合適，用在什麼場合。</li>
<li>結果呈現的原則：趨勢畫圖，數據製表，一般撰文。</li>
<li>文、圖、表各自獨立，圖表要 self-contained。</li>
<li>給老闆完整的資料，但給編輯代表性的資訊。</li>
<li>但不要只給老闆數據，你要寫成一個 section paraghragh。因為一旦你的 data 跟其他人做的混在一起，你的貢獻就沒了。</li>
</ul>
<h2 id="引用與致謝"><a href="#引用與致謝" class="headerlink" title="引用與致謝"></a>引用與致謝</h2><ul>
<li>Credit 要給原創者，不是給 review 的人，review 的人沒有做實驗。</li>
<li>Idea 只要不是自己的，一定要引用，寧可多引用給 reviewer 篩選，也不要少東少西。</li>
<li>引用要從優，挑選重要的一手文獻。</li>
<li>如果文獻值得引用，要在文中讓讀者了解原因。</li>
<li>完稿後要確認文內引用和參考文獻一一對應。</li>
<li>致謝跟科學論文沒什麼關係，因為禮貌是文明社會的生活型態。</li>
<li>公開的書面致謝是科學的玩法。</li>
<li>誰幫助你就感謝誰，但別謝過頭，反而損害自己的貢獻。</li>
</ul>
<h1 id="結論：科學論文寫作十訓"><a href="#結論：科學論文寫作十訓" class="headerlink" title="結論：科學論文寫作十訓"></a>結論：科學論文寫作十訓</h1><ol>
<li>不要讓語言阻礙科學。</li>
<li>科學不問對錯，只求合理；實驗室沒有真理，只有證據。</li>
<li>做完實驗一定要發表論文，論文發完發綜述。</li>
<li>科學論文由 WHY、HOW、WHAT、WHAT 組成 (IMRAD)，簡介與討論呼應，方法與結果配對。</li>
<li>寫作時，自己做的用過去式，別人做的用現在式。</li>
<li>Introduction 的目標就是 introduce 這篇論文：概述主題、文獻回顧、提出問題、說明目的。</li>
<li>實驗紀錄要能重複，論文方法要能重現。</li>
<li>撰寫結果只有三個原則：簡述實驗，呈現數據，文圖表擇一。</li>
<li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li>
<li>引用的榮耀屬於知識創造者，而非知識整理者。</li>
</ol>
]]></content>
      <categories>
        <category>academic</category>
        <category>mindset</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Transcribing DNA into RNA (RNA)</title>
    <url>/transcribing-dna-into-rna/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模擬 DNA 轉錄 RNA 的過程，將給定 DNA 字串中的 T 替換為 U。</p>
<blockquote>
<p>Given: A DNA string t having length at most 1000 nt.</p>
<p>Return: The transcribed RNA string of t.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/rna/">https://rosalind.info/problems/rna/</a>)</p>
<span id="more"></span>

<p>此題為字符替換問題，可使用 *str.replace(old, new, max)*，將字串中的 old（舊字符串） 替換為 new（新字符串）。若指定第三個參數 max，還可設定最大替換次數。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transcribe</span>(<span class="params">dna</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Transcribe DNA into RNA</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> dna.replace(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>R 語言與 replace 相應的 function 為 gsub，然而 gsub 可以接受向量，批次替換字符串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dna <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAATTTT&quot;</span><span class="punctuation">)</span></span><br><span class="line">rna <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> replacement <span class="operator">=</span> <span class="string">&quot;U&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span>  dna<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>rna<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>bash 的 tr (transform) 可用於替換、刪除、修改等多種字符操作。此例使用的是其替換功能，參數設定為：$string | tr old new，意指將字串中的 old（舊字符） 替換為 new（新字符）。相較於 R 的 gsub() 和 python 的 replace()，tr 只針對字符的操作（即只能 A→T，不能 AT→CG），若要替換字符串則要使用 sed，其參數設定為：sed “s&#x2F;old&#x2F;new&#x2F;g”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transcribing DNA into RNA using tr</span></span><br><span class="line">dna=<span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Translating RNA into protein using sed</span></span><br><span class="line">dna=<span class="string">&quot;GGTGGTGGTGGT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line">protein=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span> |  sed <span class="string">&quot;s/GGU/G/g&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$protein</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜VSCodeVim 常用設定</title>
    <url>/vscode-common-settings-for-vscodevim/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文紀錄一些有助於在 Vscode 使用 vim 的套件與快捷鍵設定。</p>
<span id="more"></span>
<h1 id="除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？"><a href="#除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？" class="headerlink" title="除了 Esc，還有哪些鍵適合作為模式切換快捷鍵？"></a>除了 <code>Esc</code>，還有哪些鍵適合作為模式切換快捷鍵？</h1><p>Vim 被開發出來的時候，<code>Esc</code> 位於現今當代鍵盤 <code>Tab</code> 和 <code>Caps</code> 的位置。如今，<code>Esc</code> 被移到鍵盤左上角，已不若以往方便了。既然 VSCodeVim 支援重新設定快捷鍵，那麼有哪些鍵適合作為模式切換快捷鍵？</p>
<ol>
<li><code>jj</code>：位置很棒，只是打字打到 j 時，會有輕微的停頓感。缺點是編輯中文時，要頻繁切換輸入法。</li>
<li><code>jk</code>：一次按兩顆鍵，但因為可以一起按，沒有連續按鈕的卡頓感，只是同樣要解決換模式前得切換輸入法的問題。</li>
<li><code>Enter</code>*2：剛開始使用 vim 很容易忘記切回 normal 模式，既然中文輸入會頻繁輸入 enter讓文字寫入文件，enter 設定為切換模式的快捷鍵既不會干擾文字輸入也好記。只是碰到換行時會延遲等候第二次按鍵的訊號，有時還挺煩人的。</li>
<li><code>Shift</code> + <code>Enter</code>：雖然要兩個按鈕，但位置其實不錯按，而且不會輸入新列的卡頓感。唯一的缺點是設置稍嫌麻煩。</li>
</ol>
<h2 id="前述三種方法要修改-setting-json"><a href="#前述三種方法要修改-setting-json" class="headerlink" title="前述三種方法要修改 setting.json"></a>前述三種方法要修改 setting.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;CR&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CR&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;Esc&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Shift-Enter-的方法要改-keybindings-json"><a href="#Shift-Enter-的方法要改-keybindings-json" class="headerlink" title="Shift + Enter 的方法要改 keybindings.json"></a><code>Shift</code> + <code>Enter</code> 的方法要改 keybindings.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//https://github.com/VSCodeVim/Vim/issues/2584#issuecomment-385561286</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shift+Enter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.vim_escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="使用相對列名"><a href="#使用相對列名" class="headerlink" title="使用相對列名"></a>使用相對列名</h1><p>由於 vim 可以為指令添加數字以重複執行，所以為了計算方便，需要設置相對行號，設定方式為：</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，啟動 UI 設定</li>
<li>搜尋 “Line numbers” </li>
<li>由 “on” 改為 “relative”，預設為絕對行號</li>
</ol>
<p>然而，內建方式只能顯示絕對行號或相對行號，若要一併顯示，則要安裝 <em>Double Line Numbers</em> 套件。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>X</code>，開啟擴充套件。</li>
<li>搜尋並安裝 <em>Double Line Numbers</em> </li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，輸入 <code>Double Line Numbers: Relative + Absolute</code></li>
</ol>
<h1 id="怎樣設定快捷鍵"><a href="#怎樣設定快捷鍵" class="headerlink" title="怎樣設定快捷鍵"></a>怎樣設定快捷鍵</h1><p>vscode 和 vim 有些彼此衝突的快捷鍵，例如常用的 <code>Ctrl</code> + <code>F</code> 或 <code>Ctrl</code> +<code>W</code> 等。依照個人習慣，可以選擇 vim 模式要啟用那些快捷鍵</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置來關掉 vim的快捷鍵 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="attr">&quot;vim.handleKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-d&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-s&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-w&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-t&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-z&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
這些是我常用的指令。</li>
</ol>
<h1 id="怎樣才不會忘記在切換模式後切為英文輸入法"><a href="#怎樣才不會忘記在切換模式後切為英文輸入法" class="headerlink" title="怎樣才不會忘記在切換模式後切為英文輸入法"></a>怎樣才不會忘記在切換模式後切為英文輸入法</h1><p>由於 Normal mode 僅能以英文輸入法下指令，假如在 Insert mode 以中文輸入法編輯文件，使用預設的 <code>Esc</code> 切換模式後，仍維持中文輸入法，還要將輸入法切回英文，才能下達指令。為了解決這問題有兩個策略：</p>
<h2 id="改變模式切換快捷鍵"><a href="#改變模式切換快捷鍵" class="headerlink" title="改變模式切換快捷鍵"></a>改變模式切換快捷鍵</h2><p>第一種策略是把切換模式的快捷鍵設定為 <code>jj</code>，雖然不見得比較快，但一定能避免中文輸入法讓指令無法執行的問題。由於改用英文字母作為切換快捷鍵，所以在切換模式前一定要更換輸入法，所以能確保切換後一定是英文輸入法</p>
<ol>
<li><code>Shift</code>, then <code>jj</code>，切為 Normal mode</li>
<li><code>i</code>，切為 Insert mode</li>
<li><code>Shift</code>，切為中文輸入法</li>
</ol>
<h2 id="自動切換輸入法"><a href="#自動切換輸入法" class="headerlink" title="自動切換輸入法"></a>自動切換輸入法</h2><p>另一種是呼叫自動切換輸入法的腳本，在切回 normal mode 時自動幫我們切換文字</p>
<ol>
<li>下載 (im.select.exe)[<a href="https://github.com/daipeihust/im-select]">https://github.com/daipeihust/im-select]</a> 放到任何你喜歡的路徑</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置以啟用輸入法自動切換 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe -s &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>透過這樣設置，在切回 normal mode 瞬間，就會變成英文輸入法。而進入 insert mode 時，就會回到當初離開時的輸入法。</p>
<h1 id="關閉括號自動補全"><a href="#關閉括號自動補全" class="headerlink" title="關閉括號自動補全"></a>關閉括號自動補全</h1><p>VSCode 內建括號與引號自動補全，然而有時這還挺雞肋的，因為在括號內打完字還要使用方向鍵移到括號外才能繼續打字，若使用 Vim 還得切模式再移動，不管哪種方式都沒省太多功夫。因此，對於一般文本編輯或編輯程式碼的需求而言，似乎可以在 setting.json 添加以下設置來關閉自動補全。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// automatical closing</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingQuotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingBrackets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h1 id="調整視窗大小的快捷鍵"><a href="#調整視窗大小的快捷鍵" class="headerlink" title="調整視窗大小的快捷鍵"></a>調整視窗大小的快捷鍵</h1><p>設定快捷鍵，就不用為了調整欄位大小，辛苦地讓游標對齊邊框了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="更新檔案瀏覽側欄"><a href="#更新檔案瀏覽側欄" class="headerlink" title="更新檔案瀏覽側欄"></a>更新檔案瀏覽側欄</h1><p>使用終端或指令新增或刪除檔案不會同步更新在檔案探索側欄，因為重新整理的按鈕太小了，所以我也設定快捷鍵輔助。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f5&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;when&quot;</span><span class="punctuation">:</span><span class="string">&quot;filesExplorerFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="超棒的學習資源和網站"><a href="#超棒的學習資源和網站" class="headerlink" title="超棒的學習資源和網站"></a>超棒的學習資源和網站</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10291847">VsCodeVim 自動在normal mode切回英文輸入法的方法</a></li>
<li><a href="https://www.blog.lasai.com.tw/2020/07/05/vscode-vim-mode/">vscode vim mode</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode｜無助於開發，但有助於身心的套件</title>
    <url>/vscode-extensions-that-are-do-nothing-but-are-cool/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近調查 VSCode 有哪些能幫助軟體開發的工具時，發現不少有趣的擴充套件，這些套件也許不能提升開發速度，但說不定能為百無聊賴、獨自 coding 的下午增添風格與生氣。</p>
<span id="more"></span>

<h1 id="像駭客一樣寫程式"><a href="#像駭客一樣寫程式" class="headerlink" title="像駭客一樣寫程式"></a>像駭客一樣寫程式</h1><p>首先是能增加打字回饋感並且裝模作樣的套件。</p>
<h2 id="Power-Mode"><a href="#Power-Mode" class="headerlink" title="Power Mode"></a>Power Mode</h2><blockquote>
<p>This is the most necessary and MUST TO plugin EVER. Now I can feel the power of my typing. Recommended to all my friends and colleges. 1000000&#x2F;10</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hoovercj/vscode-power-mode/7bbc4f68dd46da883b24011ae67516c861d09d1b/images/demo-presets-particles.gif" alt="powermode"></p>
<p>Power Mode 能大幅增加 coding 的回饋感，除了隨著打字噴發的特效與劇烈震動以外，在頁面右上角也會顯示連續打字次數，讓打字除了聽覺與觸覺的回饋感以外，還增加了視覺的激情與火爆。</p>
<p>Power Mode 的設定健全，無論特效的形式、時間、幅度、頻率或觸發條件都可調整。以震動特效為例，若覺得太過干擾，可以透過以下方式關閉，</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟設置</li>
<li>搜尋 “Powermode &gt; Shake: Enabled”</li>
<li>關閉震動特效</li>
</ol>
<h2 id="VSCode-HackerTyper"><a href="#VSCode-HackerTyper" class="headerlink" title="VSCode HackerTyper"></a>VSCode HackerTyper</h2><blockquote>
<p> Writing Code Like a Real Hacker </p>
</blockquote>
<p><a href="https://hackertyper.net/">HackerTyper</a> 是模擬駭客寫程式的網頁。一點開網頁，映入眼簾的即典型的駭客工作環境：黑底綠字的終端畫面、等寬的程式碼字體、閃爍的文字游標等。</p>
<p>在這畫面中，無論敲打哪個按鍵，網頁都會印出虛構的迴圈、變數、判斷，營造出用戶正在快速寫程式的模樣。</p>
<p><img src="https://github.com/jevakallio/vscode-hacker-typer/raw/master/docs/hackertyper-video.gif" alt="VSCode HackerTyper 讓你像個駭客一樣 coding"></p>
<p>相較之下，VSCode HackerTyper 可以印出「真正」的程式碼。這款套件能錄製文件編輯行為，再透過用戶每次按鍵撥放來達到網頁版的效果。由於是採用自己的程式碼，所以這項套件也挺適合在現場示範時博其它人一笑的（詳見開發者親自示範如何<a href="https://www.youtube.com/watch?v=ulnC-SDBDKE">像個駭客一樣現場 demo</a>。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VSCode 命令列。（接下來指令皆於命令列執行)</li>
<li>輸入 “HackerTyper: Record Macro”，接著開始編輯文件</li>
<li>編輯完文件後，輸入 “HackerTyper: Save Macro” 紀錄並命名</li>
<li>要展示駭客技能時，開啟文件並輸入 “HackerTyper: Play Macro”</li>
</ol>
<p><em>已知 VSCodeVim 與此套件衝突，所以要使用這工具前，得先停用 VSCodeVim 並且重啟視窗</em></p>
<h2 id="Cursor-smooth-setting"><a href="#Cursor-smooth-setting" class="headerlink" title="Cursor smooth setting"></a>Cursor smooth setting</h2><blockquote>
<p>Watching those lines of codes flow like butter along with your cursor is just another satisfying thing to watch for any programmer like the satisfying sounds of their mechanical keyboards. 😌 (Trishiraj)</p>
</blockquote>
<p>除了使用套件，VSCode 也有許多內建設置能調整編輯的視覺效果，其中我覺得最有效提升視覺舒適感的是一系列平滑設定。</p>
<p>好比說啟用 “Cursor Smooth Caret Animation” 之後，VSCode 會在移動過程添加殘影動畫，讓游標在字元與行列間跳動時的移動軌跡更接近肉眼習慣的模式，看起來更為滑順與流暢。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code></li>
<li>搜尋 “smooth”</li>
<li>勾選 “Cursor smooth Caret Animation”</li>
</ol>
<h2 id="hacker-theme"><a href="#hacker-theme" class="headerlink" title="hacker theme"></a>hacker theme</h2><p>有了 Power Mode、HackerTyper、smooth cursor，再加上 VScode 商店許多駭客佈景主題，就能打造一座自嗨小天地，或是秀一回盛大而且浮誇的表演囉。<br><img src="https://github.com/thorerik/vscode-hacker-theme/raw/HEAD/media/Code_2020-08-12_01-55-19.png" alt="pro hacker theme"></p>
<h1 id="寫程式時不再孤獨"><a href="#寫程式時不再孤獨" class="headerlink" title="寫程式時不再孤獨"></a>寫程式時不再孤獨</h1><p>接著讓 coding 在鍵盤敲擊聲、鍵盤的觸感與閃爍的游標之外，還增添人造互動的套件。</p>
<h2 id="vscode-pet"><a href="#vscode-pet" class="headerlink" title="vscode-pet"></a>vscode-pet</h2><blockquote>
<p>Coding can be lonely sometimes but these pets always keep me company !! (Aya Lahrech)</p>
</blockquote>
<p>vscode-pets 會在 VSCode 側欄新增寵物窗格，可以在其中添加貓咪、小狗與小雞等寵物。除了看著寵物閒晃以外，也能透過點擊或擲球與他們互動。</p>
<p><img src="https://tonybaloney.github.io/vscode-pets/_images/throw-ball.gif" alt="VSCode 小動物會追著丟出的球跑，也會以表情符號回應點擊。"></p>
<p>若覺得預設的背景太單調，可以在設定更換背景</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟設定</li>
<li>搜尋 “vscode-pets.theme”，設定想要的主題</li>
</ol>
<p><img src="https://tonybaloney.github.io/vscode-pets/_images/forest.gif" alt="除了森林，還有城堡與海灘背景"></p>
<h2 id="Encourage"><a href="#Encourage" class="headerlink" title="Encourage"></a>Encourage</h2><blockquote>
<p>There are times when writing code is drudgery. In those dark times, bathed in the soft glow of your monitor, engrossed in the rhythmic ticky tacka sound of of your keyboard, a few kind words can make a big difference. And who better to give you those kind words than your partner in crime - your editor. (Haacked)</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/7860985/79793932-66320380-831f-11ea-8188-fb4a627f670a.gif" alt="Encourage 會在文件儲存時，根據程式碼正確與否給予對應的回饋。"></p>
<p>Encourage 是款文字互動套件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。 ">1</span></a></sup>，會根據文件儲存當下，程式碼是否語法錯誤給予對應的回饋。假如沒有錯誤，則會隨機印出鼓勵的話；反之，則會吐出吐槽或挖苦的句子。</p>
<p>這套件支援自訂語錄，所以可以自行添加喜歡的座右銘、名言或幹話等，</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟設定介面 </li>
<li>搜尋 “Preferences: Open User settings (JSON)”</li>
<li>在大括號內添加以下內容，即可新增自訂語錄： <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [extensions]: Encourages</span></span><br><span class="line"><span class="attr">&quot;encourage.additionalEncouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;Wake the fuck up, Samurai. We have a city to burn 🔥🔥🔥&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Just focus, you are better than them.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Fuck yeah!!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Death to Corpos!!!💀&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Never stop fighting.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Holy FUCK!!!&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
<li>若只想聽到鼓勵的話，可以用空字串覆蓋預設的挖苦內容。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;encourage.discouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>此處我加入了一些 Cyberpunk 2077 的台詞，但你也可以調整成從飲料封膜看到的冷笑話或農民曆頁緣的生活訣竅。</p>
<h2 id="Hotheaded-VS-Code"><a href="#Hotheaded-VS-Code" class="headerlink" title="Hotheaded VS Code"></a>Hotheaded VS Code</h2><blockquote>
<p>love how it kic…, corrects me. (Venipa)</p>
</blockquote>
<p>相較於 Encourage 的文字訊息，Hotheaded VS Code 會在語法出錯時放出嫌棄的語音（而且只有嫌棄，沒有鼓勵）。雖然我個人是比較喜歡鼓勵大於責備啦，但這在業界是種獎勵也說不定。</p>
<p><em>聲線可以參考配音員<a href="https://www.fiverr.com/dalfaria">dalfaria 的網站試聽</a></em></p>
<h1 id="讓人哭笑不得"><a href="#讓人哭笑不得" class="headerlink" title="讓人哭笑不得"></a>讓人哭笑不得</h1><p>最後則是能讓自己的 IDE 與他人很不一樣的主題。此處推薦兩則 VSCode 官方推特也說讚的主題套件<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://twitter.com/code/status/928315998075215873">2</span></a></sup>。</p>
<h2 id="Cage-Icons"><a href="#Cage-Icons" class="headerlink" title="Cage Icons"></a>Cage Icons</h2><blockquote>
<p>With this I’m gonna steal the Declaration of Independence. (Kishore Newton)</p>
</blockquote>
<p>我覺得尼可拉斯凱吉是詮釋「身不由己」最出色的演員，他的表情也是迷因的重要來源。這套件會將原生圖標替換那些常在梗圖裡看到的尼可拉斯凱吉表情。<br><img src="https://raw.githubusercontent.com/GabeStep/cage-icons/master/example.png" alt="用膩了 Materials Icon Theme？何不試試 Cage Icons！"></p>
<h2 id="Hot-dog-stand"><a href="#Hot-dog-stand" class="headerlink" title="Hot dog stand"></a>Hot dog stand</h2><blockquote>
<p>This is AMAZING! I can hardly see anymore, recently started using a walking stick. couldn’t recommend more! (Franklin Volcic)</p>
</blockquote>
<p>Hot dog stand 套件復刻了 Win 3.1 史上最糟糕的視覺設計<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/">3</span></a></sup>。套件開發者介紹說，這套主題能在 15 秒內毀了用戶雙眼，但根據 VSCode 推特小編的說法，其實大約只需兩秒鐘……</p>
<p><img src="https://raw.githubusercontent.com/SomeKittens/VSC-HDS/master/theme.png" alt="安裝這款主題後，我只堅持了一秒鐘就移除了。"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>有時，認真研究點沒意義的事，其實也挺好玩的啊！</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://twitter.com/code/status/928315998075215873<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜ Failed to parse remote port from server output</title>
    <url>/vscode-remote-ssh-connection-not-working-after-update/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="狀況描述"><a href="#狀況描述" class="headerlink" title="狀況描述"></a>狀況描述</h2><p>原本在 Windows 都能正常用 VSCode Remote SSH 連線伺服器，但一早卻發現連線失敗。當時，VSCode 不斷要求輸入密碼卻無法登入，”OUTPUT” 頁面提示的訊息節錄如下：</p>
<blockquote>
<p>Failed to parse remote port from server output</p>
</blockquote>
<blockquote>
<p>Acquiring lock on &#x2F;home&#x2F;username&#x2F;.vscode-server&#x2F;bin&#x2F;some-hash-code-here&#x2F;vscode-remote-lock.username.some-hash-code-here</p>
</blockquote>
<p><em>版本資訊：windows 21H2, VSCode 1.74.2</em></p>
<span id="more"></span>
<h2 id="原因與解決辦法"><a href="#原因與解決辦法" class="headerlink" title="原因與解決辦法"></a>原因與解決辦法</h2><p>參考 <a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">VSCode remote ssh connection not working</a>，簡言之，VSCode 遠端連線前，需要在伺服器端的 <code>.vscode-server/bin</code> 安裝連線相關的工具並進行一些連線設置。假設伺服器已有這些套件，”OUTPUT” 會提示 <code>Found existing installation at (.vscode-server/bin 的路徑)</code>；若沒有這些套件，則會從官方網站下載與安裝。</p>
<p>若伺服器的套件和配置沒有隨本地 Vscode 更新，便可能因為連線兩端的資訊不相符而無法順利連線，此時可刪除並重新安裝這些工具與配置檔來解決問題。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟指令視窗</li>
<li>搜尋並執行 “Remote-SSH: Kill VS Code Server on Host”，刪除 <code>vscode-server</code> 檔案與目錄</li>
<li>選取欲清除既有工具的伺服器</li>
<li>重新連線，VSCode 便會重新安裝相關軟體了</li>
</ol>
<h2 id="檢查方式"><a href="#檢查方式" class="headerlink" title="檢查方式"></a>檢查方式</h2><ol>
<li>開啟 command line 工具，以 <code>ping</code> 確認連線正常</li>
<li>使用 putty 或 mobaXtern 等工具連線伺服器，確認問題出在 VSCode </li>
<li>重新開機、重新安裝 Remote SSH、移除 <code>C:/Users/username/.ssh/Known_host</code> 的內容，確認問題不在本地端</li>
<li>按照前述步驟刪除伺服器內 <code>vscode-server</code> 的內容，重新連線</li>
</ol>
<h2 id="其他可能解法"><a href="#其他可能解法" class="headerlink" title="其他可能解法"></a>其他可能解法</h2><p>若此處提及的方式無法解決問題，可參考以下連結試試看其他人的解法。</p>
<ul>
<li><a href="https://mushding.space/2021/12/22/vscode%20remote-ssh%20%E5%95%8F%E9%A1%8C%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/">首次遠端連線且因為網路問題下載工具受阻</a> </li>
<li><a href="https://www.cnblogs.com/netsa/p/14857577.html">本地與伺服器的 SSH key 因為更新等緣故沒有同步</a></li>
<li><a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">任何可能與遠端連線配置或安裝的問題</a></li>
<li><a href="https://blog.csdn.net/myWorld001/article/details/119443079">伺服器上的 <code>vscode-server</code> 文件過時</a></li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>IDE 及其擴充套件相當方面，可以免去不少開發環境設置的功夫。畢竟我們不會等到摸熟了 IDE 所有功能及其實踐方式才開始開發，所以功能故障算是讓了解 IDE 機制或潛在設定的好機會。在本文的案例哩，可以關閉自動更新來避免這種狀況發生。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟 Settings</li>
<li>搜尋 “update: Mode”</li>
<li>設定為 “manual” 或 “none”</li>
<li>重新啟動 VScode</li>
</ol>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜常用快捷鍵與個人設置</title>
    <url>/vscode-useful-shortcuts-and-their-settings/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>VSCode 有許多快捷鍵設置，本文記錄一些我覺得挺實用的設置</p>
<span id="more"></span>

<h1 id="開啟個人快捷鍵配置"><a href="#開啟個人快捷鍵配置" class="headerlink" title="開啟個人快捷鍵配置"></a>開啟個人快捷鍵配置</h1><ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code></li>
<li>搜尋 “Preferences: Open Keyboard Shortcuts (JSON)”</li>
</ol>
<h1 id="調整當前子頁尺寸"><a href="#調整當前子頁尺寸" class="headerlink" title="調整當前子頁尺寸"></a>調整當前子頁尺寸</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="開啟連結"><a href="#開啟連結" class="headerlink" title="開啟連結"></a>開啟連結</h1><p>設定條件是為了避免快捷鍵彼此衝突，點連結的行為大概只有在編輯 md 檔案時發生，所以才這樣設置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+l&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;editor.action.openLink&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus &amp;&amp; editorLangId == &#x27;markdown&#x27;&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h1><p><code>Alt</code> + <code>[0-9]</code>：切換至指定分頁</p>
<h1 id="刷新側欄檔案目錄"><a href="#刷新側欄檔案目錄" class="headerlink" title="刷新側欄檔案目錄"></a>刷新側欄檔案目錄</h1><p><code>Ctrl</code> + <code>0</code>：開啟檔案目錄，再按一次則聚焦檔案目錄</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+F5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.explorer.fileView.focus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="游標動畫"><a href="#游標動畫" class="headerlink" title="游標動畫"></a>游標動畫</h1><p>VSCode 有一系列滑順特效動畫，能讓游標移動與視窗滑動的軌跡帶有殘引，看起來更加滑順。我自己覺得彷彿是影片從 720p 改善到 4k 的滑溜溜感。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code></li>
<li>搜尋 “smooth”</li>
<li>勾選 “Cursor smooth Caret Animation”</li>
</ol>
]]></content>
      <categories>
        <category>programming</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>卡住、沒靈感、寫不出東西怎麼辦？</title>
    <url>/what-to-do-when-you-are-stuck-in-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原本我開啟部落格編輯器是打算寫一篇文章，總結我兩周以來學習降噪演算法的經驗，但回過神來，已經盯著標題與目錄一個鐘頭了。我意識到再這樣下去不是辦法，於是把原先的標題刪除，開始思考「如果寫文章碰到瓶頸，除了躲在桌下哭訴沒有人愛我以外，還能做些什麼？」，在閱讀了網路和實體書籍資源後，我寫了這文章。因此，本文不只是各項建議的彙整，也是這些方法的實踐。  </p>
<span id="more"></span>
<h2 id="寫作瓶頸的成因為何？"><a href="#寫作瓶頸的成因為何？" class="headerlink" title="寫作瓶頸的成因為何？"></a>寫作瓶頸的成因為何？</h2><h3 id="我寫不下去了……"><a href="#我寫不下去了……" class="headerlink" title="我寫不下去了……"></a>我寫不下去了……</h3><p>儘管已經寫了十幾篇文章，每次開啟新文件的時候還是很掙扎，因為我要不是在文章的開頭感到絕望，就是在寫一半的時候覺得快不行了。我試著問論文寫作的老師，當他碰到寫作瓶頸時會怎麼克服，他說：「我在列完大綱後都能順利地寫完論文，所以沒有碰過這種障礙。」  </p>
<p>人類的悲喜和苦惱並不相通，我得靠自己找出解決辦法。  </p>
<h3 id="為什麼會碰到障礙？"><a href="#為什麼會碰到障礙？" class="headerlink" title="為什麼會碰到障礙？"></a>為什麼會碰到障礙？</h3><p>寫文章卡住多半是源於<strong>沒有東西寫（知識問題）和寫不出字來（心態問題）</strong>。在我的寫作經驗裡，大部分的情況都是碰到心態問題。畢竟無論是寫何種題目，至少都有個預設的目標，有目標表示有初步的想法，既然有想法便不至於沒內容可以寫。是以多數的情況是讀穿了參考資料，卻在文件上打兩個字刪三個字，好似永遠也寫不出文章來。  </p>
<h3 id="怎麼辨識寫作瓶頸的成因？"><a href="#怎麼辨識寫作瓶頸的成因？" class="headerlink" title="怎麼辨識寫作瓶頸的成因？"></a>怎麼辨識寫作瓶頸的成因？</h3><p>針對不同原因需要不同的解決辦法，那麼該如何辨識寫作瓶頸的成因呢？Esor Huang（電腦玩物的站長）建議大家口頭陳述想要表達的概念，由於打嘴砲不用負責，所以如果內心有點想法的話幾乎都能講出一些東西來，進而排除是知識問題。  </p>
<p>除了這個方法，我也提供一項判斷的策略：問問現在自己的感覺如何。假如<strong>真的沒東西寫了，那面對空白文件的時候，腦中浮起的應該是困惑</strong>：「什麼是微生物分析？」、「什麼是天文生物學？」、「我什麼都不知道，為什麼我會在這裡」，此時有充分好奇心的同學，應該會自動自發找資料，在資料搜索的過程中為撰寫文章準備。  </p>
<p>然而，<strong>如果是心態問題，打開文件時應該會出現恐懼、焦慮、害怕、猶豫、逃避等情緒</strong>。假如某個人笑著看著文件，卻不時點開社群網站和 Youtube 呵呵笑，即使沒有前述情緒，這個人也碰上了心態問題。  </p>
<h3 id="知識問題和心態問題需要不同的解決策略"><a href="#知識問題和心態問題需要不同的解決策略" class="headerlink" title="知識問題和心態問題需要不同的解決策略"></a>知識問題和心態問題需要不同的解決策略</h3><p>如果是知識問題，唯一的解決辦法就是充實知識，閱讀書籍也好，回顧先前的筆記也好，讓空乏的大腦裝滿寫作的素材克服無東西可寫的困難。如果是心態問題，那麼解決之道便是調整心態，想辦法擠出字來，榨乾自己直到碰上知識問題。我認為寫作一定會碰到障礙，從興起寫作的念頭，我們就開始「不知道寫什麼、閱讀和學習、寫不下去了、調整心態、榨乾自己、不知道寫什麼、……」的循環，既然決定寫文章，就拋開恐懼吧。  </p>
<h2 id="知識問題：該寫什麼？"><a href="#知識問題：該寫什麼？" class="headerlink" title="知識問題：該寫什麼？"></a>知識問題：該寫什麼？</h2><h3 id="成長是寫作與學習的循環"><a href="#成長是寫作與學習的循環" class="headerlink" title="成長是寫作與學習的循環"></a>成長是寫作與學習的循環</h3><p>關於知識問題，紀大偉老師有很棒的建議：<strong>研究所（或成長）是寫作與閱讀的循環。</strong>當寫得殫精竭慮，再也寫不出東西的時候，便該停下筆去學習或去閱讀。不必侷限於文章的主題，相關的專著或文章都可以接觸，既能補充匱乏的知識，也能促進知識間的連結，有助於寫作時有足夠且有趣的內容可以輸出。  </p>
<h3 id="學習不能作為逃避寫作的藉口"><a href="#學習不能作為逃避寫作的藉口" class="headerlink" title="學習不能作為逃避寫作的藉口"></a>學習不能作為逃避寫作的藉口</h3><p>然而<strong>吸收知識不能作為逃避寫作的藉口</strong>。之前寫多樣性分析的簡介文章時，因為總覺得不夠熟悉各項指標，所以遲遲無法下筆。我原本以為這是知識問題，但世上的知識是讀不完的，我的文章也非得涵蓋所有知識，因為對自己知識的不安而裹足不前，這是心理問題。  </p>
<p>擱置手邊的工作去閱讀是為了寫作，而不是為了享受閱讀的過程。如果真的發現要補足的知識讀不完，那麼應該重新審視文章的主題，而不是陷在學習的沼澤裡無法自拔。  </p>
<h3 id="為了寫作而學習，為了學習而寫作"><a href="#為了寫作而學習，為了學習而寫作" class="headerlink" title="為了寫作而學習，為了學習而寫作"></a>為了寫作而學習，為了學習而寫作</h3><p>因此，有效的閱讀要寫筆記。藉由寫筆記留下內容與思考的紀錄，之後撰寫文章便不需要回顧原始資料，還可以累積寫作的素材。例如這篇文章即是我讀了不同來源資料的筆記彙整出來的。  </p>
<h2 id="寫作兼具思考和表達兩種功能"><a href="#寫作兼具思考和表達兩種功能" class="headerlink" title="寫作兼具思考和表達兩種功能"></a>寫作兼具思考和表達兩種功能</h2><h3 id="寫作既是表達的媒介，也是協助思考的工具"><a href="#寫作既是表達的媒介，也是協助思考的工具" class="headerlink" title="寫作既是表達的媒介，也是協助思考的工具"></a>寫作既是表達的媒介，也是協助思考的工具</h3><p>在說明心態問題前得先釐清寫作的兩個功能。首先，寫作是傳達觀念的媒介，亦即寫作是表達的工具。但寫作有另一種身分，寫作是協助思考的方式，或著說，<strong>寫作其實是思考的一部份</strong>。  </p>
<p>因為這兩種功能的差異，所以儘管許多人曾碰到寫文章卡住的問題，仍有些編輯主張沒有寫作瓶頸這回事。因為從寫作即是思考的觀點而言，寫作之於思考有如呼吸之於跑步，跑步覺得有些吃力的時候，不該歸究於呼吸障礙而停止呼吸，應該專注於調整呼吸才對。寫作時亦然，想<strong>不到該寫什麼的時候，不應輕易中止寫作，反而要設法用寫作解決問題。</strong>  </p>
<h3 id="透過寫作思考的好處"><a href="#透過寫作思考的好處" class="headerlink" title="透過寫作思考的好處"></a>透過寫作思考的好處</h3><p>但為什麼寫作能夠協助我們思考並解決寫文章卡住的問題？首先，我們很難不依賴具體的東西把事情想清楚，例如在跟人說話的同時比劃手勢，或是利用紙筆和公式協助數學運算。因此，在寫不出東西的時候更要利用寫作呈現思考的過程，讓大腦主動思考，集中思緒在主題上，以免不同的想法在腦中衝撞，最後只剩下美食、假期和旅遊等無關事物。  </p>
<p>此外，我們的大腦無法一次處理太多事物。寫作留下的紀錄可以讓我們追溯思考的路徑，並依此延伸新想法，繼而組織文章的架構。  </p>
<h3 id="以寫作（思考性寫作）解決寫作（表達性寫作）問題"><a href="#以寫作（思考性寫作）解決寫作（表達性寫作）問題" class="headerlink" title="以寫作（思考性寫作）解決寫作（表達性寫作）問題"></a>以寫作（思考性寫作）解決寫作（表達性寫作）問題</h3><p>綜上所述，<strong>當我們寫文章卡住的時候，其實是用於表達的寫作中止了，但用於思考的寫作應持續進行</strong>，利用自由書寫等方式呈現把所想的內容保留在文字。如此一來，既推進了寫作的進度，也累積了一些文章的素材。  </p>
<p>##完美主義的心態問題</p>
<h3 id="最好是更好的敵人"><a href="#最好是更好的敵人" class="headerlink" title="最好是更好的敵人"></a>最好是更好的敵人</h3><p><strong>完成永遠比完美更重要</strong>，因為任何事都不可能完美，我自己寫作時經常犯完美主義的問題。以我部落格人氣最高的那篇文章為例，那篇就是完美主義的產物。你稍微看一眼可能會感到疑惑：「完美主義？可是那篇用字紊亂而且格式也歪掉了耶？看起來不是很完美啊！」  </p>
<p>沒錯，這就是完美主義的的下場。在撰寫開頭時便字斟句酌，隨後每寫一個字要反覆修改半天，這樣子不僅離完成遙遙無期，還會因為過分在乎細節，反而分不清文章各段的價值，忽略整體的優劣。截止日接近的時候，在匆忙之下也沒有時間充分的修改，最後不得不發布未經潤飾的最新版，而不是理想中的最佳版。  </p>
<h3 id="化解完美主義的心理暗示"><a href="#化解完美主義的心理暗示" class="headerlink" title="化解完美主義的心理暗示"></a>化解完美主義的心理暗示</h3><p>既然完美主義是心理問題，那解決問題的方式就是改變心態，以下是幾個在寫文章前可以提醒自己的事情。  </p>
<ul>
<li><p><strong>其實沒有人在乎你寫了什麼</strong>：我的網站雖然意在吸引那些潛在的同儕或貴人，但其實每天點進來的人真的很少，為了一兩個字或一句話搞些有得沒的實在不值得。</p>
</li>
<li><p><strong>其實也沒有人會好好看文章</strong>：其實我寫完文章的時候都會寄給朋友或老師看，他們未必對內容有興趣，即使有興趣也不會一個字一個字看，所以別太在乎一兩個字的差異。</p>
</li>
<li><p><strong>其實寫文章也沒什麼了不起</strong>：雖然寫了部落格記錄學習歷程，面試還是被嘴沒有實際作為實踐理想，在學校也不會因為多寫了什麼被打高分。所以與其寫得字字珠璣，還不如白話地寫出自己的見解，幫助自己才是寫作的初衷。</p>
</li>
<li><p><strong>其實在乎的事情可能是垃圾</strong>：寫文章不免來回增刪好幾次，要怎麼知道目前寫的那段是不是垃圾？只有寫完初稿才知道。所以不痛快下筆完成文章，有可能就是在垃圾堆裡面反覆撿拾垃圾，還以為自己很用心。</p>
</li>
<li><p><strong>其實沒寫完就是零</strong>：我的電腦裡還躺有好多文稿和寫作計畫，大腦裡也一直浮現新的點子和想法，但是沒寫出來誰也不知道有這些東西。你看，李嚴又帥又強，炸蝦讓人在電視前看了都想吃，結果少了收尾的醬汁還是被小當家打臉。</p>
</li>
</ul>
<p>當然寫這些不代表說寫文章是一文不值，文章累積起來還是很可觀的，只是要調整心態，畢竟寫完才有修改的空間。  </p>
<h3 id="在輕鬆的媒介寫作"><a href="#在輕鬆的媒介寫作" class="headerlink" title="在輕鬆的媒介寫作"></a>在輕鬆的媒介寫作</h3><p>除了心理暗示，也可以<strong>改變寫作的媒介降低完美主義的顧慮</strong>。大家應該有類似的經驗吧，新學期發了新課本，擔心頁面被弄髒不敢翻頁不敢做筆記，但讀二手書的時候怎麼劃記都不心疼。  </p>
<p>寫作也是一樣，當坐在高級辦公室、高級椅子、蘋果電腦、高品質文書編輯軟體前鄭重地打開文件卻寫不出字來時，不妨用隨便的態度看待寫作這件事，用廢紙、新文字文件等看起來很廉價的媒介去寫，寫爛了也不在乎，反而能擺脫完美主義的魔咒。這篇文在用電腦編輯前，即是在印壞的影印紙上擬出來的。  </p>
<p>或是找朋友聊天，即使朋友無法給出回饋，只要他能作為自己的聽眾便有助於克服完美主義的障礙。使用臉書、LINE 或 Instagram 等能記錄文字的通訊軟體聊一聊寫作主題，也順便留下草稿紀錄。我的經驗是，在對方不懂主題的情況下，自己為了裝出一副厲害的樣子便會大放厥詞，反而無意間寫出許多有價值的東西。  </p>
<p>如果沒有朋友，自己在紙上或社群網站開一則小文章自我對話也是不錯的選擇。想想平時在 PTT 或臉書發廢文的時候文思泉湧，但開 word 寫文章卻處處制肘，恐怕是社群平台本來就鼓勵大家發表沒路用的想法，在上頭可以在這種氛圍下擠出字來。  </p>
<h3 id="以截止日督促自己行動"><a href="#以截止日督促自己行動" class="headerlink" title="以截止日督促自己行動"></a>以截止日督促自己行動</h3><p>除了降低期待，設下截止日也是化解完美主義的必要方法。人都很浪漫的，如果沒有截稿日提醒現實的殘酷，也許還會以諾貝爾文學獎為目標慢吞吞地寫文章。藉由設下截稿日，讓自己意識到生存的危機，便不會浪費青春去雕琢一部大作了，從而腳踏實地展開行動。  </p>
<h2 id="工作負擔的心態問題"><a href="#工作負擔的心態問題" class="headerlink" title="工作負擔的心態問題"></a>工作負擔的心態問題</h2><h3 id="因為看不到完成的一天而拖延"><a href="#因為看不到完成的一天而拖延" class="headerlink" title="因為看不到完成的一天而拖延"></a>因為看不到完成的一天而拖延</h3><p>「完蛋，我一定完成不了」這是每個決心萬丈高樓平地起，千里始於足下的熱血男兒起步後的第一個念頭，於是整個人癱在電腦前不斷發呆，看似在網站上尋找解決問題的辦法，其實只是在逃避現實，最終在截止日當天被擊倒。  </p>
<p><strong>解決心理負擔的策略即是減少單次的工作量</strong>，例如權衡標題的廣泛性，縮減議題到可處理的範圍，列大綱和細綱將文章分為獨立的單元，利用每天的空閒時間自由書寫，再用完整的時間整合不同的片段形成段落，最後完成文章。  </p>
<h3 id="多少做一點努力"><a href="#多少做一點努力" class="headerlink" title="多少做一點努力"></a>多少做一點努力</h3><p>即使有很重的心理負擔，也不要全然放棄努力。運動、唱歌、爬山、耍廢都無助於完成文章，東摸西摸也不會加速完成的時間，只有專注於文章才有機會成功。因此在信心被擊倒的時候，得加減做些事情，例如調整大綱、加入新的圖片、改善排版、插入引用等等，在等候勇氣恢復的時候為之後寫作的過程減輕負擔。  </p>
<p>真的寫不出來，也可以先寫點其他的文章。此舉可以保持書寫的慣性和動力，讓大腦處在書寫模式，增加完成的文章的信心也順便磨筆頭。  </p>
<h3 id="安排可行的寫作計畫"><a href="#安排可行的寫作計畫" class="headerlink" title="安排可行的寫作計畫"></a>安排可行的寫作計畫</h3><p>安排寫作計畫的快感跟寫完一篇文章一樣，所以不要安於計畫。但有時仍需要可執行且可維持計畫，我自己的經驗是把文章撰寫分為蒐集資料、紀錄筆記、自由書寫、彙整想法、寫草稿、列大綱、撰寫文章、修改與校正等八個步驟，由於大家都不是專職作家，總會有俗務纏身，所以想要立下「今天要完成這篇文章」這種目標往往會失敗。  </p>
<p>因此，<strong>相較於以目標安排進度，用努力的程度來安排進度會比較適當</strong>，例如今天安排花三小時蒐集資料，如果蒐集不完就算了，用僅存的資料先走一步。如果全部流程走完，一篇文章的內容撐不起標題，那改標題即可，不需節外生枝。畢竟已經用努力來安排進度，每段時間都投注了最大的精力，如果只完成這些內容，那也沒有愧對任何人了，驕傲地把標題改小吧。  </p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>寫文章卡住的時候應釐清是源於知識問題還是源於心態問題。如果是知識問題，需要藉由閱讀和學習充實寫作的素材。如果是心態問題，則要逼自己擠出任何文字，直到腦中沒有任何想法，得重新學習為止。  </p>
<p>寫作既是思考的方式也是表達的方式，儘管寫作（表達）碰上障礙，也不要停止寫作（思考），藉由自由書寫呈現想法，保留思考的途徑和內容，將有助於規劃文章內容。  </p>
<p>完美主義和拖延的心態是完成文章的敵人，因此寫作時要降低期待，列大綱劃分文章為數個單元各個擊破。即使碰到障礙也不要輕言放棄，看書寫筆記、調整排版、繪製配圖和修正錯字等工作都有助於減輕之後的負擔。畢竟<strong>沒有克服絕望的方法，耍廢和講幹話只會讓時間流逝，面對寫作瓶頸只有硬著頭皮闖過去才有機會。</strong>  </p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p>Esor Huang (2016)：<a href="https://www.playpcesor.com/2016/04/lifehack-8.html">[LifeHack 8] 先寫再想，激發靈感潛能的心流筆記法</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2016)： <a href="https://www.playpcesor.com/2016/09/help-you-write-something.html">如何開始一場寫作風暴？編輯給任何人寫不出東西時的建議</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2018)：<a href="https://www.playpcesor.com/2018/04/write-plan.html">不要這樣列寫作計畫，幫你不拖延完成論文、書籍與部落格創作</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2019)：<a href="https://www.playpcesor.com/2019/03/write-speed.html">寫作加速法教學，解決寫報告論述文章的截稿壓力與速度瓶頸</a>。電腦玩物  </p>
</li>
<li><p>Mark Levy (2011)：《自由書寫術》。商周出版  </p>
</li>
<li><p>Steve Wallace (2018)：<a href="https://www.editing.tw/blog/progress/%E6%B2%92%E6%9C%89%E3%80%8C%E5%AF%AB%E4%BD%9C%E7%93%B6%E9%A0%B8%E3%80%8D%E9%80%99%E6%AA%94%E4%BA%8B.html">沒有「寫作瓶頸」這檔事</a>。華樂絲學術寫作部落格  </p>
</li>
<li><p>李連江 (2018)：《如何進行學術寫作．在學術界謀生存》。香港中文大學出版社  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E6%9C%9F%E6%9C%AB%E5%A0%B1%E5%91%8A%E8%87%AA%E6%95%91%E6%B3%95-%E5%AF%ABpaper-%E5%AF%AB%E8%AB%96%E6%96%87-%E5%AF%AB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E6%80%8E%E9%BA%BC%E8%BE%A6-add4ebb2c827">便秘：寫paper，寫碩論，卡住怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E5%8E%BB%E9%9A%94%E5%A3%81%E5%81%B7%E8%8F%9C-%E8%AE%80%E6%9B%B8%E5%8D%A1%E4%BD%8F-%E5%AF%AB%E5%AD%97%E5%8D%A1%E4%BD%8F-%E6%80%8E%E9%BA%BC%E8%BE%A6-1f6cf064c324">去隔壁放鬆：讀書卡住、寫字卡住，怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>英論閣學術論文編修 (2018)：<a href="https://www.enago.tw/academy/%e7%aa%81%e7%a0%b4%e5%af%ab%e4%bd%9c%e7%93%b6%e9%a0%b8%e6%9c%89%e5%85%b7%e9%ab%94%e6%96%b9%e6%b3%95%e7%9a%84%ef%bc%81/">突破寫作瓶頸有具體方法的！</a>  </p>
</li>
<li><p>畢恆達 (2005)：《論文寫作症候群：寫作心理 ．教授為什麼沒告訴我》。學富文化  </p>
</li>
<li><p>彌糧糧 (2012)：<a href="https://paste.plurk.com/show/WypPD1CYUH0MqpNAQ7b8">大家都有寫報告寫心得寫論文寫文章卡稿的經驗吧？</a>。Plurk paste 彌糧糧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>academic</category>
        <category>writing</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>寫科普又不能當飯吃，為什麼還要寫？</title>
    <url>/why-do-people-write-scientific-articles/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文是 Mitalk 4 講座「科普如何當飯吃？」的聽講心得，陳俊堯老師在演講一開始先回答了這問題，再一一告訴我們，如果無法靠寫科普賺錢營生，那麼從事研究的學生、老師和學者們，到底有什麼理由勞心費神去寫科普文？</p>
<blockquote>
<p>科普如何當飯吃？做夢吧，科普怎麼可能當飯吃。</p>
</blockquote>
<span id="more"></span>

<h2 id="科普不能當飯吃，為什麼還要寫科普？"><a href="#科普不能當飯吃，為什麼還要寫科普？" class="headerlink" title="科普不能當飯吃，為什麼還要寫科普？"></a>科普不能當飯吃，為什麼還要寫科普？</h2><h3 id="即使無法靠科普吃飯，也能藉由撰寫科普成長"><a href="#即使無法靠科普吃飯，也能藉由撰寫科普成長" class="headerlink" title="即使無法靠科普吃飯，也能藉由撰寫科普成長"></a>即使無法靠科普吃飯，也能藉由撰寫科普成長</h3><p>老師提到，他的著作《細菌好朋友》雖然囊括許多獎項，但半年的銷量折算為利潤後僅得兩萬餘元。既然連成功的出版品都無法為作者帶來財富，那研究生為什麼要勞費心力撰寫更冷門的科普文章？</p>
<p>儘管老師提及科普能促進跨領域對話、增進國民素養或支援科學教育，但先不論寫科普的外部效益，書寫本身就是一種有效的學習方式。</p>
<p>很多時候我們不是懂了才開始寫作，而是從蒐集資料、提煉知識和撰寫文章的過程中，逐漸了解想要傳達的事物。具體的文字能協助我們察覺思路不嚴謹之處，而寫作瓶頸則讓我們意識到知識的空缺。因此，即使我們無法憑藉科普營生，也能從撰寫中成長。</p>
<h3 id="研究員也能為自己的愛好發聲"><a href="#研究員也能為自己的愛好發聲" class="headerlink" title="研究員也能為自己的愛好發聲"></a>研究員也能為自己的愛好發聲</h3><p>但是，當今有許多科普網站和知識型 Youtuber 向大眾導讀論文和破解迷思，那麼研究員還有必要跳進來寫科普嗎？若想要自我成長，為什麼不寫在筆記本上就好了？</p>
<p>首先，學術需要政府與社會支持，研究員不能總是期待他人為研究議題發聲。以新視野號任務為例，由於美國政府的漠視，探索冥王星始終不是太空任務的優先目標，即使獲准執行，其預算也接連被削減。</p>
<p>為此，志在研究冥王星的 Alan Stern 只得想盡辦法遊說國會，並發起請願以尋求大眾支持。最終，新視野號任務總算排進了正式的探索行程中。雖然不能把任務的成功完全歸功於科普，但這項案例告訴我們：若研究員能為了自己的好奇心而發聲，嘗試去說服他人，那麼確實有機會將個人的願望推廣為大眾的願望。</p>
<p>在說服大眾方面，科普文章是性價比很高的工具。儘管影視寓教於樂，但研究員恐無暇製作。相較之下，寫作的成本低廉還能傳遞最多資訊。內容確實且題材多樣的文字材料，可作為其他科普媒介發展的基礎，擴張文章的影響力。</p>
<h3 id="不輕易將話語權讓給不懷好意的人"><a href="#不輕易將話語權讓給不懷好意的人" class="headerlink" title="不輕易將話語權讓給不懷好意的人"></a>不輕易將話語權讓給不懷好意的人</h3><p>教育家不是唯一對科普感興趣的人，還有濾水器廠商、智慧設計學家、政客等不懷好意的人也等著扭曲科學事實以支持他們的主張。因此，即使認為教育普羅大眾沒什麼益處，研究員也是較有立場和專業去維護科學的理性客觀價值。</p>
<p>相關案例在同婚公投期間層出不窮。護家盟為了表達反同立場，除了引用爭議性研究以外，還任意曲解其他學者經過長年研究和同儕審查得出的嚴謹結果。即使是研究人員本身，也會受到政治立場影響，做出有瑕疵的研究。</p>
<p>鑒於這些情形，研究員就算不為積極的理由寫作，也有動機為消極的理由發聲，以免研究成果為人利用，最後損及大眾對科學的信任。</p>
<h3 id="科普文章是經驗交流的管道"><a href="#科普文章是經驗交流的管道" class="headerlink" title="科普文章是經驗交流的管道"></a>科普文章是經驗交流的管道</h3><p>最後，撰寫科普也能協力國內的科學教育發展。儘管推動雙語教學的風氣日盛，中文始終是最便捷的語言。但除了有限的翻譯書籍和科普網站，國高中生欠缺可靠的中文資料，架構完整而且內容正確的中文科普文章可以填補這個空缺。</p>
<p>我認為，即使是研究生也能受益於科普寫作。相較於國外林立的論壇，台灣的網路學術經驗交流很封閉，許多技術細節和科研心得埋藏在碩博士論文、實驗室內網或私密社群裡，以至於解決問題的經驗無法共享和傳承。</p>
<p>可是，國外既有成熟的討論區，為何執意要促進我們自己的交流風氣？首先，多數人的中文優於英文，故以中文撰寫文章較能準確表達觀念。再則，即使面對同樣問題，解決辦法與說明方式也因人而異，多元的內容能惠及不同程度和背景的群眾。</p>
<p>是以，撰寫科普文章不僅能彙整思路和鞏固知識，也能保留思考的成果，幫助他人解決困難。由於互助的效益會隨參與人數增加，所以即使費時耗力也值得投資。</p>
<h2 id="那麼該如何撰寫科普文章呢？"><a href="#那麼該如何撰寫科普文章呢？" class="headerlink" title="那麼該如何撰寫科普文章呢？"></a>那麼該如何撰寫科普文章呢？</h2><h3 id="科普、課本和論文的差異在於受眾"><a href="#科普、課本和論文的差異在於受眾" class="headerlink" title="科普、課本和論文的差異在於受眾"></a>科普、課本和論文的差異在於受眾</h3><p>由於科普、課本和論文的目的皆為有效傳達訊息，優良的著作皆具有趣、簡潔和明瞭等特性。然而，三種文體的受眾不一，所以各自側重不同特性。論文的讀者是學者，所以旁徵博引、言簡意賅；課本的讀者是學生，因此體系完整、內容詳盡。</p>
<p>至於科普的讀者，則是任何有興趣的大眾。是以，科普雖然像論文一樣報導新知，卻不能吝於用字；科普也跟課本一樣具有理解新知所需的背景知識，卻不應填塞無關的資訊。除了話不能省和料不能多，科普文章要能製造驚奇以取悅讀者。</p>
<h3 id="撰寫科普的第一步是選定讀者"><a href="#撰寫科普的第一步是選定讀者" class="headerlink" title="撰寫科普的第一步是選定讀者"></a>撰寫科普的第一步是選定讀者</h3><p>讀者的年齡、背景和興趣攸關選材、用字和敘事風格。因此，撰寫科普文章的第一步是選定讀者，接著推測讀者想讀的內容，尋找具有衝擊性的主題。至於該怎麼寫，可以參考老師提出的「派大星貓一拳結構」。</p>
<p>每一篇科普都是一場冒險，文章開頭要建立現實與科學之間的橋樑，吸引讀者踏入作者營造的奇妙世界。例如，想要介紹趨化性 (chemotaxis)，可以從「撲鼻而來的雞排味」寫起，利用與主題相關的生活經驗，讓讀者對內容有具體的概念，也讓他們了解自己與主題的關係。</p>
<p>好的故事需要鋪陳，重要觀念也有其前提，所以破題之後先別切入重點，要交代問題和背景知識。例如經典的回馬槍結構：提問以後，先順應大眾的常識推論，接著點出先前敘述的矛盾，讓讀者在觀念衝突之下，迫不及待想要知道答案。</p>
<p>鋪陳以後迎來故事的高潮，要把想傳達的科學概念清楚明瞭地寫出來。最後則要總結文章，再次連結主題和生活經驗，把讀者送回現實。而更多寫作結構的細節，老師推薦我們讀讀《怎樣談科學》。</p>
<h3 id="撰寫科普的訣竅"><a href="#撰寫科普的訣竅" class="headerlink" title="撰寫科普的訣竅"></a>撰寫科普的訣竅</h3><p>寫作時請留意，科普讀者只是還沒學到相關知識，而不是欠缺理解能力。因此，要簡化內容，但不要藐視讀者（例如對著國小學生用）。</p>
<p>其次，儘管寫作時要交代背景知識，並且陳述推理的過程，但用字仍要力求簡練，以免花俏或冗贅的字眼模糊焦點。老師強調「話不能省」是指邏輯不要跳躍，而不是用繁複的文字困擾讀者。</p>
<p>最後，撰寫文章是學習的過程，所以開始動筆時對主題沒有完整的理解仍可以接受。然而在交付文章之前，要再三確認自己已經搞懂，以免寫出似是而非的奇怪內容。</p>
<h2 id="該如何練習寫科普？"><a href="#該如何練習寫科普？" class="headerlink" title="該如何練習寫科普？"></a>該如何練習寫科普？</h2><h3 id="所謂寫作，就是空出時間寫作"><a href="#所謂寫作，就是空出時間寫作" class="headerlink" title="所謂寫作，就是空出時間寫作"></a>所謂寫作，就是空出時間寫作</h3><p>所謂寫作，就是空出時間寫作。他人整理的訣竅得在練習中實踐，障礙和困難也只有在實作中才能體會。而且，文章完成後才有被閱讀和被修改的機會，因此，老師在建議大家，聽完演講以後趕快找一則論文試試看。</p>
<h3 id="以改寫培養寫作能力"><a href="#以改寫培養寫作能力" class="headerlink" title="以改寫培養寫作能力"></a>以改寫培養寫作能力</h3><p>如果真的不知道怎麼寫，可以從改寫起步。首先熟讀感興趣的論文，再擷取核心觀念以中文重述（若想要省事也可以直接從摘要開始改寫）。</p>
<p>接著，思考想傳達給讀者的訊息，開始移除不必要的內容。例如在介紹飲食跟腸道微生物關係的文章裡，不需要用大半篇幅解釋 PCA ，重點是讓讀者明白吃肉的人吃素的人，腸道裡的微生物有什麼差異。</p>
<p>由於術語、抽象詞和簡稱會造成困惑，所以可以用代稱、範例和比喻等技巧減輕讀者的負擔。例如以下這段截自維基百科的句子便含有許多難解的詞彙：</p>
<blockquote>
<p><strong>枯草桿菌（學名：Bacillus subtilis）</strong>，是<strong>芽孢桿菌屬</strong>的一種細菌，為<strong>革蘭氏陽性</strong>的好氣性菌，普遍存在於土壤及植物體表，在人體亦可發現在腸道內共生的枯草桿菌。型態上的主要特徵是菌體表面生有<strong>鞭毛</strong>，體內形成的<strong>內生孢子</strong>可抵抗惡劣的外在環境而存活。</p>
</blockquote>
<p>可以改寫為：</p>
<blockquote>
<p>人的肚子裡住著一群長條狀的細菌，叫做 Bacillus subtilis ——就叫它 B 細菌吧。 B 細菌身上有條尾巴，所以可以在肚子裡游來游去。</p>
</blockquote>
<p>在改寫版本裡，用「肚子裡住著」來解釋「共生」（比喻），用 B 細菌替代 Bacillus subtilis 減輕讀者對英文的恐懼（代稱）卻不損害本意。最後以游泳為例，說明鞭毛的功能（範例）。此處用尾巴比喻鞭毛可能造成誤解，所以可以補充鞭毛的照片給讀者正確的印象。</p>
<p>改寫後，能用「因為」、「所以」、「但是」等連接詞完善文章的架構，讓讀者了解此段的用意和前後文關係。而且要顧及讀者的注意力和記憶力，適時總結內容或插入圖片以調整閱讀節奏。</p>
<p>綜上所述，透過改寫培養寫作能力的流程就是：閱讀文獻、決定要旨、篩選內容、改寫文句、理清句子關係、安插小結與圖片。接下來就能分享成品給其他人看，再從回饋中改進自己不足之處了。</p>
<h3 id="可以在哪裡寫科普？"><a href="#可以在哪裡寫科普？" class="headerlink" title="可以在哪裡寫科普？"></a>可以在哪裡寫科普？</h3><p>寫文章難，找到讀者更難，讀者願意給意見則難上加難。儘管讀者的回饋可以促使作者成長，但寫作初期不容易找到知音，此時可以投稿科學月刊、泛科學和科普寫作網路平台等媒體，在與編輯來往的過程中學習。（即使被退稿，也能了解自己與已出版著作的差異。）</p>
<p>除此之外，社群網站也是分享文章的管道。許多組織都會利用社群網站傳遞消息，所以作者也能利用臉書或推特宣傳作品。然而社群媒體適合宣傳，卻不適合保存知識。簡言之，這些網站的內部檢索不友善，對搜尋引擎的支援也不佳，所以不易取用裡頭的資訊。</p>
<p>所以，我認為在個人網頁寫作然後用社群網站推廣，是兼顧知識保存和即時交流的好方法（也可以利用 medium 這樣結合寫文和社交的平台）。而這種方式也非新鮮事，因為在軟體工程的圈子裡，透過撰寫技術文章來自我提升已是常態。</p>
<p>當然，寫作除了養成能力以外，也是建立個人知識品牌的手段。想知道在熟練科普寫作以後，要怎麼拓展自己發言的份量，老師推薦我們讀《知識內容寫作課》。</p>
<h3 id="科普不是終點"><a href="#科普不是終點" class="headerlink" title="科普不是終點"></a>科普不是終點</h3><p>演講後，有同學請教老師怎麼避免想要解釋的衝動。的確，為了達到普及的效果，科普不免要犧牲文章的精確性，所以身為作者，有時難以克制更正內容的渴望。然而，溝通的效率不在於作者說了什麼，而在於讀者接收了多少。如果詳實的說明阻礙交流，那麼科普便喪失其意義了。</p>
<p>不過即使有意掌握文章的深度，初學者該怎麼判斷什麼應該寫進文章呢？老師指出，最好的方式就是在讀者的回饋中養成品味，所以再次強調，寫作的訣竅是練習。</p>
<p>更重要的，科普不是終點，科普的目標在於承先啟後。讀者終究要放下科普，拿起課本或期刊論文，踏入嚴肅而且冷漠的科學世界。科普作者的職責是為自己的言論負責，在告訴讀者瑰麗想像的同時，也要說明當前研究的限制。因此，只要留下足夠的參考資訊，讀者就能在往後的學習中，逐漸了解當初作者想方設法要告訴他們的，是科學的哪一面。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>即使無法以科普謀生，也值得為了提升能力、宣揚理念與捍衛自己的研究寫作。科普的特性是寫實、有趣和淺顯，寫作前可鎖定讀者以安排內容深淺和用字風格。科普文章也像故事，需要破題和鋪陳，欲傳達的知識若在故事的高潮細述，有助於讓讀者在讀畢後回味無窮。</p>
<p>行文時要留意，內容簡化不代表裝可愛，用字盡可能周詳而不冗贅，抱著分享而非炫耀的心態。吸引讀者之後，若能保持他們的注意力，移除無關或令人困惑的內容，可以大幅增加文章的可讀性。完成作品後可以投稿或刊登在自己的網站上，利己也利人。</p>
<p>若擔心簡化的內容會誤導讀者，可以用註記或參考資訊補充說明。畢竟科普的目的是引領讀者踏入科學世界，只要留下足夠的延伸資訊，讀者終究能從比喻中習得事實。</p>
]]></content>
      <categories>
        <category>academic</category>
        <category>writing</category>
      </categories>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>「It&#39;s MyGo!!!!!」太好看了八😭</title>
    <url>/why-should-we-watch-bangdream-its-my-go/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>「It’s MyGo!!!!!」太好看了八😭😭😭，這部和「放學後的昴星團」一樣，是應取代雅量與鄭伯克段於鄢，納入國民義務教育的作品。</p>
<span id="more"></span>
<p>動畫標題的含義是「迷路的孩子」，講述一個樂團解散後，曾經的成員與愛慕虛榮的轉學生在組織新樂團時，發生種種得面對各自過往創傷的故事。</p>
<p>在卡牌動畫裡，沒有什麼爭端是「決鬥」不能解決的；在超級機器人的世界觀，最終的命運往往要靠「合體」來決定；至於在樂團作品，上了台，「音樂」就是對一切的回應。</p>
<p>儘管「It’s MyGo!!!!!」靠音樂的感染力掩飾掉部分生硬的情節轉折。我覺得這部作品仍然可貴的理由在於，編劇並沒有因為主題是迷茫，就為了推動情節而向觀眾許諾一個有解的宇宙。</p>
<p>到了故事尾聲，角色的目標與方向不見得較開始時清晰明朗，反而還有更多不甘、愧疚、困惑與說不清的苦楚。</p>
<p>苦、茫與惑這些字眼從甲骨文保留到當代未曾消失，就像現實中冰會融、雨會下一樣自然，繞了一大圈仍回到原點的事情也屢見不鮮。</p>
<p>然而，如同動畫專輯封面所呈現，角色歷經了這麼多，雖然雨還在下，但他們已曉得撐傘。即使在熱力學主宰的世界裡，「冰塊融化後，還是會有像水一樣留下的東西」，也因為存在摩擦，邁向原點的曲折路上依然能發（不可見）光發熱。</p>
<p>在動畫第十集插曲MV的最後畫面，新成立樂團的五位成員在舞台上的站位，對應著團名的首字母，也象徵著仙后座的形象。找齊仙后座的五顆星，便能在茫茫星河之中，找到指引著方向的北極星。</p>
]]></content>
  </entry>
  <entry>
    <title>凝視太陽 — 學習面對死亡也是學習自由</title>
    <url>/yalom-2008-staring-at-the-sun/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自我意識是人類最珍貴的特質，但伴隨著思考能力而來的，卻是對消亡的恐懼。雖然嬰兒在出生時沒有被灌輸死亡的觀念，但從季節更迭、花開花謝和親人離世等跡象中，他們也會留意到，有些東西會因某個原因「永遠消失」。</p>
<p>隨著成長，不祥的事例逐漸累積心中。儘管一開始可能無法理解，但從大人的反應，孩童也知道這些現象不會是好事情。一旦他們意識到自己終將面臨相同的命運，孩童的生活便蒙上了死亡的陰影。</p>
<span id="more"></span>

<h1 id="凡人的傷痛"><a href="#凡人的傷痛" class="headerlink" title="凡人的傷痛"></a>凡人的傷痛</h1><p>面對兒女萌生的死亡焦慮，父母往往把孩童的注意力轉移到奇幻故事、宗教寓言或是遙遠的未來，試圖脫離這個不吉利的話題。然而這些舉動雖然能讓孩童暫時淡忘，卻沒辦法把死亡逐出他們的腦海。死亡焦慮在青少年時期會沒入潛意識中悄悄作祟，使人們做出瘋狂的舉止以在行動中證明自己的存在。</p>
<p>不過，輕狂的歲月是短暫的。隨著出社會，人們將面臨社會壓力和成家立業的負擔，忙碌取代幼年的敷衍想像和青年的瘋狂舉止，掩蓋我們對於死亡的恐懼。</p>
<p>不過等到退休賦閒且兒女離家時，自己也年過半百。此時，我們再沒有能擺脫死亡的手段，只能直視它步步逼近。</p>
<h1 id="辨識死亡焦慮"><a href="#辨識死亡焦慮" class="headerlink" title="辨識死亡焦慮"></a>辨識死亡焦慮</h1><h2 id="死亡焦慮確實存在"><a href="#死亡焦慮確實存在" class="headerlink" title="死亡焦慮確實存在"></a>死亡焦慮確實存在</h2><p>受到佛洛伊德去死亡化的精神分析模式影響，死亡焦慮往往被視為其它種焦慮的替身。然而作者歐文．亞隆認為，死亡焦慮確實存在，只是因為隱匿得難以察覺，才會和其他焦慮混淆。</p>
<p>在死亡的陰影中，人們難以享受當下的愉快。細查那些沒來由的焦慮，很可能追溯到個體對死亡的不安，如果心理治療師沒辦法辨識恐懼的根源是什麼，便無法有效改善諮商對象的狀況。</p>
<p>所以這本書將從鑑別死亡焦慮開始，討論我們恐懼死亡的緣由，接著引用賢哲的智慧和作者的經歷，指出死亡不足懼的原因。最後提出正視死亡並緩解焦慮的可行手段，以幫助讀者度過充實的人生。</p>
<h2 id="死亡焦慮的形式"><a href="#死亡焦慮的形式" class="headerlink" title="死亡焦慮的形式"></a>死亡焦慮的形式</h2><p>如前所述，死亡焦慮可能偽裝成不同形式。有的人陷入購物瘋狂，有的人則在晚年迷上化妝，有的人擔心自己的事業會一夕間崩解，在這些案例裡，造成焦慮的行為實際上是諮商對象擺脫死亡陰影的途徑。</p>
<p>例如過分在意外表而一再補上濃妝的人，或許不是求偶焦慮，而是擔心在鏡面上顯露老態，讓自己意識到死亡的逼近。而對事業的擔憂，也是因為事業反映了諮商對象的存在價值，如果寄託的事物瓦解，那麼自己也不得不面對消亡的事實。</p>
<p>另外有些人在年紀輕時不願去同學會，但在年老時又樂於出席社交場合。因為這樣的場合讓他們想起年輕歲月，在交流中彷彿又能重新擁有對於刺激生活的夢想與期待。</p>
<h2 id="死亡焦慮怎麼現身？"><a href="#死亡焦慮怎麼現身？" class="headerlink" title="死亡焦慮怎麼現身？"></a>死亡焦慮怎麼現身？</h2><p>死亡焦慮之所以隱晦，是因為日夜笙歌的假象和案牘勞形的無暇都能讓我們暫時把注意力移到求生。然而我們賴以維持理智的人事物也有其壽命，不可能永遠隔開我們與死亡。</p>
<p>以父母過世為例，我們的痛苦不只是因為離別的哀傷，也是因為再也沒有人能擋在我們與死亡之間，我們得獨自面對死亡的憂鬱。</p>
<p>除了保護者離世讓人意識到自己的死亡，其他威脅到生命、意識到沒有明天、感受時間流逝、體會到老化、察覺到傾頹等人事物也會讓死亡焦慮現身。</p>
<p>雖然死亡焦慮是令人不安的經驗，可是一旦現身，便是我們嘗試面對與疏解的機會。</p>
<h1 id="為什麼害怕死亡？"><a href="#為什麼害怕死亡？" class="headerlink" title="為什麼害怕死亡？"></a>為什麼害怕死亡？</h1><h2 id="死亡：我們害怕自己對死亡的想像"><a href="#死亡：我們害怕自己對死亡的想像" class="headerlink" title="死亡：我們害怕自己對死亡的想像"></a>死亡：我們害怕自己對死亡的想像</h2><p>有些人害怕的是死亡本身和死後的痛苦。相信神的人擔憂最終的審判，不相信神的則害怕亡故後永遠困在不可知的黑暗。這些害怕是源於我們對死亡的想像，因此作者認為需要在觀念上轉變解決。</p>
<p>伊比鳩魯認為死亡是阻礙享樂的主因，也是痛苦的根源。他提出三項克服死亡恐懼的觀念：首先，靈魂將滅，所以不需要害怕死後迎來的懲罰和審判。其次，自我在死亡那剎即消失，我們根本意識不到死亡，也不必憂慮屆時是否懊悔、是否孤獨與寂寞。最後，生死對稱，死後如同出生前，不必抱著特別或驚恐的眼光看待。</p>
<p>換句話說，我們必須理解到死亡和死後本身不可懼，因為那時已經沒有我們的事了。</p>
<h2 id="無意義：害怕死亡讓一切喪失意義"><a href="#無意義：害怕死亡讓一切喪失意義" class="headerlink" title="無意義：害怕死亡讓一切喪失意義"></a>無意義：害怕死亡讓一切喪失意義</h2><p>然而理解死亡本身不可懼，不代表能抵禦死亡為世間一切帶來的無意義感。可曾有過一種顫慄經驗？也就是在面對廣袤無垠的宇宙，感受到自己的渺小，繼而對存在的意義起了懷疑。</p>
<p>然而意義實際上與尺度無關，也與其存在的時間無關。事物之所以有意義是因為它們令人驚艷，而不是它們很顯眼或是能否在往後重現。</p>
<p>作者引用佛洛伊德的論述，解釋美不會因其終將消逝而失去價值，重點在於美在當下帶來的感受。我們存在的意義也是一樣，和肉體或靈魂是否永垂不朽無關，只要曾激起他人心中的波瀾，曾惠澤家人朋友乃至不相識的人，我們在世界的一切便有其意義。</p>
<h2 id="孤獨：害怕死亡帶來的終極隔絕"><a href="#孤獨：害怕死亡帶來的終極隔絕" class="headerlink" title="孤獨：害怕死亡帶來的終極隔絕"></a>孤獨：害怕死亡帶來的終極隔絕</h2><p>孤獨有兩種，一種是人際關係上的孤立，另一種則是個人與世界的隔絕。第二種孤獨是死亡之所以讓人害怕的原因，我們自嬰兒起不斷為自己的獨立性奮鬥，想要與他人區隔，想要自主活動。但是我們又苦於死亡帶來的毀滅，所以嘗試與他人連結，這就是生與死的焦慮。</p>
<h1 id="存在性焦慮的改善方法"><a href="#存在性焦慮的改善方法" class="headerlink" title="存在性焦慮的改善方法"></a>存在性焦慮的改善方法</h1><p>總結恐懼死亡的原因，除了死亡本身，其實可以追溯到更深層的存在性焦慮。作者建議，我們要努力過活克服無意義感，並降低人際孤獨以緩解存在性孤獨。</p>
<h2 id="覺醒經驗：努力過活克服無意義"><a href="#覺醒經驗：努力過活克服無意義" class="headerlink" title="覺醒經驗：努力過活克服無意義"></a>覺醒經驗：努力過活克服無意義</h2><p>死亡給人立下界線，使人因理想挫敗而沮喪；我們應正視至種感覺，試著充實地活著，減少臨走前的遺憾。</p>
<p>作者將種種讓人意識到死亡的事件稱為刺激，而個人在受到刺激後從中頓悟，從原先僅關注生理和世俗層次的日常階段，轉向留意到自身存在意義的本體階段，進而努力活下去的過程，則稱為覺醒。</p>
<p>換言之，我們必須把意義的來源從外在事物轉向自身，以免那些短暫易逝的事物消失後，我們存在的證據也跟著不見。</p>
<h2 id="漣漪效應：透過聯繫緩解孤獨"><a href="#漣漪效應：透過聯繫緩解孤獨" class="headerlink" title="漣漪效應：透過聯繫緩解孤獨"></a>漣漪效應：透過聯繫緩解孤獨</h2><p>古代的陪葬習俗顯漏了人們想抗拒死亡帶來的存在性孤獨——它不僅隔絕人與人的關係，還把死者徹底玻璃這個世界。因此增進與他人的關係，並真誠地陪伴能減緩死亡的寂寞，尤其是為他人帶來恩澤的漣漪效應是對此的最大安慰。</p>
<h1 id="治療師與存在心理治療"><a href="#治療師與存在心理治療" class="headerlink" title="治療師與存在心理治療"></a>治療師與存在心理治療</h1><h2 id="察覺死亡：回憶錄"><a href="#察覺死亡：回憶錄" class="headerlink" title="察覺死亡：回憶錄"></a>察覺死亡：回憶錄</h2><p>此章呼應作者在治療過程中自我袒露的主張，主動分享它自己體認死亡的種種經歷，並且如何克服這種焦慮，寫書在某方面也是其一，它帶來的漣漪是作者最大的安慰。另一部份提到宗教和超自然論述，作者在治療中並不會刻意否定其功效，畢竟病患的福祉仍是最要緊的，可是作者自己並不依賴宗教，它認為宗教並無解決死亡焦慮，只是抹煞了死亡的事實。</p>
<h2 id="給治療師的建言"><a href="#給治療師的建言" class="headerlink" title="給治療師的建言"></a>給治療師的建言</h2><p>作者最後想表達，精神異常其實不只是生理和匱乏等因素造成，對「存在」的疑問也可能是造成絕望的原因。治療師應注意到這方面的問題，並且在與輔導對象的關係中不知不覺引入。</p>
<p>治療雖有理論根據，但過程卻是在與對象建立關係中進行。一段友好關係並非治療的目標，卻是確保過程順利的手段。治療師的工作並非挖掘過往種種或關切未來動向，而是從當下的關係中找尋癥結。每次治療都是人際十彥，能看出對象供述內容外的一手消息，還有他們最真實的反應。所以要留意此時此地，甚至是自己的情緒波動也要利用。</p>
<p>雖然這些主張有違正統，但如果對療程有益的話，適時講解治療遠裡或袒露自我的以增進治療效果</p>
<h1 id="結論與心得"><a href="#結論與心得" class="headerlink" title="結論與心得"></a>結論與心得</h1><p>海德格說：「死亡的定義是不再有任何可能。」</p>
<p>昆德拉說：「死亡最駭人之處不是沒有未來，而是失去過去。」</p>
<p>我想這些說法之間沒有衝突，而是每個人恐懼死亡的原因不同。我大概在七、八歲的時候意識到終將一死，那時聽著自己的心跳聲，我開始思考「萬一停下來了怎麼辦？」，然後我想像著之後的事情，逐漸感到害怕與不安。</p>
<p>直到現在，我仍會在夜深人靜之時突然陷入恐慌。雖然說起來很可笑，但我實在是沒辦法想像一個自己不在，但仍安然運轉的世界。就好像要求一台電腦估算自己關機的速率，人要怎麼在存活的時候想像不存在的狀態？所以對我而言，活著就好像待在時間的監獄一樣，困在時間軸的一小段裡面。</p>
<p>然而如同伊比鳩魯所述，死亡其實與當事人最沒關係，我們實際上更該關注於現世，而不是畏懼自己的想像。畢竟，有形的監牢會限制我們的自由，而無形的枷鎖也會讓我們淪為不自覺的奴隸。除了物質和虛妄的聲名，對於死亡的恐懼也約束著我們的所作所為。如果能夠學習面對死亡，那麼便沒有其他東西可以束縛我們了（生死之間就是在服人類役）。</p>
<p>所以我希望自己能好好過日子，好好與人相處，好好養生，這樣才能降低對死亡的恐懼。無懼死亡不是魯莽送死，而是可以自由地活著。生活中不須擔驚受怕，面對崇高理想時，也能慷慨赴義。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
</search>
