<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>〈教育的烏托邦〉</title>
    <url>/5uperb0y-2016-utopian-education/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>　　夢臨市的天空是電腦的顏色，電腦死機的蔚藍。</p>
<p>　　「人終究會走出自己的路來。」眼前就有一條長廊，路面被通勤者腳步給蝕刻出間格規律的腳印，老表在雜遝足跡中找到屬於他的坑，踩著五十年如一的步伐來到一座有一百三十七層高的藍紅色建築物，正門上方寫著幾個大字：中央教育測驗服務社(CETS)。</p>
<span id="more"></span>

<p>　　大樓坐東朝西，插滿因巨大流量而肥腫的動靜脈，不安、臉色鐵青的孩童比肩繼踵地往內流動，形成樓外粗枝交錯的青筋；從大樓伸出的管道則注滿自信得意面容紅潤的孩童，他們在社會的肝臟中成熟，最終送往社會的大腦、社會的肌肉、社會的腎臟和社會的肛門。</p>
<p>　　夾在地底志留紀筆石與泥盆紀裸蕨間的是大樓負四十二層，適性教育中心。穿過緩衝道是一座兩千公升的儲存槽，槽身有一半被拖入地底，一條條銅線將濃度、溫度與酸鹼值等參數傳入檯座上的監控幕。三架人形機具頂著清潔罩，外披屍白色辨識裝小心繞過儲存槽，全神貫注地把一塊塊磚頭運進隔離室，除了齒輪回應齒輪，這兒就只有攪拌子在槽內轟隆旋轉的聲音。老表的辦公室〈也是諮商室〉就在隔離室隔壁，門旁停靠一台拙夫腳踏車，上頭垂掛著棉製內褲、塑膠護手和一套無塵制服。辦公桌上批不完的公文堆積成山，一份紅色封套的急件從天花板的轉送口墜落砸在山峰，連同一大捆文件從桌沿嘩啦啦沖下，激盪出迷濛霧霾；灑落地面的文件淹沒桌腳氾濫到走道、沙發甚或流進休息室，文件的河流最終在辦公室沖積出一塊纖維平原，失去動能的那封急件恰好在老表腳前沉澱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　﹝機考成績﹞ </span><br><span class="line">　　姓名：灰仔(13,男性)</span><br><span class="line">　　羅格標準智商指數：五十(底標)</span><br><span class="line">　　霍蘭德興趣偏差：正負零點零八六(無取向)</span><br><span class="line">　　柯賽人格氣質量表：？？？(不鮮明)</span><br><span class="line">　　HSF測驗：V項，三十四分；Q項，十五分；AW項，零點五(失能)。</span><br></pre></td></tr></table></figure>
<p>　　「哦喔。」老表打了嗝，往背面翻去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　﹝問卷紀錄﹞</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的志向是什麼？」</span><br><span class="line">　　受測者：「……」</span><br><span class="line">　　訪談者(AI-Ford7th)：「你的興趣是什麼？」</span><br><span class="line">　　……</span><br></pre></td></tr></table></figure>
<p>　　還沒讀完，護理機器人已把這位男孩帶到老表面前。</p>
<p>　　「除了視力、體脂率過高和手指頭長期發炎導致的扭曲外沒有其他問題。」死板的聲音從機殼傳出，在老表點下確認鈕後滑步離開。</p>
<p>　　「灰仔你好，這邊……」老表一面說一面翻找那部可以讓人放鬆的儀器，把一大把文件移開後，終於在散落的紙張下找到。</p>
<p>　　「……這邊坐。」老表指著椅墊，但男孩似乎沒聽見，五感深埋實境頭盔裡，專心敲開磚頭挖出金幣，使勁踩爛長著獠牙又會跑動的香菇，吞下看得見陽光的花朵。</p>
<p>　　老表走上前，輕柔地抓住他的肩膀把實境機的電源關上，小心翼翼地把頭盔拆下，將他引到沙發去。斷離數碼世界，男孩的眼神空洞了十來分鐘才重新聚焦。「是雙機眼。」老表心想。義務教育絕種後，缺少定期眺望黑板休息的機會，無時無刻不死盯著藍光頻幕導致近視加深速度比換眼鏡還快。嫌麻煩的父母索性把歷經億萬年錯亂的達爾文實驗才長出的兩粒珍珠摘下，換上僅三十年歷史的電腦眼球。</p>
<p>　　老表再次拿出那份報告，從第一列掃視起。</p>
<p>　　「什麼時候才可以走？」</p>
<p>　　「一下子、一下子，只要回答幾個問題。」</p>
<p>　　「咦？」</p>
<p>　　「簡單的問題，幫助你找尋自我定位和生涯的目標。」</p>
<p>　　「哦？」</p>
<p>　　「我的意思是回答完你就可以走了。」</p>
<p>　　「哈！」</p>
<p>　　「不花十分鐘。」老表放下報告，安上鬧鐘，用紅筆在公文附錄的磚瓦實業廠職缺表上打勾。</p>
<p>　　「首先，你的志向是什麼？」老表啪嚓啪嚓踏過紙堆，來到門邊腳踏車旁，</p>
<p>　　「我要打電動！」</p>
<p>　　「那你的興趣呢？」把內褲遠遠甩到一邊，從坐墊上拎起無塵防護服抖落上頭的灰塵。</p>
<p>　　「我喜歡打電……」</p>
<p>　　「你的專長是什麼呢？」套上它，檢查外覆層上每個可能的縫隙，</p>
<p>　　「我會打……」</p>
<p>　　「你的理想是什麼呢？」走向儲存槽，把填充瓶注滿金黃色的「霓麻」，</p>
<p>　　「……」</p>
<p>　　「依照你的興趣和能力，我很確定你能把這份工作做好。」</p>
<p>　　老表嘴巴開合著，足像一具發條機器人不合節奏地吐出一個個標點符號。鬧鐘「滴滴滴滴、滴滴滴滴」作響，催促這場對話的結束。</p>
<p>　　「可以……走了？」</p>
<p>　　「是的，灰仔，你會在你喜歡的事物中找到未來。」疲乏的節奏，無力的嗓音。</p>
<p>　　男孩被帶到隔壁的隔離室，房間中央堆著他熟悉的磚頭。隨後門關上，鼓風機運轉，層流吹襲循環整座隔離室。老表熟練地背起噴霧器，一壓一放間，陳舊的幫浦發出哀鳴，噗嘶噗嘶地將霓麻撒在磚上，即使被隔絕在四層纖維之下，老表仍能嗅到那熟悉的甜味。霓麻在近地處積累，慢慢向上蒸騰成雲，最後將燈源與通風口遮住，陰影壓在兩人身上，佐劑和緩衝劑在瀰漫的雲中製造出驚人的化學電光，霓麻蒸發吸收了熱量使得隔離間溫度湊降，冰晶凝結在牆壁、手把、老表與灰仔呆愣的面孔上。飽和，再也容不下更多，氣氛死寂陰冷悲愁憂傷。第一滴雨跌落，兩滴，三滴，四滴，最終化成傾盆大雨，濕透男孩頭髮，衣服，每寸肌膚。</p>
<p>　　「這是什麼，好甜！」</p>
<p>　　老表並沒有回答，他徐步退後，從另一個出口離開。卸去一身負擔，累得轉不開水龍頭，勉強走到休息間把自己摔在床上，使不出拉棉被的力氣，虛弱得只蓋得上眼皮。闔眼前老表透過玻璃窗隱約看見男孩吸吮手指殘餘的霓麻，看他把上衣脫掉，頭承著衣服，雙手用力擰出汁來貪婪吞下。</p>
<p>　　「會找到，」疲憊無力，老表慢慢進入夢鄉「自己的……」</p>
<p>　　擠盡最後一口汁液的男孩注意到一旁疊放的磚頭，被霓麻結晶漆成金黃色，像極價值連城的金塊，他拋開衣服猛然撲上，以不協調的姿勢爬到推疊最高處，舔著，發狂舔著，滿心歡喜地舔著，曾經最愛的實境遊戲機就遺棄在旁。</p>
<p>．　．　．</p>
<p>　　老表從口袋掏出墨鏡戴上避免被星光曬傷，穿著海灘褲塗好防曬油的卡爾薩根乘著幽浮在眼前呼喚「要不要跟我一起同享這個宇宙與世代啊？」於是他開始奔跑，雖然沒有腳，卻有下身長出的兩條右臂。</p>
<p>　　其實也沒有地板，老表是在一條橡皮圈上團團繞，繞出時間的漩渦把他送回十三歲的時候，薩根的臉和適性教育中心的輔導長融合在一起。</p>
<p>　　「小表，你的志向是什麼？」</p>
<p>　　「星……」</p>
<p>　　「那你的興趣呢？」</p>
<p>　　「ㄒ……」</p>
<p>　　「你只是串會思考的芭蕉。」</p>
<p>　　連同蕉皮被丟進廚餘桶，老表依稀聽見幫浦抽放的聲音，感覺到霓麻在舌尖跳動的興奮。外頭年老者在街頭閒晃「高齡比七成，沒人力浪費的空間了。」從跨下傳來主任嚴厲的聲音「把對的人放到對的地方：智商指數頂標和HSF測驗頂標者，是為學者；人格氣質量表領袖類，是為企業家。至於沒有方向或方向錯誤的……失調者，」上班第一天，他坐在主任睿智的禿頭上。「是你的職責。」主任耳朵旁的頭髮將老表兩腿緊緊纏住，將他拖入腦漿中。從眼眶能清楚看到四點三光年外的半人馬阿爾法星，追逐上去！一條條物理公式擋在前頭，攀越直積高牆，撐起積分篙，用範數作筏橫渡空集合，絕對值大道在眼前開展變寬，星，就在不遠的地方。然而，根號勾住衣角，被圓周率絆倒，有理數沉沉壓在背上，從海馬迴、杏仁核與額葉聯絡區襲來的梯度與正則子群刺得他滿身是傷。</p>
<p>　　星星、符號、薩根、空氣漸速遠去，殘影紅移一路散逸微波輻射拖拉了數萬光年。現在這世界到處都是輔導長、主任和被霓麻漆成金黃色的噴霧器，熟悉的甜味周圍飄來，輔導長和主任喋喋不休地說著：</p>
<p>　　「照你喜歡的去做。」</p>
<p>　　「畢竟擅長打鐵卻偏要去念書是個悲劇，也是浪費。」</p>
<p>　　「會在你喜歡的事物中找到未來的。」</p>
<p>　　「輔導，是對失調者的社會救濟。」</p>
<p>　　「小表很適合當輔導師。」</p>
<p>　　 ……</p>
<p>．　．　．</p>
<p>才剛被昨天沒洗的衣服熏醒，老表又躺回去睡。</p>
<p>　　今天是一年一度的「輪休日」，適性中心黑壓壓一片。沒有對未來徬徨的小孩會送來，也沒有新的公文要蓋章，把工作當樂趣的時代，休息就成為義務。</p>
<p>　　這五個月來老表時常夢見符號、公式和掛在天上閃亮亮的東西，醒來後總有股怪異的衝動湧現，他察覺到對噴霧器漸漸失去興趣。起初利用職務之便暗地施用額外的霓麻維持工作的熱情，然而用量卻日益膨脹。這三星期來只能用高劑量的霓麻壓抑對噴霧器的厭惡。</p>
<p>　　必須，必須離開這裡。</p>
<p>　　左顧右盼了一會，小心翼翼自枕套裡挖出一本盜印的參考書〈決勝CETS‧新西方〉。書齡估計有七十五年，書背沒標上ISBN，作者也無從找起，內頁更被蠹魚游出一片大洋，徒存沒有本文的註腳。經過一個下午的時間，殘破的訊息終於完整謄錄到公文紙背面，老表坐起身，從第一頁看起。</p>
<p>　　讀書對老表而言無疑是種折磨，段落完整處不多，句子離散得像詩，有些部分還只能當書法欣賞。每停駐一個字都有股刺痛感產生，一針一針扎著他顱內的韋尼克區。嘗試將支離破碎的字詞拼湊出意義，卻失敗的一蹋糊塗，換來更劇烈的痛苦，他撇過頭等待痛楚消退才翻頁。暫停，繼續，暫停，繼續……老表一把抓起筆記，揉成紙團用力往牆面砸，紙團不踏實地打中繪有世界地圖的卷軸，發出輕輕聲響。他躺回床上，從枕套裡拿出橙色信封放進口袋，什麼都不想，沉沉入睡。</p>
<p>．　．　．</p>
<p>　　三架人形機具仍然在隔離間忙進忙出，不過這次他們搬運碗盤；又一封紅色急件砸在諮詢室的大堆文件上；護理機器人帶來一個滴著口水，皮膚鑲嵌七八種色塊的女孩進來。</p>
<p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p>
<p>　　「除了排汗失常、營養不良和文字辨識障礙外沒有其他問題。」</p>
<p>　　「……」</p>
<p>　　沒人回應的機器人僵在門口死板地重複通知，女孩掙脫機器手臂好奇地往辦公室探頭，黑漆漆的半個人影都沒有。</p>
<p>．　．　．</p>
<p>　　「主任馬上就到。」秘書機器人再次向久候的來訪者告知。</p>
<p>　　會客室在CETS大樓頂層，日光照進東側的大落地窗，非常明亮；從窗邊可以俯瞰整座夢臨市：藍色緞帶似的河道蜿蜒繞過市中心，機動風帆船悠悠地在河面行駛，遞送南北區的物流。然而老表只是一味踱來踱去，在腦海裡不停排練想像待會的對話，絲毫沒去注意窗外匆忙的世界。就在他糾結於該怎麼替對話收尾時，主任，CETS的實質負責人，輕快地走進來。</p>
<p>　　他調低空調溫度，把秘書機器人支開。「看來你是對工作失去熱忱了，老表。」他說。</p>
<p>　　老表嚇了一跳，先是看看主任又轉而盯著長桌旁的罌粟花試圖閃躲主任的眼神，不知如何反應掙扎了一會兒，最後脫口：「辭……辭職。」疲乏的節奏，無力的嗓音。</p>
<p>　　「但你幹得真不錯，」主任撫著手，「幹得真不錯。」</p>
<p>　　「可是，」老表繼續說，「雖然幾十年間喜歡的工作，但是……呃，就是……」</p>
<p>　　「我得勸你留在崗位上，只剩十年呢！」長桌上映射出老表的人事資料，簡歷只有一條：CETS專任輔導師。</p>
<p>　　老表吞吞口水滋潤乾澀的喉嚨，才鎮定下來說「我仍要轉行。」</p>
<p>　　「轉行？」主任露出一絲詫異的笑容。</p>
<p>　　「對，天文學家。」慢慢地，一字一字念出。</p>
<p>　　主任把當年老表的應試結果調出，投影到他眼前。「這樣的成績，無論觀測員或理論學者你都無法勝任。」摺疊起資料夾，又笑笑補了一句「更何況輔導員可沒辦法把恆星撒上霓麻，這點你應該最清楚。」</p>
<p>　　「沒效，」老表臉孔扭曲地說，「霓麻已經克制不住，工作的厭倦。」</p>
<p>　　「這不是新案例，」主任從書架取出〈醫典〉，扣在檢索機上。書本開始唰唰唰翻頁，愈來愈快，爾後漸漸減速：DRUG、DRUG DEPENDENCE、DRUG SEN-SITIZATION……最終在DRUG TOLERANCE停下。「藥物耐受性，因對霓麻暴露量超標引發的藥物耐受性。」，「不過並不是大問題，最新研究的佐劑能重置對藥物的敏感度，延長職業壽命。」</p>
<p>　　「不需要霓麻，星辰本身就值得嚮往……」老表小聲插嘴。</p>
<p>　　「嚮往星辰？那你嚮往哈密頓系統、傅立葉分析及弗里德曼方程式嗎？」</p>
<p>　　「一定得喜歡物理嗎？」這令老表回想到昨晚挑燈夜讀的痛苦經歷，和被數學符號砸得頭破血流的夢境。不僅從沒念過一本物理書，事實上，他對物理一點興趣都沒有。</p>
<p>　　「若不喜歡，那探索天文就只是一連串和數字掙扎的痛苦歷程，最終庸碌一生。」</p>
<p>　　「我不要求成為牛頓、愛因斯坦那樣的名家。」</p>
<p>　　「但對教育者而言，放任失調者不合宜地去研究出破銅爛鐵、出版劣質的小說、烹調難下嚥的食物——是教育的失敗和社會人力的浪費。」</p>
<p>　　「繳稅，我還繳稅不虧欠社會什麼。」</p>
<p>　　「你打算放棄自己擁有的才華，待在不適任的位置然後逼自己做不喜歡的事，就為滿足心裡空無的期待？」</p>
<p>　　「不是……」老表沒有辦法反駁，腦袋一片空白。被適性測驗挑出的失調者用霓麻培養喜好，用霓麻建立興趣，經林立市郊的職訓所針對專長養成技能，有能力有熱忱，處在各行各業都能驕傲地勞動，這樣有什麼不好？</p>
<p>　　「事實上，你選擇了折磨自己。」</p>
<p>　　「可是，我喜歡天空……」老表思考能力到了極限，外加熬夜的疲憊幾乎要跪倒。他拿出橘色信封，裡面備齊身分資料，還有工作多年的積蓄。「拜託讓我重新參加測驗。」卑微地，老表伏在地上，「我願意去做那些噁心厭煩、令人頭痛欲裂的事！」</p>
<p>　　「是嗎？隨便你。」主任說畢轉身離去。</p>
<p>．　．　．</p>
<p>　　不安、臉色鐵青的孩童比肩繼踵地往內移動，有個面容枯槁的老人不協調地排在人龍中間，跟著隊伍往前。查驗機吞下准考證，三道雷射自閘門上方向下掃描，分別檢驗了基因、金屬反應與外型特徵，電腦遲疑了一會兒才發出合格鳴叫。通過身分認證後，老表朝向第213036試場走去。試場有六扇門，每扇門後有一部機考駕艙，它們將依據應試結果駛向對應的職訓中心。</p>
<p>　　老表年老萎縮的身軀還勉強能擠入設計給孩童的應考座，大腿貼著胸口，下巴抵在膝上，雙手沒地方擺只得僵硬地半舉。警鈴響起，艙門喀鏘關上，裏頭一片黑暗，老表緊張得直發抖，嘴巴喃喃默背著參考書內容「托勒密布魯諾哥白尼克普勒伽利略，PV&#x3D;NRT，M&#x3D;m+5lgR」</p>
<p>　　前方的黑暗亮起倒數字幕，虛擬的指導人聲開始說明應考程序。附有吸盤的軟管從坐墊下伸出，向上攀升最後牢牢固定在老表的後頸。視線左上角跳出一個愛心符號，中間數字印著一百二十二，右上角的氣體含量表顯示當前二氧化碳濃度過高。老表心想，如今他像個嬰兒一樣，屈身金屬子宮以光纖臍帶與母電腦連結，等待十小時煎熬後的重生。</p>
<p>　　長達兩千兩百道是非題存成一株高入雲天的二元樹，參雜無數誘答與實驗選項，排除了隨意作答與背誦舊題的偏差(即使適性測驗補習班幾乎銷聲匿跡)。老表全身顫抖地在選項間遊蕩，穿過無數條分岔的迴廊：愛好動物&#x2F;喜歡機械、偏愛操作&#x2F;擅長思考、活潑奔放&#x2F;害羞內向……每次抉擇都捨棄了半數可能，二分之一、四分之一……以O(logn)時間複雜度指向一個對老表而言未知的未來。</p>
<p>　　最後一個指令輸入，第一階段結束。駕艙正「喀鐺、喀鐺」朝下個應考點前進，即使五感都被封鎖在機殼內，仍能感受到因慣性從椅背傳來的壓迫。</p>
<p>　　「試判斷有沒有一個正整數n, 可使n恰可被2000個相異的質數整除，且可被n整除。」</p>
<p>　　「……」</p>
<p>　　「有一時鐘的時針長度為 5 公分，分針長度為 8 公分。假設時針針尖每分鐘所移動的弧長都相等。試求時針針尖每分鐘所移動的弧長。」</p>
<p>　　「……」</p>
<p>　　「同時擲出一枚50元與一枚10元硬幣，兩枚都出現正面的機率為多少？」</p>
<p>　　「……」</p>
<p>　　時間條如火藥引信逐漸燒盡，因正確率過低電腦不斷調低題目水平，老表被無止盡的挫折包圍，在汪汪題海中捲入錯答的漩渦死命掙扎。</p>
<p>　　「5×6＝？」</p>
<p>　　「一、二、三……」僅存三十秒時間，好不容易碰上有把握的題目，老表扳著手指吃力計算。</p>
<p>　　「1＋1＝？」</p>
<p>　　終止的警鈴在作答前響起，駕艙緩緩剎車紮實停在地面，老表視線落在熄滅的螢幕上，呆愣地搓揉發麻的雙腳等候艙門打開。</p>
<p>　　「喀鏘！」</p>
<p>　　門縫透出一線光芒，他嗅到一股熟悉的甜味，不遠處公文砸在辦公桌上的聲音傳來。</p>
<p>　　「回……回來了嗎？」正當老表失落地想跨出腳步時，</p>
<p>　　「轟隆」</p>
<p>　　機器起了劇烈搖晃，他一個踉蹌跌回座上。下降，駕艙失控地下降，失重感侵襲全身，一幕幕過去從腦中閃過，恍惚間，他回到熱衷噴灑霓麻的時候，回到被輔導的時候，回到上次參加測驗的時候，昏厥前一刻，老表回到了一歲的時候。</p>
<p>　　老表癡愣地坐在地上，眼前似乎有筆、有試管、有衣服、有手槍……周遭的成人不知道在鼓噪些什麼，像是認份般他賣命往前爬，奮力一抓，卻什麼也沒抓住。</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>常見的生物資訊軟體開發文件</title>
    <url>/a-collection-of-essential-documents-for-bioinformatis-software/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>撰寫軟體的理想目標是讓程式碼自我解釋，使得任何受過訓練的工程師能夠僅靠程式碼本身理解其含意。然而，隨著軟體功能與部件日益複雜，我們仍須依賴額外的文件來說明程式碼的商業邏輯、運作情境與潛在限制等背景知識。</p>
<p>在生物資訊軟體開發領域，尤其是醫療軟體開發中，文件的詳盡程度與正確性尤為重要。為了把關產品品質與和保障用戶權益，醫療產品驗證要求產品送審時提供完整的軟體設計、需求分析和產品驗證報告。這些文件的種類繁多且規範細緻，撰寫和維護這些文件往往成為開發者的重擔。</p>
<p>減輕這種負擔的一種方法是讓開發人專注於與開發相關的文件，並將這些文件作為合規文件的來源。透過簡化文件類別和統一內容來源，來簡化文件撰寫和維護的流程。</p>
<p>因此，本文整理了常見的生物資訊軟體開發文件，闡述與開發密切相關的文件類型，並列舉優良的撰寫指南，同時對各類文件的定位差異提出個人見解。</p>
<span id="more"></span>

<h1 id="常見的生物資訊軟體開發文件清單"><a href="#常見的生物資訊軟體開發文件清單" class="headerlink" title="常見的生物資訊軟體開發文件清單"></a>常見的生物資訊軟體開發文件清單</h1><p>雖然文件內容會依專案性質與規模而有所不同，但在開發過程中通常會隨專案進展逐步納入以下幾種文件，</p>
<table>
<thead>
<tr>
<th>名稱</th>
<th>內容</th>
<th>額外受眾</th>
<th>指引</th>
</tr>
</thead>
<tbody><tr>
<td>Issues</td>
<td>紀錄 bugfix 或 feature request 等開發需求與問題</td>
<td>專案經理</td>
<td><a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Feature-Requests">Writing Good Feature Requests</a> &amp; <a href="https://github.com/rstudio/rstudio/wiki/Writing-Good-Bug-Reports">Writing Good Bug Reports</a></td>
</tr>
<tr>
<td>Docstring &amp; Type hints</td>
<td>描述程式模組的功能、參數與回傳資訊</td>
<td>開發者</td>
<td><a href="https://peps.python.org/pep-0257/">PEP 257</a> &amp; <a href="https://peps.python.org/pep-0484/">PEP 484</a></td>
</tr>
<tr>
<td>Code comments</td>
<td>程式碼的補充說明，包括任務標記和權益作法提示</td>
<td>開發者</td>
<td><a href="https://stackoverflow.blog/2021/12/23/best-practices-for-writing-code-comments/">Best practices for writing code comments</a></td>
</tr>
<tr>
<td>Built-in help</td>
<td>軟體內建的用戶幫助訊息</td>
<td>用戶</td>
<td><a href="http://docopt.org/">docopt</a></td>
</tr>
<tr>
<td>Commit messages</td>
<td>摘要程式碼異動的內容、理由與背景</td>
<td>開發者</td>
<td><a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional commits</a></td>
</tr>
<tr>
<td>Pull requests</td>
<td>簡述為滿足需求對應的軟體異動及其理據</td>
<td>審查者</td>
<td><a href="https://www.pullrequest.com/blog/writing-a-great-pull-request-description/">Writing A Great Pull Request Description</a> &amp; <a href="https://github.blog/2015-01-21-how-to-write-the-perfect-pull-request/">How to write the perfect pull request</a></td>
</tr>
<tr>
<td>README</td>
<td>介紹專案目標、安裝使用與授權等入門資訊</td>
<td>用戶</td>
<td><a href="https://www.makeareadme.com/">Make a README</a></td>
</tr>
<tr>
<td>CHANGELOG</td>
<td>紀錄專案開發歷程與各版本更新內容</td>
<td>用戶</td>
<td><a href="https://keepachangelog.com/en/1.1.0/">Keep a CHANGELOG</a></td>
</tr>
</tbody></table>
<p>除了專案進展，開發文件的內容和格式也會根據團隊或任務需求而異。例如，單一腳本構成的小型專案在初期可能僅需程式碼註解和內建幫助訊息；隨著專案成熟，可以逐漸增加 README 文件來補充安裝和授權資訊，並在軟體定版後定期更新CHANGELOG。而個人開發的專案可能沒有 Pull Request 資訊；但團隊開發除了需要 pull request 把關軟體品質外，還需要 issues 管理專案排程。</p>
<p>表中的連結已提供詳細的文件撰寫指引，以下我將補充一些對個別文件定位的看法。</p>
<h1 id="README-和-CHANGELOG-的差異"><a href="#README-和-CHANGELOG-的差異" class="headerlink" title="README 和 CHANGELOG 的差異"></a>README 和 CHANGELOG 的差異</h1><p>README 呈現專案的現況，包括專案簡介、安裝和使用方法、軟體授權等必要資訊，是用戶或開發者了解專案的首要途徑。除此之外，README 還充當軟體文件的目錄，連結到用戶手冊、常見問題和開發指南等資源，供進階用戶或開發者參考。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># README</span><br><span class="line"></span><br><span class="line">## Introduction</span><br><span class="line"></span><br><span class="line">## Quick start</span><br><span class="line"></span><br><span class="line">## installation</span><br></pre></td></tr></table></figure>
<p>CHANGELOG 則記錄專案的過往，包括軟體變更和版本號次等更新資訊，是用戶或開發者了解開發歷程的入門管道。此外，CHANGELOG 也充當專案歷程的目錄，連結到 issue 和 pull request 等資源，供進階用戶或開發者參考。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CHANGELOG</span><br><span class="line"></span><br><span class="line">## [1.1.0] - 2019-02-15</span><br><span class="line"></span><br><span class="line">### Added</span><br><span class="line"></span><br><span class="line">- Danish translation (#297).</span><br><span class="line">- Georgian translation from (#337).</span><br></pre></td></tr></table></figure>

<p>換言之，README 和 CHANGELOG 總結了專案的現況與過往，是用戶與開發者了解專案最基礎的媒介。因此，這兩份文件通常會擺在專案目錄的最頂層，確保所有人一眼就能找到。</p>
<h1 id="Commits-和-CHANGELOG-的差異"><a href="#Commits-和-CHANGELOG-的差異" class="headerlink" title="Commits 和 CHANGELOG 的差異"></a>Commits 和 CHANGELOG 的差異</h1><p>如前所述，CHANGELOG 主要記錄軟體的重要變更，這些變更可能影響軟體的功能或使用方式。典型的 CHANGELOG 會按時序編排條目來排列，並依版本和變更類型組織變更紀錄。每條記錄不僅簡要描述了變更內容，還會連接到相關的需求文檔，補充軟體變更背景資訊。</p>
<p>相較之下，commit messages 主要面向開發者，著重於個別程式碼的變更，而非對整體用戶的影響。標準的 commit messages 通常包括變更類型和簡要說明，其中類型方便篩選和查找相關資訊，而簡要說明則提供了變更的摘要。這些資訊讓查閱者能夠追蹤開發歷程（例如使用 <code>git log --onelines</code>），並在需要時回溯程式碼的變更。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure>
<p>更完整的 commit messages 則包含了變更的背景、原因或機制的詳細解釋，有時還會附上註腳標記相關的 issue 連結，補充程式碼變更的需求情境</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure>
<p>雖然兩者都是開發紀錄的一部分，但 CHANGELOG 著重於需求的處置，commit 則聚焦程式碼的具體變更；CHANGELOG 通常隨著軟體更新而更新，而 commit 則在提交後鮮少變更；CHANGELOG 強調變更的影響，而 commit 則更注重變更的細節。由於這兩種文件的目標受眾和內容尺度殊異，直接從 commits 生成 CHANGELOG 可能會導致不必要的冗餘資訊，從而無法達到 CHANGELOG 的設計目的。</p>
<h1 id="Code-comments-和-Docstring-的差異"><a href="#Code-comments-和-Docstring-的差異" class="headerlink" title="Code comments 和 Docstring 的差異"></a>Code comments 和 Docstring 的差異</h1><p>程式碼內的文字不被執行的文字片段可分為 code comments （註解）與 docstring。以 Python 為例，docstring 是記錄函數、類別或模塊的特殊屬性，它們被夾註在三重雙引號之中，用於描述功能、參數和回傳資訊等自訂資訊。透過內置的 <code>__doc__</code> 方法可以取得 docstring，使其能被語義化工具解析，用於自動化文件生成，如 docopt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def complex(real=0.0, imag=0.0):</span><br><span class="line">    &quot;&quot;&quot;Form a complex number.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    real -- the real part (default 0.0)</span><br><span class="line">    imag -- the imaginary part (default 0.0)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if imag == 0.0 and real == 0.0:</span><br><span class="line">        return complex_zero</span><br></pre></td></tr></table></figure>
<p>另一方面，註解也是程式碼中不執行的文字片段，可用於解釋程式碼的背景或機制。值得注意的是，註解通常無法以內置方法取得，因此較常用於標記任務（如：<code>TODO</code>）、提供權宜性解法的提示或對複雜程式碼進行補充說明，並會隨著程式碼的改進而被簡化或刪除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TODO: remove the deprecated method</span><br><span class="line"></span><br><span class="line"># Use the name as the title if the properties did not include one (issue #1425)</span><br><span class="line"></span><br><span class="line"># Magical formula taken from a stackoverflow post at &lt;URL&gt;, reputedly related to human vision perception.</span><br></pre></td></tr></table></figure>
<p>總結來說，註解的內容較為多樣，可能包括臨時註記或任務提醒；而 docstring 則是程式碼正式文件的一部分，記錄了關於程式本身使用上的更多資訊。</p>
<h1 id="開發文件應存放何處？"><a href="#開發文件應存放何處？" class="headerlink" title="開發文件應存放何處？"></a>開發文件應存放何處？</h1><p>理想上，開發文件應具備好找、好讀和好維護等特性。這些特性可以這樣定義：</p>
<ul>
<li><strong>好找</strong>：文件應支援全域搜尋或資料庫搜尋，方便獲取重要資訊。</li>
<li><strong>好讀</strong>：文件應能在網頁、圖形介面或終端機中打開，並且資訊清晰簡潔。</li>
<li><strong>好維護</strong>：文件應集中存放於單一位置並能進行版本控制，以減少文件與開發進度不一致的風險。</li>
</ul>
<p>考量到這些原則，一些常見的文件格式可能不適合管理開發文件。例如，Office 系列文件不易進行搜尋和版本控制。將文件存放在品管系統 (ISO) 或多個資料夾中也不利於取得文件。而 HTML 和 LaTeX 等格式則包含過多無關的排版標記，使內容難以閱讀。</p>
<p>因此，目前最普遍的做法是使用 Markdown 進行純文本編輯，並將文件統一存放在專案目錄下。這樣不僅便於備份、版控和搜尋，還可以像程式碼一樣按照開發流程更新文件，從而將開發和文件緊密結合，降低不一致的風險。</p>
<p>常見的專案文件結構如下，例如 Python 的 <a href="https://github.com/psf/requests">requests</a> 專案或生物資訊領域的 <a href="https://github.com/nf-core/sarek/tree/3.4.0">nf-core</a> 等專案都採用了這樣的結構。</p>
<p>將 README 和 CHANGELOG 這兩種反映專案主要內容的文件放在專案根目錄，方便用戶或開發者取得這些資訊。再以單獨的目錄管理其他自訂文件，並共享多媒體資源，如圖片、影片或字體等。這種做法的好處除了方便管理外，還可以通過程式碼工具將文件編譯成網頁或 PDF 等易於閱讀與分享的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">|- README.md 					# 專案現況的學習途徑                   </span><br><span class="line">|- CHANGELOG.md              	# 開發歷程的入門管道   </span><br><span class="line">|- docs/                        # 自訂文件</span><br><span class="line">    |- assets/                  # 共享的多媒體資源</span><br><span class="line">    |- &lt;usage/output/faq&gt;.md    # 用戶、開發者或分享用的文件</span><br><span class="line">    |- &lt;makefile&gt;               # 用以編譯文件檔為其他格式</span><br></pre></td></tr></table></figure>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>在生物資訊軟體開發的領域中，常見的文件類型可以分為三大類：程式碼本身 (Source Code)、軟體當前狀態 (README)、以及開發歷程 (CHANGELOG)。這些文件不僅涵蓋了軟體的關鍵資訊，還透過互相連結和註腳形式，串聯起相關的文件內容。這樣的做法有利於在必要時將內容改寫為合規文件的格式。最佳的文件管理方法是將其儲存在專案目錄下，採用 Markdown 格式進行純文本編輯。這不僅保證了文件的可檢索性和易讀性，還可通過 Git 進行版本控制，確保文件的維護和更新與程式碼開發流程同步，從而達到易於維護的目的。</p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href="https://academic.oup.com/bib/article/19/4/693/2907814">Top consideratios for creating bioinformatics software documentation</a></li>
<li><a href="https://understandlegacycode.com/blog/where-to-put-documentation/">Where should you put the documentation</a></li>
<li><a href="https://agilemodeling.com/essays/agiledocumentation.htm">Lean&#x2F;Agile Documnetation: strategies for agile teams</a></li>
<li><a href="https://www.ithome.com.tw/voice/95002">技術文件產能工具</a></li>
</ul>
]]></content>
      <tags>
        <tag>development</tag>
      </tags>
  </entry>
  <entry>
    <title>bad interpreter: No such file or directory</title>
    <url>/bad-interpreter-no-such-file-or-directory/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Linux 執行 Perl、R 或 Python 腳本時，有幾種情況可能會跳出 “bad interpreter: No such file or directory”。</p>
<span id="more"></span>

<h1 id="打錯字"><a href="#打錯字" class="headerlink" title="打錯字"></a>打錯字</h1><p>檢查 #!&#x2F;usr&#x2F;bin&#x2F;env 有沒有拼對，如果拼錯的話也會報錯。</p>
<h1 id="路徑不對"><a href="#路徑不對" class="headerlink" title="路徑不對"></a>路徑不對</h1><p>即「<a href="https://www.cnblogs.com/xuxianren/p/4612440.html">執行Python “&#x2F;bin&#x2F;usr&#x2F;python: bad interpreter: No such file or directory” 錯誤</a>」中提到的問題：當腳本開頭寫成 #!&#x2F;usr&#x2F;bin&#x2F;python 時，如果沒有主動連結到安裝的 python 版本，有可能找不到。改寫成 #!&#x2F;usr&#x2F;bin&#x2F;env python，就會自動尋找 python 的路徑了。</p>
<h1 id="腳本的編碼格式不相容"><a href="#腳本的編碼格式不相容" class="headerlink" title="腳本的編碼格式不相容"></a>腳本的編碼格式不相容</h1><p>Windows 記事本的格式和 Linux 的腳本不同，所以會因為隱藏的字元而無法判讀，解決方法可參考「<a href="https://www.cnblogs.com/xuxianren/p/4612440.html">sh腳本異常：&#x2F;bin&#x2F;sh^M:bad interpreter: No such file or directory</a>」，在 vi 或 vim 編輯器下，以 :set fileformat&#x3D;unix 修改腳本編碼。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>天體生物學和尋找外星生命</title>
    <url>/astrobiology-and-the-search-for-extraterrestrial-life/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>低調的人類從學會抬頭那一刻，就不斷在地球、月球、火星乃至其它銀河尋找自己不特別的證據。</p>
<span id="more"></span>

<h1 id="Astrobiology-是什麼？"><a href="#Astrobiology-是什麼？" class="headerlink" title="Astrobiology 是什麼？"></a>Astrobiology 是什麼？</h1><h2 id="Astrobiology-簡介"><a href="#Astrobiology-簡介" class="headerlink" title="Astrobiology 簡介"></a>Astrobiology 簡介</h2><p>除了地球生靈以外，宇宙中還有其他生命嗎？無論這個問題的答案是肯定還是否定，都能引發我們省思。假如能找到任何外星生命跡象，那麼我們肯定對其外型感興趣，也會想了解地球生命與外星生命的關係。但如果地球是唯一能孕育生命的星球，所有尋找外星生命的努力都注定是徒勞，這個問題也還沒完。因為我們勢必會感到疑惑，究竟地球有哪些獨一無二的特徵，容許生命在此發源繁盛？</p>
<p>雖然外星生命是想像作品的熱門題材，但在二十世紀中葉以後逐漸興起的天體生物學（Astrobiology，以下譯為天文生物學，理由見第三節）正是以事實與理論為基礎，試圖在太陽系乃至其他銀河搜尋地外生命的科學。</p>
<p>儘管目前未搜索到任何地外生命，鑒於宇宙龐大的規模以及地球生命形成的速度，存在地外生命仍然是合理的想像。何況，天文生物學除了尋找地外生命外，也肩負了解生命定義和地球生命起源的任務。</p>
<h2 id="天文生物學的研究方向"><a href="#天文生物學的研究方向" class="headerlink" title="天文生物學的研究方向"></a>天文生物學的研究方向</h2><p>包含尋找地外生命在內，天文生物學有以下三個研究方向。</p>
<p>釐清生命的定義與特質：雖然生命在地球隨處可見，卻難以為生命立下明確的定義，並區隔其與物質的差異。原則上，生命仍受制於物理和化學法則，但以人類目前的科技水準尚無法在實驗室中合成任何現今定義為生命的個體。生命與非生命之間的差異是什麼？人造生命的嘗試還欠缺何種要素？為了回答這些問題，天文生物學的首要目標即是研究生命的特質以了解生命究竟是什麼。<br>了解地球生命形成的條件與機制：除了比較生命與物質的差異，研究無機物轉變為生命的過程亦有助於了解生命的特性。當物質隨時間逐漸變得複雜，哪一刻起可稱之為生命？在形成生命的許多反應途徑中，何者是關鍵的一步？哪種環境條件是生命形成所必須？哪種環境條件造就了地球生命的特色？天文生物學的目的不只是理解地球生命形成的條件與機制，也試圖以地球生命起源為基礎，探討其它宇宙生命的特徵。<br>搜索地外的適居環境與生命跡象：理解生命的另一條途徑就是尋找地外生命。地球生命是目前已知唯一的生命形式，所以至今人類只能從僅有的樣本推論所有生命的普遍特徵。如果能夠找到任何地外生命，便能夠比較兩地生物的異同，得知生物的那些特徵是生命的通性，哪些又因形成環境而異，進而促進生命本質的理解。因此天文生物學的第三個研究方向，即是增加生命的樣本數。</p>
<p>總言之，天文生物學的研究方向是了解生命的本質，所以天文生物學一方面從地球生命的起源推論所有潛在生命的共同特徵，另一方面則試圖搜索地外生命以增加推論的依據。達成這些目標仰賴生物學、地球科學與天文學等學科知識，因此雖然天文生物學的主軸是生物，實際的研究課題卻跨越了不同領域。</p>
<h2 id="天文生物學的譯名"><a href="#天文生物學的譯名" class="headerlink" title="天文生物學的譯名"></a>天文生物學的譯名</h2><p>了解天文生物學的研究內容後，再來談談天文生物學的名稱。實際上這名稱曾讓許多初次接觸的人感到困惑，以為天文生物學只與望遠鏡有關和顯微鏡無關。</p>
<p>天文生物學在發展初期曾有許多不同的名字，例如萊德柏格 (Joshua Lederberg, 1925 - 2008) 即提倡以 Exobiology（地外生物學）表示研究生命在宇宙中發源、演化和分布的學科。然而國際生命起源研究社群卻對其中搜索地外生命的部分有異議，最終發明Bioastronomy（生物天文學）來描述以望遠鏡搜索地外生命的學問。</p>
<p>不過這兩個名稱的爭議在於，在找到地外生命之前「地外」或是「生物天文」等詞彙是否合宜？</p>
<p>於是到 1997 年，NASA 開始推廣以 Astrobiology 取代 Exobiology 等其它術語。在那之後還有許多關於名稱的爭議，可以閱讀 Lemarchand (2000) 的 A New Era in the Search for Life in the Universe  獲得其它細節。不過如今我們知道，Astrobiology 成為這個學科的主流名稱。</p>
<p>Astrobiology 結合了希臘字 astron（星星或天體）和德國字 Biologie（生物學），字面上解釋作「星星的生物學」，常見譯名有天體生物學、天文生物學或太空生物學等。雖然前述譯名中，天體生物學較其他兩者普及，但 Astrobiology 的研究範圍其實不限於特定天體，還涵蓋了生命在其他宇宙空間的分布與演變，所以我認為「宇宙生物學」較能反映其特質，但宇宙生物學應另指 Cosmobiology 一詞，因此為了顧及字根與學術含意，譯為天文生物學也還算恰當。</p>
<h1 id="從天文生物學到廣義生物學"><a href="#從天文生物學到廣義生物學" class="headerlink" title="從天文生物學到廣義生物學"></a>從天文生物學到廣義生物學</h1><p>我已經說明了天文生物學的具體目標，接著我將解釋天文生物學的含意。</p>
<h2 id="生命之樹與生物學"><a href="#生命之樹與生物學" class="headerlink" title="生命之樹與生物學"></a>生命之樹與生物學</h2><p>如果以系統發生樹描繪歷史上曾經出現過的生物，會發現地球生命化作一棵大樹，真細菌、古菌和真核生物等枝枒最後匯集在名為最後共祖 (Last universal common ancestor, LUCA) 的根部。透過研究這棵樹上各式各樣的生物，造就了當今的生物化學、分子生物學還有演化學等學科。</p>
<p>也因為現今的生物傳承一段共同的演化歷史，所以研究細菌得出的分子機制往往能夠推廣到其他的生物。然而，如果生命在地球形成了數次，我們能否想像其中一支在不受干擾的情況下獨立演化，以至於這種生命形式與已知的生命毫無親緣關係？</p>
<p>這種生命被稱為影子生物圈 (Shadow biosphere) ，牠們或由不同的元素構成，或採不同的遺傳機制和生化過程，奠立於已知生命的現代生物學可能無法直接適用於影子生物圈。</p>
<h2 id="人造生命與合成生物學"><a href="#人造生命與合成生物學" class="headerlink" title="人造生命與合成生物學"></a>人造生命與合成生物學</h2><p>然而到目前為止，仍未找到任何影子生物圈存在的證據。原因可能是生命形成時遭逢浩劫導致僅有一支生命形式流傳下來，也可能是生命僅能以地球生命的形式萌生，或僅僅是我們選擇了錯誤的搜索方式。</p>
<p>究竟是何種原因仍未有定論，不過合成生物學的研究方向或許能為此帶來一絲線索。合成生物學涵蓋兩個目標：第一，重組既有生命的組件（例如基因、胞器或細胞等）實踐工程目標。第二，從複雜程度不等的物質試圖合成生命。</p>
<p>人造生命可以在兩方面促進生命的理解：第一，人造生命直接拓展我們對於生命可能形式的見解。第二，製造人造生命雖然不等同地球生命形成的真實過程，但卻可以作為測試生命起源理論的對象。</p>
<h2 id="地外生命與天文生物學"><a href="#地外生命與天文生物學" class="headerlink" title="地外生命與天文生物學"></a>地外生命與天文生物學</h2><p>天文生物學則採取跟合成生物學相反的管道，直接搜索可能從地外天體萌生的生命。如同合成生物學，發現任何地外生命都能拓展已知生命的樣本數，也能從地外生命的演化歷程推論地球生命起源的條件與機制。</p>
<p>我想天文生物學家們多少心知肚明，如果我們沒有在太陽系內找到任何其他生命，即使其他恆星系統存在生命，以人類的科技水準也沒有直接研究的指望。因此，儘管天文生物學似乎一再強調「地外」或是「天體」，研究範圍從行星、太陽系以至其他銀河，但天文生物學的基礎不是建立在還沒找到的生命，而是是地球生命本身。</p>
<h2 id="生命之林與廣義生物學"><a href="#生命之林與廣義生物學" class="headerlink" title="生命之林與廣義生物學"></a>生命之林與廣義生物學</h2><p>在一系列討論中，我已經提及三種未知的生命形式：於地球上誕生的影子生命、於實驗室誕生的人造生命，還有其他星球誕生的地外生命。這些假設的生命形成了涵蓋許多潛在生命形式的生命空間（類似向量空間的概念。向量空間是給定向量的所有可能組合，生命空間則是給定物質和能量，所有可能形成的生命形式）</p>
<p>目前的生物學專注於生命空間中的地球生命，對於其他潛在生命的解釋能力有限。合成生物學和天文生物學分別透過製造生命和尋找生命拓展我們已知的生命空間，如果這些嘗試取得成果便會多出許多研究標的。如此一來，生物學將不再限於探討地球生命，而會推廣到其他的生命形式，衍生出「星際生態學」或「碳基與矽基比較生物學」等聽起來很科幻的學科。</p>
<p>換句話說，生物學將從研究生命之樹的學科轉變成研究生命之林的廣義生物學。從這個角度看來，合成生物學建造新的生命之樹，天文生物學則連結已經存在的諸多生命之樹，兩者都是廣義生物學的一部份。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>天文生物學的研究目標是了解生命本質，探討生命形成的機制和搜索地外生命。其與合成生物學的研究進展能促進我們對於其他生命空間的理解，將生物學推廣為廣義生物學。</p>
<p>若想了解更多天文生物學的知識，可參考<a href="https://www.coursera.org/learn/astrobiology">〈天體生物學和尋找外星生命〉線上課</a>。〈天體生物學和尋找外星生命〉是愛丁堡大學天文生物學教授既英國天文生物中心的創辦人 Charles Cockell 於 Coursera 平台開設的入門課程，內容涵蓋生命起源、地球生物史以及搜索地外生命等天文生物學核心議題。</p>
<p>雖然授課內容淺顯，隨堂考也很簡單，可是舉凡天文生物學的理論背景、科學問題的前提假設或是各項發現的衍伸含意都講得很清楚。</p>
]]></content>
      <tags>
        <tag>astrobiology</tag>
      </tags>
  </entry>
  <entry>
    <title>我們就是火星人：尋找宇宙中的地外生命</title>
    <url>/bignami-2012-we-are-the-martians/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>生命和宇宙的聯繫是《我們就是火星人》的主旋律。大霹靂後的原初核合成（Big Bang nucleosynthesis）雖然僅持續短暫時間，卻製造了宇宙含量最豐富的元素氫、氦。然而隨著空間持續膨脹，溫度下降到無法維持核融合反應，導致原初核合成中止。</p>
<p>直到第一批恆星誕生，最初的元素才在恆星核融合過程中轉變成組成身體的碳、呼吸所需的氧以及胺基酸裡的硫和氮。不過比鐵更重的銅、鉬等微量元素，得仰賴超新星的爆炸核合成。它提供足夠能量形成這些元素，填補了元素週期表其他空白。另外因超新星爆發而四逸的元素聚集為星際氣體，它們的組成成分隨著每次爆發變得越來越多元，成為孕育複雜分子和行星系統的搖籃。</p>
<span id="more"></span>

<h2 id="生命起源的隨機性與決定性"><a href="#生命起源的隨機性與決定性" class="headerlink" title="生命起源的隨機性與決定性"></a>生命起源的隨機性與決定性</h2><p>若形成最初生命的分子證實來自外太空，那麼宇宙物質的種類與數量分布可能影響了生命的型態，了解它們的源頭與生成機制，就有依據推測為何生物僅採用特定分子而不用另一群分子的謎題（例如手性不對稱）。然而目前為止，這些現象是隨機事件導致的巧合（生命原料源於外太空），還是分子差異演化所致結果（生命原料在地球生成）仍未有定論。</p>
<p>不過最重要的是明白「隨機」和「決定」的含意，如果形成生命的樞紐是可遇不可求的事件，那麼就意味著即便備齊良好條件，沒有機運仍然不會產生生命；反之，如果生命是反應的必然結果，那我們就更有可能從其他條件良好的星球發現生命跡象。</p>
<p>除了體內元素和宇宙的歷史連結，作者還說明了怎麼透過光、隕石和火箭聯繫我們、天體和遙遠的過去。第三章聚焦在搜索行星的觀測天文學，討論觀測結果對行星理論的衝擊。由於行星是生存的根據地，所以適居行星的形成機率也是攸關生命是否普及在宇宙中的關鍵。</p>
<h2 id="接觸天文學與泛種論的關聯"><a href="#接觸天文學與泛種論的關聯" class="headerlink" title="接觸天文學與泛種論的關聯"></a>接觸天文學與泛種論的關聯</h2><p>而在第四、五、六章介紹的接觸天文學，則是從墜落地球的隕石或是從其他天體採集的岩石中直接獲取資訊，由於沒有被瘋狂的地質活動風化，它們仍保留歷史的痕跡，研究者可以藉此得知岩石以至地球的過去。其中較有趣的是默奇森隕石和ALH84001，前者含有豐富有機物質，後者則有疑似微生物的化石，它們暗示著生命源於外太空的泛種論（Panspermia）。</p>
<p>泛種論可以追溯到希臘哲學家Anaxagoras，繼而由提出解離說的阿瑞尼斯發展，解釋胞子受輻射推動從一個星球飄到另一星球（Radiopanspermia），發現DNA雙螺旋結構的克立克亦曾參與，但他認為是外星智慧刻意安排生命在星際中遷移。此書則採用岩石泛種論（Lithopanspermia）試著估算微生物附著在拋向太空的岩石上，散播到其他天體的機會。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>我已經陳述了此書的知識概要，雖然大半篇幅是看似無關的天文學細節上，但這是因為作者一再強調的事——生命和宇宙的過往緊緊聯繫著。探索生命起源之謎可以從既有生命回推古早生命，但追尋古早生命的無機物源頭也是個途徑，沒理由不從天文學找線索，或許能從中找到生命之所以如此的終極原因。</p>
<h2 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h2><p>查詢天文生物學相關書籍時往往會碰上名、實不符的狀況。有些書意不在探討形成生命的機制，但內容卻涉及機制的關鍵環節，得了解這領域的研究方向才會注意到。</p>
<p>另外，生命起源和地外生物也是宗教人士愛好的話題，所以有些書雖然叫作「揭開生命起源的奧祕」，實則在提倡智慧設計和玄學理論。還有一些像此書一樣，書名看起來像科幻童書，卻正正經經地介紹組成生物體的物質源頭。</p>
<p>因此，為了挑到合宜的文本，除瀏覽作者背景和內容概要外，還可以透過圖書館分類號確認，其中與天文生物學密切相關的有361.9（天文生物學）和361.12（生命起源）。</p>
]]></content>
      <tags>
        <tag>life in the universe</tag>
      </tags>
  </entry>
  <entry>
    <title>再創世紀</title>
    <url>/church-2014-regenesis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《再創世紀》的作者將合成生物學的各項里程碑比擬為生物演化和產業革命的重要階段，簡介晚近的基因工程技術並討論其引發的倫理爭議。雖然主題不是講解天文生物學，但是此書前三章關於合成生命的討論對釐清生命的定義有許多啟發。</p>
<span id="more"></span>

<p>人造生命可分為三種：由現有物種重組新物種、以生物原料製造生命和電腦模擬的虛擬生命。</p>
<p>2010年克雷格凡特團隊的人工基因組細菌即是重組生物的一個案例，研究者合成出維持生命所需的最短基因，再轉殖到細菌中取代原本的基因，這種極簡生命體不只排除了影響生產效率或實驗結果的未知干擾，製作過程中也有助於辨別何為生命的必須要素。至於從無到有建立生命的嘗試則能在找不到地外生物的情況下，拓展或是挑戰我們對生命的定義。</p>
<p>目前這問題仍莫衷一是，除了國中生物課本採用的條列式定義（生命具有繁殖、生長、代謝、運動等性質），還有NASA的定義：生命是能自我增值並遵循達爾文演化的化學系統。</p>
<p>作者則主張生命並非涇渭分明的概念，而是一種連續的屬性，可以透過再現複雜度（replicated complexity）度量。然而作者沒有明講其定義，只能從他舉的例子推測再現複雜度是指「重現近似複雜結構的能力」和「複雜結構間的關聯性」。這觀念可以解釋條列式定義的反例，例如：</p>
<ul>
<li><strong>病毒</strong>：得仰賴宿主的酵素系統複製基因組，因此只有有限重現能力，是再現複雜度較低的生命形式。</li>
<li><strong>騾子</strong>：雖然不能繁殖，但是體內細胞仍有自我複製能力，而且個體的複雜度源頭可連結自親代，仍有相對高的再現複雜度。</li>
<li><strong>火焰</strong>：火焰也是能夠成長和自我複製的系統，但是延燒火焰的性質和燃燒物有關，和原本的火焰關聯較低，因此再現複雜度不高。</li>
</ul>
<p>不同的定義反映著不同的哲學觀。好比說NASA把生命限制為化學系統是基於太空搜索的實用目的；但是作者作為創造生命的鼓吹者，自然不滿足於這種限制，因此他的定義能涵蓋自我複製並演化的機械人。我覺得重要的不是比較這些定義的優劣，而是了解定義的理論背景和適用範圍。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Church &amp; Regis. (2014). Regenesis: how synthetic biology will reinvent nature and ourselves. 中國由電子工業出版社翻譯並出版，《再創世紀：合成生物學將如何重新創造自然和我們人類》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>what is life</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Complementing a strand of DNA (REVC)</title>
    <url>/complementing-a-strand-of-dna/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 序列，回傳其反向互補序列。</p>
<blockquote>
<p>Given: A DNA string s of length at most 1000 bp.</p>
<p>Return: The reverse complement sc of s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/revc/">https://rosalind.info/problems/revc/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>2017 年交大某生物相關研究所入學考試其中一題為：「若 DNA 其中一股序列為 ATCGATCG，求其 complementary DNA 序列為何？ (A) AUCGAUCG (B) ATCGATCG (C) TAGCTACG (D) GCTAGCTA。」<br>解題的關鍵在了解分子生物的專有名詞定義，以下是各種 DNA 序列的簡介</p>
<ul>
<li>DNA: 去氧核醣核酸</li>
<li>RNA: 轉錄 DNA 之產物</li>
<li>complementary DNA (cDNA)：反轉錄 RNA 之產物</li>
<li>complementary strand of DNA：DNA 兩股互為彼此的 complementary strand of DNA</li>
<li>reverse complement of DNA：順序反轉的 complementary strand of DNA</li>
</ul>
<p>若 DNA 在轉錄後未經加工，原則上對於 DNA 的其中一股而言有以下關係：</p>
<ul>
<li>DNA 序列 &#x3D; complementary DNA 序列</li>
<li>RNA 序列 &#x3D; 把 T 換成 U 的 complementary strand of DNA 序列</li>
<li>complementary DNA 的序列和 complementary strand of DNA 互補</li>
</ul>
<p>因此，答案為 (B) ATCGATCG，若混淆 complementary DNA 和 complementary strand of DNA 會選到完全相反的答案。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>取得反向互補序列的任務可分解為替換鹼基和反轉序列順序。</p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 的字串可以像 list 一樣以索引值提取數值，因此得以 <code>str[::-1]</code> 取得反向序列，此表達式的涵義為「由字串的最後一個字符，一次一個取出所有字符」。而替換互補鹼基則要先建立密碼表（即 A to T, T to A, C to G, G to C），再參考密碼表替換字串中的字符。我使用的第一個策略是以 dictionary 儲存互補鹼基的密碼表，接著建立逐一替換輸入的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    comp = &#123;<span class="string">&quot;A&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;T&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;G&quot;</span>: <span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(comp[nt] <span class="keyword">for</span> nt <span class="keyword">in</span> dna[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>第二個方法則是使用 maketrans(old, new) 建立字符替換的密碼表，再以 translate() 依據密碼表同時替換字串中相應的字符。由於maketrans 是字串這個物件的靜態方法，所以需要在前面加字串來調用之。既然這字串跟副程式其它功能無關，就用空字串表示以免混淆，不然理論上用什麼字串都行，可參考 <a href="https://stackoverflow.com/questions/64513034/purpose-of-string-in-front-of-maketrans">Purpose of string in front of maketrans</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_complement</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;complementing a strand of dna</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> dna[::-<span class="number">1</span>].translate(<span class="string">&quot;&quot;</span>.maketrans(<span class="string">&quot;ATCG&quot;</span>, <span class="string">&quot;TAGC&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下則是我最初的錯誤嘗試，原先打算連續使用 replace() 替換鹼基，但後來發現第一次迴圈的結果會被第二次會圈抵銷掉（第一次：A to T, 第二次 T to A），所以才會採用前述的方法迴避問題。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># WRONG METHOD!</span><br><span class="line">code = &#123;&quot;A&quot;: &quot;T&quot;, &quot;T&quot;: &quot;A&quot;, &quot;C&quot;: &quot;G&quot;, &quot;G&quot;: &quot;C&quot;&#125;</span><br><span class="line">rcdna = dna</span><br><span class="line">for i, j in code.items():</span><br><span class="line">    rcdna = rcdna.replace(i, j)</span><br><span class="line">print rcdna</span><br></pre></td></tr></table></figure>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>相較於 python，R 無法以索引值擷取字符，所以需要將字串轉變為其他格式再處理，以下方法參考 Four ways to reverse a string in R[<a href="https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]">https://www.r-bloggers.com/2019/05/four-ways-to-reverse-a-string-in-r/]</a></p>
<ol>
<li>利用 strsplit() 將字串分割為 list，再以 rev() 反轉 list 順序，最後使用 paste0() 將 list 合併為字串。</li>
<li>利用 utf8ToInt() 將字串中 utf-8 編碼的字符轉變為 UTF-32 編碼的整數向量，再以 rev() 反轉向量順序，最後用 intToUtf8() 恢復 utf-8 編碼的字符組成之字串</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dna &lt;- &quot;AAAACCCGGT&quot;</span><br><span class="line"># strsplit() method</span><br><span class="line">reversed &lt;- paste0(rev(strsplit(dna, &quot;&quot;)[[1]]), collapse = &quot;&quot;)</span><br><span class="line"># utf8ToInt() method</span><br><span class="line">reversed &lt;- intToUtf8(rev(utf8ToInt(dna)))</span><br></pre></td></tr></table></figure>

<p>由於 gsub() 只能把多種匹配到的字符串替換為一種字符串，<br>，所以得倚重可同時替換多種指定字符的 chartr()。  chartr() 的用法接近 bash 的 tr，會將字串中的 old (舊字符) 替換為 new (新字符)，例如 chartr(“AC”, “TG”, str) 表示 A to T, C to G。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rcdna &lt;- chartr(old = &quot;ATCG&quot;, new = &quot;TAGC&quot;, reversed)</span><br><span class="line">print(rcdna)</span><br></pre></td></tr></table></figure>

<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>bash 的作法較 python 和 R 簡潔，讀取字串，以 rev 反轉字串順序，再以 tr 替換互補鹼基等步驟可寫成一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dna=&quot;AAAACCCGGT&quot;</span><br><span class="line">echo &quot;$dna&quot;| rev | tr ATCG TAGC</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Counting DNA Nucleotides (DNA)</title>
    <url>/counting-dna-nucleotides/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 DNA 字串，依照 “A”、”C”、”G”、”T” 的順序，印出四種鹼基符號的數量。</p>
<blockquote>
<p>Given: A DNA string s of length at most 1000 nt.</p>
<p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols ‘A’, ‘C’, ‘G’, and ‘T’ occur in s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/dna/">https://rosalind.info/problems/dna/</a>)</p>
<span id="more"></span>

<p>在此例使用 dictionary 的 key 記錄鹼基符號，利用 value 記錄出現頻率，透過迴圈遍歷整個字串，每逢與 key 相同的字符即增加該 key 之 value。</p>
<p>儘管統計鹼基的方法很直觀，但輸出的順序要留意。題目要求以 A、C、G、T 之順序輸出鹼基出現頻率，但 python 的 <em>dictionary</em> 為無排序的雜湊表，所以值不會依照字母的順序或定義時的順序印出。為了回傳排序後的統計量，要在輸出前調整順序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    freq = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0</span>, <span class="string">&quot;T&quot;</span>: <span class="number">0</span>, <span class="string">&quot;C&quot;</span>: <span class="number">0</span>, <span class="string">&quot;G&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> nt <span class="keyword">in</span> dna:</span><br><span class="line">        freq[nt] = freq[nt] + <span class="number">1</span></span><br><span class="line">    output = <span class="string">&quot; &quot;</span>.join( <span class="built_in">str</span>(freq[nt]) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span> )</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>也可以不自己寫迴圈，套用 python 的字串方法 <em>count()</em> 來統計特定鹼基的數量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nt_freq</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Counting DNA nucleotide</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">str</span>(dna.count(nt)) <span class="keyword">for</span> nt <span class="keyword">in</span> <span class="string">&quot;ACGT&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>shell script 要尋找字串也有許多寫法，其中一種做法是透過 grep -o 取得匹配的鹼基，再傳給 wc -l 計算列數（即字串中，指定鹼基符號的數量）。四種鹼基符號的統計值儲存於 array 並以空格間隔，以便輸出時辨識 array 各項目的數值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&quot;AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC&quot;</span></span><br><span class="line">d=()</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> A C G T;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    d+=$(<span class="built_in">echo</span> $(<span class="built_in">echo</span> <span class="variable">$s</span> | grep -o <span class="variable">$ch</span> | <span class="built_in">wc</span> -l) <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span>  <span class="string">&quot;<span class="variable">$&#123;d[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Counting Point Mutations (HAMM)</title>
    <url>/counting-point-mutations/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定兩等長字串 s 和 t，計算兩者的 Hamming distance dH(s,t)</p>
<blockquote>
<p>Given: Two DNA strings s and t of equal length (not exceeding 1 kbp).</p>
<p>Return: The Hamming distance dH(s,t).</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/hamm/">https://rosalind.info/problems/hamm/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>分子生物學的突變 (mutations) 是基因序列的改變。其中，點突變 (point mutations) 是指單一鹼基的變化，依照變化的模式可分為 transition（pyrimidine → pyrimidine, purine → purine）和 transversion (purine ←→ pyrimidine)。</p>
<p>點突變的常見原因為化學修飾或複製錯誤。例如亞硝酸 (nitrous acid) 可透過氧化脫胺將 cytosine 轉化為 uracil，導致該位置的鹼基在下一輪複製發生 transition：C≡G (initial base pair) → U≡G (after mutation) → U&#x3D;A (after replication)。</p>
<p>由於 Hamming distance 是兩等長字串對應位置之字符不相符的數量，一條序列要轉變為另一條序列最少需要的點突變次數可用 Hamming distance 描述，藉此得以推論源於共同祖先的兩條基因序列的最簡演化途徑。</p>
<ul>
<li>ATCG 和 AAAA 的 Hamming distance 為 3</li>
<li>1234 和 1233 的 Hamming distance 為 1</li>
<li>dog  和 god  的 Hamming distance 為 2</li>
</ul>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>使用迴圈依序比對兩字串對應位置的鹼基是否一致，再透過記數變項統計不相符的數量即可計算 Hamming distance</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;GAGCCTACTAACGGGAT&quot;</span></span><br><span class="line">t = <span class="string">&quot;CATCGTAATGACGGCCT&quot;</span></span><br><span class="line">hdist = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> s[i] != t[i]:</span><br><span class="line">        hdist = hdist + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> hdist</span><br></pre></td></tr></table></figure>
<p>此任務亦可配合 zip 改寫為 list comprehension 形式，即合計兩字串對應位置鹼基符號不相符的數量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">sum</span>([a != b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(s, t)])</span><br></pre></td></tr></table></figure>

<p>簡言之，zip 可將兩 list 的元素依序取出配對形成新的 list，所以能配合 for 一次處理兩個 list 的元素。例如輸入 zip(“abc”, “def”) 會回傳 [(“a”, “d”), (“b”, “e”), (“c”, “f”)]。zip() 的介紹詳見 <a href="https://blog.gtwang.org/programming/python-iterate-through-multiple-lists-in-parallel/">Python 使用 zip 與 for 迴圈同時對多個 List 進行迭代</a></p>
<p>至於 List comprehension 則能以較簡潔的程式碼應用 for loop，也往往有較高的執行效率。此表達法的典型形式為 [expression for item in iterable]。例如要從字串中取出非A的序列，一般的 for loop 寫法為</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># common method</span><br><span class="line">str = []</span><br><span class="line">for i in &quot;AATCGG&quot;:</span><br><span class="line">	if i != &quot;A&quot;:</span><br><span class="line">		str.append(i)</span><br><span class="line">print str</span><br></pre></td></tr></table></figure>
<p>使用 List comprehension 可將程式碼簡化為一行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># list comprehension method</span><br><span class="line">print [i for i in &quot;ATCGG&quot; if i != &quot;A&quot;]</span><br></pre></td></tr></table></figure>
<p>使用 list comprehension 的其他特性，可參考<a href="https://stackoverflow.com/questions/16341775/what-is-the-advantage-of-a-list-comprehension-over-a-for-loop">What is the advantage of a list comprehension over a for loop?</a> </p>
<p>回到 hamming distance 的計算，另一種寫法是不直接加總 True&#x2F;False，而是用判斷式把不相符時的距離加權記錄在程式中，這樣可以明確表達鹼基不符時，要計算多少距離。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_distance</span>(<span class="params">s1, s2</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Calculating hamming distance of two strings with equal length</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span>( <span class="number">1</span> <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s1, s2) <span class="keyword">if</span> c1 != c2 )</span><br></pre></td></tr></table></figure>

<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>R 的作法則是使用 strsplit 將字串轉換為 list，再以向量運算對應位置的鹼基是否一致，最後以 sum 統計相異鹼基的數量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s &lt;- &quot;GAGCCTACTAACGGGAT&quot;</span><br><span class="line">t &lt;- &quot;CATCGTAATGACGGCCT&quot;</span><br><span class="line">sum(strsplit(s, &quot;&quot;)[[1]] != strsplit(t, &quot;&quot;)[[1]])</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>DADA2 execution halted (Error in table: attempt to make a table with &gt;= 2^31 elements)</title>
    <url>/dada2-execution-halted-error-in-table-attempt-to-make-a-table-with-2-31-elements/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文純粹是技術問題。我之前以 Qiime2 外掛的 DADA2 處理已切除轉接子的 16S rRNA 基因序列 (V4 region) 時，因為以下錯誤而中斷了執行四天的程式。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Plugin error from dada2<span class="operator">:</span> An error was encountered <span class="keyword">while</span> running DADA2 <span class="keyword">in</span> R <span class="punctuation">(</span><span class="built_in">return</span> code <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> please inspect stdout and stderr to learn more.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>我檢查錯誤報告後發現以下敘述：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Error <span class="keyword">in</span> table<span class="punctuation">(</span>pairdf<span class="operator">$</span>forward<span class="punctuation">,</span> pairdf<span class="operator">$</span>reverse<span class="punctuation">)</span> <span class="operator">:</span></span><br><span class="line">attempt to make a table with <span class="operator">&gt;=</span> <span class="number">2</span><span class="operator">^</span><span class="number">31</span> elements</span><br><span class="line">Calls<span class="operator">:</span> mergePairs <span class="operator">-&gt;</span> lapply <span class="operator">-&gt;</span> FUN <span class="operator">-&gt;</span> table</span><br><span class="line">Execution halted</span><br><span class="line">Running external command line application<span class="punctuation">(</span>s<span class="punctuation">)</span>. This may print messages to stdout and<span class="operator">/</span>or stderr.</span><br><span class="line">The command<span class="punctuation">(</span>s<span class="punctuation">)</span> being run are below. These commands cannot be manually re<span class="operator">-</span>run as they will depend on temporary files that no longer exist.</span><br></pre></td></tr></table></figure>

<p>於是根據關鍵字查詢只找到<a href="https://github.com/benjjneb/dada2/issues/641">一起相似案例</a>，但該討論串沒有提供可行的解決辦法。簡言之，提問者的資料中可能有人類序列汙染，導致獨特序列的數量超出 DADA2 演算法的上限，所以程式才異常中斷。</p>
<p>然而，抽檢資料卻沒發現人類序列汙染，而且使用小量資料可以順利執行，讓我難以判斷問題的癥結點。因此，我蒐集 Qiime2 論壇上常提到的出錯狀況，一一測試來確認能否解決問題。</p>
<p>首先，我<a href="https://forum.qiime2.org/t/dada2-error-return-code-1/7140/3">調整了線程</a>以免記憶體用罄，接著<a href="https://forum.qiime2.org/t/dada2-return-code-1/2972">檢查格式</a>確保資料完整無誤，也重新安裝以排除未知問題，但這些方法都無濟於事，所以我只好 Qiime2 論壇<a href="https://forum.qiime2.org/t/dada2-execution-halted-error-in-table-attempt-to-make-a-table-with-2-31-elements/11845">求助</a>。</p>
<p>開發團隊指出，這狀況可能是資料中有未清除的技術片段、定序品質太差或是存在汙染序列，使得 DADA2 在其中一步驟時，因數據量過載而中斷（這也可以解釋少量資料可以順利執行的原因）。</p>
<p>在我移除潛在的文庫汙染，切除末端的低品質序列後，DADA2 便能順利執行了。綜上所述，此錯誤源於數量過多的低品質&#x2F;汙染序列，在移除汙染和品質控管後，即可解決問題。</p>
<p>而關於除錯，我也學到了幾個經驗：</p>
<ul>
<li>仔細閱讀錯誤訊息，鎖定問題癥結點後才能有效排除障礙。胡亂猜測出錯原因無濟於事，反而浪費時間和精力。</li>
<li>要以錯誤訊息為關鍵字，上網找尋類似問題的解決方式；若找不到直接相關的問題，則重新檢視演算法，說不定可以找到問題來源。</li>
<li>把蒐集到的方法整理成表，一一測試結果。</li>
<li>若查詢和測試皆無果，則準備詳盡資料到專門論壇求助。</li>
<li>解決問題後把過程記錄下來，幫助其他人克服困難🥰</li>
</ul>
]]></content>
      <tags>
        <tag>metagenomics</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Enumerating Gene Orders (PERM)</title>
    <url>/enumerating-gene-orders/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一正整數 n，求包含數字 1 到 n 的所有可能數列與其總數。</p>
<blockquote>
<p>A permutation of length n is an ordering of the positive integers {1,2,…,n} . For example, π&#x3D;(5,3,2,1,4) is a permutation of length 5.</p>
<p>Given: A positive integer n≤7 .</p>
<p>Return: The total number of permutations of length n , followed by a list of all such permutations (in any order).</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/perm/">https://rosalind.info/problems/perm/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>基因體重排（genome rearrangement）泛指基因體上發生的刪除（deletion）、插入（insertion）、重複（duplication）、反轉（inversion）或易位（translocation）等現象。這些變動通常涉及數百至數百萬對鹼基，相較於點突變，它們的影響更為廣泛。</p>
<p>基因體重排的發生機制主要有<sup id="fnref:gu2008"><a href="#fn:gu2008" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.
">gu2008</span></a></sup>：</p>
<ul>
<li>non-allelic homologous recombination (NAHR)：細胞分裂中，染色體對齊時發生錯位，導致片段重組。</li>
<li>non-homologous end-joining (NHEJ)：DNA 斷鍊修復時，連結了非同源的染色體。</li>
<li>Fork Stalling and Template Switching (FoSTeS)：DNA 複製時因故停滯時，新合成的 DNA 意外移動到其他模板進行複製。</li>
</ul>
<p>這些變化可能導致基因無效而喪失功能、彼此融合而改變功能，或是副本數變動而加強&#x2F;減弱功能，從而影響細胞結構與生理。許多疾病和癌症與基因體重排有關，例如 BRCA1 和 BRCA2 的副本數變化與乳癌發作密切相關。<sup id="fnref:ewald2009"><a href="#fn:ewald2009" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.
">ewald2009</span></a></sup></p>
<p>基因體重排不僅是疾病基因體學的重要研究對象，也因為被視為種化的分子機制之一，而在演化生物學中占一席之地。相較於點突變，基因體重排的發生頻率較低，使得親緣關係相近的物種在染色體層級上保持一致，即使它們在局部基因序列上略有不同。</p>
<p>然而，親緣關係較遠的物種則可能因為基因體重排而有顯著差異。在演化過程中，這些沒有被分離到道不同區域或染色體的基因彼此聚集成 synteny block。在比較基因體學中，synteny block 提供了一種比染色體數量和大小更細緻的描述單位，有助於在不過度瑣碎的層級上討論基因體的變化。透過比較 synteny block 的繼承與變化，可以推輪物種分化的歷史。<sup id="fnref:touchman2010"><a href="#fn:touchman2010" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">touchman2010</span></a></sup></p>
<p>這題的設計反映了基因體重排的概念，將每個數列視為一條染色體，其中每個數字代表一個 synteny block，數字的順序則代表這些 block 在餐考基因體上出現的順序或染色體編號。透過模擬單一染色體 synteny block 的不同排列，探索可能的重排情境。</p>
<h1 id="解題"><a href="#解題" class="headerlink" title="解題"></a>解題</h1><p>讓我們從最簡案例來推論怎麼用遞迴解這題。假設數列只有一個數字，也就只有一種可能的排列；而兩個數字的排列也很直觀。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n = 1</span></span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># n = 2</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>現在考慮數列有三個數字的情形。由於沒辦法一眼得到解答，於是我們需要更系統的解決辦法，其中一個策略是：</p>
<ol>
<li>先取出其中一個數字</li>
<li>排列剩下的數字</li>
<li>把取出的數字加回排列結果</li>
<li>重複取出所有數字後，便得到數列的所有可能</li>
</ol>
<p>如同以下各數列所示，我首先依序取出 1、2、3 （數列的首項），然後再排列剩餘兩個數字，再把取出的數字與排列後的數列結合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># n = 3</span></span><br><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>歸納前述方法，便能用 python 實作以下關係：</p>
<ul>
<li>若數列只有一個數字，回傳此數列</li>
<li>若數列不只一個數字，則依序取出各數字，排列剩餘數字，再把取出的數字加到排列的結果中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Permutations of a list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [l]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>隨後便可整理排列的結果為題目要求的格式。由於我們已經列出所有可能數列，所以直接計算數列總數即可，不用多做一次階乘計算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_permutations</span>(<span class="params">n</span>):</span><br><span class="line">    num_perms = lperm(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(num_perms))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> num_perms:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, p)))</span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>我解這題的靈感來自 <a href="https://stackoverflow.com/questions/23116911/all-permutations-of-a-string-in-python-recursive">All Permutations of a String in Python (Recursive)</a> 這串問答，我只需要把原方法改寫為適合 list 的方式即可。不過一開始我寫成以下形式，能看出會報什麼錯誤嗎？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !!!! WRONG SOLUTION !!!!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> = [</span><br><span class="line">            p + [e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> lperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>關鍵在於遞迴關係的初始狀態設定，這個 function 預期要回傳一個存儲所有可能數列的巢狀 list，但我在初始狀態的時候寫成 <code>return l</code>，導致遞迴調用 function 回傳了一個攤平的 list。於是 <code>p</code> 就成了整數，自然無法和 <code>[e]</code> 相連，讓程式無法運作。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:ewald2009"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">ewald2009.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Ewald et al. (2009). Genomic rearrangements in BRCA1 and BRCA2: A literature review. Genetics and Molecular Biology, 32, 437-446.<a href="#fnref:ewald2009" rev="footnote">↩</a></span></li><li id="fn:gu2008"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">gu2008.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Gu et al. (2008). Mechanisms for human genomic rearrangements. Pathogenetics, 1, 1-17.<a href="#fnref:gu2008" rev="footnote">↩</a></span></li><li id="fn:touchman2010"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">touchman2010.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/">https://www.nature.com/scitable/knowledge/library/comparative-genomics-13239404/</a><a href="#fnref:touchman2010" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND | Enumerating k-mers Lexicographically (LEXF)</title>
    <url>/enumerating-k-mers-lexicographically/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定字符序列 $\mathscr{A}$，求由這些字符組成且長度為 k 的所有字串。這些字串須依照 $\mathscr{A}$ 字典序排列。</p>
<blockquote>
<p>Given: A permutation of at most 12 symbols defining an ordered alphabet $\mathscr{A}$ and a positive integer n (n≤4).</p>
<p>Return: All strings of length at most n formed from $\mathscr{A}$ , ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/lexv/">https://rosalind.info/problems/lexv/</a>)</p>
<span id="more"></span>
<p>$\mathscr{A}$ 是一個字符序列，除了規範了可用的字符外，也定義了這些字符的字典序。像是英文字母的字典序是從 A 到 Z，所以 “AA” 會排在 “AB” 前面。這題要求從 $\mathscr{A}$ 生成指定長度的所有可能字串，並確保這些字串依照字典序排序。</p>
<p>假設今有 $\mathscr{A}$ 為 <code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code>，而且指定長度為 3，則生成步驟為：</p>
<ol>
<li>從 $\mathscr{A}$ 依序取出字符來組成字串（”A”、”B”、”C”）</li>
<li>對於每個字符，追加 $\mathscr{A}$ 中的每个字符，生成長度為 2 的所有可能字串（”AA”、”AB”、”AC”、”BA”、”BB”、……”CC”）</li>
<li>對於長度為 2 的字串，再度追加 $\mathscr{A}$ 中的每个字符，生成長度為 3 的所有可能字串（”AAA”、”AAB”、”AAC”、”ABA”、……”CCC”）</li>
<li>最終將生成 $3 \times 3 \times 3 &#x3D; 27$ 個字串。</li>
</ol>
<p>由上述案例，我們可以歸納遞迴關係如下：</p>
<ul>
<li>終止條件：當 <code>k=1</code> 時，回傳 $\mathscr{A}$。</li>
<li>遞迴關係：對於 $\mathscr{A}$ 每個字符，生成長度為 <code>k - 1</code> 的所有可能字串，再讓字符作為這些字串的前綴。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lexf</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate all permutations of a specified length from a given set of elements.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> elements</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;e&#125;</span><span class="subst">&#123;k_str&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> elements</span><br><span class="line">            <span class="keyword">for</span> k_str <span class="keyword">in</span> lexf(elements, k - <span class="number">1</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<p>最後再把結果依題目要求的格式印出來。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_results</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="keyword">for</span> k_str <span class="keyword">in</span> lexf(elements, k):</span><br><span class="line">        <span class="built_in">print</span>(k_str)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Enumerating Oriented Gene Orderings (SIGN)</title>
    <url>/enumerating-oriented-gene-orderings/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一正整數 n，求包含數字 1 到 n 與 -1 到 -n 的所有可能數列與其總數。</p>
<blockquote>
<p>A signed permutation of length n is some ordering of the positive integers {1,2,…,n} in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, π&#x3D;(5,−3,−2,1,4) is a signed permutation of length 5</p>
<p>Given: A positive integer n≤6</p>
<p>Return: The total number of signed permutations of length n, followed by a list of all such permutations (you may list the signed permutations in any order).</p>
</blockquote>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Synteny blocks 是相異物種因為基因體重排而分離的同源片段。在 <a href="https://5uperb0y.com/enumerating-gene-orders/">Enumerating Gene Orders</a> 當中介紹了以數列排列模擬 synteny blocks 重排的想法，我們可以額外考慮 blocks 的方向性來改善模型的精細度。DNA 雖然由兩股去氧核酸構成，但轉錄僅發生在其中一股。</p>
<p>由於 synteny blocks 在演化過程中除了易位，也可能發生轉置，顛倒基因的排列和方向性，改變轉錄與基因調控等行為，從而影響個體的表徵。例如，Factor VIII Intron 22 的轉置便是血友病A的成因之一。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>這題的解法近似<a href="https://5uperb0y.com/enumerating-gene-orders/">數列的排列</a>，只是透過正負號來表示 synteny blocks 的方向。因為要考慮正負符號，所以需要兩個調整。</p>
<ol>
<li>遞迴的 base case 要回傳數字與其相反數。例如輸入數列 <code>[1]</code>，要回傳 <code>[[1], [-1]]</code>。</li>
<li>在把數字放回排列後的數列時，也要分別加入數字和其相反數。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">slperm</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;permutations of a numberic list, including -/+ of each number.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [[l[<span class="number">0</span>]], [-l[<span class="number">0</span>]]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            p + [sign_e]</span><br><span class="line">            <span class="keyword">for</span> i, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(l)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> slperm(l[:i] + l[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> sign_e <span class="keyword">in</span> [e, -e]</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:lakich1993"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">lakich1993.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Lakich et al. (1993). Inversions disrupting the factor VIII gene are a common cause of severe haemophilia A. Nature genetics, 5(3), 236-241.<a href="#fnref:lakich1993" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>《時空旅人之妻》的人物描繪分析</title>
    <url>/exploring-character-depictions-in-the-time-travelers-wife/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《時空旅人之妻》細膩地刻劃出由於時空錯置所引發的複雜情緒，如悲傷、惆悵與無奈等。以主角亨利為例，在他首次覺悟到，自己竟然是唯一的時空穿越者的情節中，作者精確地捕捉並揭露了年幼亨利的失落與成年亨利的無助，以及無論在何時都無法擺脫的孤獨。</p>
<p>這橋段我非常喜歡，因此全文引述如下：</p>
<blockquote>
<p>這若即若離的半透明時刻。另一個我原先搞不太清楚，然後就懂了。就像現在這樣，我看著這件事情發生，希望同時成為我們兩個，希望再感受那種迷失自己的感覺，希望再一次感受第一次看到未來和現在夾雜在一起的感覺。但是我已經太習慣、太熟悉這種感覺了，所以我只能當個局外人。我想起我九歲時的驚訝，我那時突然了解：我的朋友、導師兼哥兒們，就是我。我，就只有我。這種感覺真寂寞。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>「你就是我。」<br>「但你比較老。」<br>「可是……其他人呢？」<br>「其他的時空旅人嗎？」<br>他點點頭。<br>「我不認為還有別的時空旅人，我從來沒碰過其他人。」</p>
<p>有顆淚珠凝聚在他左眼眼角。當我還是個小鬼頭時，我想像有一大群時空旅人，而亨利，也就是我的老師，是一名使者，被派來訓練我；而我最後也能加入這個友好的大圈子。我到現在依然覺得自己就像個被世人遺棄的人，是某個曾經繁榮族類碩果僅存的一人。這就好像魯賓遜在海灘上發現了人類的足跡，但後來才知道那是他自己的腳印。那個我自己，那個小得像片樹葉、薄得像水的自己，哭了起來。我抱住他，抱住自己，久久不放。</p>
<p>後來，我們向客房服務點了熱巧克力，一邊觀賞強尼．卡森的節目。燈還亮著，亨利就睡著了。節目播完後，我盯著他看，直到他消失無蹤，回到我爸公寓的那個老房間，昏昏欲睡地站在以前那張床的床邊，然後滿心感激地倒在床上。我把電視和床頭燈關掉，一九七三年的街道噪音從打開的窗戶飄進來。我想回家。我躺在旅館硬梆梆的床上，很孤單、很寂寞，還是不明白這是怎麼一回事。</p>
</blockquote>
<p>除了情感的刻劃，角色和環境的描寫也栩栩如生。加上作者巧妙地運用時間跳躍的設定，為角色的日常生活情節添加了懸疑、推理，甚至是動作的元素，所以即便故事的主線是描述日常的愛情關係進展，卻仍然能引人入勝。</p>
<p>因此，我認為值得花時間去研究和學習作者的寫作技巧。例如，書中描述亨利偶然在過去碰見母親的片段，在此場景，亨利以旁觀者的角度，描述眼前母親的形象：</p>
<blockquote>
<p>我看到媽媽跟我在一起的情況：她懷孕了；他們把我從醫院抱回家了，她推著嬰兒車去公園，坐下來背樂譜，輕聲唱著歌，還微微比著手勢，對我扮鬼臉，拿玩具逗我；或是牽著我的手散步，欣賞松鼠、汽車、鴿子，以及任何會動的東西。(page 127)</p>
</blockquote>
<p>作者以行為而非外觀作為起點，透過描繪與母親共度的生活點滴，來塑造出讀者可以共鳴的人物形象。</p>
<p>我覺得有趣的地方在於，這段文字雖然字詞簡潔，描述亦不繁複，然而，這些行為的涵義已深深烙印在大眾的共識中，無論這些印象來源於媒體或個人經驗。因此，儘管沒有明示行為中的親情元素，讀者仍能依照自己的經驗，補全對於「慈愛」的回憶與想像。</p>
<p>換言之，在敘述故事時，文字不只是人物形象的代言，更是激發讀者想像力的媒介。我們如何描述人物，其實源於我們如何觀察人。當我們在腦海中塑造人物形象時，我們最關注的是什麼特質？在寫作時，我們又希望這些人物如何在故事和我們的想像中活躍？除了外貌、打扮和性格標籤外，什麼樣的行為可以讓人物顯得充滿生命力？</p>
<p>此外，我也摘錄了書中一些描述人物外觀的段落，試圖了解作者怎麼形容人物的外觀，並藉此佐證透過人物行為所營造的形象。</p>
<p>案例一，亨利描述他的母親：</p>
<blockquote>
<p>她穿著布做的外衣還有七分褲，腳上套著懶人鞋。她有一頭烏黑的秀髮、引人注目的五官、豐滿的嘴唇、大大的眼睛、俏麗的短髮；她看起來像義大利人，但其實是猶太人。我媽連去乾洗店也會擦口紅、畫眼線、塗睫毛膏、刷腮紅還有畫眉毛(page 127)</p>
</blockquote>
<p>案例二，克萊兒首次拜訪亨利家時，見到金咪（很照顧亨利的鄰居）的印象：</p>
<blockquote>
<p>亨利敲了敲一間公寓的門。有個嬌小的韓國女人馬上就把門打開，那是金咪，她穿著一件藍色絲質洋裝，還塗著大紅色的口紅，她的眉毛畫得有點左右不平衡，頭髮是黑白相間的那種灰色。她把頭髮編成辮子，然後在兩邊的耳朵旁各盤了一個髮箕。不知為什麼，她讓我想到了羅絲．高登。金咪身高大概到我肩膀，她把頭往後仰，說，「亨利，她長得太漂亮了！」(page 250)</p>
</blockquote>
<p>案例三，克萊兒瞧著亨利的父親：</p>
<blockquote>
<p>我點點頭，然後跟著她走進客廳，亨利的爸爸也在裏頭，坐在一張扶手椅上。<br>他什麼話也沒說，就只是盯著我看。亨利的爸爸高高的，瘦骨嶙峋，看起來很疲憊的樣子。他長得不太像亨利，有一頭灰白的短髮、黑眼睛、長鼻子、薄嘴唇，嘴角有一點下垂。他縮成一團坐在椅子裡，我注意到他的手，又長又優雅，就像正在打盹的貓咪躺在他的膝蓋上。(page 251)</p>
</blockquote>
<p>案例四，初次約會時，亨利對克萊兒的觀察：</p>
<blockquote>
<p>「哈囉，」我打了個招呼，克萊兒穿著一件酒紅色的絲絨洋裝，戴著珍珠項鍊，看起來就像是用約翰．葛萊姆手法所寶線出來的波提切利畫下的女子，有著灰色的大眼睛、挺直的鼻子、日本藝妓般的櫻桃小口。她的紅色秀髮及肩，遮住了她的肩膀。克萊兒實在是太蒼白了，看起來就像燭光下的蠟像。我把玫瑰花送到她的面前，「送給妳的。」(page 21)</p>
</blockquote>
<p>案例五，亨利與往後的摯友首次見面：</p>
<blockquote>
<p>電鈴聲很嚇人，我把門打開。「往上走就對了！」一個低沉的男性嗓音喊道。我慢吞吞地爬了四段樓梯。嗓音來自一個高大的金髮男性。留著舉世無雙的龐巴度髮型，叼著一根菸，穿著波蘭「團結工聯」的T桖。他看起來很面熟，但我一時想不起曾在哪裡見過他。對一個有著西班牙名「戈梅茲」的人來說，他看起來太像……波蘭人了。後來我才知道他的真名是楊．戈莫林斯基。(page 147)</p>
</blockquote>
<p>案例六，亨利與克萊兒的父親見面：</p>
<blockquote>
<p>克萊兒介紹我時，他們突然微微露出一股嫌惡之情，不過菲利普．艾布希爾是名律師，可以主宰他臉上的五官，所以在一分鐘之內就換成了一張和藹可親的笑臉。這位東道主，也就是我女朋友的爸爸，一個頭逐漸禿了的中年人，戴著飛行員眼鏡，有一副鬆弛中的運動員身材，還有一雙肥厚有力的手、打網球的人的手，雖然他很推心置腹地咧著嘴笑，但是一直用灰色的眼睛充滿驚覺地盯著我。(page 187)</p>
</blockquote>
<p>案例七，亨利去拜訪肯德瑞克博士（亨利的主治醫師）：</p>
<blockquote>
<p>我進入肯德瑞克博士的辦公室，他在某個檔案夾上記東西。我坐了下來，他還在寫。他比我想像的更年輕，大概才三十七、八歲吧。我總以為醫生都是老人家，沒辦法，這是我小時候見過無數個醫生所留下來的印象。肯德瑞克博士有一頭紅髮，臉很瘦，留著絡腮鬍，還帶著鏡片很厚的金屬框眼鏡。他看起來有點像 D. H. 勞倫斯，穿著一套很好看的炭灰色西裝，打著細長的深綠色領帶，領帶上別著虹鱒的領帶夾。這間房間瀰漫著香菸的煙霧，雖然她現在沒有抽菸，但菸灰缸都滿出來了。房間裡的一切都很現代：鋼管、米色的斜紋布、淺色的木頭。他抬頭看著我，對我微笑。(page 327)</p>
</blockquote>
<p>總結這些段落，我們可以發現，人物的介紹始於一個事件，事件讓文字聚焦在人物身上，也確定了描繪的起點。新角色透過感知（案例五）、回憶（案例一）、空間轉換（案例二、案例七）等情況自然地進入場景。</p>
<p>進入場景的事件也限制了最初描繪人物的方式。比如在案例五中，如果亨利是透過聽到呼喊聲才意識到戈梅茲的存在，那麼一開始，應該只能仰賴聽覺描述，隨著戈梅茲進入視線範圍，才會加入視覺描述。</p>
<p>在案例二中，當金咪出現在門口時，克萊兒首先注意到的是金咪的衣著（個人最明顯的特徵），然後才是對方的臉，特別是對髮型的詳細描述。而在案例三中，克萊兒是被動地注意到亨利父親的視線，所以反而是先描述對方五官的形象，然後再描寫手部的狀況。</p>
<p>完成初步描述後，作者的描述模式因角色而有所不同，但仍可以歸納為以下幾點：</p>
<ol>
<li>陳述引入人物的事件，然後根據事件的性質，給出人物的初步描述。</li>
<li>從最顯眼處描述人物的衣著、五官或身材，然後從頭到腳或從腳到頭補充細節。例如在案例六中，因為首先描述了克萊兒父親的禿頭，所以接下來才從上到下描述角色的眼睛、身材和手；而在案例二中，則是先看到金咪的口紅，所以從下到上依次描述眉毛與發型。</li>
<li>詳細描述能反映角色形象的外觀特徵，比如在案例一中的母親的妝容、案例二中的金咪的髮型、案例三中的亨利父親的手，以及案例五中的熟悉的面孔。</li>
<li>可以穿插敘述者對人物的印象或比喻等，幫助讀者想像。</li>
</ol>
<p>儘管這些內容還不全面，但我認為這樣的模式已經可以指引一些寫作方向。畢竟，人物描寫不僅僅是文筆問題，還涉及到如何選擇對象、要觀察哪些特徵、如何尋找故事性、要選擇哪些詞語等問題。因此，為了提高人物描述的能力，我可能會進行以下的練習：</p>
<ol>
<li>留意記憶中或生活中值得關注的人物。</li>
<li>回想這些人物因為何種事件或行為讓人印象深刻。</li>
<li>按照本文總結的模式進行人物描寫。</li>
<li>通過描寫的過程，了解自己在詞匯和觀察方面的不足。</li>
<li>思考這些人物描述可以放在故事的哪個環節，需要多少篇幅才合適。</li>
</ol>
<p>當然，這些指導是為了練習寫作而設計的，除了外觀和行為，人物形象還包括思想、習慣、信仰、目標、能力和恐懼等面向，而人物描述也只是故事的其中一個環節。</p>
<p>然而，外表和行為是最容易觀察的項目，也是反映人物態度與選擇最直接的線索。因此，從這些外顯要素著手，對於寫作新手的我來說，或許是一個非常好的出發點。</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND | Finding a Motif in DNA (SUBS)</title>
    <url>/finding-a-motif-in-dna/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>給定字串 s 與 t，其中 t 的長度小於等於 s，求 s 與 t 一致之子序列的起始位置。</p>
<blockquote>
<p>Given: Two DNA strings s and t (each of length at most 1 kbp).</p>
<p>Return: All locations of t as a substring of s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/subs/">https://rosalind.info/problems/subs/</a>)</p>
<span id="more"></span>
<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Motif 是指在一範圍內反覆出現且具鮮明特質的物體或概念，其指涉的對象因脈絡而異 。在分子生物中，motif 被用以形容一段為生物體共享的核酸或蛋白質序列，這些序列可能有相似的功能，且對各生物都至關重要。在網路生物學中，motif 則可用以形容一出現頻率高於隨機分布的子圖，這些子圖的出現頻率很高且有獨特的網路結構，因此能在欠缺相關生物學知識的情況被辨識出來。而在結構生物學中，motif 則代表核酸或蛋白質上呈規律結構的區段，這些區段可能由多個二級結構所構成。</p>
<p>雖然 motif 定義多元，但皆不脫「重複」與「特別」兩項屬性。是以，透過在核酸或蛋白質序列尋找重複序列來辨識 motif，也算在找尋某種特別的屬性。在結構生物學中，domain 是與 motif 相關的概念。Domain 也具有規律的結構和鮮明的特質，但與 motif 不同，domain 能獨立發揮某項功能。換句話說，motif 強調結構的實體，而 domain 則強調功能的實體。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>此題意在尋找與 motif 相符的子字串之位置。在 Python 中，我首先建立 list 儲存子字串位置，接著以 for 迴圈依序取出長度與 motif 一致的子字串，再比對兩者的序列。若序列一致，則將子字串的起始位置儲存至 list。由於 python 計數由 0 開始，所以輸出結果還要 +1 才符合題目要求。因為最後要回傳 list，所以也能用 list comprehension 呈現。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subs</span>(<span class="params">s, t</span>):</span><br><span class="line">	<span class="keyword">return</span> [</span><br><span class="line">		i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(s[:-<span class="built_in">len</span>(t)])</span><br><span class="line">		<span class="keyword">if</span> s[i:i+<span class="built_in">len</span>(t)] == t</span><br><span class="line">	]</span><br></pre></td></tr></table></figure>

<p>最後再把結果依照題目要求印出，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(subs(s,t))))</span><br></pre></td></tr></table></figure>

<p>在 R 中，我採取了另一種策略：先列出所有與 motif 長度一致的子字串，再回傳序列與 motif 相同的子字串位置。因此，我先定義了能從一字串取出所有特定長度子字串的 function。接著再以 grep 搜索子字串中，與 motif 相符者的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exemplified data</span><br><span class="line">dna &lt;- &quot;GATATATGCATATACTT&quot;</span><br><span class="line">motif &lt;- &quot;ATAT&quot;</span><br><span class="line"># Generate kmer from a string</span><br><span class="line">kmer &lt;- function (s, k) &#123;</span><br><span class="line">  char &lt;- unlist(strsplit(s, &quot;&quot;))</span><br><span class="line">  kmer &lt;- unlist(lapply(0:(nchar(s) - k), function (x) &#123;paste0(char[seq(k) + x], collapse = &quot;&quot;)&#125;))</span><br><span class="line">  return(kmer)</span><br><span class="line">&#125;</span><br><span class="line"># identify motif from kmer with grep </span><br><span class="line">find_motif &lt;- function (dna, motif) &#123;</span><br><span class="line">  mer &lt;- kmer(dna, nchar(motif))</span><br><span class="line">  return(grep(motif, mer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="1-motif-相關知識來源"><a href="#1-motif-相關知識來源" class="headerlink" title="1. motif 相關知識來源"></a>1. motif 相關知識來源</h2><p>本文關於 motif 的定義參考以下文獻與網站</p>
<ul>
<li><a href="https://www.merriam-webster.com/dictionary/motif">https://www.merriam-webster.com/dictionary/motif</a></li>
<li>[莊榮輝，生物化學基礎 Biochemistry Basics 2008] (<a href="http://juang.bst.ntu.edu.tw/BC2008/slides/Proteinx3a.htm">http://juang.bst.ntu.edu.tw/BC2008/slides/Proteinx3a.htm</a>)</li>
<li>Pizzuti, &amp; Rombo. (2018). Algorithms for Graph and Network Analysis: Clustering and Search of Motifs in Graphs. Encyclopedia of Bioinformatics and Computational Biology: ABC of Bioinformatics, 95.</li>
</ul>
<h2 id="2-R-kmer-function"><a href="#2-R-kmer-function" class="headerlink" title="2. R: kmer function"></a>2. R: kmer function</h2><p>K-mers 是指一字串所有長度為 k 的子字串，長度為 l 之字串會有 l - k + 1 個 k-mers，此概念常用於基因體學的序列比對和品質篩選的演算法。</p>
<p>我的 kmer function 的運作方式是先將字串分割為獨立字符，再用 lapply 依序取出 k 個字符以 paste0 合併為長度為 k 的子字串。由於僅有 l - k + 1 個 k-mers，所以 lapply 迴圈僅執行  l - k + 1 次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kmer &lt;- function (s, k) &#123;</span><br><span class="line">  char &lt;- unlist(strsplit(s, &quot;&quot;))</span><br><span class="line">  kmer &lt;- unlist(lapply(0:(nchar(s) - k), function (x) &#123;paste0(char[seq(k) + x], collapse = &quot;&quot;)&#125;))</span><br><span class="line">  return(kmer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-R-grep-和-grepl"><a href="#3-R-grep-和-grepl" class="headerlink" title="3. R: grep 和 grepl"></a>3. R: grep 和 grepl</h2><p>grep 用以尋找文字向量中符合特定模式的元素之索引值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; grep(pattern = &quot;A&quot;, x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;))</span><br><span class="line">[1] 1 5</span><br></pre></td></tr></table></figure>
<p>grepl 用以判斷文字向量的各元素是否符合特定模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; grepl(pattern = &quot;A&quot;, x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;A&quot;))</span><br><span class="line">[1]  TRUE FALSE FALSE FALSE  TRUE</span><br></pre></td></tr></table></figure>
<p>由於此題要求回報子字串的位置，因此使用 grep 實踐之。</p>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND | Finding a Shared Motif (LCSM)</title>
    <url>/finding-a-shared-motif/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一 FASTA 檔案，內含數條由 A、C、G、T 組成的字串，求這些字串共享的最長子字串。</p>
<blockquote>
<p>A common substring of a collection of strings is a substring of every member of the collection. We say that a common substring is a longest common substring if there does not exist a longer common substring. For example, “CG” is a common substring of “ACGTACGT” and “AACCGTATA”, but it is not as long as possible; in this case, “CGTA” is a longest common substring of “ACGTACGT” and “AACCGTATA”.<br>Note that the longest common substring is not necessarily unique; for a simple example, “AA” and “CC” are both longest common substrings of “AACC” and “CCAA”.</p>
<p>Given: A collection of k (k≤100) DNA strings of length at most 1 kbp each in FASTA format.</p>
<p>Return: A longest common substring of the collection. (If multiple solutions exist, you may return any single solution.)</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/lcsm/">https://rosalind.info/problems/lcsm/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>如果我們能夠透過理論計算或是資料庫數據得知某種 motif 的組成，便能按照 <a href="https://5uperb0y.com/finding-a-motif-in-dna/">Finding a motif in dna</a> 這題的要求，在一條 DNA 中尋找已知 motif 的位置。然而，並非所有研究對象都能事前得知 motif 的資訊，所以更常見的方法是透過比較多組基因體，歸納出反覆出現且序列相似的 motif。</p>
<p>為了簡化問題，這題只要求找出最長的 motif，因為長度愈長，motif 涉及的功能往往越多。此外，題目還假設同一種 motif 的序列完全一致，這意味著這些 motif 在演化中沒發生任何突變，暗示其功能相當重要，具有相當的穩定性。換句話說，這些 motif 可能反映了各基因體共享的核心功能。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>這題相當於尋找各字串的最長共同子字串（longest common substring, LCS）。最直觀的解法在於了解「 LCS 的長度不大於最短字串的長度」，因此可以列出最短字串的所有子字串，再拿這些子字串由長至短一一與其它字串比較。第一個出現在所有字串的子字串就是題目要求的 LCS。</p>
<p>以下使用 python 實作這個算法，首先找到最短的子字串 <code>min_s</code>，求出它所有的子字串 <code>kmer</code>，最後由長至短檢查子字串是否出現在所有字串中，一旦符合條件，便直接回傳結果。（由於這裡是由短至長生成 <code>kmer</code>，所以後面把它倒置 <code>kmer[::-1]</code> 來改變比對的順序。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common substring from multiple strings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    min_s = <span class="built_in">min</span>(strs, key = <span class="built_in">len</span>)</span><br><span class="line">    kmer = [</span><br><span class="line">        min_s[i:i+k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_s) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(min_s) - k)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> mer <span class="keyword">in</span> kmer[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(mer <span class="keyword">in</span> s <span class="keyword">for</span> s <span class="keyword">in</span> strs):</span><br><span class="line">            <span class="keyword">return</span> mer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>由於題目要求輸入 FASTA 檔案，所以需要一個讀檔的副程式。FASTA 檔案是紀錄序列的通用文字格式，<code>&gt;</code> 開頭的列紀錄 DNA、RNA或蛋白質序列的名稱，直到碰到下一個 <code>&gt;</code> 符號之前的列則記錄了序列本身。為了方便在終端機用肉眼判讀，有些 FASTA 檔案中的序列會分成數列表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Read_id</span><br><span class="line">ACTGACTGATCGGATAGTAGTGATAGCGATCGATCAGCATATCGACTATCAGCTAGCTACAGCTGAGCATCGATCG</span><br><span class="line">ACGATTACGACGATCAG</span><br></pre></td></tr></table></figure>

<p>以下程式將 FASTA 讀進 python dictionary。凡是 <code>&gt;</code> 開頭的列，就把它當作 dictionary 的 key，而其餘的列則串接起來成為 dictionary 的 value。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_fasta</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Read a fasta file into a dictionary</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reads = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;&gt;&quot;</span>):</span><br><span class="line">                key = line[<span class="number">1</span>:].strip()</span><br><span class="line">                reads[key] = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reads[key] = reads[key] + line.strip()</span><br><span class="line">        <span class="keyword">return</span> reads</span><br></pre></td></tr></table></figure>

<p>結合讀檔與 LCS 主程式，便能滿足題目的要求了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcsm</span>(<span class="params">fasta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common nucleotide sequence from multiple sequences in a fasta file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seqs = <span class="built_in">list</span>(read_fasta(fasta).values())</span><br><span class="line">    <span class="keyword">return</span>(lcs(seqs))</span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="longest-common-substring-longest-common-subsequence"><a href="#longest-common-substring-longest-common-subsequence" class="headerlink" title="longest common substring &amp; longest common subsequence"></a>longest common substring &amp; longest common subsequence</h2><p><a href="https://en.wikipedia.org/wiki/Longest_common_substring">Longest common substring</a> 和 <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence">longest common subsequence</a> 是不同的問題：”AB” 是 “ABXC” 和 “ABOC” 的 longest common substring，”ABC” 則否；<code>[A, B, C]</code> 是 <code>[A, B, X, C]</code> 和 <code>[A, B, O, C]</code> 的 longest common subsequence，<code>[A, B]</code> 則否。</p>
<p>因為在生物資訊的語境裡，序列（sequence）也用於描述 DNA&#x2F;RNA&#x2F;蛋白質，而這些序列資訊往往也用字串（string）紀錄。因此，當初想這題有什麼巧妙解法時，誤入歧途去查了 longest common “subsequence” 的解法。</p>
<p>寫出的程式沒有返回預期結果時，問問 chatgpt 怎麼解 longest common subsequence 還覺得是不是 AI 變笨了，怎麼給你 Rosalind 題目的完整輸出入結果還嘴硬。分清楚這兩個問題後，我才明白小丑是我自己🤡。</p>
<p>（如果想要找到更快的算法，可以點進 Longest common substring 連結看看維基百科的解釋）</p>
<h2 id="所有字串的-LCS-不見得與一對字串的-LCS-一致"><a href="#所有字串的-LCS-不見得與一對字串的-LCS-一致" class="headerlink" title="所有字串的 LCS 不見得與一對字串的 LCS 一致"></a>所有字串的 LCS 不見得與一對字串的 LCS 一致</h2><p>明白小丑是我自己之後，我謄錄了一份利用動態規劃尋找兩字串 longest common substring 的方法。簡言之，這方法會一一比對兩字串每個字符，並且將最長子字串的長度紀錄在一個矩陣中。再比對過所有字符後，便能得出 LCS。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common substring from two strings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (<span class="built_in">len</span>(s2) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1) + <span class="number">1</span>)]</span><br><span class="line">    max_len, end_pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s1) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> max_len &lt; dp[i][j]:</span><br><span class="line">                    max_len = dp[i][j]</span><br><span class="line">                    end_pos = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> s1[end_pos - max_len:end_pos]</span><br></pre></td></tr></table></figure>

<p>我原先的以為，一對字串的 LCS 會與所有字串的 LCS 相同，所以我可以像是「找出最大的數字」一樣，找出「最長的共同子字串」，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 這是錯的!!!!!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcsm</span>(<span class="params">fasta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finding the longest common nucleotide sequence from multiple sequences in a fasta file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    seqs = <span class="built_in">list</span>(read_fasta(fasta).values())</span><br><span class="line">    m = seqs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> seqs[<span class="number">1</span>:]:</span><br><span class="line">        m = lcs(s, m)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>

<p>雖然這支程式可順利通過 ROSALIND 的測資，但我在討論區立刻看到一則反例，才乖乖寫成題解那個形式。</p>
<blockquote>
<p>I’m not sure the LCS of all the strings would necessarily be a substring of the pairwise LCS’s. For example, in this set of strings:<br>AAAAATATATAACGT AAAAACCCCCACGT ACACACCCCCACGT<br>The LCS of the first and second string will be AAAAA, the LCS of the second and third string will be CCCCC, but the LCS of all three strings will be ACGT.</p>
</blockquote>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>戰爭，不再適用於描述宿主與微生物的關係</title>
    <url>/forum-on-microbial-threats-2006-ending-the-war-metaphor/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>撇除雷文霍克和虎克那個用顯微鏡觀察微生物以展示風雅的時代，微生物學的重大發展皆與解決釀酒、蠶業、農業等產業問題息息相關，而人體微生物學也是源於臨床應用背景。</p>
<p>(Forum on Microbial Threats. (2006). Ending the War Metaphor: The Changing Agenda for Unraveling the Host-Microbe Relationship-Workshop Summary. National Academies Press.)</p>
<span id="more"></span>

<p>二十世紀初人類的衛生觀念基於巴斯德和柯霍等人確立的細菌致病學說（the germ theory of disease），認為特定病原菌破壞人體健康狀態而導致疾病，所以當時的防疫觀念著重消毒，試圖透過全面滅菌降低細菌傳播。在細菌致病學說指引下，研究者系統地搜索病原菌，結合同時期發展的疫苗、化學療法和抗生素挽救無數人性命。此外，細菌致病學說納入了病毒致病因素後，拓展為更為成熟的微生物致病學說，持續引領晚近的人體微生物學研究。　<br>　<br>儘管微生物致病的典範取得了巨大的成功，這種以病原為中心的觀點（pathogen-centered）過度強調疾病與特定物種的關係，忽略了物種與物種、物種與宿主間交互作用變動造成的疾病，也沒有考慮到物種的多重屬性。因此面對晚近浮現的超級細菌、腸道發炎疾病及自體免疫等的問題時，施用不同藥物試圖全面撲滅病原的策略往往不能奏效，傷害患者身體的同時還間接篩選更頑強的細菌。<br>　<br>除了致病菌以外，晚近的研究也指出體內微生物的組成和神經疾病、肥胖、過敏相關，這意味著微生物不只單純棲息於體內，它們可能參與人體生理的大小反應。</p>
<p>新興疾病的醫療危機以及微生物與宿主的生理相關性揭示了微生物與宿主間的複雜關係，於是學界漸漸重視微生物致病的其他因素，例如：微生物的變化、微生物與環境的關係、微生物間的作用網路、免疫系統與微生物間的互動、……等，模糊了人類與病原菌之間壁壘分明的界線。</p>
<p>換句話說，學界引進了生態學的思考方式，將人體視為棲息地（human-as-habitat perspective）而不是廝殺的戰場（body-as-battleground perspective or the War matephor），微生物是人體的一部份而非外來的異客，身體狀態是細菌與人體細胞共同作用的外顯特徵，而健康則是生態系平衡的紅利（ecosystem service）不是固有的狀態。</p>
<p>看待微生物的觀點轉變不僅影響研究圈，也會影響臨床醫療的決策。雖然傳統醫療手段不會被取代，但是面臨複雜症狀的疾病時需要更仔細考量發病的環境脈絡，以免貿然治療造成反效果。另外生態系適應性經營（adaptive management）或許能運用於人體，透過連續的調查與評估，鎖定生態網路中的致病節點，借鑑動植物生態學的經驗，修復生態或引進原生物種以移除病原（probiotics therapy）。</p>
<p>然而要達成上述目標需要更深入理解人體微生物生態學和演化學，並釐清微生物的組成、功能與交互作用網路，而 Allan 和Stankey 設想生態系適應性經營的四步驟則能協助理解的前提。首先必須識別生態紅利的供應者，篩選影響其功能的環境或生物因素，最後評估作用的時空限制。就此框架看來，僅確認微生物與特定現象的因果仍不夠，必須深入理解造成現象的特定因素，而這些關鍵的要素就藏在微生物的生態網路當中，所以架起了基礎科學和應用科學的聯繫。</p>
<p>由於觀測、培養和分類困難，微生物生態學的發展落後於動植物生態學，直到基於核酸的鑑定理論與方法成熟才得以開啟微生物學的博物學時代，此階段的研究雖然看起來像過往一樣遵循「鑑定物種分析關聯」的流程，但往後以功能與交互作用等更複雜的現象為目標。這些基礎科學的成果，不只有助於治療疾病也將能開拓微生物的應用價值。</p>
]]></content>
      <tags>
        <tag>ecology</tag>
      </tags>
  </entry>
  <entry>
    <title>寫論文的糟糕和美好經驗</title>
    <url>/good-and-bad-experiences-in-journal-article-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我對論文寫作的第一印象是「寫論文很難，要花很長的時間才能完成，而且從準備到發表過程中會受到大量的批判，一路過關斬將才有機會嶄露頭角」。</p>
<p>所以每當開啟 word 檔開始打字的時候，都有起步的焦慮感：覺得自己還沒準備好，想要把文獻回顧完全，研究結果做到滴水不漏才有辦法動筆。</p>
<p>這種印象部分奠基於碩士論文寫作經驗，當時往往盯著螢幕許久沒有任何想法，最後歸因於自己文獻回顧不夠完整或是研究做得不夠完善。</p>
<p>我意識到阻礙我進展的是對於完美論文的期待，我期待論文能夠達到讓我感到愉悅和成就感的標準。</p>
<p>然而，人們總是無法在初稿時達到滿意的程度吧？而且論文需要於修改中逐漸精緻，沒辦法一蹴可幾，我的期待反過來成為我的壓力。</p>
<p>為了舒緩這種壓力和焦慮，我轉而把精力投注在文獻回顧或改進研究內容。雖然多做準備能暫時減緩我的焦慮和踏實感，但這只是將自己的壓力和負擔延後，之後將面對更多的時間、資源和要求的壓力。</p>
<span id="more"></span>

<h2 id="「發表論文的初衷是感謝」"><a href="#「發表論文的初衷是感謝」" class="headerlink" title="「發表論文的初衷是感謝」"></a>「發表論文的初衷是感謝」</h2><p>而我對論文的美好經驗則來自研究所的老師。我的指導教授從前曾問我：「你認為我們為什麼要投稿論文？」</p>
<p>從功利的角度講，Publish or Perish。發表論文是在學術界生存的根本，也是一個人能力的證據，舉凡畢業、獎學金、申請學校、公司求職、學校教職等皆可能需要論文作為能力的佐證。</p>
<p>然而，我的指導教授認為這些都只是其次，發表論文的初衷是感謝。</p>
<p>為什麼感謝？做研究總是關注著某些議題，為了解決問題，我們參考了這麼多文獻，我們正是對於前人的文獻表達感謝。</p>
<p>表達感謝的途徑有二，首先是引用這些文獻，彰明他們的貢獻；其次是基於這些文獻發展出我們的想法，促進對議題的理解，讓這些想法得以演化和繁衍下去。</p>
<p>科學是尋求解釋的活動，而我們對世界的認知並非一日造就而成的。無論是科學革命還是漸進式的科學史觀，當今的知識體系都是多人長年活動累積的結果，一項研究的鑄成往往有其思想根基和參考依據，無論是要贊同、反駁還是引發想法，都會踏過前人的足跡。</p>
<p>經過長期演變，論文已是紀錄和傳播科學活動成果的最有效和公認的媒介，研究和發表其實就是：我們感到疑惑，我們開始研究，我們參考了誰的想法和觀念，我們想到了一些點子和把持一些觀點。</p>
<p>我們想要提供一些新的解釋，我們感謝前人對於我們思想和研究的幫助，我們回饋學界這些觀念，用一種經過長期演變且公認最有效率的媒介，論文。</p>
<p>以感謝的角度來看待論文發表很大程度地舒緩了寫論文的恐懼和壓力，即使論文有那些功利價值，但我的指導教授還是提醒了我研究和發表理想和溫暖的一面。</p>
<h2 id="「一則文獻既不是最重要的也不是最不重要的」"><a href="#「一則文獻既不是最重要的也不是最不重要的」" class="headerlink" title="「一則文獻既不是最重要的也不是最不重要的」"></a>「一則文獻既不是最重要的也不是最不重要的」</h2><p>而對論文另一部份美好經驗則來自論文寫作課的老師。</p>
<p>有別於我的指導教授，寫作課老師從實用角度分析論文的寫作與發表，將論文寫作描述得很像 youtube 上頭 8 分鐘的 DIY 影片，好像我們在某個閒暇無事的下午，點開影片照著做就可以完成，不是什麼無法做到的事。</p>
<p>總結他的課程，他強調論文寫作縱使有那些功利價值，也不需要感到壓力，論文發表會被 reject 沒錯，但再換家推銷就好。</p>
<p>換句話說，寫作課老師讓我感受到，即使沒有達到最完美的狀況，論文還是有價值；即使還沒有準備好，也能開始動筆；即使能力還不夠，進展中就會有所成長；即使被批判，那也是很自然，因為這都是科學過程的一部分。</p>
<p>一則文獻既不是最重要的也不是最不重要的，科學重視的是合理而非真理，文獻呈現的是探索的過程，我們沒辦法在一則文獻中完全佐證我們的主張或對世界的看法。</p>
<p>錯誤與正確都是研究累積後，後世對我們的評價而已，所以不用太擔心文獻被批判等等，這本來就是科學新陳代謝的一環。</p>
<h2 id="正向寫作經驗的關鍵"><a href="#正向寫作經驗的關鍵" class="headerlink" title="正向寫作經驗的關鍵"></a>正向寫作經驗的關鍵</h2><ul>
<li><strong>寫作是 routine</strong>：寫作跟運動很像，寫作的愉悅需要一點投資，最重要的投資就是起步的意願，隨後是堅持的決心。寫作是 routine，而非儀式行為。是以，治療寫作不快或抑鬱的方法跟控制慢性病一樣，每天吃藥（寫作）。</li>
<li><strong>參與感</strong>：讓寫作交流可以提升寫作的回饋感，因為寫作終究是科學交流的一部份。透過研討會、一對一討論、編修等途徑，可以從中得到寫作靈感而疏通寫作瓶頸，也可以從交流中獲得參與感和社群歸屬，最終得到「意義」</li>
<li><strong>正面看待評論</strong>：看待拒稿和批評的認知轉換有助於降低寫作的恐懼，投稿寫作就跟賣東西一樣，一定有人買，只是看誰會買和賣什麼價碼而已。論文跟基因不一樣，別人罵你先天特徵是沒機會改變，但別人批評論文內容有改善的機會。</li>
<li><strong>分享的心</strong>：如果真心喜歡自己的研究，那寫作就是分享自己熱情和喜好的管道。若有類似的經驗便能體會為什麼用分享看待寫作可以增加正向寫作經驗。</li>
</ul>
<h2 id="當然還是有糟糕的經驗"><a href="#當然還是有糟糕的經驗" class="headerlink" title="當然還是有糟糕的經驗"></a>當然還是有糟糕的經驗</h2><p>儘管羅列了一堆美好經驗和建立正面想法的「要點」，寫論文還是有坐困愁城和自我質疑的時候，像是指示牴觸價值觀、結果不明又不想自欺欺人、截止日到但品質不滿意等等。</p>
<p>舉我的例子來說，我不太習慣被 Paul Nurse 稱之為「修正主義 (revisionist)」的科學敘事 (Nurse. (2016). Cell, 165(6), 1301-1306.)。就我理解，這是指論文敘事隱藏了科研的意外與不可控，調整文章內容以說個毫無破綻的好故事，而不是說個貼近事實的發現歷程。</p>
<p>最容易接觸這類修正主義的途徑可能是台灣的理科教科書。從歐幾里得、牛頓、孟德爾、波爾、拉瓦節，課本呈現的是生硬且不直觀，但和諧線性的科學史觀。理論的發展與邏輯的推演高度相符，彷彿有了前提、假設和足夠的測量，理論即順水推舟浮現，科學史跟課本都能一併翻向的新頁。</p>
<p>我想，為了溝通的效率，精簡內容和梳理邏輯是撰寫論文的必要過程。然而，當論文呈現與事實迥異的發現軌跡，後人要追溯某項理論的沿革時，只能走在一條虛構的途徑上，而這條途徑很可能只在想像中行得通。</p>
<p>等到開始寫論文，我也希望自己能夠避免這種狀況，想盡可能讓論文的敘事貼近發現的過程，保留激發研究點子的關鍵因素，討論理論與結果衝突的理由與和解方式，而不是為了結果而調整敘述過程的方向。</p>
<p>雖然只是一點點，但我也想要為自己認同的理念和未來做點事。不過，我後來才體會到，論文寫作還是有協商的因素存在，與合作者的協調、與計畫主持人的溝通、與編輯和審閱者的答辯等等。</p>
<p>我想這些合作與協商是必要的，只是折磨之處在於，若討論不是基於事實與道理，而是訴諸權威或群眾等無關論文內容的事情，那麼我有點難克服下筆時的抗拒感。</p>
<h2 id="但我還是想記住好的"><a href="#但我還是想記住好的" class="headerlink" title="但我還是想記住好的"></a>但我還是想記住好的</h2><p>儘管如此，我其實是喜好寫作表達想法的，我覺得將自己的主張和論證陳述清楚，嘗試去說服別人的過程仍值得投入。</p>
<p>畢竟寫論文也是一種發聲管道，若渴望能依照這途徑去實踐或改變什麼，那是否要做下去也非取決於經驗的好壞，而是渴望的程度。</p>
<p>既然如此，傾聽內心裡較良善的聲音讓自己有動力做下去，我覺得會比被糟糕回憶困住半途而廢還來得有機會幫助自己達到目標。</p>
]]></content>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>樹之歌</title>
    <url>/haskell-2017-the-songs-of-trees/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>歌，是有序的聲音；聲音，則是波動的一種形式。若沒有變動與交互作用，也就不會產生聲音。因此，聲音也是網路的一項性質。</p>
<p>Haskell 以樹木為觀察對象，描述樹木與雨水、風、動植物、微生物等事物互動發出的聲響，揭示了看似孤立的樹，實則串聯萬物的生命史，形成龐雜的生命網路。</p>
<span id="more"></span>

<p>除了科普生態與植物學知識，Haskell 亦借題簡介有關的生態議題，探討人類應抱持何種倫理觀點，看待因開發造成的生態破壞。究竟要把人類視為自然的一部份，而連帶將汙染與滅絕視為無須干預的現象？還是劃清人類與自然的界線，強調人類維護自然的責任？</p>
<p>Haskell 認為，前者會陷入虛無主義，後者則忽略了人的自然性。因此，真正的答案，或許得回歸生物網路之中，我們需要把自己放在自然網路的脈絡思考，而不是單用人類這物種的觀念看待自己。</p>
<p>畢竟，塑造我們的不只是這副軀體，還有環境、共棲微生物、作物和獵物等。所有的生命過程，都是網路中的一個節點和其他節點形成持續變動的關係。透過這是腳，我們能漸漸體會何者為美，何者為值得保護的東西，什麼又代表好，從而找出人類在全球變遷中該負起何種道義責任。</p>
<p>這本書讀起來，像帶有自然書寫風格的抒情文，用字遣詞華麗而浪漫。在此紀錄書中一些有趣的概念。</p>
<ul>
<li><strong>雨的語言</strong>：由於各地的空氣粒子組成不同，黏附著不同懸浮粒子的雨水也就蘊含著各自的語彙和文法。</li>
<li><strong>植物的記憶</strong>：植物雖然不像動物以電流傳遞訊號，但也會用化學留住事件的傷痕。我想，如果延伸「疤痕是種記憶」的想法，那麼因為河流侵蝕而留下的河谷，是不是也算得上大地的記憶了？</li>
<li><strong>歌的來源</strong>：書中提到克丘亞族相信，樹木與河流都是會唱歌的生命，族裡傳頌的歌曲都是從它們學來的。這點與《複眼人》的瓦憂瓦憂族一致！<br>瓦奧拉尼人：瓦奧拉尼人注重群體而輕視個體，個人的自主性和能力是建立於社群中。他們認為名字是關係的產物，若脫離既有社群，就得捨棄舊有的名稱。例如他們會以植物的用途或是植物與其他生物的關係來為植物命名。因此，同一種植物可能會有不同的名稱和描述，來表示植物與不同事物的關係。</li>
<li><strong>細胞特化</strong>：細胞特化除了增進效率，也避免了細胞擁有過多發展性而癌化。</li>
<li><strong>海洋微粒</strong>：海洋微粒會增加微生物可依附的表面積，從而改變海洋微生物群落組成。</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">David George Haskell. (2017) The songs of trees: stories from nature's great connectors. 台灣由商周翻譯並出版，《樹之歌：生物學家對宇宙萬物的哲學思索》。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>ecology</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 部屬後網頁報錯 &quot;cannot get /&quot;</title>
    <url>/hexo-cannot-get-slash-error/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>新的一年好不容易提振精神來寫文章，想說先把文章的調整更新到網站上。不料，輸入完 <code>hexo clean &amp;&amp; hexo delopy</code> 之後，雖然 Github action 顯示部屬正常，但網頁卻無法瀏覽，分別顯示 “This is not the web page you are looking for” 以及 “There isn’t a GitHub Pages site here”</p>
<p><img data-src="https://i.stack.imgur.com/Hp57y.png" alt="This is not the web page you are looking for."></p>
<ul>
<li><a href="https://github.com/hexojs/hexo/issues/4098">404 There isn’t a GitHub Pages site here. #4098</a></li>
<li><a href="https://stackoverflow.com/questions/66569047/github-what-causes-gaps-in-issue-number-404-this-is-not">GitHub what causes gaps in issue #Number (404 This is Not…)</a></li>
</ul>
<p><strong>TL;DR: 如果你也碰到這情形，可能是 hexo 部屬工具不全或是，上網隨便找一篇教學，或參照以下指令把相關套件更新後再部屬看看。</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="環境設置"><a href="#環境設置" class="headerlink" title="環境設置"></a>環境設置</h1><p>忘了，只是想一寫文章啊，眼看元旦就要消失了，急著解問題沒記錄環境設置。不過這倒能衍伸出一項新年展望，下次碰到問題記得留意環境問題喔。</p>
<h1 id="調查過程"><a href="#調查過程" class="headerlink" title="調查過程"></a>調查過程</h1><p>使用 <code>hexo server</code> 檢查，發現網站根本起不來，只有一串的 <code>Cannot GET /</code> 掛在蒼白的網頁上。</p>
<p>通常，這項錯誤肇因於 <a href="https://blog.csdn.net/qq_45593330/article/details/116702792"><code>source/_posts</code> 沒有任何文章</a>，可是查看專案資料夾卻發現，所有文章都好端端留在那啊，究竟部屬的時候發生了什麼事？</p>
<p>回頭翻部屬訊息才注意到，哇乾，hexo 不知何故把 <code>gh-page</code> 大多數檔案移除（慘況可參考 repository 上的 <a href="https://github.com/5uperb0y/5uperb0y.github.io/commit/3929872560d5bb2db64fd0a68eb441cac377e355">commit 歷史</a>）。接下來我推測了各種可能性：</p>
<ul>
<li>token 過期等權限問題？但都能順利推上 github 了，先排除這項可能。</li>
<li>可能手賤刪除文章不自知？嘗試回到舊 commit 再部屬，問題依舊。</li>
<li>可能 <code>_config.yml</code> 的分支設錯？檢查設置檔，也確定 origin 分支了，問題依舊</li>
</ul>
<p>到了最後才懷疑套件可能安裝不全或有問題？找了這篇 <a href="https://feifacunzai.github.io/2020/06/29/Hexo-%E7%B4%80%E9%8C%84%E6%9B%B4%E6%96%B0%E9%81%8E%E7%A8%8B/">Hexo 紀錄更新過程</a>，照裡面講的步驟更新套件後再部屬後，網頁和文章都回來啦。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>人生難免碰到困難與障礙，有時並非個人不努力，而是大環境的問題。既然錯不在己，過度糾結也無濟於事，不如更新環境或給自己重新開機的機會，也許問題會迎刃而解呢。</p>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>勇往直前 1 &amp; 2</title>
    <url>/hideaki-1988-gunbuster-and-Kazuya-2004-diebuster/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>從這部《トップをねらえ!》到往後的《天元突破グレンラガン》，深深覺得熱血的科幻動畫裡頭重要的不是真實，而是無視自然定律，突破現實框架的暢快（例如引爆木星充作黑洞核心、推動地球當質量武器、低於絕對零度的冷凍射線……之類的作戰計畫）。</p>
<span id="more"></span>

<h1 id="第一部簡述"><a href="#第一部簡述" class="headerlink" title="第一部簡述"></a>第一部簡述</h1><p>一、二部的時間橫跨一萬兩千年，從第一艘超空間跳躍艦在巡航中遭襲擊開始，人類研發宇宙戰鬥人型兵器，徵招青年駕駛員建立Top部隊以對抗潛在的威脅。主角法子繼承父親遺志加入宇宙防衛部成為buster駕駛預備員，在沖繩宇宙學校被太田教練發掘，與另一位天才駕駛員天野和美共同成為Top部隊日本代表。然而法子只是個普通女孩，在眾多精銳中顯得無能，不只同儕猜忌還受自己崇拜的和美所輕視。</p>
<p>第三集中，田代艦長帶領以旗艦第四代戰艦exelion為首的艦隊，搭載Top部隊向宇宙深處進發，卻在LEAF64區遭遇宇宙怪物的哨兵。Top部隊首次實戰卻死傷慘重，艦長下令進行超空間跳躍回防地球。法子依賴的男友史密斯也在遭遇戰中因她的怯懦而戰死，為此自責不已的法子主動要求太田訓練她。</p>
<p>還沒等到歸航，艦隊在亞空間受到伏擊，艦長下令脫離亞空間以免暴露地球座標，雙方在火星軌道接戰，艦隊幾乎全滅。艦長決定和宇宙生物的頭目同歸於盡，此時法子毅然決然搭上未完成的最終兵器gunbuster主動出擊，gunbuster在有限的操縱時間內展現壓倒性的破壞力，摧毀敵軍附屬部隊，最後以軀體阻擋頭目衝鋒，瓦解宇宙生物第一波攻勢。</p>
<p>殘餘的艦隊才返航不久，地球方便偵測到龐大的宇宙生物群接近太陽系邊境防線，作為人類方舟的第五代戰艦完成率不及百分之十六，人類唯一的希望就是在敵軍中心引爆舊旗艦的塌縮爐，將鄰近行星捲入風暴中形成微型黑洞吞噬一切。然而擔任護衛的gunbuster二號機駕駛和美卻因所傾慕的教練卻因宇宙輻射病不久於人世而無心戰鬥，因為出征代表的是雙方無法見彼此最後一面。在法子的鼓勵下，和美才振作起來不負教練犧牲小我的大義完成任務。這次作戰消滅了敵軍九成部隊，和美在作戰後和教練結婚，而法子則在艦隊中待命準備迎向最後一戰。</p>
<p>人類在太陽系作戰後轉守為攻，以五代艦eltreum連帶數千艘戰艦突進敵軍巢穴，計畫以黑洞炸彈在銀河中心製造出巨大的黑洞將敵軍一網打盡。黑洞炸彈到達後受到宇宙怪物接連攻擊，人類艦隊再次重創，且炸彈的控制棒被摧毀無法啟動，法子和和美自願駕駛gunbuster進入炸彈核心——壓縮的木星當中，把機組塌縮爐充作啟動器，終於引爆炸彈，把周邊一切給吞噬殆盡。</p>
<p>兩人則因時間膨脹的關係，在一萬兩千年後才回航地球，迎著他們的是用燈火打出的歡迎詞。</p>
<h1 id="第二部簡述"><a href="#第二部簡述" class="headerlink" title="第二部簡述"></a>第二部簡述</h1><p>第二部則設定在法子與和美返回地球的十多年前，這階段科技衰退嚴重，沒有warp也沒有塌縮爐，人類被佈滿天空的宇宙怪物給封鎖在太陽系。此時地球的主要戰力是一群擁有啟動buster machine超能力的青年，主角諾諾則是一心想成為駕駛員的鄉下女孩，因為一次宇宙怪物襲擊火星的事件被帶到太空，和所崇拜的駕駛員拉路可一同行動。</p>
<p>前兩集只是日常，第三集進入主線，超能力者群當中有兩個雙胞胎正在開發土衛十當中潛在的機械，他們相信這力量可以帶給他們永遠的青春，因此指派其他駕駛員解決巡邏於附近的宇宙怪物，這邊衍伸出琪可和木星的故事。在挖掘出機械的前一刻，宇宙怪物大量集結湧向土衛十，在苦戰中雙胞胎成功召喚埋葬萬年的外星機械，他們一舉擊敗宇宙怪物後卻不受控制無差別地打向所有人，超能力者只剩下兩三人存活，其他都死於失控的外星機械。</p>
<p>當眾人陷入絕望之中時，諾諾覺醒了，原來她是第七號buster machine，能夠指揮「宇宙怪物」作戰，她及時趕到解除土衛十的危機。經過這次事件才讓人類明白，原來他們之前一直戰鬥的是萬年前人類建造出來的太陽系防衛機械群，受到超能力者的影響才轉而攻擊人類，真正帶來毀滅的是那超越人類和宇宙怪物力量的巨獸。</p>
<p>後來新的宇宙怪物自太陽系邊界襲來，連用行星投擲都無法擊退，對方直接超空間跳躍到地球附近，人類只好犧牲地球將之作為質量兵器與宇宙怪物同歸於盡，最終諾諾把地球推回原來軌道，和拉路可合作擊敗敵軍後消失。最後人類點燈歡迎法子和和美的歸來。</p>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>這兩部的設定要在衍伸漫畫和小說當中才能補齊，當中也有有趣的東西呀：第二代宇宙戰艦是用魔王星的反物質為動力，這魔王星的反物質我第一次看到是在〈2001夜物語〉裏頭，然後電影內的細節也致敬好多東西，不過我觀影歷練不長，所以實在看不出源頭。</p>
<p>另外大部分人都比較推第一部，我想是因為一部比二部還要多掙扎、絕望與成長。法子與和美時代的宇宙怪物是以億萬計，且一波又一波襲向地球毫無喘息餘地；然而諾諾時代的戰鬥規模減少很多，最終魔王也只是一部的一雜兵而已。雖然諾諾被塑造成開朗認真的女孩，但是她覺醒成七號buster的過程卻顯得無力，相較之下法子從一個脆弱的女孩在生離死別、私情與大義的拉扯中成長，最終能獨當一面作戰還反過來鼓勵失意的和美姊。</p>
<p>但是我還是很喜歡二部的，不只是因為他畫風和風格比較接近現在，還多很多元素：例如忌妒與陰謀，那個要消失能力的男駕駛為了保持能力和雙胞胎合謀，還吃一大堆奇怪食物。另外琪可對自己能力不足以保護摯愛的人那段也很不錯。只是僅六集沒法把細節做好，就會給人一種倉促且劇情不集中的印象（其實兩部元素沒有差太多，但是一部把劇情聚焦在法子和美身上，但是二部分散在幾個不同人身上）。</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>All You Need Is Kill</title>
    <url>/hiroshi-2004-all-you-need-is-kill/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>距地球四十光年外的智慧生命為了開拓生存空間，向地球投射 Terra forming Bomb，一種行星改造奈米機器。不料，它們和地球生物共生後不斷演化，形成威脅地球人類生存的「擬態」</p>
<span id="more"></span>

<p>主角銅谷啟二在聯合防衛軍服役，在初陣中意外擊破「主機擬態」而獲得生死輪迴的能力。然而，這種穿越時空的能力實為幻覺。主機擬態在被破壞後，會以速子將訊息回傳過去，以免其他擬態重蹈覆轍；而接觸主機擬態的人類則會連帶接收這些訊息，得到猶如親歷的印象。</p>
<p>對於自己的遭遇，銅谷起初想要脫逃，卻徒勞無功，每每遭到擬態給殺害。為了找出脫離輪迴並存活下去的方法，他利用每次重生機會鍛鍊戰技，成為優秀的士兵。直到他在第 158 次戰鬥，碰到同樣受困於輪迴的戰鬥天才麗塔，事情才真相大白。原來，銅谷先前得以重置，是因為麗塔擊敗主機擬態的緣故。</p>
<p>兩人為了生存下去共同擬定了作戰計畫，成功毀掉了備份擬態和負責傳訊的天線擬態。然而，麗塔的大腦因為多次輪迴，已逐漸異變為傳訊天線。麗塔明白，遲早銅谷也會有相同的遭遇，唯有一的方法是摧毀擬態傳輸訊號的途徑，讓輪迴不再繼續，但這勢必得犧牲兩人之一。</p>
<p>因此，麗塔打算透過對決來決定誰能生存下去，背負著為人類繼續戰鬥的宿命。最終銅谷擊敗麗塔，也摧毀了主機擬態。由於擬態喪失了傳輸途徑，此次戰鬥之前發生的事件再沒有重來的機會。</p>
<p>自此，銅谷接替了麗塔戰爭英雄的地位，也承擔起麗塔曾體會的孤單、無法挽救所有人的無奈、殺死唯一知己的痛苦與折磨。</p>
<p>雖然這本小說的主軸包含很多心理描述，還很特別地在全書前後分別用銅谷和麗塔的視角敘事。例如麗塔重複了多次戰鬥，從最初試著救人到後來把一切交給命運；孤獨地戰鬥到後來碰到知己卻得互相殘殺的哀痛等。</p>
<p>最初我是為了了解輕小說筆法才讀這本書，然而我太關注主線戰鬥和行文模式，又受到一些齣戲的角色和對話內容影響（例如日本化的美國角色形象等），所以讀的時候有點難起共鳴，於是筆記中少了很多心理層面的紀錄。</p>
<p>然而，劇情讀起來還是挺流暢的。至於，改編版電影雖然與小說有很大的差異，但看得也很過癮。原則上，在家裡如果轉到了就會看下去（例如今天又看了一遍）。</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>「天文」生物學：數量的緣故</title>
    <url>/history-of-astrobiology-naked-eyes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>國中時，剛看完《星艦迷航記VIII：戰鬥巡航》的我向學校裡最接近外星生物專家的生物老師詢問是否真有外星人，他告訴我地球外還有許多星球，如果沒有其他生命也太奇怪了。</p>
<p>如同我的生物老師所述，對於地外生命的信心有很大一部分是建立在數量上，既然宇宙已經誕生百餘億年，當中又充滿無數星系，很難想像當中不會有其他生命存在。</p>
<p>然而宇宙的尺度也是經學界漫長掙扎才逐漸變得清晰，早在人類只能以肉眼觀察世界的時候，滿天繁星已不計其數，甚至至今我們對於宇宙中有多少顆適居行星仍沒有精確的估計。</p>
<p>天文生物學的發展不只是事實的累積，也是世代人觀念轉變的結果。</p>
<span id="more"></span>

<h2 id="肉眼"><a href="#肉眼" class="headerlink" title="肉眼"></a>肉眼</h2><p>最初人類只能以肉眼觀察這個世界，其他的天體在天空化為一個小亮點，這些亮點的意義在不同人眼裡衍伸出不同的樣貌，這些推論與想像便成為天文生物學興起前，人們對地外生命的想像基礎。</p>
<p>對於無法觸及的天空，德膜克利特(Democritus, 410 - 380 BC) 等原子學派 (Atomists) 哲人認為，既然原子的隨機運動組成了世間萬物，天與地應遵循相同法則，形成地球的過程沒理由不能在天外形成其他世界，是以其後繼者伊比鳩魯在給希羅多德的信 (<a href="http://www.attalus.org/old/diogenes10b.html">Letter to Herodotus</a>) 中提到，</p>
<blockquote>
<p>We must not believe that all worlds necessarily have one identical form.  Let us also beware of thinking that animals are derived from the infinite; for there is no one who can prove that the seeds from which animals are born, and plants, and all the other objects which we contemplate, have been brought from the exterior in such a world, and that this same world would not have been able to produce them of itself. （我們絕對不能假設各個世界有一致的樣貌，……，因為沒有人能證明形成動物、植物和我們眼前一切的種子無法在這樣的世界萌生。）</p>
</blockquote>
<p>伊比鳩魯的門徒 Metrodorus（400 BC） 也對地外生命的可能留下更明確的評述。</p>
<blockquote>
<p>It is unnatural in a large field to have only one stalk of wheat, and in the infinite universe only one living world.（無垠宇宙僅有一個育有生命的世界和沃野千里卻只長出一束麥子一樣不尋常。）</p>
</blockquote>
<p>相較於原子學派，亞里斯多德學派哲人認為地球是唯一的世界，所以沒有為地外生命留下空間。</p>
<p>亞里斯多德以朝向&#x2F;背離中心的本性解釋火、水、土和空氣四種基本元素的運動現象，所以如果世界不只一個，那麼物質便喪失了明確的運動目標，維繫世界運作的基本原理將不復存在。透過這個規謬過程，四元素說結合地心說共同否定了多重世界的觀點。</p>
<p>此外，天與地也在亞里斯多德體系中割裂。有別於四元素，天空是由以太組成。太陽、月亮還有其他五顆行星就在層層嵌套的天球上緩緩繞著地球旋轉，而原子學派眼裡可能存在繽紛世界的星斗只是鑲在最外層恆星天上閃爍的光點。</p>
<p>同片天空不同的想像與推論，形成了不同的結論。</p>
<p>如今我們知道，原子學派哲人的想像比較接近當今學界對世界的認知，然而這不代表他們是天文生物學還是任何現代科學的根源。囿於當時的觀察手段，無論哪派哲人的思想都沒有嚴謹事實支持，即使有許多詞彙為後世研究者共用，其中的內涵也已發生很大的變化。</p>
<p>但另一方面，儘管只能取得有限的線索，希臘人仍試圖靠著理性與智力解釋世界，而不是將問題簡化為鬼、神、UFO 或我不知道。</p>
<p>亞里斯多德的學說在中世紀時期被阿奎納 (St. Thomas Aquinas, 1225-1274) 納入神學體系，此後單一世界的想法持續主宰著歐洲人的世界觀。然而關於「數量」的爭議並沒有就此定論，亞里斯多德體系在哥白尼掀起科學革命後逐漸衰落，現代科學興起後更多的科技與觀察手段逐漸揭示宇宙的樣貌。</p>
]]></content>
      <tags>
        <tag>life in the universe</tag>
      </tags>
  </entry>
  <entry>
    <title>從碩班第一次專題課說起......</title>
    <url>/how-i-learn-from-seminars/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>讀碩班前，我其實不知道 seminar 到底要幹嘛，也不知道和我有什麼關係。所以如同曖昧、戀愛等陌生概念，所有關於 seminar 的知識都是PTT教我的。</p>
<p>然而在完成人生中第一次正式報告後，我發現生資所碩一的專題課跟想像中有些差距：老師在有限的檢討時間內傾向於引導同學發現邏輯錯誤，或是補充報告中值得大家學習的觀念，不曾直接指正學習態度、格式錯誤或邏輯謬誤。這點和以往聽聞前輩提到的「 seminar 被老師痛電」很不一樣，上一周報告結束後沒有被批評到一文不值，所以心裡有些不踏實。</p>
<p>不過我內心期望的只是被電的體驗嗎？不對。我渴望的是成長，批判不是成長的唯一途徑。我要從 seminar 中學習的不是接受批評或是習於挨罵，因為這種本領已在服役期間漸漸培養起來，我想從 seminar 獲得學者的素養。</p>
<span id="more"></span>

<h2 id="seminar-是什麼？"><a href="#seminar-是什麼？" class="headerlink" title="seminar 是什麼？"></a>seminar 是什麼？</h2><p>seminar 源於拉丁文的「seminar ium」（苗床），從字根可以看出教育者的期許是讓 seminar 成為新概念的苗床，希望學生在檢視新近研究成果之外，也能互相討論激盪出新的想法。另外，對學生而言，準備報告和參與討論的過程考驗彙整資料、傳達觀念及構思問題的能力，這樣的演練有助於奠立從事學術的基礎。</p>
<p>但是了解  seminar  的起源和目的有什麼幫助呢？</p>
<p>我認為如果可以辨識出課程用意，便能聚焦在學習的成效上，而非「有沒有被電？」、「什麼時候輪到我報告？」、「報告完了是否該吃一頓大餐？」、「同學幹嘛問機掰問題」等無關緊要的指標。</p>
<p>因此，為了學習到更多有價值的事物，我彙整了網路上蒐集到的資料，列舉應當要從課程中培養的能力，並提出可行的練習方式，以在往後的專題課中實踐。</p>
<ul>
<li>學會閱讀研究論文及其內涵</li>
<li>在有限時間內清晰地表達科學概念</li>
<li>能即時答覆聽眾的提問</li>
<li>學會「聽講」這種學習或交流方式</li>
<li>能於聽講過程中組織問題，並清楚地向講者提問</li>
</ul>
<p>雖然要培養的能力還可以找到一大堆，但要專題課的目標可以歸納為「學習扮演研究者、策畫者、講者和聽眾」。儘管還沒有實際投入研究，但學生可以鑽研論文來學習研究者怎麼從觀察中形成問題意識，找出疑點提出假說，最後設計實驗驗證之。</p>
<p>除了實驗結果，科學交流也是科研的一環，有效的溝通能讓他人接受你的主張，所以研讀論文後也要試著報告給其他人聽，學會結合腹稿、逐字稿、簡報呈現流暢的演說。</p>
<p>而且聽講是接受新穎資訊的最快方式，如果想跟上研究前沿，勢必要從研討會中有效接收想法，並累積新觀念。因此一門課不會在報告完就結束了，課程的不同時間點，都有要投注心力的事項和可以學習的地方。</p>
<h2 id="聽講筆記"><a href="#聽講筆記" class="headerlink" title="聽講筆記"></a>聽講筆記</h2><p>準備這次 seminar 的過程中，我累積了一些關於閱讀論文、製作簡報及練習演說的經驗和想法，學習怎麼當個好聽眾也是很重要的議題。</p>
<p>聽講是快速入門研究領域的方式，但成功的報告不只是講者的工作，也需要聽眾的努力。從這幾周的專題報告中我學到一個教訓，就是儘管一開始很認真想理解內容，卻可能因為一時分神或不解而和講者的節奏脫節。</p>
<p>由於時間有限，講者未必有機會頻繁停下腳步回顧內容。聽眾可以透過事先預習背景知識和研究骨幹來減少聽講當下的負擔。例如在報告前細讀書面報告或是瀏覽原始論文，再整理出簡單的筆記帶到會場。如此一來，對於報告內容就有比較明確的形象，即使自己一時分心或沒跟上講者的邏輯，也能靠著預先準備的筆記重新聚焦重點。</p>
<p>此外，由於簡報不像課本那麼詳盡，所以如果沒在演講中把握要點，回家後要複習就只能面對生硬的論文了。因此，如果能在歷次聽講中改善自己的筆記方法，便有助於演講後整理出完整的筆記，這些筆記配合講者的投影片和書面報告，就是往後複習的利器。</p>
<h2 id="練習發問"><a href="#練習發問" class="headerlink" title="練習發問"></a>練習發問</h2><p>如果只是單方面聽講，那麼聽眾與講者的念頭便沒有機會在互動中產生洞見。然而，我們的專題課討論風氣不盛，這可能源於「不敢問」及「不知道要問什麼」兩項障礙。</p>
<p>針對「不敢問」這項障礙，我覺得可以多多思考發問的好處。發問是聽眾在演講中展現主動權的行為，能釐清聽不懂的內容、反駁被曲解的觀念、探討湧起的靈感等，</p>
<p>但是問了蠢問題或有失水準的問題怎麼辦？會不會很丟臉？儘管指導老師總是說世上沒有蠢問題，有問題就要發問。然而，我一直覺得指導老師只是想是要鼓勵同學發言而非描述現況。因為，每次自己問出 google 能輕易解決、過於空泛而無明確或是邏輯不通的問題時，還是覺得自己挺低能的。這些問題對於旁人一點幫助也沒有，浪費其他人提問的寶貴時間，還展示了自己的無知與隨便，所以感到很丟臉。</p>
<p>只是，難道因為會丟臉就不問了嗎？不對啊，變強都來不及了，哪還管什麼丟臉。將相本無種，沒有跌倒幾次怎麼會有往後的好表現？ seminar 是學習與嘗試的好機會。班上有形形色色的同學，每次發問都能和不同的人交流，嘗試不同的提問方法，如此能累積經驗，更有信心面對更大的場合。</p>
<p>此外，每個人對聽講的期待或是議題的關注各不相同，他人對我們提問內容的評斷既無法控制也難以得知。若提出問題的初衷是「我」感到困惑，那麼只要發問可以解決自己的困惑，那麼我認為它就是有價值問題。</p>
<p>畢竟，seminar 都規劃了提問的環節，充分利用這個機會來解決自己的需求，我覺得其實也沒有什麼好丟臉的。如果還是很擔心緊張，也可以課前多花時間預習，聽講時寫好筆記，提問前整理好問題，這樣就不至於給自己太大的心理壓力。</p>
<p>至於「不知道要問什麼」的障礙，除了預習和寫筆記以理解內容外，可以參考平常老師或其他人發問的方式，整理出可以問的問題以及這些問題的特徵，然後依樣畫葫蘆問問題，多問、多想，遲早能問出可以獲得許多回饋的問題。</p>
<h2 id="寫回饋單"><a href="#寫回饋單" class="headerlink" title="寫回饋單"></a>寫回饋單</h2><p>有些學校的專題課會抽同學評論報告內容的優劣，提供意見讓講者更進步。不過如果沒有要求，總覺得這個工作還是交給老師吧。</p>
<p>儘管如此，還是能整理一份鑑賞筆記，用來提示自己或同學徵詢時給他當參考。獨立於報告內容的筆記，鑑賞筆記用於評斷報告的科學結構、內容品質、視覺設計和口語表達的優劣，解釋這場報告優秀或低劣的原因，找出可以學習的優點，紀錄要避免的錯誤。</p>
<p>模仿別人怎麼評論是學習鑑賞的快速方法，可以細聽老師們的回饋，這麼做一方面提醒自己，另一方面也蒐集了評論標的，成為下次聽講時觀察的重點。整理不同的評論內容後，還可以設計出一份回饋單，不僅能節省撰寫評論的時間，這份回饋單也可以作為報告練習時蒐集意見的工具。</p>
<p>在上台報告前通常需要內部演練，收集他人的意見以改進報告品質。事前提醒聽眾要留意的地方或發放回饋單有助於聽眾給出針對性的意見，也方便他們紀錄內容以免忘記，讓講者更有機會獲得明確且豐富的建議。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章是我第一次參加專題課後的心得，裏頭提到的心理障礙有許多仍是我現今要面對的問題。至於，過了這麼久，我對於參加研討會或 seminar 有什麼新的想法或轉變嗎？有啊，我漸漸不再把問問題當秀場了。</p>
<p>以往期待自己能像某些大神一樣，能提出讓講者與聽眾都陷入深思的犀利問題。回過頭來，我發現自己用問題的品質來衡量我的水準，才追逐著所謂「好問題」，試圖證明自己是有能力的人。</p>
<p>然而，一旦陷入這樣的心態，就會不自覺給問題貼上有價值的、沒價值的、令人訝異的、稀鬆平常的等標籤。於是，每次心中有疑惑時，便開始思考這問題有沒有價值。聽講到最後，往往因為覺得問題很平凡，而一個也沒有提。面對這種狀況，我有時還挺懊惱的，例如之前參加微生物生態學年會便有不少精彩的演講，明明有許多共鳴與想法卻不敢發言，錯失了學習的機會。</p>
<p>直到我參加了許多講座與會議，聽到了從基本、艱深到與講題毫無關聯的提問，才矯正了內心對偉大問題的期待。我意識到（或回想起）：「對啊，我就是因為不懂才問問題啊！」</p>
<p>至於能否問個犀利的問題，我蠻喜歡在 <a href="https://www.zhihu.com/question/36980830">知乎</a> 上看到的說法</p>
<blockquote>
<p>我覺得吧，聽講座也罷，看文章也好，讀教科書也算，更重要的不是去挑刺，而是一個更有建設性的問題</p>
</blockquote>
<p>簡言之，研究或開發本身就不是件易事，要從方法學或應用條件等方向去挑毛病真的太容易了。然而，除了指出漏洞並提出可能解決方式以外，另一種延伸想法的途徑是去思考，如果對方的結論是真的，那麼要如何利用這項結論，來幫助我的研究與問題？</p>
<p>透過這種方式思考問題，能延伸出許多跟自己相關的議題，也比較有動機向講者請教，還能拓展關於待解問題的深刻理解或有用猜想。</p>
]]></content>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>很久很久以前，自然用什麼盛裝生命？</title>
    <url>/how-nature-contains-life-in-early-earth/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1953年，在試管裡的雷鳴閃電與水氣蒸騰之後，米勒與尤里成功在模擬的早期地球環境中合成胺基酸，開啟了研究生命起源的先河。</p>
<p>隨著多種有機質在實驗室合成或於隕石中發現，研究人員逐漸了解生命的物質來源。然而，散落各處的有機質需要彼此接觸才有機會引發生化反應。在早期環境中，有什麼物質能夠形成容器，匯集生命形成所需的反應物？</p>
<span id="more"></span>

<p>現存生命被包覆在由磷脂組成的細胞膜內。磷脂膜的結構穩定且功能齊全，但其組成複雜，所以可能不是最早形成的容器。相較之下，脂肪酸不僅結構簡單，也能形成會膨大與分裂的囊泡。因此，脂質囊泡是構成原始細胞膜的可能選項。 </p>
<p>然而，脂質囊泡對酸鹼值與離子濃度敏感，可能難於多變的環境中穩定存在。是以，Jia等認為在磷脂膜或脂質囊泡形成前，其他容易形成的物質可能組成結構穩定的過渡容器，發揮匯集物質及促進反應的功能。 </p>
<p>為了檢驗這項假說，Jia等採取類似米勒與尤里的策略。Jia等發現，可能普遍存在早期地球的果酸可於模擬環境中形成微滴。這些微滴不僅耐受溫度、壓力和酸鹼值變動，也能吸納蛋白質和RNA等生物分子。</p>
<p>儘管目前無法確認生命是否透過果酸微滴形成，Jia等的研究成果仍支持了新的研究途徑：除了構成現存生命的大分子，存在早期地球的其他分子也可能形成過渡容器，在細胞膜出現前匯集生命形成所需的反應物。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Jia et al. (2019). Membraneless polyester microdroplets as primordial compartments at the origins of life. <em>Proceedings of the National Academy of Sciences</em>, 116(32), 15830-15835.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>origins of life</tag>
      </tags>
  </entry>
  <entry>
    <title>怎麼決定合併雙端序列時允許的錯配數量？</title>
    <url>/how-to-decide-max-mismatch-when-merging-paired-end-reads/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>illumina 的 Miseq 和 Hiseq 平台常用於定序 16S rRNA 基因特定變異區的增幅產物。因為這兩平台皆屬雙端定序 (paired-end sequencing)，所以每一條 DNA 都會獲得順向和逆向的序列（即定序結果）。在資料處理時，須比對這對序列的重疊區域，再基於重疊區域合併雙方，才能重建出代表該 DNA 的完整序列。</p>
<p>不管使用的軟體為 FLASH 、PEAR 還是 Usearch，合併雙端序列時都有許多參數可以設定。其中一個參數是合併時允許的錯配數量。這參數的必要性在於，即使順向和逆向序列都源於同一條 DNA，兩者的重疊區域仍會因為定序錯誤而略有差異。合併時允許少量的錯配數量能避免捨棄掉這些正確的序列。</p>
<p>然而，我們要怎麼知道洽當的錯配數量上限？使用預設值、反覆試誤、調查文獻都是常見的方法，不過我更想要知道能依照資料選定適用參數的策略。畢竟，如果能先推算出理論值，那麼測試時便有參考的基準，除了能縮減試誤時間，在寫論文或向他人解釋方法時也比較有依據。</p>
<p>因此，雖然在資料處理流程已成熟的今日，糾結參數設定可能被視為無關宏旨，我還是想以本文紀錄，自己思考這個問題的方向與看法。</p>
<span id="more"></span>

<p>首先，順逆向序列的重疊區只要有任一列發生定序錯誤便會發生錯配。由於 illumina 定序平台的逆向序列品質往往較順向序列品質低，假設不計兩序列同時出錯的狀況，重疊區的錯配數量可由逆向序列的預期鹼基錯誤數量估計。</p>
<p>由於 illumina 定序平台的逆向序列品質往往較順向序列低，而且重疊區任何一條序列發生定序錯誤便會造成錯配。假設不計兩序列於相同位點同時出錯的狀況，那麼重疊區的錯配數量上限，可以由逆向序列的預期鹼基錯誤數量估計：錯配數量 &lt; 逆向序列重疊區的預期鹼基錯誤數 * 2</p>
<p>舉例來說，若增幅和定序 16S rRNA 基因 V4 區域之後，獲得一對長度為 250 bp 的序列。由於 V4 區域大約只有 253 bp 長，所以這對序列的重疊區長達 247 bp，幾乎覆蓋了整個 V4 區域。</p>
<p>假設考慮最極端的狀況，即要在順向和逆向序列的每個鹼基都完全對應時，我們才肯相信合併後的序列源於同一條 DNA。那麼，在逆向序列平均品質分數為 20 的狀況下，重疊區的預期錯誤數量為 $0.99 * 247 &#x3D; 2.47$。</p>
<p>這意味著，即使是這對序列得自於同一條 DNA，平均而言也會出現 $2.47 * 2 &#x3D; 4.94$ 個錯配。因此至少要允許 5 個錯配，才能確保這些源於同一條 DNA 的正確序列能順利合併。</p>
<p>推廣來說，錯配數量上限取決於重疊區的長度與品質。隨著對重疊區長度的要求放寬，預期的鹼基錯誤數會跟著下降，允許的錯配數量也得調低，才能確保合併雙端序列的特異性和靈敏度平衡。</p>
<p>依照這個推論，在取得資料時，可以先思考「若這對序列沒有定序錯誤，要有多長的重疊序列，才肯相信它們得自於同一條DNA」。</p>
<p>接著，找到平均品質最差的那個樣本的逆向序列，計算其 3’ 端重疊區域的預期鹼基錯誤數（該段區域的定序錯誤率之和），得出數值的兩倍，應該可以當作測試雙端序列合併的參數的起始值。</p>
]]></content>
      <tags>
        <tag>ngs</tag>
      </tags>
  </entry>
  <entry>
    <title>如何下載和安裝 RDP classifier</title>
    <url>/how-to-download-and-install-rdp-classifier/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RDP classifier 是基於 Naive Bayes 的物種分類器，常用於註解 16S rRNA 基因序列的分類資訊。除了使用內建的 RDP 資料庫以外，RDP classifier 也允許使用自訂資料庫來訓練分類器。除了內建的 RDP database，也支援以其他資料庫來訓練分類器。</p>
<p>目前，RDP classifier 的核心演算法已被整合到 Mothur 和 DADA2 等流程的副程式庫，所以只要有安裝這些流程軟體，即使沒有安裝 RDP classifier，也能以相同的演算法註解物種資訊。然而，若想要依據自訂或最新的資料庫註解序列，或是使用 copy number 校正等功能，仍有獨立使用 RDP classifier 的必要。</p>
<p>本文將介紹三種下載和安裝 RDP classifier 的方式。</p>
<span id="more"></span>

<h2 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h2><p>透過 conda 安裝的方式可參考 <a href="https://anaconda.org/bioconda/rdp_classifier">Anaconda 的教學</a>。目前，conda 與 RDP 官網提供的 classifier 皆為最新的 2.13 版。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c bioconda rdp_classifier</span><br><span class="line">conda install -c bioconda/label/cf201901 rdp_classifier</span><br></pre></td></tr></table></figure>

<h2 id="官方網站"><a href="#官方網站" class="headerlink" title="官方網站"></a>官方網站</h2><p>若不想要裝一堆附加的軟體或剛好 conda 沒有需要的版本，也可以直接到官網提供的<a href="https://sourceforge.net/projects/rdp-classifier/">連結</a>下載可執行檔。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/rdp-classifier/rdp-class</span><br><span class="line">ifier/rdp_classifier_2.13.zip</span><br><span class="line">unzip rdp_classifier_2.13.zip</span><br><span class="line"><span class="built_in">chmod</span> u+x path/to/rdp_classifier_2.13/dist/classifier.jar</span><br></pre></td></tr></table></figure>

<p>由於 RDP classifier 是依賴 JAVA 的軟體，所以執行時要輸入 .jar 的絕對路徑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar &lt;<span class="built_in">command</span>&gt;  </span><br><span class="line">&lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<p>為了簡化指令，可以創造名為 rdp_classifier 的腳本，並將腳本所在的目錄加入環境變數。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch rdp_classifier</span><br><span class="line">chmod u+x rdp_classifier</span><br><span class="line">vim rdp_classifier</span><br></pre></td></tr></table></figure>
<p>接著把落落長的指令放到腳本中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">java -jar /path/to/rdp_classifier_2.13/dist/classifier.jar $*</span><br></pre></td></tr></table></figure>
<p>如此一來，往後執行時就只需要輸入 rdp_classifier即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdp_classifier &lt;<span class="built_in">command</span>&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>若是 Ubuntu，則可以從套件庫安裝。只是相較於 conda，ubuntu 套件庫內的 RDP classifier 還<a href="https://packages.ubuntu.com/impish/rdp-classifier">停在 2.10 版</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install rdp-classifier</span><br></pre></td></tr></table></figure>
<p>除了前述方法，也能夠安裝集合了 RDP 團隊包含了 classifier 在內各種開發工具的 <a href="https://github.com/rdpstaff/RDPTools">RDPTools</a>。只是 RDPTools 是透過 make 和 makefile 來編譯與安裝。由於依賴的軟體和環境設定等問題，我到現在還沒成功過，暫時無法整理出相關的筆記。</p>
]]></content>
      <tags>
        <tag>metagenomics</tag>
      </tags>
  </entry>
  <entry>
    <title>如何管理常用的 Command Line 指令？</title>
    <url>/how-to-manage-commands/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img data-src="https://imgs.xkcd.com/comics/tar_2x.png" alt="xkcd:tar (https://imgs.xkcd.com/comics/tar.png)"></p>
<p>有些指令很常用，但使用頻率不見得高到能讓人既起來。那麼，除了使用記事本以外，還有什麼方法能有效管理這些指令呢？</p>
<p>本文總結一些管理指令的經驗和訣竅，並且介紹好用的開源工具供參考。</p>
<span id="more"></span>

<h2 id="怎麼管理常用但不見得能記起來的指令？"><a href="#怎麼管理常用但不見得能記起來的指令？" class="headerlink" title="怎麼管理常用但不見得能記起來的指令？"></a>怎麼管理常用但不見得能記起來的指令？</h2><p>在初學程式的時候，我除了用 word，還會用紙本筆記紀錄程式碼和常用指令。這些紀錄就擺在我的電腦桌面和電腦桌面上，以便不時參閱。雖然有時會忘記指令放在電腦還是筆記本上，可是當時的內容不多，所以也沒特別感到困擾。大學畢業後，因為微軟的校園授權過期，我索性把所有筆記都搬遷到 Goolge Doc。由於 Google Doc 能是雲端應用程式，所以可以讓文件跨裝置讀取與保管，讓我能統一管理寫作、報告還是程式碼指令等多媒體文件。</p>
<p>除了文書編輯軟體，我也曾跟上筆記軟體的風潮，試著用 Evernote 和 Notion 等工具。這些軟體把筆記篇幅劃分為更小的單位，加入標籤、資料夾或是資料庫系統，提升了管理筆記的彈性；而它們通常也支持多媒體輸入，也內建全域搜尋系統，改善了許多維護與使用筆記的體驗。</p>
<p>筆記軟體、文書編輯軟體或紙本筆記本在紀錄筆記上各有千秋，不過據我的使用經驗，它們在管理指令上有共通的問題：查閱指令離使用指令的距離太遠了。讓我們以按鍵數量來衡量查閱與使用的距離，假設要解壓縮一份 <code>tar.gz</code> 檔，前述幾種方法要按上幾次鍵？打開瀏覽器&#x2F;軟體&#x2F;文件、啟動搜尋、鍵入關鍵字、複製指令、打開終端機、貼上指令，扣除搜索的成本，最少也要六次以上。</p>
<p>這聽起來很像個人 kimochi 的問題，不過如果你的職業正好是個厭世的軟體工程師，那麼想點辦法稍稍拯救一下上班的心情也是個好主意吧？屏除開發或維護的流暢性，若能確保筆記與應用場合貼近，也有助於即時更新筆記的內容。</p>
<p>綜合以上提及的因素，指令的良好管理方式至少具有統一管理、跨平臺存儲、貼近使用場合等特性，才能提升用戶維護與使用的流暢性。以 Command Line 指令為例，筆記最直觀的存放位置是伺服器或電腦本身，讓他們能透過 Github 備份與版本控管。由於幾乎沒有多媒體需求，使用 markdown 語法紀錄的純文本能兼具可讀性與標籤的功能性，還可在各平台讀取。此外，command line 的搜尋系統普遍比文書與筆記軟體強大，也降低了分類、標籤和重新排序的成本。</p>
<p>最後，還需要一些程式來銜接筆記與應用的落差，例如將搜尋到的指令直接貼到 command line，就不需要重複複製貼上。</p>
<h2 id="有哪些好用的工具？"><a href="#有哪些好用的工具？" class="headerlink" title="有哪些好用的工具？"></a>有哪些好用的工具？</h2><p>只要在 Github 主題搜尋 <code>snippet</code> 或 <code>oneliner</code> 便能找到許多指令管理工具可以參考。以下幾款都支援指令速查與調用，而 <code>navi</code> 和 <code>pet</code> 甚至能引導用戶交互式輸入指令所需的參數。以刪除特定的 Docker image 為例，<code>navi</code> 可以做到用快捷鍵搜尋刪除 image 的指令，再用快捷鍵搜尋 image 的名稱，自動回填到刪除指令的參數位置。</p>
<p>這些工具都允許用戶依照其規範的格式增補指令，有些還內建的指令庫，彙整了像是 <a href="https://github.com/tldr-pages/tldr">tldr</a> 這樣被開源社群維護的簡明指令手冊。</p>
<ul>
<li><a href="https://github.com/yuki-yano/zsh-fzf-snippet">zsh-fzf-snippet</a>：基於 fzf 且適用於 zsh 的輕量級指令管理工具，支援指令速查與執行。核心功能只含一支腳本以及紀錄指令的設置檔。</li>
<li><a href="https://github.com/babarot/easy-oneliner">easy-oneliner</a>：同樣基於 fzf 且適用於 zsh 的輕量級指令管理工具，只是指令的記錄格式與 <code>zsh-fzf-snippet</code> 不同。</li>
<li><a href="https://github.com/denisidoro/navi">navi</a>：基於 Python 語言的指令管理工具，彙整了 Github 著名的指令庫，除了指令速查與執行的功能外，也會交互式引導用戶輸入指令的參數。</li>
<li><a href="https://github.com/knqyf263/pet">pet</a>：基於 Go 語言的指令管理工具，定位與 <code>navi</code> 類似，同樣具有指令速查與交互式參數輸入功能。</li>
<li><a href="https://github.com/chubin/cheat.sh">cheat.sh</a>：彙整了 Github 著名的指令庫，只支援指令速查。有線上版本，所以不需要安裝也能使用。</li>
</ul>
<h2 id="如何自己寫一套指令管理工具？"><a href="#如何自己寫一套指令管理工具？" class="headerlink" title="如何自己寫一套指令管理工具？"></a>如何自己寫一套指令管理工具？</h2><p>由於這些工具的原理單純，所以如果對它們的使用方式與格式規範不滿意，DIY 一套適合自己業務需求的輕量級工具也是可行。觀察前述幾項工具之後，我們可歸納出實踐指令速查功能需要的部件，</p>
<ul>
<li>儲存格式：儲存指令的格式和語法，理想上要能滿足用戶瀏覽與程式編譯的需求。</li>
<li>搜尋介面：搜尋指令與自動補全的介面，包含搜尋、瀏覽與預覽功能。</li>
<li>指令輸出：選中指令後的反應，例如執行、印出或是啟動其他程式等。</li>
</ul>
<p>以我模仿 <code>zsh-fzf-snippet</code> 的 <a href="https://github.com/5uperb0y/fzf-oneliner-manager">fzf-oneliner-manager</a> 為例。我採用習慣的 markdown 來記錄指令，標題 (<code>#</code>)紀錄摘要，程式碼區塊(<code>``</code>)紀錄指令，無標記段落則作為補充說明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Print line number X of a file</span><br><span class="line">`head -n &lt;num&gt; &lt;file&gt; | tail -n 1`</span><br><span class="line">https://www.linuxquestions.org/questions/programming-9/print-line-number-x-of-a-file-in-shell-273849/</span><br><span class="line"></span><br><span class="line"># Remove duplicate lines from a file </span><br><span class="line">`awk &#x27;!seen[$0]++&#x27; &lt;file&gt;`</span><br><span class="line">https://linux.cn/article-6881-1.html</span><br></pre></td></tr></table></figure>

<p>我採用模糊搜索工具 <a href="https://github.com/junegunn/fzf">fzf</a> 來製作搜尋指令的介面。fzf 能依照部分匹配來搜索文字，所以能免除用正則表達式搜尋字串的負擔。除此之外，也提供了一套方便的介面供用戶搜尋和瀏覽文字檔。</p>
<p>當使用快捷鍵觸發指令速查時，<code>fzf-oneliner-manager</code> 會將指令文件整理成 TSV 檔，其中每一列都包含一條指令的標題、指令內容與補充說明，然後分別陳列標題與補充說明給用戶，讓他們能透過關鍵字或是方向鍵瀏覽要調用的指令。</p>
<p>一旦指令被選中，指令內容會被截取出來，黏貼到用戶的 command Line 上，只要再按下確認，即可觸發這條指令。這項功能有賴 bash 的 <code>bind -x</code> 指令與 <code>READLINE_LINE</code>&#x2F;<code>READLINE_POINT</code> 變項。</p>
<p><code>bind -x</code> 能重新映射按鍵以觸發指定的腳本或副程式，此處我把 <code>Ctrl + A</code> 設定成啟動指令速查的快捷鍵。<code>READLINE_LINE</code> 是啟動 <code>bind -x</code> 時，command Line 的內容；而 <code>READLINE_POINT</code> 則是游標所處的位置。換句話說，只要將選中的指令取代既有的 <code>READLINE_LINE</code>，並且把游標挪到指令字串的末端，便能在完成速查後將指令貼到 Command line 上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">READLINE_LINE=<span class="string">&quot;<span class="variable">$&#123;selected&#125;</span>&quot;</span>			<span class="comment"># 用選中的指令替換 command line 既有的內容</span></span><br><span class="line">READLINE_POINT=<span class="string">&quot;<span class="variable">$&#123;#READLINE_LINE&#125;</span>&quot;</span>	<span class="comment"># 移動游標到指令字串的末端</span></span><br></pre></td></tr></table></figure>

<p>因此，有了這樣的工具，管理指令的日子看起來就像這樣：</p>
<ol>
<li>「那個解壓縮的指令好像叫 tar 蝦米碗糕的？」，啟動速查。</li>
<li>找到指令，按下確認執行並解決問題。</li>
<li>沒找到指令，上網 Google 或是求救 chatgpt。</li>
<li>把查到的指令補充到指令文件內以便往後搜索。</li>
<li>無聊時可以打開指令文件緬懷自己的青春，「啊啦啊啦，我小時候可是用 word 紀錄管理 server 的程式碼呢！」。</li>
</ol>
<h2 id="結論：即使有-AI，"><a href="#結論：即使有-AI，" class="headerlink" title="結論：即使有 AI，"></a>結論：即使有 AI，</h2><p>不過現在 chatgpt 或 bing AI 那麼方便，指令速查工具還有用嗎？</p>
<p>我覺得兩者的定位不大一樣。雖然當今生成式 AI 的功能已相當全面，卻仍無法免除溝通的成本。對於陌生議題，獨自構思方法可能比實際解決問題費時，所以上網搜尋、求助他人或是詢問 AI 等借重既有經驗的方法都能縮短整體工時。</p>
<p>然而，隨著用戶熟悉方法，溝通成本便成為額外的負擔。呼應文首那幅四格漫畫，為了解壓縮一份 <code>tar.gz</code> 檔，你要先打關鍵字、按下搜索、點選網頁、複製&#x2F;貼上、執行，若你用 chatgpt，還得等他做些寒暄和反應的時間。在這種情況下，速查工具能做為很好的捷徑，方便用戶迅速取得常用指令，保持工作的流暢性。</p>
<p>這也是為什麼我覺得用戶要自己維護指令集，因為這樣內容才會符合每個人各自的頻率、需求和合適的搜索關鍵字。當然，等到哪天勞工不用為系統管理或是NGS分析，AI 能自動自發把事情做完的未來時，那又另當別論。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>莫莉的眼睛：《神經喚術士》的未來描寫</title>
    <url>/how-william-gibson-depict-the-future-in-neuromancer/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cyberspace 首見於威廉吉布森的著作，是指由可彼此互動的實體連結而成的網路空間，諸如物聯網、網際網路乃至生物體的訊息傳遞網路也可屬其範疇。</p>
<p>在《神經喚術士》(Neuromancer) 裡，吉布森為讀者描述了一個義體改造、意識研究與生化科技發達的世界。在這世界中，熱衷竊取情報與資訊的好手能透過面板將神經系統與網路連結，從而擺脫肉體束縛，讓意識遨遊在 cyberspace 之中。</p>
<p>顯然，故事中的 cyberspace 是至今尚未實現的概念，我們仍然仰賴鍵盤、滑鼠與螢幕等人機介面與網際網路的另一端互動。那麼，吉布森要怎麼描述意識連結到龐大而無遠弗屆的 cyberspace 時，會呈現什麼景象呢？</p>
<span id="more"></span>

<p>故事的主角凱斯因為竊取了雇主的情報而遭受私刑懲罰，雖然保住一命卻喪失了連網能力。在故事開端，神秘人物阿米提找到了凱斯，以治療其神經系統為條件，換取凱斯3以其卓越的駭客能力為他辦事。</p>
<p>當凱斯接受了先進醫療重獲連網能力後，他久違地再次進入 cyberspace，作者這樣描述：</p>
<blockquote>
<p>他閉上眼。<br>找到電源鈕凹凸不平的表面。<br>在他眼睛後方泛血光的黑暗中，銀色光幻視從空間邊緣翻騰湧入，入眠前的影像晃盪而過，彷彿以隨機畫面拼湊而成的電影。符號、人影、臉孔，一副模糊、破碎的視覺資訊曼陀羅。<br>拜託，他祈禱，現在──</p>
<p>一個灰色碟狀物，千葉天空的顏色。<br>現在──<br>灰碟開始旋轉，愈轉愈快，變成一個較淡灰色的球。漸漸膨脹──<br>接著湧動，為他而湧動；液態霓虹的摺紙戲法；他那無遠近的家、他的祖國逐漸開展，透明 3D 棋盤無間延展。東方沿海裂變管理局（Eastern Seaboard Fission Authority）那附階梯的猩紅金字塔在美國三菱銀行（Mitusbishis Bank of America）的綠色方塊後方發光，他張開內在之眼看著這座金字塔；而在非常高遠之處，他看見軍事系統的螺旋臂，他永遠無法觸及。</p>
<p>然後他在某處笑著，在一個白漆閣樓，遙遠的手指愛撫控制板，解脫的淚水從臉龐滑落。</p>
</blockquote>
<p>雖然術語的堆砌與連續不斷的描述可能造成閱讀的困難，然而陌生字眼和意識流般的描述正好塑造了資訊洪流湧入凱斯意識之中的感受。</p>
<p>因此，雖然初次閱讀時可能難以將這些詞彙轉化為清晰的形象與畫面，但這些敘述帶來的思覺負擔卻能體現出 cyberspace 的某些特質。這也是為什麼 cyberspace 也可被譯作「塞爆空間 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「塞爆」不只是音譯 (https://danjalin.blogspot.com/2008/07/blog-post_22.html)">1</span></a></sup>」，寓意著資訊流的氾濫與過載。<br>一般而言，名詞的堆砌和冗長不間段的描述會形成閱讀的阻礙，然而陌生的字眼、意識流似的描述卻在此處營造出 cyberspace 資訊洪流湧入凱斯意識中的感覺。</p>
<p>在 cyberspace 之外，《神經喚術士》則有許多篇幅較短而資訊較稀疏，卻絲毫不減其為未來世界帶來鮮明印象的段落。</p>
<p>阿米提治療了凱斯的神經系統時，也委託醫生替他更換了因嗑藥而幾近衰竭的肝臟，以免任務完成前病故途中。作者並沒有直接描述人工器官的先進或義體置換的複雜，而是透過手術後令人不快的後遺症來描述。</p>
<blockquote>
<p>「你在浪費時間，牛仔。」凱斯從外套口袋拿出一顆八角藥丸時，莫莉這麼說。<br>「怎麼說？要來一顆嗎？」他把藥丸遞給莫莉。<br>「你的新胰臟，凱斯，還有你肝臟上的插頭。阿米提讓它們繞過那些玩意兒。」她用一根勃根地指甲輕點藥丸，「你在生物化學上沒辦法享受安非他命或古柯鹼。」<br>「媽的。」他看著藥丸，然後看著她。<br>「吃啊，吃一打下去。什麼也不會發生。」<br>他吃了，真的什麼也沒有。</p>
</blockquote>
<p>我尤其喜歡書中對殺手莫莉的的眼睛的描述。莫莉與凱斯同樣受僱於阿米提，但她對阿米提的背景持有疑慮，因此與凱斯合作的過程也嘗試調查幕後真相。</p>
<p>當凱斯與莫莉初次見面時，他留意她的特殊之處：</p>
<blockquote>
<p>她搖頭。凱斯這才察覺那副眼鏡是以手術嵌入，封住了她的眼窩。銀色鏡片看似從顴骨上方平滑蒼白的肌膚長出來，框在蓬亂的黑髮下。</p>
</blockquote>
<p>這裡簡潔的敘述留給讀者需多想像空間，隨著劇情發展，透過凱斯對莫莉性格的逐步理解，她的外表與內在逐漸豐富。（關於這雙眼睛，可以在 google 查詢 「neuromance molly fan art」看看大家根據這些描述能畫出幾種版本的莫莉）</p>
<p>接著，他們有了更親密的肢體接觸：</p>
<blockquote>
<p>「沒關係，」她說，「我看得見。」剝下皮褲的聲音。她在他身旁扭動，掙脫皮褲後踢到一旁。她一腿跨過他，而他碰觸她的臉。植入鏡片意想不到地堅硬。「不要。」她說，「指印。」</p>
</blockquote>
<p>在執行任務途中，他們也談起改造後的生理感受：</p>
<blockquote>
<p>「我不哭，通常。」<br>「但妳會怎麼哭，如果有人把妳弄哭？」<br>「我吐口水。」她說，「淚腺牽到嘴裡。」”</p>
</blockquote>
<p>這種利用生活瑣事的不便與疙瘩感營造出的真實感，不僅讓未來世界更為具體，也豐富了角色的形象。</p>
<p>例如，在描寫凱斯透過終端與莫莉連接時，作者沒有說明意識共感的具體原理和操作方式，反而著重在莫莉與凱斯的互動：</p>
<blockquote>
<p>「目的是？」<br>「沒概念。只知道我要幫莫莉裝上播送裝置，所以你多半是要存取她的感覺中樞吧。」芬恩搔了搔下巴，「這下你可以弄清楚她的牛仔褲到底多貼身了，嗯？」</p>
</blockquote>
<blockquote>
<p>「感覺如何，凱斯？」他聽見字句，也感覺到她構句。她一隻手滑進口外套，一根指尖繞著溫暖絲綢下的乳頭打轉。那感覺令他屏住呼吸。她大笑，但這連結是單向的，他無法回應。</p>
</blockquote>
<p>類似的還有以下意識被數位化的描述，同樣沒有講清意識載體的外在形象，卻讓人對這項科技印象深刻。</p>
<blockquote>
<p>「你好嗎，迪西？」<br>「我死了，凱斯。在保坂裡待的時間足以想通這點。」<br>「感覺如何？」<br>「沒感覺。」<br>「困擾嗎？」<br>「困擾的是，沒東西讓我感到困擾。」<br>「怎麼說？」<br>「我有這麼一個夥伴先前在俄羅斯營區，西伯利亞，拇指凍傷了。軍醫來切掉拇指。一個月後，他整晚翻來覆去。愛羅伊，我說，你在煩什麼？該死的拇指癢死我了，他說。所以我告訴他，那抓一抓啊。麥考伊，他說，是另一隻天殺的拇指。」構體笑時顯現出來的是不一樣的東西，不是笑聲，而是從凱斯脊椎往下蔓延的一陣寒意。「幫個忙，老弟。」<br>「什麼忙，迪西？」<br>「你的這一局結束時，把這該死的東西刪除。」</p>
</blockquote>
<p>寫到這裡，驟然勾起我關於科技進展與感官變化的回憶。我的右手食指與中指間長著厚繭，所以持筆寫字時總是感到不舒服。我想這都得歸咎於以前看書時，往往不乖乖坐在桌前，而是靠在牆邊環抱雙臂，用一隻手比出剪刀姿勢夾住書脊把書頁支撐在視線處，試圖展現瀟灑氣質與俠客風範。</p>
<p>時至今日，我也不怎麼讀書了，倒是很常癱軟在椅上看著一則則短影片傻笑，絲毫不介意展現頹廢無為的作風。頂多偶爾因為耐不住手機重量，讓小指的第二指節有喘息的時間。</p>
<p>回到寫作的話題，要具體描述下一代人們裝酷耍廢或賴以為生的事物還真不容易。不過喀了嗨不起來的鬱卒、殺手罕見的眼淚、摸不著的困擾、指縫間的厚繭、小指節的痠疼感這類感受，這類根植於人類這物種的原始體驗或許能作為橋接人們想像與不存在事物的公約數吧。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「塞爆」不只是音譯 (<a href="https://danjalin.blogspot.com/2008/07/blog-post_22.html">https://danjalin.blogspot.com/2008/07/blog-post_22.html</a>)<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, mVCF)</title>
    <url>/introduction-to-multiverse-variant-call-format/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假設在很久很久以後的未來，人類有能力偵測到發生在多重宇宙各時間線的事件，也有演算法來比較事件間的異同，從而彙整出能代表多數宇宙歷史的標準時間線。利用跨宇宙與跨時間線的全史資料，往後的史家能將蒐集的歷史資料與標準時間線比較，推測事件的偶然與必然，指引未來史的發展方向。</p>
<p>面對龐大歷史分歧資料，這些史家或許需要適當的格式與軟體來管理之。對於這個數萬年後才會出現的新興史學與其困境，我想聊聊一些衍伸自生物資訊經驗的想像和白日夢……</p>
<span id="more"></span>

<h1 id="什麼是-mVCF？跟-VCF-有什麼不同？"><a href="#什麼是-mVCF？跟-VCF-有什麼不同？" class="headerlink" title="什麼是 mVCF？跟 VCF 有什麼不同？"></a>什麼是 mVCF？跟 VCF 有什麼不同？</h1><p>多重宇宙異變事件儲存格式 (Multiverse Variant Call Format, 以下簡稱為 mVCF) 是一種純文字檔案格式，用於紀錄觀測事件在特定宇宙內各時間線的分歧（詳細內容可參考我寫的<a href="https://github.com/5uperb0y/mVCF/blob/main/mVCF-spec.md">格式規範</a>）</p>
<p>mVCF 的構想源於基因體學的 <a href="https://github.com/samtools/hts-specs/blob/master/VCFv4.3.pdf">VCF</a> (Varaint Call Format)。VCF 檔案紀錄了樣本基因體與參考基因體的 DNA 鹼基差異，這些差異被稱之為變異 (variant)。因為基因變異可能與生物的疾病、性狀與演化史相關，所以可作為臨床診斷、族群遺傳乃至生態演化的研究基礎。</p>
<p>由於 VCF 檔為純文字檔、排版友善、容易擴充又被辨識基因變異的軟體所重用，所以 VCF 已是生物資訊領域通用的格式。去年，VCF 已經更新至 v4.3 版本，除了少數鹼基的變動、插入與刪除外，也納入倒置、跨染色體合併或是大片段缺失等結構變異的表示法。</p>
<p>當我在一個百無聊賴的下午，讀著 VCFv4.3 格式細則時，萌生了一個想法：既然 VCF 能用來紀錄 DNA 變異，那能否描述同為線性結構的時間？更進一步地，我能否用 VCF 檔紀錄一則關於平行宇宙、時空跳躍與蝴蝶效應的懸疑故事？於是我模仿 VCF，著手設計能像描述基因變異一樣，描述各時間線歧異事件的 mVCF。</p>
<p>不過，基因體與時間線的性質顯然有許多差異，所以雖然能挪用 VCF 的格式規範，不過要留意指涉對象的含意。</p>
<ul>
<li><strong>樣本</strong>：樣本是研究母體的子集，其範疇與形象因研究目的而異。在基因體學裡，樣本可以是細胞、組織乃至一盆湖水；而史學裡，可能是個人、國家乃至某種文化與風潮。</li>
<li><strong>鹼基&#x2F;事件</strong>：基因體的基本單位是鹼基，而歷史的基本單位則是事件。然而，相較於離散基因，時間則是連續的。因此，研究事件時更需要定義其範圍與尺度，事件間的差異也不只是字串比對，還需要梳理事件來龍去脈。</li>
<li><strong>建庫&#x2F;考古</strong>：基因體研究始於採樣與抽取 DNA，而史學也需要蒐集考古材料與文獻。如同 DNA 建庫的手段多元，未來也許會發展出更多考古技術，能取得其他宇宙與時間線的文物或口述記錄，讓歷史事件的輪廓更加清晰。</li>
<li><strong>定序&#x2F;編年</strong>：DNA 需經定序解碼鹼基的順序與種類，其結果構成<em>樣本的基因體</em>（樣本DNA的集合）；而考古材料也需要編年與考證，確認事件的順序與可信度，其結果構成<em>樣本的時間線</em>（樣本事件的集合）。</li>
<li><strong>參考基因體&#x2F;標準時間線</strong>：參考基因體是特定物種基因體的整合；而標準時間線則是特定實體（個人、國家或文化等）時間線的整合。兩者都匯集了多樣本的結果，涵蓋較全面的鹼基定序或事件編年資訊，可作為研究與比較的基礎。</li>
<li><strong>染色體&#x2F;宇宙</strong>：每條染色體都乘載了特定的基因，在 VCF 檔裡也有各自的座標；而每個宇宙都有各自的宇宙常數與物理定律，有其獨特的歷史脈絡與事件變化。</li>
<li><strong>變異&#x2F;異變</strong>：基因變異是樣本基因體與參考基因體的歧異，事件異變則是樣本時間線與標準時間線的歧異。</li>
</ul>
<p>釐清 mVCF 和 VCF 的概念差異之後，讓我以《高堡奇人》的假想歷史為例，說明 mVCF 紀錄歷史分歧事件的方式。</p>
<h1 id="如何解讀-mVCF？"><a href="#如何解讀-mVCF？" class="headerlink" title="如何解讀 mVCF？"></a>如何解讀 mVCF？</h1><p>《高堡奇人》是菲利普狄克的假想歷史著作，描述了軸心國贏得二戰後的故事。小說世界與真實歷史的分歧始於 1933 年小羅斯福總統遇刺身亡，導致美國無法脫離經濟蕭條並於歐戰爆發時仍保持孤立。</p>
<p>由於美國的政治態度與國力衰退，孤立無援的英國與歐陸為納粹所征服，隨後太平洋戰爭也以日軍大捷作結。分歧的歷史中，二戰遲至納粹德國與日本帝國於 1947 年征服美國並瓜分世界才告終。</p>
<p>以下即是小說時間線比對真實歷史的 mVCF 範例。若曾接觸生物資訊的話，應該能留意到它的形式其實與 VCF 一致，只是紀錄項目因應歷史事件的特徵而有所調整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##fileformat=mVCFv0.1</span><br><span class="line">##fileDate=20240105</span><br><span class="line">##source=BiblioMapperv1.0.7</span><br><span class="line">##eventEncoding=CEES27</span><br><span class="line">##reference=file:///chronology/100000HumanHistory-pilot.tl</span><br><span class="line">##INFO=&lt;ID=EF,Number=A,Type=Float,Description=&quot;Alternative Event Frequency&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DP,Number=A,Type=Integer,Description=&quot;Read Depth, number of bibliography supporting alternate events&quot;&gt;</span><br><span class="line">##INFO=&lt;ID=DESCRIB,Number=R,Type=String,Description&quot;Event Description&quot;&gt;</span><br><span class="line">#COSMOS	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	MITHC</span><br><span class="line">U34	1933	.	P	ρ	.	.	EF=0.5;DP=1;DESCRIB=&quot;Mayor cermak is assassination&quot;,&quot;President Roosevelt is assassinated&quot;	.	.</span><br><span class="line">U34	1933	.	E	EEEEEEEE	.	.	EF=0.5;DP=1;DESCRIB=&quot;US Great Depression&quot;,&quot;US Great Depression&quot;	.	.</span><br><span class="line">U34	1945	.	W	WWW	.	.	EF=0.5;DP=1;DESCRIB=&quot;WWII&quot;,&quot;WWII&quot;	.	.</span><br><span class="line">U34	1945	.	P	.	.	.	EF=0.5;DP=1;DESCRIB=&quot;United Nations Founds&quot;	.	.</span><br></pre></td></tr></table></figure>

<p>每份 mVCF 依序分為三個部分：元資訊列 (meta-information line)、標題列 (header line)、資料列 (entry line)。</p>
<ul>
<li><strong>元資訊列</strong>：以 <code>##</code> 開頭，紀錄「如何讀懂這份檔案」的資訊，例如檔案格式、產出日期、縮寫含意等。</li>
<li><strong>標題列</strong>：以 <code>#</code> 開頭，紀錄資料列各欄的含意</li>
<li><strong>資料列</strong>：紀錄分歧事件所發生的宇宙、時間、性質、證據以及描述等資訊，每一列都表示某時間點發生的分歧事件。</li>
</ul>
<p>此處先忽略看起來更繁雜的元資訊列（這部分通常是不懂時查找用的），專注在假想歷史的第一項分歧「小羅斯福刺殺事件」。</p>
<table>
<thead>
<tr>
<th>#COSMOS</th>
<th>POS</th>
<th>ID</th>
<th>REF</th>
<th>ALT</th>
<th>QUAL</th>
<th>FILTER</th>
<th>INFO</th>
<th>FORMAT</th>
<th>MITHC</th>
</tr>
</thead>
<tbody><tr>
<td>U34</td>
<td>1933</td>
<td>.</td>
<td>P</td>
<td>ρ</td>
<td>.</td>
<td>.</td>
<td>EF&#x3D;0.5;DP&#x3D;1;DESCRIB&#x3D;”Mayor cermak is assassination”,”President Roosevelt is assassinated”</td>
<td>.</td>
<td>.</td>
</tr>
</tbody></table>
<ul>
<li><code>#COSMOS</code>：發生事件的宇宙（具有特定宇宙常數與物理定律的環境），用以規範時間線描述的範圍。<code>U34</code> 是我們所處宇宙的代號。</li>
<li><code>POS</code>：發生事件的時間點。由於時間尺度因事件而異，所以需參照元資訊列確認所用的時間單位。此處以日歷年為單位，符合二戰歷史的事件發生頻率和時長。</li>
<li><code>ID</code>：特定事件的辨識碼。通常在各宇宙與時間線普遍發生的重大事件，例如地球生命起源或宇宙爆發等，會被標註辨識碼供交流與研究用。</li>
<li><code>REF</code>：在標準時間線預期發生的事件代碼。標準時間線是全史學家採樣可探測宇宙各時間線所拼湊的歷史，便於後續研究察覺罕見分歧事件。為了記錄方便，事件通常會以單字符碼概括。各領域有其常用的編碼系統，此處採用 CEES27 系統，<code>P</code> 為重大政治事件 (“politics”)，即芝加哥市長 Cermak 遇刺事件。</li>
<li><code>ALT</code>：在觀測時間線實際發生的事件代碼，可稱之「分歧事件」或「異變」，比較 <code>REF</code> 和 <code>ALT</code> 即可了解事件在各時間線的差異。在《高堡奇人》的時間線中，遇刺死亡的人不是 Cermak 是小羅斯福總統。</li>
<li><code>QUAL</code>：分歧事件的可信程度。受限於跨時空探測技術以及殘存的文獻紀錄，並非所有發現的事件都那麼可靠，這項數值即反映了研究人員對分歧事件是否存在的信心。</li>
<li><code>FILTER</code>：分歧事件是否可靠，基於文獻品質、數量以及考古證據等資訊，判斷分歧事件的可信程度是否達所設定的標準。</li>
<li><code>INFO</code>：其餘關於事件本身、探測技術或是可信程度的補充資訊。例如 <code>DP=1</code> (Read Depth) 表示僅有一份文件佐證分歧事件的發生，而後續的 <code>DESCRIB</code> 則提供了事件的摘要。</li>
<li><code>FORMAT</code>：假設我們不只採樣《高堡奇人》小說版的時間線，也納入影集版本的時間線，那麼就需要標記各自與標準時間線的分歧。此欄規範了標記各觀測時間線的格式。</li>
<li><code>MITHC</code>：觀測時間線的辨識碼 (the Main in The High Castle, MITHC)。每份 mVCF 皆可含有多筆觀測紀錄（或稱「樣本」），屬於該觀測的紀錄規範在 <code>FORMAT</code> 之中。每個觀測皆獨立一欄，依序置於<code>FORMAT</code> 之後。</li>
</ul>
<p>綜合這些欄位的資訊，這條紀錄可解讀為「1933年，於我們所處宇宙的時間線發生政治事件分歧，小羅斯福取代 Cermak 死於 Giuseppe Zangara 刺殺事件。這項分歧可在一半的時間線中觀測到，但僅有一份文獻支持其存在。」，而接續幾列則陳述了在假想的歷史中，經濟蕭條 (E, Economy) 與二戰 (W, War) 拖延的比預期更久，聯合國也不曾成立。</p>
<p>至此，我已介紹了 mVCF 的雛型，但對於怎麼取得分歧事件資料，或說如何詮釋歷史分歧的影響等問題仍有許多討論空間。以下分別陳述我認為值得研究和改善的議題。</p>
<h1 id="目前-mVCF-還有什麼待解或研究議題？"><a href="#目前-mVCF-還有什麼待解或研究議題？" class="headerlink" title="目前 mVCF 還有什麼待解或研究議題？"></a>目前 mVCF 還有什麼待解或研究議題？</h1><h2 id="如何編碼事件？"><a href="#如何編碼事件？" class="headerlink" title="如何編碼事件？"></a>如何編碼事件？</h2><p>構成 DNA 和蛋白質的基本單元只有 24 個分子，所以使用 26 個英文字母便足以表示。然而，構成時間線的事件彼此之間在時空尺度、內容性質、牽涉對象可能大相逕庭。好比說，國際政治是十數年間的的合縱連橫，地質年代則是百萬年的板塊遷移；個人史涉及了數十人的愛恨情仇，但戰史卻攸關數萬人的生離死別。</p>
<p>換句話說，定義事件基本單位的方式會因領域而異 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。">1</span></a></sup>，無法像基因體學只用一套編碼描述各物種的遺傳變化。因此，若想模仿 VCF 或 FASTA 等格式以單字符描述基本單元，需要適當的編碼系統，依照事件屬性將之分門別類，賦予簡明的代號以利用戶判讀。</p>
<p>舉前述的《高堡奇人》為例，書中的國際關係事件便用以下系統化約少量的英文字母方便於表中呈現，其餘細節則補充在於 <code>INFO</code> 欄位供參照。</p>
<table>
<thead>
<tr>
<th>編碼</th>
<th>事件類型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>Political Changes</td>
<td>政權更迭或其他事件，例如政權更迭與當權者上位等</td>
</tr>
<tr>
<td>W</td>
<td>War and Conflict</td>
<td>戰爭或軍事衝突，例如歐戰與二戰</td>
</tr>
<tr>
<td>T</td>
<td>Technological and Scientific Breakthroughs</td>
<td>科學發現或科技發明，例如發明蒸汽機與發現核能</td>
</tr>
<tr>
<td>C</td>
<td>Cultural and Societal Shifts</td>
<td>社會變遷或文化風行，例如啟蒙思潮</td>
</tr>
<tr>
<td>E</td>
<td>Economic Shifts</td>
<td>經濟危機或發展，例如經濟大蕭條</td>
</tr>
<tr>
<td>X</td>
<td>Discovery and Exploration</td>
<td>開拓生存空間，例如發現新大陸與航路</td>
</tr>
<tr>
<td>D</td>
<td>Disasters and Catastrophes</td>
<td>天然或人為災難，例如西班牙大流感與南亞海嘯</td>
</tr>
</tbody></table>
<p>值得留意的是，編碼意味著篩選、歸納與簡化，所以不免捨棄部分資訊並引入主觀判斷。所以可預期每份 mVCF 的編碼系統都反映了記錄者的觀點，反映他們對驅動歷史的根本邏輯與關鍵動力的認知。這就像基因體學的 VCF 不只記錄了序列的差異，其實也蘊藏了識別變異的算法邏輯和假設。</p>
<p>是以，當我們討論 mVCF 所記錄的事件時，必須承認歷史的多元性與複雜性。歷史不僅由大事件構成，同時期也包含了眾多零星事件、個人故事或文化現象等。然而，實務上不一定要標記出所有事件的分歧，因為 mVCF 要涵蓋的事件內容可透過確定研究前提與範疇而聚焦。</p>
<h2 id="要記錄什麼事件？"><a href="#要記錄什麼事件？" class="headerlink" title="要記錄什麼事件？"></a>要記錄什麼事件？</h2><p>儘管目前沒有其他時間線的觀測報告，我們仍然可以從歷史策略遊戲的設計理念得到一些靈感。這些遊戲容許玩家參與特定時代，左右國家政權的發展，創造出與現實截然不同的歷史途徑<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考[维多利亚2（Victoria2）：历史的逻辑](https://necromanov.wordpress.com/2010/09/01/victoria2/)的總結">2</span></a></sup>。</p>
<p>以《世紀帝國》系列遊戲為例，玩家將選定特定文明，歷經黑暗、封建、城堡與帝王時代，逐步發展經濟與強化軍事，並以征服對手的文明為目標。在這種情況下，驅動事件的是勝負，遊戲機制維護的是玩家操作的合理性。</p>
<p>事件發展皆與取勝密切相關，例如生產村民、升級科技或建立軍隊等，玩家會因戰局的發展做出行動，而不是各項遊戲內的社會因素與事件長遠影響。 歷史在此處作為遊戲氛圍的點綴，其真實性與玩家舉動沒什麼關係，也可能出現與史實脫節的狀況。</p>
<p>而光榮的《三國誌》系列則展現了以人物為中心的敘事方式，讓玩家沉浸在大時代的故事中，挑戰歷史人物曾面臨的困境，實現他們曾立下的宏願。 基於這項設計，遊戲維護著歷史事件本身的獨特性。舉例來說，即使遊玩過程有別，赤壁之戰的劇本就該由曹操、劉備與孫權三方參與，才能營造出當代的氛圍。</p>
<p>即使是假想的劇情，也會遵循一條合適的劇本發展。由於驅動遊戲進行的是劇本，因此事件紀錄更為著重在決定劇本分歧的選擇，這些會成為往後重啟遊戲回顧的關鍵（例如嘗試失敗，就得回到存檔點再試一次）。</p>
<p>相比之下，由 paradox 公司出品的遊戲（例如《維多利亞》和《鋼鐵雄心》），更強調事件發生的合理性。在這種觀點下，遊戲機制維護的是事件發生的邏輯，而不是歷史事件本身。簡言之，參與事件的各方被抽象化，當各項參數合乎條件時，即可能觸發事件，然而因為國家環境與政治初始條件的影響，宏觀的歷史軌跡很可能相似，但在細節上可能會有差異。這類遊戲事件則更為複雜，紀錄的是影響參數的事件，例如革命事件可能會跟民生、外交與軍事等行為相關，從而影響民心之類的參數。</p>
<p>這類歷史模擬遊戲的假想時間線是三款之中較接近基因體學研究現況的，相較之下，世紀帝國系列的歷史發展更像遵循熱力學（在遊戲的情境中即是取得勝利）而隨機構成的聚合物，事件的前因後果較為鬆散；這類遊戲的假想歷史紀錄呈現明顯的歷史分岔和障壁，在特定檢查點的狀況會引領迥然不同的路線。</p>
<p>綜上所述，mVCF 紀錄的事件類型取決於紀錄者對歷史的看法。這些事件會與影響歷史的因素相關，從而允許我們從中歸納出歷史的必然和偶然。</p>
<h2 id="個案研究：星際移民史"><a href="#個案研究：星際移民史" class="headerlink" title="個案研究：星際移民史"></a>個案研究：星際移民史</h2><p>既然已經探討了事件類型與其編碼方法，不妨透過個案研究來加深理解。想像一下，如果我們打算研究某個文明在不同時間線上展開星際移民的可能性。考量跨星系移動所需的龐大能量，可從文明的利用效率來推斷其進行星際移民的可能性。在這樣的研究框架下，我們將關注那些直接影響能源應用效率和規模的關鍵事件；而相對地，社會文化或國際政治事件則較無關緊要。</p>
<p>為了有效編碼事件，我們可採用卡爾達肖夫指數 (<a href="https://en.wikipedia.org/wiki/Kardashev_scale">Kardashev scale</a>) 作為衡量標準，標記一個文明各時期所能利用的能量規模。假設該文明能在夠長的時間內維持可觀的能源利用，這表明該文明更有可能具備承擔星際旅行所需能源的能力；反之，這個文明也可能因為戰爭或自然災害而喪失先進的科技水準。雖然這種事件編碼方式省略了許多細節，但它依然能夠概括地呈現文明的發展軌跡。</p>
<p>在以下範例中，自然數代表卡爾達肖夫指數。在標準時間線中，可預期該文明將在四萬年後掌握恆星能源的應用。然而，在可觀測的眾多時間線裡，多數情況下 (99.99%) 文明會因某些事件而喪失這種能力。只有極為罕見的案例 (0.01%)，該文明的技術水準蕙突飛猛進，達到了能夠掌握並維持星系能源利用的階段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#COSMOS	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	MITHC</span><br><span class="line">U42	40000	.	2	2333333333333333333333333,20	.	.	EF=0.0001,0.9999;DP=1000,1000	.	.</span><br></pre></td></tr></table></figure>

<p>基於這項範例的觀察，星際交流可能非常罕見，因為在大多數時間線上都能觀察到科技衰退現象。這意味著或許存在某種過濾機制限制了文明的發展，這可以為人類文明的未來，或是解釋費米悖論指引一些研究方向。</p>
<h2 id="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"><a href="#什麼是異變（分歧事件），時間線的分歧又意味著什麼？" class="headerlink" title="什麼是異變（分歧事件），時間線的分歧又意味著什麼？"></a>什麼是異變（分歧事件），時間線的分歧又意味著什麼？</h2><blockquote>
<p>異變或分歧事件在 mVCF 中指的是在不同時間線中發生的、與標準時間線不同的事件。這些分歧可以是小到一場戰役的結果不同，也可以是大到整個文明的興衰不同。這些分歧事件揭示了歷史的非線性和多變性，表明即使是微小的改變也可能引發巨大的連鎖反應。理解這些分歧有助於我們更深刻地認識決策的重要性以及歷史的複雜性。<br>基因變異與事件變異在性質上有顯著差異。基因變異通常局限於生物的物理屬性，而事件變異則涉及複雜的歷史語境。事件比對（類似於序列比對）涉及了事件的完整背景、因果關係和語境。例如，在科技發展史研究中，牛頓與萊布尼茲的微積分發明可能被視為同一事件，但在英德歷史研究中則被視為不同事件。這種比對可能需要更複雜的演算法或全面的人工智慧判斷。<br>在研究目的上，類似於基因變異的臨床檢驗、生態演化與族群遺傳，時間線分歧的研究可能專注於預測未來、判斷歷史驅動因素的必然性或偶然性，或是進行時間線間的比較研究。不同於基因變異影響衍生物，時間線的變異直接作用於其自身，這可能導致對歷史事件的解釋和影響分析更為複雜。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件異變與基因變異在本質上有顯著區別。基因變異影響的是生物體的物理特性，而事件異變則涉及更為複雜的歷史語境和因果關係。在分析事件異變時，我們需要考慮事件的整體背景、相互關聯和影響。例如，在科技發展史的研究中，牛頓和萊布尼茲各自發展的微積分可能被視為相同的事件，但在英國和德國的國家史中，則可能被視為不同的事件。這種事件比對比基因序列比對更為複雜，可能需要全面的人工智慧判斷或高度專業的人工分析。</span><br><span class="line"></span><br><span class="line">就研究目的而言，時間線分歧的分析可用於預測未來、判斷歷史驅動因素的必然性或偶然性，或進行不同時間線的比較研究。不同於基因變異影響生物體的衍生特性，時間線的變異直接作用於其自身，這可能對歷史事件的解釋和影響分析帶來更為複雜的挑戰。</span><br><span class="line">在處理事件異變時，我們需要的不僅是簡單的序列比對，而是對事件背景、動機、影響和連帶後果的全面分析。例如，科技發展史中的牛頓和萊布尼茲微積分的發明，雖然可以被視為相同的事件，但在英國和德國的國家史中，這兩件事就可能被視為不同事件。這需要比基因序列比對更複雜的演算法或全面的人工智慧判斷。</span><br><span class="line"></span><br><span class="line">比如，在臨床檢驗中，基因變異的研究可以幫助我們理解疾病的成因和治療方法。在歷史的脈絡中，分析事件的異變可以幫助我們理解特定決策或事件對歷史進程的影響。在生態演化中，基因變異的研究可以揭示生物多樣性和物種進化的機制；類似地，研究歷史事件的異變可以揭示文化和社會結構的演變。在族群遺傳學中，基因變異的研究有助於描繪人群遷徙和混合的歷史，而在mVCF的脈絡下，類似的分析可以揭示不同文化和政治力量如何塑造歷史的走向。</span><br></pre></td></tr></table></figure>
<p>怎麼樣才知道事件發生分歧？換句話說，在辨別分歧事件時，我們需要迥異於序列比對的手段。事件可能很類似，但他們有完全不一樣的語境，那能否視為。<br>例如牛頓發明微積分與萊布尼茲發明微積分在是否可歸類於相同事件，若</p>
<p>目前我還沒有比較明確的想法，但<br>在基因體學，偵測變異的原因不外乎歸納成因、<br>基因體與時間線其它差異在於：基因變異影響蛋白質與性狀，事件分歧則影響隨後的事件；基因變異作用在其衍生物，時間線發生分歧卻作用在其本身。</p>
<h1 id="如果還等不到來自其他時間線的招呼…"><a href="#如果還等不到來自其他時間線的招呼…" class="headerlink" title="如果還等不到來自其他時間線的招呼…"></a>如果還等不到來自其他時間線的招呼…</h1><p>最後談談發現多重宇宙與其他時間線之前，能利用 mVCF 做些什麼。</p>
<ul>
<li>文獻管理</li>
<li>完善格式</li>
</ul>
<blockquote>
<p>它可以作為一個強大的文獻管理工具，幫助研究者整理和分析涉及替代歷史或假想情境的文獻。</p>
</blockquote>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">也許往後會有類似 IUPAC 的機構，凝聚各領域事件編碼的共識。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">網路上有不少關於歷史策略遊戲的史觀討論資源，此處參考<a href="https://necromanov.wordpress.com/2010/09/01/victoria2/">维多利亚2（Victoria2）：历史的逻辑</a>的總結<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>攻殼機動隊 STAND ALONE COMPLEX</title>
    <url>/kenji-2002-ghost-in-the-shell-stand-alone-complex/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這部由主線──笑臉男事件和支線──電子腦、義體普及引發新型社會問題組成。</p>
<p>主線外的小故事可以獨立看，不影響通篇劇情理解。但是支線是以公安九課的各幹部為主角(還有思考機器人，塔奇克馬)，只聚焦笑面男事件就會錯失了解個別配角的機會。例如每次調查幾乎都是佗古薩上陣，笑面男的突破線索幾乎由這個有家庭沒義體化的new comer給找出來。</p>
<p>不過我覺得笑面男事件結尾有點不過癮，反派顯得不夠力。前頭醞釀的巨大陰謀在夕陽西下的最後一集平淡結束，讓前一集被激起的情緒無處宣洩。</p>
<span id="more"></span>

<h1 id="電子腦和義體"><a href="#電子腦和義體" class="headerlink" title="電子腦和義體"></a>電子腦和義體</h1><p>本作最重要的設定為電子腦和義體：電子腦是把意識和網路、程式連結起來的設備。義體簡單如義肢、義眼用以取代或強化原有器官，複雜的可以直接作為意識的載體。</p>
<p>依照電子腦的連結對象又可分為三種情形：硬體、軟體、其他人腦(在能把意識資訊化的世界觀裡，自我意識要算廣義的軟體了)，每個情形出現異常、矛盾或是和社會價值衝突就成為個小故事的題材。</p>
<p>電腦有各種存取資料的結構搭配不同的演算法以解決問題。人腦雖然沒有堆疊、佇列或樹來保留學習記憶和本能，處理問題卻比電腦有創意多了。</p>
<p>像 26 集「公安九課 再臨」最後面笑臉男和少佐講一堆名言時，課長把電子腦和連結到外部資料庫以聽懂他們的對話。要及時理解對話，就要對那些名言佳句有印象。</p>
<p>印象，也就是記憶。當電子腦和資料庫連結架起，且讀取資料的時間能和人們讀取回憶一樣快時，就會產生有印象的錯覺。但假若資料庫沒辦法像人腦那樣存取，那讀取的速度就會受限於資料庫本身設計，這樣的連結頂多是不用手指划的智慧型手機。</p>
<p>可是每個人記憶的模式不一樣，資料庫是為通用的查詢所設計，所以連結的同時也得對資料進行處理。也許是那瞬間將資料庫依序放進電子腦，再依照個人特質進行儲存。或者，因應電子腦的出現，個人資料庫和個人網站一樣跟著普及起來。畢竟前述方法仍要花時間在預先分類資料。</p>
<h1 id="義體與本體感覺"><a href="#義體與本體感覺" class="headerlink" title="義體與本體感覺"></a>義體與本體感覺</h1><p>而第11集「在若林的森林」提到的電子腦自閉症，是電子腦和硬體連結不協調進一步到病症的例子。</p>
<p>器官移植要解決免疫系統在生理上的排他，義體又是比器官移植更劇烈的變化還須克服心理上的排他。雖然組成身體的分子每分每秒都在代換，但是結構不變我還是能認得自己。但像是換肢手術的例子，就算免疫系統接納了捐贈者的器官，受贈者心理上仍須花時間適應。</p>
<p>義體更是把腦以外全換為人造器官，面臨的心靈衝擊又更大，輕者只是感知遲鈍地像醉酒，重者產生自閉症、甚至變植物人完全無法協調。像少佐很小的時候就全身義體化，要隨成長更換義體，每次都要對更大的身體重新適應（難怪叫ghost in shell , 隨成長更換的外骨骼）</p>
<p>另外比較小的問題就是電子腦和武器做連結若不能達成人機一體的同步率，會造成使用者的不便(例如 15 集「機器們的時間」裡面的新型狙擊裝置)</p>
<h1 id="電子腦與自我意識"><a href="#電子腦與自我意識" class="headerlink" title="電子腦與自我意識"></a>電子腦與自我意識</h1><p>除了高同步率(即操作、讀取的效率)，電子腦也得內建系統避免人與人的界線因電子腦間的連結而消弭。畢竟讀取別人的腦和讀取自己的腦一樣便捷，還能認得出我是誰嗎？</p>
<p>像第 18 集「暗殺二重奏」 連結上父親記憶的兒子在舉止上越來越像父親，甚至在兒子身上產生父親的人格。第 21 集「丟棄的軌跡」巴特錯把佗古薩重傷的時的情緒當成自己的情緒變得暴躁起來。</p>
<p>電子腦發明前，人的意識被肉身包覆，要彼此影響只能靠有限的五官(語言、行為)，雖然意念轉換成過程有可能造成誤會，但也保護了個體的獨立性：只能用嘴巴說服、用行為證明、用金錢誘惑……只能從外在下手，而且一個人即便行為舉止受制於人，仍能保有自我思考這最後的自由。</p>
<p>一旦原始的防壁敞開，意識就有被人操作的危險(笑臉男就常控制別人意識幫她代言)，所以也就有個人防壁的產生。</p>
<p>然而，也有不設防壁的例子，讓別人不需迂迴地經過文字、圖畫、影像、聲音來理解自己的概念，例如 15 集「機器們的時間」把自己電子腦開放的導演，讓與之連結的人沉迷於其腦海裡的電影構想而無法自拔。</p>
<h1 id="義體、電子腦與社會"><a href="#義體、電子腦與社會" class="headerlink" title="義體、電子腦與社會"></a>義體、電子腦與社會</h1><p>至於價值觀、宗教的反對電子腦化，貧富不均導致義體分配不均……都是些老問題，癥結點往往不是出在科技本身。</p>
<p>像是宗教和價值觀的反對是個人理念，貧富不均則是社會體制的問題，就算沒有電子腦換成別的發明都會持續存在。</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜太空生物學</title>
    <url>/lee-2017-astrobiology/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>李炎的太空生物學是台灣少見的天文生物學專著，不過內容卻虛實參半。前半段摘錄新聞網或部落格報導的奇聞軼事，補充維基百科的條目說明，加上一些感想湊成討論生命起源和地外生命的篇章。然而，參考資料似乎不限於期刊論文，好比「墨西哥人發現外星人寶寶」之類的農場新聞也直接收錄，並沒有加以解釋或編輯。</p>
<span id="more"></span>
<p>中段改編自美國國家太空生物研究中心發表的《人類在太空的生理學》(Human Physiology in Space)，這是太空生物學(Space biology)的一環，雖然和字面上的涵義和天文生物學(Astrobiology)相似，但是前者研究太空環境對既有生物的影響，後者探討生命是怎麼來的。</p>
<p>太空生物學有許多實用價值，例如若能了解動物的生理變化將有助於設計太空人的健康維護措施，而掌握植物的太空生理學知識也能應用在太空農業上。至於微生物生長繁殖的狀況，則與天文生物學息息相關。由於各行星可能因隕石衝擊而把表土拋向太空，假如土中的微生物能捱過最初的撞擊，並在微重力、高輻射的極端環境存活，便有機會把生命播種到其他星球。</p>
<p>此書各章節較為零碎，例如第一部分看起來像鄉野奇談、第二部分讀起來像人體生理學課本，較難看出與主題的關聯。此書末以幾篇應用藍菌淨化代謝廢物的實驗報告作結。查詢了作者與其研究生的論文，發現原文僅提到可處理畜牧業或廚餘廢水，沒說明是否能應用在太空船的維生系統，因此這部分內容可能是作者自行延伸而來。</p>
<p>這部分有點可惜的是，作者用很大的篇幅（幾乎把整份論文貼了上來）來強調藍菌具有生物淨化的潛力。可是，閱讀以太空生物學為題的作品時，會期待能了解太空與畜牧環境差異，以及應用時會碰上的困難，但是作者較少著墨這些問題。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">李炎 (2017)《太空生物學》，漢珍數位圖書股份有限公司。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>life in the universe</tag>
      </tags>
  </entry>
  <entry>
    <title>戲說統計</title>
    <url>/lee-2017-introduction-to-statistics-and-quantitative-analysis/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知乎上有段軼聞可以很好地形容我讀《戲說統計》的心境：</p>
<blockquote>
<p>以前上新東方時候聽老師講的，說以前老俞還講課的時候，特別陶醉，做完題對答案，就問“有沒有人哪道題不懂啊？”要是有人提問題的話，老俞總是深情地看一眼題目，然後放下手中的教案，說：“同學們啊，這道題讓我想起了當初創業時候的的一件事，balabalabala”短短幾分鐘的就能把全班人講的如痴如醉，然後來一句“好的，大家還有哪道題不懂嗎？（阿冰，知乎）</p>
</blockquote>
<span id="more"></span>

<p>讀《戲說統計》是因為我很喜歡李連江老師的另一本書。教讀者怎麼走入和走好學術這條路的書有很多，例如讀《別鬧了，費曼先生》可以立志，讀《你和你的研究》讓人不忘摘星，讀《研究生完全求生手冊》則能學習踏實做事。</p>
<p>然而李老師的《在學術界謀生存》卻教讀者在了解自己是個平凡人後，怎麼面對期望落差，怎麼處理生涯焦慮，怎麼不負自己的使命與期待。因此，得知他還有一本既講統計也談學術生涯的著作時，便到圖書館借來看。</p>
<p>在經驗分享方面，《戲說統計》的立論與《在學術界謀生存》一致，皆勸勉讀者在看清事實後仍保持積極，追求自我的價值與肯定，例如：</p>
<blockquote>
<p>人生的智慧在於準確判斷自己，欣然接納自己。(144)</p>
</blockquote>
<blockquote>
<p>設立現實的目標，才能建立自信。(287)</p>
</blockquote>
<blockquote>
<p>看過，看不懂，很好！好在哪裡？好在創造了機會。看不懂，讓人不快，不憤不啟。(292)</p>
</blockquote>
<p>這些原則跟我讀了一些書、問了一些人而且親自碰一次壁後體會的想法一樣：多做事，少幹話；爭取機會，別找藉口；把握現在，不要懊悔過去；用指標衡量進展，但不要用指標定義自我價值。</p>
<p>至於描述統計的內容，對學過統計學的讀者而言可能較淺。作者用了許多篇幅討論詞彙的含意，也試圖澄清專有名詞的命名邏輯。例如 variable 應譯為變量還是變項？而 variable 的三層意義，即事實與反事實之別（因果推論）、個體屬性的日新月異（縱向研究）、屬性的因人而異（橫斷研究），為什麼攸關研究設計？</p>
<p>這些立論初學者讀來可能恍然大悟，但要應用於實務難題時恐怕無從發揮；而有經驗者讀來或許覺得有趣，但可能會發出「早點知道這種理解方法」的喟嘆，畢竟自己已度過瓶頸，如今不需要這樣的輔助才能理解抽象概念。</p>
<p>此外，書中多以比喻取代公式推導來解釋統計觀念，但能否理解作者的比喻與推理則見仁見智。例如作者雖然很用心講解樣本分布、抽樣分布和誤差分布的關係，但對這些觀念已經有定見的人來說，比喻與借代反而有可能阻礙讀者理解作者想傳達的意義。</p>
<p>總結對《戲說統計》的看法，我會說這本書是很私人的著作，是作者盡到傳承與坦率之義務的著作。</p>
<p>李老師（即作者）曾寫道：「最有效的誤導方法就是培養學術明星，製造學術天才，甚至奇才」，也在這本書提到「學者要盡到承傳的天職，對學生坦誠自己求學的辛苦是本分 (012)」。《戲說統計》記錄了李老師學習統計時遭遇的難點和克服這些困難的方式，未經歷這些困難的讀者可能覺得行文囉嗦，但有共鳴的讀者或會感到助益匪淺。</p>
<p>畢竟讀者很多元，一本著作有這樣兩極的評價也不是什麼問題。我覺得教育講究感同身受，即使是再簡單的問題，若有一位搞不懂的學生，便需要一位能讓學生搞懂的老師。假設不存在這樣的老師，那位學生自己搞懂以後能指導曾跟他一樣迷惘的學生，不也是一樁美事嗎？</p>
<p>書中還有一些有意思的句子摘錄如下：</p>
<blockquote>
<p>我認為教師的功勞不是教知識，而是鼓舞學生。知識可以教，但要靠學生自己刻苦研究才能學到；能力不能教，只能靠學生自己鍛鍊提高。學生學知識，長本領，出成就，都靠學生自己。教師起什麼作用呢？教師的責任主要是影響學生。用什麼影響？就是以書本上的知識為手段，幫助學生樹立自己的學習目標，激發學生的創造精神，鼓勵學生艱苦努力，幫助學生認識自己的潛力，促使學生把自己的潛力發揮出來。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師的主要功勞就是給學生偉大的刺激，偉大的鼓舞。教師要在課堂上把學生的學習精神、奮鬥精神鼓舞起來，教師的作用就是刺激和鼓舞，用敲鑼打鼓的方法振奮學生，讓學生努力。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>… 學生造就老師。老師的成就有學生的貢獻，不是教師自己本來就那麼優秀。必須有優秀的學生，教師才能進步，這是我堅信不疑的。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>教師刺激學生，學生就會跟教師研討，有研討，就能出成就。老師的智慧是學生敲出來的，學生很優秀，總是敲打教師，教師就進步了。（代序，車銘洲）</p>
</blockquote>
<blockquote>
<p>在方法論中，術語歸根結蒂是「約定」。約定俗成，遊戲能玩下去，溝通有效，誤會不深，就沒有必要更改術語。(008)</p>
</blockquote>
<blockquote>
<p>不怕了，就是學會了；敢用了，就是學通了；用對了，就是學精了。(011)</p>
</blockquote>
<blockquote>
<p>琢磨怎樣化繁為簡，化平淡為有趣，化有趣為智慧，也是教書的樂趣。(012)</p>
</blockquote>
<blockquote>
<p>英國哲學家奧斯丁說，通常情況下，我們需要的不是被告知，而是被提醒。方法論的主要作用就是提醒我們注意思維的漏洞與陷阱，(027)</p>
</blockquote>
<blockquote>
<p>常是相對的，變是絕對的。常是異常，無常是常。常往往是希望的目標，不是研究對象。希望常，是因為害怕變；提倡常，是因為現實中有不可阻擋的變。所以，「天不變，道亦不變」是個訴諸虛幻奢望的討好建議，不是基於事實研究的明智建言。話說回來，因為變是常態，也因為變很難把握，所以保守是明智，求變是進取。(027)</p>
</blockquote>
<blockquote>
<p>對人生來說，日新月異之變是唯一能直接觀察的變。人生之所以難，之所以有趣，歸根結蒂是因為人能意識到這兩種變化，試圖打通這兩種變化。我們看到種種因人而異之變，自然會想到自己日新月異之變。問題在於，這兩者之間，只在很有限的程度上相通，而且我們很難準確知道到底在什麼程度上、在哪個方面相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的智慧與藝術，關鍵就是在正確的時候採納適當的價值觀。人生不能沒有希望，希望來自相信因人而異之變與日新月異之變相通；然而有希望必然有失望，失望來自二者經常並不相通。(037)</p>
</blockquote>
<blockquote>
<p>人生的關鍵是發現和發揚正態分布對自己有利的屬性，躲避和弭補正態分布對自己不利的屬性。 (139)</p>
</blockquote>
<blockquote>
<p>… 最難判斷的就是我們的相對位置，而平均值和標準差可以幫我們確定自己的相對位置。在這個意義上，我們關注平均值和標準差，就是希望知道自己在這個世界上的位置，也是希望改變我們的地位。人生的苦悶在於，無論我們做什麼，都既糾結於平均值，也糾結於標準差。(141)</p>
</blockquote>
<blockquote>
<p>年輕時要努力奮鬥，因為自己的位置是不確定的，自己的潛力是未知的。但是一定要注意，人生的舞台有很多，人的能力有多面，千萬不要覺得人生只有一條路。你在這一條路上可能平平，在另一條路上卻可能優秀。一方面要堅韌不拔，另一方面要靈活機動，才能找到你最擅長做的事。(145)</p>
</blockquote>
<blockquote>
<p>研究生是學者最畏懼的讀者，他們會跟老師說，你把數據庫給我，我重複做一遍，跟你學。(185)</p>
</blockquote>
<blockquote>
<p>無論學什麼，都分兩個功夫：一個是投入時間學，另一個是用心琢磨怎麼學。又投入時間學，又用心想，就會慢慢找出一個適合自己的方法。哪一天你找到適合自己的方法了，你就學會了。(262)</p>
</blockquote>
<p>[^*] 李連江 (2017)《戲說統計：文科生的量化方法》，中國政法大學出版社。</p>
]]></content>
      <tags>
        <tag>statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1. Two Sum</title>
    <url>/leetcode-1-two-sum/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>
</blockquote>
<p>求數列內，和為目標值的兩數之座標</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,2,4], target &#x3D; 6<br>Output: [1,2]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code>：數列長度介於 2 至 104 之間</li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code>：數列各項可能有負值</li>
<li><code>-109 &lt;= target &lt;= 109</code>：目標值可能為負值</li>
<li>Only one valid answer exists.：僅有一組解</li>
</ul>
<span id="more"></span>

<p><strong>知識點</strong><br>hash table</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題最直觀的解法是將數列各項兩兩相加，最遲到比對所有組合後才找到題解。然而，目標值在這算法裡僅作為判斷結果的依據，沒有充分利用其提供的資訊。</p>
<p>為了充分利用目標值，可以各項與目標值之差為 keys，各項座標為 values，建立 hash table 存儲讀過的數字。</p>
<p>若現在的數字為先前出現過的數字與目標值之差，則回傳這兩數字的座標即為題解；若否，則新增現在的數字與目標值之差到 hash table 內。由於題目設計保證有唯一解，所以最遲遍歷整個數列即可找到題解。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = &#123;&#125;  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> record.keys() :</span><br><span class="line">                <span class="keyword">return</span>([record[nums[i]], i])</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                record[diff] = i</span><br></pre></td></tr></table></figure>
<ul>
<li>此以 python dict 實踐 hash table 的功能。</li>
<li><code>record.keys()</code> 可寫成 <code>record</code>，但標出來比較清楚</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜1480. Running Sum of 1d Array</title>
    <url>/leetcode-1480-running-sum-of-1d-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>計算數列逐項的累積和 (runningSum)</p>
<span id="more"></span>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array nums. We define a running sum of an array as runningSum[i] &#x3D; sum(nums[0]…nums[i]).<br>Return the running sum of nums.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,4]<br>Output: [1,3,6,10]</p>
</blockquote>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array  </p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題應該算是 for loop 練習，我覺得要留意 (1) indices out of range 以及 (2) len(nums) &#x3D;&#x3D; 1 的狀況。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runningSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[n] = nums[n - <span class="number">1</span>] + nums[n]</span><br><span class="line">        <span class="keyword">return</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜153. Find Minimum in Rotated Sorted Array</title>
    <url>/leetcode-153-find-minimum-in-rotated-sorted-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given the sorted rotated<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]">1</span></a></sup> array <code>nums</code> of unique elements, return the <em>minimum element of this array</em>.</p>
</blockquote>
<p>平移一嚴格遞增數列各項 n 單位後，求此數列的最小值</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [3,4,5,1,2]<br>Output: 1</p>
</blockquote>
<p><em>須留意幾個樣例：數列只含一項、數列只含兩項、平移後與原數列相同、最小值位於數列尾部</em></p>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li><code>n == nums.length</code>：數列長度為 n</li>
<li><code>1 &lt;= n &lt;= 5000</code>：數列長度介於 1 至 5000 項</li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code>：數列各項介於 -5000 至 5000，因此兩項相加不至於超出整數大小的上下界</li>
<li>All the integers of <code>nums</code> are <strong>unique</strong>：數列各項唯一</li>
<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times：數列已排序，且至多平移 n 次，最少平移 1 次</li>
<li>You must write an algorithm that runs in <code>O(log n)</code> time：此題有時間複雜度限制</li>
</ul>
<p><strong>知識點</strong><br>binary search</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此題的關鍵在於判斷最小值，並使用二分搜尋法簡化找尋最小值的步驟。</p>
<p>由於數列已由小到大排序，所以如果某項數值在平移後小於前一項，該項即為數列的最小值。依照這項原則，可以先定義 <code>left</code>、<code>mid</code>、<code>right</code> 三個指標，其中 <code>mid</code> 是 <code>left</code> 與 <code>right</code> 的中間值。</p>
<p>若 <code>nums[mid]</code> 小於其前一項，則 <code>nums[mid]</code> 為最小值，即可中斷迴圈並回傳題解。若尚未找到最小值，則可比較 <code>nums[mid]</code> 與 <code>nums[right]</code>，選定下一個搜索標的。</p>
<p>假設 <code>nums[right]</code> &gt; <code>nums[mid]</code>，表示數列於 <code>mid</code> 至 <code>right</code> 之間嚴格遞增，表示原數列的首尾交接處不在此區間，所以可以縮小搜索範圍到 <code>left</code> 至 <code>mid - 1</code> 之間。反之，則表示數列於 <code>left</code> 至 <code>mid</code> 之間嚴格遞增，則可縮小搜索範圍至 <code>mid + 1</code> 至 <code>right</code> 之間。</p>
<p>由於嚴格遞增數列一定有唯一的最小值，所以最遲在 <code>left</code> 與 <code>right</code> 指向同一座標時，會找到數列最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = right - (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>(nums[mid])</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="mid-的定義方式"><a href="#mid-的定義方式" class="headerlink" title="mid 的定義方式"></a><code>mid</code> 的定義方式</h3><p><code>mid</code> 亦可定義為 <code>(left + right)//2</code>，但聽同事討論，若兩數的數值極大，則有數值超出整數範圍的風險。以相減的方式撰寫則一定不會超出範圍。</p>
<h3 id="判斷首尾交界處的方式"><a href="#判斷首尾交界處的方式" class="headerlink" title="判斷首尾交界處的方式"></a>判斷首尾交界處的方式</h3><p>有看過同事在比較時，不比對 <code>nums[right]</code>，而是比對 <code>nums[-1]</code>，有一樣的效果。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">rotation 是指數列各項座標平移相同單位，例如 [1, 2, 3, 4] 平移 1 單位即為 [4, 1, 2, 3]，平移 2 單位則為 [3, 4, 1, 2]<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜53. Maximum Subarray</title>
    <url>/leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an integer array nums, find the subarray which has the largest sum and return its sum.</p>
</blockquote>
<p>給一整數數列，求其子數列級數的最大值。</p>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6</p>
</blockquote>
<span id="more"></span>

<p><strong>限制</strong></p>
<ul>
<li>$1$$\leq$ nums.length $\leq$$10^5$：數列長度介於 $1$ 至 $10^5$ 間</li>
<li>$-10^4$$\leq$ nums[i] $\leq$$10^4$：數值介於 $-10^4$ 至 $10^4$ 間</li>
</ul>
<p><strong>知識點</strong></p>
<ul>
<li>dynamic programming</li>
<li>Kadane’s Algorithm</li>
</ul>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>這題常見的作法是 Kadane’s algorithm，我在解題時並不知道這套演算法，所以一開始是用極端情形勾勒 function 的輪廓，再透過更多樣例「擬合」出可能的解法，最後才整合為提交的答案。</p>
<ul>
<li><strong>數列僅包含一個數字</strong>：解為該項數字，表示即使只有一個數字也能回傳</li>
<li><strong>數列全為正值</strong>：解為數列各項之和，所以程式碼內含有累加操作</li>
<li><strong>數列全為負值</strong>：解為數列最大的一項數字，所以程式碼內含有暫存最大值的變項與比較數值的判斷式</li>
</ul>
<p>由此分析可知問題癥結在於，累加的級數在碰到負數時要如何處置？</p>
<ul>
<li>若級數於累加後增加，則將這些數字納入計算。例如 [2, -1, -3, 5]，由於 5 &gt; -1 + -3，所以仍有涵蓋這兩個負數的價值。</li>
<li>若級數於累加後減少，則跳過這些數字，從新的位置開始計算。例如 [2, -1, -4, 1]，累加新的數字無法抵銷兩個負數值，所以不如跳過。</li>
</ul>
<p>至此，我雖然對計算方式有個概念，但還是經過了一連串測試，才歸納出以下算法。依序累加數列各項，每次累加後 (1) 若累加後級數沒增加，則從當前項重新計算級數；(2) 更新當前級數的最大值。</p>
<p>遍歷整條數列後，當前級數的最大值即為題解。只須走一趟循環，空間用量也固定，所以時間複雜度和空間複雜度分別為 $O(n)$ 與 $O(1)$。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        maxVal = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sums += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &lt; nums[i]:</span><br><span class="line">                sums = nums[i]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; maxVal:</span><br><span class="line">                maxVal = sums</span><br><span class="line">        <span class="keyword">return</span>(maxVal)</span><br></pre></td></tr></table></figure>
<p><em>當初以為要回傳子數列的位置，所以才使用 index 取值</em></p>
<ul>
<li><code>sums</code>：紀錄當前累加值</li>
<li><code>maxVal</code>：紀錄當前累加的最大值</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜217. Contains Duplicate</title>
    <url>/leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p>
</blockquote>
<p>(給定一整數陣列，判斷其中是否含重複的數字。)</p>
<p>Example:</p>
<blockquote>
<p>Input: nums &#x3D; [1,2,3,1]<br>Output: true</p>
</blockquote>
<span id="more"></span>

<h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><p>若 array 含重複數字，則有以下特性：</p>
<ul>
<li>數字重複出現</li>
<li>array 長度大於其中數字種類數</li>
<li>若將 array 排序，則重複的數字比鄰出現</li>
</ul>
<p>根據第一種特性，可用 hash table 存儲讀過的數字，再判斷讀入的數字是否已存在 hash table 中。此處，我以 python 的 <code>dict</code> 充作 hash table 來實踐這個想法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        occur = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> occur.keys():</span><br><span class="line">                <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                occur[n] = n</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">False</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">由於計算時間和空間需求都隨陣列大小線性增長，所以時間與空間複雜度都是 $O(n)$</span><br><span class="line"></span><br><span class="line">除了 `<span class="built_in">dict</span>`，python 的 `<span class="built_in">set</span>` 也能體現 <span class="built_in">hash</span> table 的特性。`<span class="built_in">set</span>` 可想像為僅有 key 的 `<span class="built_in">dict</span>`，由於 `<span class="built_in">set</span>` 的元素皆獨一無二，故可將 array 轉為 `<span class="built_in">set</span>`，再比較兩者的長度。若 `<span class="built_in">set</span>` 長度小於 array，則表示 array 含重複值。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) != <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>至於先排序，再比較數值兩側是否有重複值的做法，可參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a></p>
<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><ul>
<li><p>使用 list, dict, set 存讀過的數字有什麼差異？（參考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448">廖雪峰的官方網站：使用dict和set</a>）</p>
</li>
<li><p>python 是怎麼體現 <code>set</code> 的概念？（參考：<a href="https://stackoverflow.com/questions/3949310/how-is-set-implemented">How is set() implemented?</a>）</p>
</li>
<li><p>排序算法跟 hash table 算法相比有什麼優點？（參考：<a href="https://medium.com/roywannago-%E6%97%85%E8%A1%8C%E4%B8%8D%E9%9C%80%E7%90%86%E7%94%B1/leetcode-%E5%88%B7%E9%A1%8C%E7%B4%80%E9%8C%84-217-contains-duplicate-easy-647bc2ccdcf6">LeetCode 刷題紀錄 ｜217. Contains Duplicate (Easy)</a>）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 筆記｜724. Find Pivot Index</title>
    <url>/leetcode-724-find-pivot-index/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>若數列某項兩側各數字的總和相同，則該項為數列的樞紐 (pivot)。給定一整數數列，判斷其是否含樞紐項。若有，求樞紐之索引值；若無，則回傳 <code>-1</code>。</p>
<span id="more"></span>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>Given an array of integers <code>nums</code>, calculate the pivot index of this array.<br>The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right.<br><strong>If the index is on the left edge of the array, then the left sum is <code>0</code></strong> because there are no elements to the left. This also applies to the right edge of the array.<br>Return the leftmost pivot index. If no such index exists, return <code>-1</code>.</p>
</blockquote>
<p><strong>樣例</strong></p>
<blockquote>
<p>Input: nums &#x3D; [1,7,3,6,5,6]<br>Output: 3</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,-1,-1,0]<br>Output: 2</p>
</blockquote>
<blockquote>
<p>Input: nums &#x3D; [-1,-1,-1,0,1,1]<br>Output: 0</p>
</blockquote>
<p><em>留意負數項、樞紐位於數列首尾、數列只含一項或兩項的案例</em></p>
<p><strong>限制</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code>：留意負數項</li>
</ul>
<p><strong>知識點</strong><br>prefix sum &amp; array</p>
<h2 id="思路與題解"><a href="#思路與題解" class="headerlink" title="思路與題解"></a>思路與題解</h2><p>此處借鑑<a href="https://leetcode.com/problems/find-pivot-index/solutions/127676/find-pivot-index/">官方解法</a>。首先計算數列的級數 (<code>S</code>)，接著依序讀過數列，並計算讀過數字之和 (<code>leftSum</code>，即當前項左側的子數列總和)。</p>
<p>由於已算過 <code>S</code>，所以當前項右側的子數列總和可透過 <code>S - nums[i] - leftSum</code> 得知。</p>
<p>若當前項左右兩側的子數列總和一致，表示當前項為樞紐，其索引值便為題解；若總和不一致，則累計 <code>leftSum</code> 的值。若遍歷數列仍未求得樞紐，即可確認此數列無樞紐，依題目要求回傳 <code>-1</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        S = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> leftSum == S - nums[i] - leftSum:</span><br><span class="line">                <span class="keyword">return</span>(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                leftSum += nums[i]</span><br><span class="line">        <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="延伸討論"><a href="#延伸討論" class="headerlink" title="延伸討論"></a>延伸討論</h2><h3 id="曾嘗試但失敗的解法"><a href="#曾嘗試但失敗的解法" class="headerlink" title="曾嘗試但失敗的解法"></a>曾嘗試但失敗的解法</h3><p>我原先的想法是定義兩個指標，在一次迴圈中從數列兩側夾擠，同時計算 <code>leftSum</code> 和 <code>rightSum</code>。當兩指標重合，且左右數列總和一致時，指標的位置即為樞紐的索引值；反之，則表示此數列沒有樞紐。</p>
<p>這種方法的關鍵在於判斷何時要調動兩側的指標，所以在程式碼中間我寫了不少判斷式。然而，當數列正負數穿插的時候，判斷式便會很難寫。</p>
<p>舉下方的程式碼為例，碰到 <code>[-1,-1,-1,0,1,1]</code> 和 <code>[-1,-1,-1,0,1,1,0]</code> 這兩個案例時，右側指標會在循環中不斷往左側移動，直接錯過樞紐的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        leftSum = nums[l]</span><br><span class="line">        rightSum = nums[r]</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span>  <span class="built_in">abs</span>(leftSum) &lt; <span class="built_in">abs</span>(rightSum):</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                leftSum += nums[l]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                rightSum += nums[r]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftSum == rightSum:</span><br><span class="line">            <span class="keyword">return</span>(l)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="練習題目時，適合使用程式語言定義好的-function-嗎？"><a href="#練習題目時，適合使用程式語言定義好的-function-嗎？" class="headerlink" title="練習題目時，適合使用程式語言定義好的 function 嗎？"></a>練習題目時，適合使用程式語言定義好的 function 嗎？</h3><p>我覺得這算是我其中一種心態糾結，即「為了打好基礎，必須手刻所有功能」。不過追根究柢，做題的目的是透過題目學習該題相關知識。</p>
<p>以這題為例，<code>sum</code>並非解題的關鍵，也不是這題的核心知識，如果使用這個 function 能改善程式碼的可讀性和簡潔性，那麼我覺得使用程式語言定義好的 function 也不錯。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>魔球</title>
    <url>/lewis-2004-moneyball/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近進度報告剛結束，在老師指點下發現研究策略和內容有些問題，若想要準時畢業勢必受限於時間與精力。在面臨這般困境的情況下，看到魔球簡介中斗大的副標：「逆境中求勝的智慧」，讓我決定研究一下看看能得到什麼啟發。</p>
<span id="more"></span>

<h1 id="運動家隊面臨了什麼樣的困境？"><a href="#運動家隊面臨了什麼樣的困境？" class="headerlink" title="運動家隊面臨了什麼樣的困境？"></a>運動家隊面臨了什麼樣的困境？</h1><h2 id="運動家隊的逆境：資本額限制所致的競爭失衡"><a href="#運動家隊的逆境：資本額限制所致的競爭失衡" class="headerlink" title="運動家隊的逆境：資本額限制所致的競爭失衡"></a>運動家隊的逆境：資本額限制所致的競爭失衡</h2><p>運動家隊的困境在於有限的經營資本，在《魔球》成書的前一年 (2002)，運動家隊的團體薪資不足洋基隊的三分之一。而資本差異會造成戰力的差距，富豪球隊不僅能網羅交易市場上最佳的球員，也能挖角其他隊伍的砥柱；窮困球隊只有次佳的人選或是其他戰力外的球員。</p>
<p>戰力落差將導致窮困球隊的戰績低迷，減損球迷進場意願，以至於營收下降。在利潤降低的情況下，團體薪資也受到波及，使球團更無力補充新秀和保住當家球星，進一步擴大其與富豪球隊的戰力落差。</p>
<h2 id="克服逆境的方式是贏球"><a href="#克服逆境的方式是贏球" class="headerlink" title="克服逆境的方式是贏球"></a>克服逆境的方式是贏球</h2><p>為了避免營收下降而陷入競爭力失衡的漩渦，運動家隊的總經理比利．比恩 (Billy Beane) 透過行銷部門調查問題的癥結點。他們發現，票房的關鍵不在眾星雲集，而在於勝負。結合有潛力的新秀和仍有價值的老將組成的無名團隊打出一連串漂亮的好仗，會比一票棒球巨星打出沉悶的敗仗還來得吸引觀眾入場。</p>
<p>只要能夠吸引球迷入場支持，便能夠增加票房，從而得到資金拓展球隊經營的手段與空間。因此，比恩的課題即是在贏球帶來票房的假設下，設法以有限的預算打贏最多場球賽，無論最終有無辦法獲得世界冠軍，都能藉此擺脫競爭失衡的困境。</p>
<h2 id="贏球的關鍵是能夠得分的球員"><a href="#贏球的關鍵是能夠得分的球員" class="headerlink" title="贏球的關鍵是能夠得分的球員"></a>贏球的關鍵是能夠得分的球員</h2><p>比恩的目標是以有限的資本取得更多勝利（最好能進季後賽），所以解決問題的第一步即是勾勒出目標的具體形象，接著規劃方向與階段任務，估算達成不同階段所需的成本，以免因追逐錯誤標的而虛耗。</p>
<p>根據比爾．詹姆斯 (Bill James) 的研究，勝場與得分息息相關。比恩的助理保羅．迪波德斯塔 (Paul DePodesta) 首先估計進入季後賽所需的勝場數，再透過得分與勝場的關係推算晉級要求的得分數。接著他根據球員過去的表現，預估往後一季運動家隊的得失分，從而衡量當前狀況是否有晉級季後賽的條件。</p>
<p>單局勝負在投打之間的對決，單場勝負則在教練間的運籌帷幄，而例行賽的爭霸則有賴球團對於人力資源的調度。因此，追求勝率的問題在比恩的眼裡便轉換為如何補強球員的問題。</p>
<h1 id="什麼樣的球員能夠幫助運動家隊克服逆境？"><a href="#什麼樣的球員能夠幫助運動家隊克服逆境？" class="headerlink" title="什麼樣的球員能夠幫助運動家隊克服逆境？"></a>什麼樣的球員能夠幫助運動家隊克服逆境？</h1><h2 id="身體素質僅片面反映球員的潛力"><a href="#身體素質僅片面反映球員的潛力" class="headerlink" title="身體素質僅片面反映球員的潛力"></a>身體素質僅片面反映球員的潛力</h2><p>一旦確認當前與目標的差距，即可判斷球隊需要投資多少預算補強選手，以獲足夠的得分與勝場。然而，要採用什麼指標才能找到能幫助球隊得分的球員？</p>
<p>在比恩仍是個潛力新秀的時期，評斷球員優劣的指標是投球、力量、跑速、守備、臂力等基礎素質，有時還加上球探對球員外貌和心理狀況的評價。基於對選手的期待和對農場的信賴，這些球探相信良好的身體素質配合有效的鍛鍊能夠養出新一代的大聯盟球星。</p>
<p>但是，球員在場上的表現也受臨場判斷和賽場經驗影響，田徑場上優秀的跑者對盜壘未必在行，能丟出快速球的標槍選手未必曉得蒙騙打者。因此，良好的身體素質是投打守等基本功的保證，但與得分能力間仍有許多未知的因素存在，所以仰賴素質不見得能正確評斷球員的價值。</p>
<h2 id="可以從統計數據觀察球員隱匿的長處"><a href="#可以從統計數據觀察球員隱匿的長處" class="headerlink" title="可以從統計數據觀察球員隱匿的長處"></a>可以從統計數據觀察球員隱匿的長處</h2><p>在身體素質之外，過去的表現可以提供認識球員的新管道。身體素質反映了球員投打守等基本功，紀錄則展示球員在賽場的真實表現；身體素質關注球員能夠培養的特質，紀錄則強調球員不可培養的天賦；身體素質放眼未來，紀錄則以過去為鏡。</p>
<p>是以無論身體素質還是攻守紀錄都是了解衡量球員的工具，只是在比恩擔任球團總經理的時候，球探們輕忽了數據的用處。由於直接量測球員在賽場的表現，所以數據最大的優點，是能夠揭示用肉眼在短期內看不出的能力差異。其次，數據較為客觀，能協助決策者擺脫個人經驗的限制。第三，也因為攻守紀錄的量化特質，它能夠被資料科學發展出來的工具利用。</p>
<p>雖然過去表現不等同未來表現，低階聯盟的成就也不盡然能在高階聯盟複製，但是長期積累的正面數據表示球員具有一些不易用數據呈現的特質。因此，在找尋到更好的指標之前，鑒於 (1) 數據與表現的關聯性，(2) 良性特質的持續性，(3) 數據的客觀性，以過往紀錄評估球員來年的表現仍是合理的決策。</p>
<h2 id="上壘率是衡量進攻能力的關鍵統計量"><a href="#上壘率是衡量進攻能力的關鍵統計量" class="headerlink" title="上壘率是衡量進攻能力的關鍵統計量"></a>上壘率是衡量進攻能力的關鍵統計量</h2><p>但並非所有數據都能忠實反映球員的能力。我們可能認為打點表示球員在關鍵時刻的打擊能力，但這也許是棒次安排的緣故，讓該名球員的打席得碰上較多次得點圈。而守備失誤則受紀錄組主觀判斷，很難說積極接球導致的失誤會劣於怠惰而造成的安打。這些例子並非否定失誤和打點的意義，但作為衡量能力的指標，有些數據混合了人為判斷和運氣因素，可能會錯估球員的能力。</p>
<p>對棒球的勝負而言，士氣、調度、佈陣等因素可能都會影響比賽的結果，但追根究柢，棒球最關鍵易懂的因素是出局數，一旦耗盡九局二十七個出局數，一場比賽便不再有任何可能；反之，如果沒有任何出局，球隊則能隨著打席演替不斷得分。是以任何能降低自己出局風險的事情都是好的，而增加出局風險的事情都是壞的。</p>
<blockquote>
<p>上壘率 &#x3D; （安打 + 四死球） ÷ （打數 + 四死球 + 高飛犧牲打）</p>
</blockquote>
<p>上壘率是球員不會出局的機率，所以它衡量了打者將進攻局往終點推進一步的可能性，然而其重要性卻一直被低估。在亨利．查德維克 (Henry Chadwick) 發展出攻守紀錄表之時，四壞保送被視為投手的失誤而非打者的技巧，因此打擊率便成為衡量球員進攻價值的主要指標。</p>
<p>然而，偶然的保送或許可以歸咎投手失誤，但高於平均的上壘率則意味著球員可能具有某些特長，例如良好的本壘板紀律或是纏鬥本領，所以上壘率也應該是衡量進攻能力的指標。</p>
<h1 id="逆境中該怎麼行動？"><a href="#逆境中該怎麼行動？" class="headerlink" title="逆境中該怎麼行動？"></a>逆境中該怎麼行動？</h1><h2 id="怎麼做到在逆境中求勝？"><a href="#怎麼做到在逆境中求勝？" class="headerlink" title="怎麼做到在逆境中求勝？"></a>怎麼做到在逆境中求勝？</h2><p>至此，再次回到開頭提出的問題：「如何用有限的預算打出競爭力？」</p>
<p>從分析得知，收益取決於票房，票房的關鍵是勝利，而勝利仰賴得分，得分則與球員組成息息相關。相較於身體素質，統計紀錄能反映球員肉眼不可見的能力。其中上壘率衡量了打者推展進攻局勢的可能性。</p>
<p>在比恩的時代，打擊率仍是評斷進攻能力的指標，這意味著某些具有得分能力的球員沒有受應有的重視。藉著網羅這些被低估的高上壘率球員，比恩便能以較低的成本，增加球隊在季賽中預期的得分數，達成提高勝率和吸引球迷入場的目標，最終擺脫競爭力失衡的循環。</p>
<h2 id="尋找自己的明星球員"><a href="#尋找自己的明星球員" class="headerlink" title="尋找自己的明星球員"></a>尋找自己的明星球員</h2><p>是以，比恩的經營策略便十分明朗了。在預算限制下，運動家隊無法買進明星球員，所以得關注初出茅廬的菜鳥或坐冷板凳的老將。由於需要詳盡數值把握球員的能力，相較於高中球員，他更青睞有較多出賽紀錄的大學新秀。即使這麼做可能會錯失一些潛力股，但保守的選才手段可以降低投資失敗的比率。</p>
<p>而球員之所以被冷落，表示他們有相當的缺陷，然而在欠缺資源的情況下必須取捨。重點不是完美，而是正確認知球員的價值和缺陷，以評估損益相抵後這些老將是否仍能為球隊帶來益處。<br>這也是《魔球》一再提及的中心價值，亦即使用適當的指標評價選手，再任用被低估的優秀球員。隨著時間演進、大聯盟環境和球隊需求變化，所謂適當的指標可能有所改變。然而逆境取勝的核心觀念都是理性思考和審慎評估，不要依賴印象和期待來決策。</p>
<h2 id="正確評估離隊球員的替代性"><a href="#正確評估離隊球員的替代性" class="headerlink" title="正確評估離隊球員的替代性"></a>正確評估離隊球員的替代性</h2><p>比起從市場購入現成的強者，透過前段敘述的方式挑選被低估的球員，再養出新的價值比較合算。然而資本限制導致球隊供不起養成的巨星，也保不住被挖腳的球隊棟樑。面對球員流失的困境，比恩的策略是 (1) 消極層面，用多位球員補強特定球員離隊的損失，(2) 積極層面，透過出售巨星的過程取得收益和選秀權等其他機會。</p>
<p>對勝負而言，球員的價值不在於個體，而是他的本領。因此，因應球員離隊的策略不是填補這個人的損失（無論有無這樣的人選，球隊都沒有足夠預算聘請），而是填補進攻和防守效率的損失。</p>
<p>比恩與運動家隊經營團隊把主力球員的能力拆分成不同的部分，仔細評估何者是影響戰力的關鍵，接著在市場上尋覓可負擔的替補球員，用迂迴的方式拼湊離隊球員帶走的得分貢獻。</p>
<h2 id="買低賣高、哄抬價碼、笑著交易"><a href="#買低賣高、哄抬價碼、笑著交易" class="headerlink" title="買低賣高、哄抬價碼、笑著交易"></a>買低賣高、哄抬價碼、笑著交易</h2><p>除了填補戰力，比恩也試著從交易球員的過程中佔便宜。例如利用市場上對終結者的迷戀，刻意培育一些資質還行的投手負責救援，讓他們累積亮眼的成績。接著刻意哄抬球員的本領，以高出市場的價碼出售，同時換來補償選秀權。</p>
<p>綜上所述，比恩與運動家隊使用被人低估的數據找到自己的明星球員。在主力球員離隊後，也能正確評估球員的替代性，以多位在單方面突出卻有其他缺陷的球員填補損失。此外，利用其他球隊對於一些虛妄數值的迷戀，比恩也能從交易的過程中，換得更便宜而且可能更有潛力的球員。</p>
<h1 id="魔球也能克服學術逆境嗎？"><a href="#魔球也能克服學術逆境嗎？" class="headerlink" title="魔球也能克服學術逆境嗎？"></a>魔球也能克服學術逆境嗎？</h1><h2 id="棒球與逆境、圍棋與人工智慧"><a href="#棒球與逆境、圍棋與人工智慧" class="headerlink" title="棒球與逆境、圍棋與人工智慧"></a>棒球與逆境、圍棋與人工智慧</h2><p>雖然《魔球》介紹的是棒球隊經理面臨逆境時的思考方式，但仍有應用在其他問題的價值。書中如先知般的棒球統計學教父詹姆斯曾說，他們把思考癌症、貧困和經濟等重大問題的能力用來思考棒球，可是我不認為思考棒球就比較不重要。</p>
<p>棒球數據分析是經營策略的有效參考。由於棒球採回合制，得失分的採計簡單（四個壘包），加上前人發展出一系列的描述統計方式，所以對其他領域的專家而言，棒球也能作為測試想法和挖掘關聯的模型。棒球和逆境思考的關係，如同圍棋和人工智慧的關係。對於人工智慧專家而言，圍棋本身不是重點，重點是複雜的棋局是測驗人工智慧的媒介。</p>
<p>綜觀《魔球》想表達的內容，即是以客觀的指標取代虛妄的猜想來衡量現況，在清楚分析問題和目標後，尋找被忽略的要素，以較高的效率克服資源有限的逆境。雖然這套方法無法保證有效（因為當今數據也有不足），卻能多少把握原先模糊的觀念，減少決策的隨機成分。</p>
<h2 id="陸永祥教授的科研團隊管理經驗"><a href="#陸永祥教授的科研團隊管理經驗" class="headerlink" title="陸永祥教授的科研團隊管理經驗"></a>陸永祥教授的科研團隊管理經驗</h2><p>當初讀《魔球》時也想過，學術圈其實很像大聯盟：各大教授教授帶著碩博士在物理聯盟、化學聯盟乃至生科聯盟作戰，必須在每個賽季裡撰寫計畫、爭取經費、網羅學生、做足研究。既有錢又大咖的教授有充裕的資本也有豐沛的人力，在學界呼風喚雨，做起研究來Nature 和 Science 連發；既貧困又要面臨升等壓力的教授，計畫屢投不中還要被刁難，學生少就算了，還得被校方凹去做行政業務。</p>
<p>面對學術圈的困境，有機會應用魔球的理論克服嗎？前幾周，普渡大學的陸永祥教授來我們所上演講，他說他擔任助理教授的時候，陷入計畫和論文屢投不中的困境。沒有計畫，資源無法到位，資源不足則無力招聘研究生，在沒有人力的情況下，研究進展也持續耽擱。</p>
<p>陸教授面臨的逆境，如同戰績低迷和票房銳減的運動家隊。他認為當前的目標是要維持研究進度，因為有了成果便能申請計畫帶來資金，所以陸教授又回到第一線做研究，同時參與民間單位的投資計劃籌備資金。</p>
<h2 id="被低估的大學生"><a href="#被低估的大學生" class="headerlink" title="被低估的大學生"></a>被低估的大學生</h2><p>然而自己做終究不是長遠之計，勢必得組織研究團隊經營中長期的規劃，所以陸教授打算以大學生取代碩博士成為團隊的研究主力。原則上大學生已經具備相當的研究能力，只是許多老師認為他們才剛入學什麼都不會，所以往往沒有留意到大學生的價值。</p>
<p>儘管不須支付大學生學費和生活費，仍須思考要用什麼報酬吸引他們無償加入。陸教授了解大學生較碩博士更注重實習帶來的經驗和履歷，所以提供對外合作或是組內培訓的機會，吸引想要有所成長的大學生投入。而這些機會的價值雖然是錢換不來的，但對於實驗室主持人而言還比準備碩博士獎學金廉價。</p>
<p>不過如同其他教授擔憂的，要怎麼確認大學生是否有能力從事研究？由於大學生的課業和經驗不足，不容易像研究所招生那樣憑成績單和履歷內容區分不同申請者的能力。所以陸教授透過對談來選材，如果雙方能在同個專業說上一個鐘頭，代表這位學生有相當的理解，至少能從事基本的工作。至於能否承擔重大的研究題目，則有賴進入實驗室後的觀察，而這也是因為招募大學生不用像收碩博士一樣對經費錙銖必較，才多少能承受選材的失誤。</p>
<h2 id="風險管控和長期經營"><a href="#風險管控和長期經營" class="headerlink" title="風險管控和長期經營"></a>風險管控和長期經營</h2><p>相較於碩博士，大學生從事研究的時間周期較短。為了維持團隊的研究計畫，陸教授除了在面試時篩選願意久待的人以外，也建立小組制度，培養團隊內的小組領導人。這樣不僅能夠有系統地培訓研究人力，也能拓展研究團隊的大小，主持多項計畫達到風險管理的作用。</p>
<p>綜上所述，陸教授的魔球策略就是以研究產出為目標，除了自己投入研究和積極找人合作，也以就業和學習機會吸引被低估的大學生，用面試篩選合格的研究能力，以較低的成本運營研究團隊，藉此擺脫科研的困境。</p>
<h1 id="研究生能從《魔球》裡找到避免延畢的智慧嗎？"><a href="#研究生能從《魔球》裡找到避免延畢的智慧嗎？" class="headerlink" title="研究生能從《魔球》裡找到避免延畢的智慧嗎？"></a>研究生能從《魔球》裡找到避免延畢的智慧嗎？</h1><h2 id="陸教授的新發現在台灣可能是常識"><a href="#陸教授的新發現在台灣可能是常識" class="headerlink" title="陸教授的新發現在台灣可能是常識"></a>陸教授的新發現在台灣可能是常識</h2><p>雖然陸教授在國外因為沒錢而被迫以大學生為研究主力，但這在國內某些學校可能是常態了。台灣讀博士的人較少，研究生又只待兩年，所以大學生從事研究的時數未必較短。而且各校的研究所往往無法吸引原校培養的大學生，所以研究生的水準不一定比提早進實驗室的大學生厲害。所以招生成效不彰的學校往往仰賴大學生為研究主力，而實驗課或計畫執行也需要大學生負責。</p>
<h2 id="延畢的危機"><a href="#延畢的危機" class="headerlink" title="延畢的危機"></a>延畢的危機</h2><p>然而現在我既不是一個球隊的總經理，也不是團隊的計畫主持人，而是個得為自己人生負責的研究生，我能從比利．比恩和運動家隊的故事中得到逆境中求勝的智慧嗎？我在研究上碰上的問題是先前風險管控沒做好，以至於當前的研究題目未必能夠得出明確結論，所以可能趕不上四個月後的口頭報告以及半年後的畢業期限。</p>
<p>我仔細分析後驗證了自己的想法，畢業的關鍵是論文，論文寫出來才有和指導教授談判的把握。而受到限制的則是時間，還有貧乏的智力，因此我的逆境是在有限的時間和智力下完成論文。</p>
<h2 id="魔球裡面的觀念每天都會碰到"><a href="#魔球裡面的觀念每天都會碰到" class="headerlink" title="魔球裡面的觀念每天都會碰到"></a>魔球裡面的觀念每天都會碰到</h2><p>由於時間有限，只能降低目標。但再低的目標都要有可以說嘴的結果才能寫論文，而要產出結果必須發掘前人忽略的指標，以表現實驗組與對照組的未曾報導的差異。《魔球》裡面雖然論證了指標的重要性，卻沒有介紹比恩和他的夥伴怎麼找出這些指標，所以我得自己想辦法。</p>
<p>首先，我要把研究問題和假說再想清楚一點。接著做出預測，在現有資料上測試已知的指標能否觀察到值得關注的現象。如果可以，那麼依照結果調整接下來的試驗；如果不行，<br>在檢視方法的同時，也開始調查既有的指標一一嘗試。最後根據資料、方法和研究三方限制的公約數，挑選要深入的方向。</p>
<p>不過這做起來恐怕沒有那麼容易，畢竟科學研究本來就一直在尋找前人忽略的東西，以在高度競爭的環境下爭取生存空間。</p>
<h2 id="認命吧，沒有克服絕望的捷徑"><a href="#認命吧，沒有克服絕望的捷徑" class="headerlink" title="認命吧，沒有克服絕望的捷徑"></a>認命吧，沒有克服絕望的捷徑</h2><p>儘管設想了那麼多，除了腳踏實地似乎沒有其他精明的選項。碩士班的研究不是賽局，而是個人的挑戰；團隊只有我一個人不算管理，題目只有一個稱不上大數據。魔球固然新穎，布萊德彼特主演的電影也很好看，但我的目的是解決問題，而不是拓展魔球理論，實在沒必要把目前的困境硬是嵌套在主人翁的背景裡。</p>
<p>如同書裡提到的「真正有威脅的，是冷靜、客觀的知識」，而不是對特定方法的景仰或崇拜，對於當前的研究困境我更該思考的是怎麼管理有限的時間和專注力，把握最重要的事情努力，不要逃避現實，即使還沒結果也趕快動筆。這樣積極行動以後，即使失敗了也學到了很多。</p>
<p>我相信許多嘗試在魔球裡找到人生解答的人應該也有相似的體悟。因為原書的副標題是「逆境中求勝的智慧」，但大家被電影裡小蝦米打倒大鯨魚的動人故事感動一場後，發現自己還是沒想到什麼有效的解決方式，而且近況似乎沒什麼改變。所以我猜看準失落心裡的書商在所以重新出版之際，把電影版書封副標改成「一個勇敢面對自己，逆轉勝的真實故事」。</p>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><blockquote>
<p>神要毀滅一個人之前，會先說他「有前途」。(Cyril Connolly, Enemies of Promise)</p>
</blockquote>
<blockquote>
<p>多年以後，他會說他當年去打職業棒球的決定，是他這輩子唯一一次為了錢去做某件事。在那之後，他絕對不再只為錢做任何事，絕不再讓市場支配他的人生方向。(027)</p>
</blockquote>
<blockquote>
<p>要把這件事做得正確，需要某種自尊，或是要拋棄某些自尊。(058)</p>
</blockquote>
<blockquote>
<p>只要我們停止揣測其他人怎麼看，事情就可以做得更好。(059)</p>
</blockquote>
<blockquote>
<p>總教練們總是傾向於選擇最不可能失敗的戰術，而不是最有效率的戰術，公然出糗的痛苦，壓過了選擇最佳戰術得到的報酬。(108)</p>
</blockquote>
<blockquote>
<p>真正有威脅的，是冷靜、客觀的知識。(113)</p>
</blockquote>
<blockquote>
<p>不要模仿別人！要學會循著理性的路線自行思考。假設、反覆求證，絕不要以為答案已經完美無瑕；不要因為某位知名棒球員說某件事是真的，就以為它是真的。(128)</p>
</blockquote>
<blockquote>
<p>窮，就得取捨。關鍵在於你捨了什麼，取了多少？(177)</p>
</blockquote>
<blockquote>
<p>不要期待完美，而是要判斷哪些缺陷不重要。(180)</p>
</blockquote>
<blockquote>
<p>重點不在於發生什麼事，而在於我們的球員怎麼做。(187)</p>
</blockquote>
<blockquote>
<p>這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。(226)</p>
</blockquote>
<blockquote>
<p>失敗的次數，注定要比成功多。(254)</p>
</blockquote>
<blockquote>
<p>重點不是比恩永遠不會犯錯；重點是他掌握到一套思考體系，讓原本難以確定的判斷，也就是球員未來的表現，稍微更確定一些。他不是算命師。他是在賭場裡算牌的玩家。(362)</p>
</blockquote>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li>Jamie (2011)：魔球 (Moneyball)：一個 Hack Everything 的棒球故事。MR JAMIE（<a href="https://mrjamie.cc/2011/11/14/moneyball/">Link</a>）</li>
<li>海倫兒朱 (2019)：弱者只能等待失敗？錯！1 個小球帶來 3 個逆境中致勝的法門。豆瓣讀書（<a href="https://book.douban.com/review/10517250/">Link</a>）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>All-Species Living Tree Project (LTP) 物種資訊的訂正和維護</title>
    <url>/living-tree-project-database-curation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>All-Species Living Tree Project (LTP)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="All-Species Living Tree Project (LTP)  相關文獻，Yarza & Munoz. (2014). The all-species living tree project. *In Methods in Microbiology* (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. *Systematic and applied microbiology*, 31(4), 241-250.">1</span></a></sup> 旨在維護所有已知古菌和細菌 type strain 的 16S rRNA 基因序列，並基於這些序列，建立古菌和細菌的譜系樹。</p>
<p>LTP 主要由四個單位參與</p>
<ul>
<li>LPSN 提供分類與命名資訊 (<a href="https://www.bacterio.net/">https://www.bacterio.net/</a>)</li>
<li>ARB 支援譜系樹建立與分類 (<a href="http://www.arb-home.de/">http://www.arb-home.de/</a>)</li>
<li>Ribocon 則負責資料庫的管理 (<a href="https://www.ribocon.com/">https://www.ribocon.com/</a>)</li>
<li>SILVA 則提供序列資料庫、計算資源與網頁介面 (<a href="https://www.arb-silva.de/">https://www.arb-silva.de/</a>)</li>
</ul>
<p>（自 2020 年起，LTP 的遷出 SILVA，獨立為一個網頁：<a href="https://imedea.uib-csic.es/mmg/ltp/%EF%BC%89">https://imedea.uib-csic.es/mmg/ltp/）</a></p>
<p>LTP 的資料常用於 16S rRNA 基因增幅序列的物種註解，而基於其收錄序列所構建的譜系樹，也能作為 Phylogenetic placement 的基礎<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. *Msystems*, 3(3), e00021-18.">2</span></a></sup>。</p>
<p>另外，由於 LTP與 RDP training set 都只收錄了 type strain 的序列資料，所以相較於透過序列預測建立的資料庫，LTP 的序列資料較為可靠，能避免在物種註釋時，要在分類錯誤之外面臨資料庫錯誤的問題。</p>
<p>儘管 LTP 已是人工維護且品質好的資料庫，但目前版本 ( LTP_01_2022) 的部分物種資訊仍有誤騰的狀況。在官方修正這些問題之前，資料庫的使用者得自己訂正這些錯誤。</p>
<span id="more"></span>

<h1 id="分類階層間少了分隔符"><a href="#分類階層間少了分隔符" class="headerlink" title="分類階層間少了分隔符"></a>分類階層間少了分隔符</h1><p>若使用 “;” 來分割這樣的字串，會得到較短的列表。</p>
<blockquote>
<p>AF251436 Ferrimicrobium acidiphilum Bacteria;ActinomycetotaAcidimicrobiia;Acidimicrobiales;Acidimicrobiaceae;Ferrimicrobium</p>
</blockquote>
<h1 id="分類名稱出現額外符號"><a href="#分類名稱出現額外符號" class="headerlink" title="分類名稱出現額外符號"></a>分類名稱出現額外符號</h1><p>文字前後出現空格、引號和句號等，可能會因字串不同而高估該分類階層的分類群數量，也可能在資料處理造成意外麻煩。</p>
<h2 id="額外的雙引號"><a href="#額外的雙引號" class="headerlink" title="額外的雙引號"></a>額外的雙引號</h2><blockquote>
<p>AY102612 Caedibacter taeniospiralis “Bacteria;Pseudomonadota;Alphaproteobacteria;Holosporales;””Caedimonadaceae””;Caedibacter </p>
</blockquote>
<h2 id="額外的句號"><a href="#額外的句號" class="headerlink" title="額外的句號"></a>額外的句號</h2><blockquote>
<p>LC552068 Conexivisphaera calida Archaea;Crenarchaeota;Conexivisphaeria;Conexivisphaerales;Conexivisphaeraceae;Conexivisphaera.</p>
</blockquote>
<h2 id="額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）"><a href="#額外的空格（位於-Hyphomonas-adhaerens-與-Bacteria-之間）" class="headerlink" title="額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）"></a>額外的空格（位於 Hyphomonas adhaerens 與 Bacteria 之間）</h2><blockquote>
<p>KF863150 Hyphomonas adhaerens Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p>
</blockquote>
<h1 id="分類名稱間有額外的分隔符"><a href="#分類名稱間有額外的分隔符" class="headerlink" title="分類名稱間有額外的分隔符"></a>分類名稱間有額外的分隔符</h1><p>會導致該紀錄多一個分類階層 </p>
<blockquote>
<p>HQ223108 Thermoleophilum minutum Bacteria;Actinomycetota;;Thermoleophilia;Thermoleophilales;Thermoleophilaceae;Thermoleophilum</p>
</blockquote>
<h1 id="重複出現的分類名稱"><a href="#重複出現的分類名稱" class="headerlink" title="重複出現的分類名稱"></a>重複出現的分類名稱</h1><p>例如同樣的分類寫兩遍，或是整個條目寫了兩遍，會導致該紀錄增加多個分類階層</p>
<h2 id="門名重複出現"><a href="#門名重複出現" class="headerlink" title="門名重複出現"></a>門名重複出現</h2><blockquote>
<p>AJ288899 Bacteriovorax stolpii Bacteria;Bdellovibrionota;Bdellovibrionota;Bacteriovoracia;Bacteriovoracales;Bacteriovoracaceae;Bacteriovorax</p>
</blockquote>
<h2 id="整串分類名稱重複出現"><a href="#整串分類名稱重複出現" class="headerlink" title="整串分類名稱重複出現"></a>整串分類名稱重複出現</h2><blockquote>
<p>“AF082795 Hyphomonas rosenbergii Bacteria;Pseudomonadota;Alphaproteobacteria;Hyphomonadales;Hyphomonadaceae;Hyphomonas Bacteria;Pseudomonadota;Alphaproteobacteria;Caulobacterales;Hyphomonadaceae;Hyphomonas</p>
</blockquote>
<h1 id="誤植分類名稱"><a href="#誤植分類名稱" class="headerlink" title="誤植分類名稱"></a>誤植分類名稱</h1><p>在此例中，屬名 Amnimonas 被誤謄為 Aminomonas（這是另一個屬）例如因為形似而寫成其他分類名、打錯字，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p>
<h2 id="誤植-Aminomonas-→-Amnimonas"><a href="#誤植-Aminomonas-→-Amnimonas" class="headerlink" title="誤植 (Aminomonas → Amnimonas)"></a>誤植 (Aminomonas → Amnimonas)</h2><blockquote>
<p>MF682432 Amnimonas aquatica Bacteria;Pseudomonadota;Gammaproteobacteria;Moraxellales;Moraxellaceae;Aminomonas</p>
</blockquote>
<h2 id="錯字-Jatrophihabitantaless→Jatrophihabitantales"><a href="#錯字-Jatrophihabitantaless→Jatrophihabitantales" class="headerlink" title="錯字 (Jatrophihabitantaless→Jatrophihabitantales)"></a>錯字 (Jatrophihabitantaless→Jatrophihabitantales)</h2><blockquote>
<p>LC323105 Jatrophihabitans telluris Bacteria;Actinomycetota;Actinobacteria;Jatrophihabitantaless;Jatrophihabitantaceae;Jatrophihabitans</p>
</blockquote>
<h1 id="異名"><a href="#異名" class="headerlink" title="異名"></a>異名</h1><p>即條目間使用該分類群的不同名稱，會導致 convergent 現象（即相同子分類群卻有不同母分類群）</p>
<h2 id="異名-1"><a href="#異名-1" class="headerlink" title="異名"></a>異名</h2><blockquote>
<p>(Bdellovibrionia [synonym] → Oligoflexia [correct name])</p>
</blockquote>
<h2 id="俗名"><a href="#俗名" class="headerlink" title="俗名"></a>俗名</h2><blockquote>
<p>(Bdellovibrionota [not validly published] → Bdellovibrionota [correct name]) HM038000 Vampirovibrio chlorellavorus Bacteria;Bdellovibrionota;Oligoflexia;Bdellovibrionales;Bdellovibrionaceae;Vampirovibrio AJ292759 Bdellovibrio bacteriovorus Bacteria;Bdellovibrionota;Bdellovibrionia;Bdellovibrionales;Bdellovibrionaceae;Bdellovibrio</p>
</blockquote>
<h1 id="欠缺完整分類階層"><a href="#欠缺完整分類階層" class="headerlink" title="欠缺完整分類階層"></a>欠缺完整分類階層</h1><p>比其它條目少了一個分類階層 </p>
<blockquote>
<p> # Lack information at Genus level (Ulvibacterium)<br> KF303137 Aestuariibaculum scopimerae Bacteria;Bacteroidota;Flavobacteriia;Flavobacteriales;Flavobacteriaceae</p>
</blockquote>
<h1 id="檢查方式以及我們的義務"><a href="#檢查方式以及我們的義務" class="headerlink" title="檢查方式以及我們的義務"></a>檢查方式以及我們的義務</h1><p>這些問題的模式紛亂，其實不容易找到有效的偵測方法，以下枚舉幾個我曾用過的策略，</p>
<ul>
<li>以分隔符切割字串，檢查輸出字串列表當中，長度異常的條目</li>
<li>下載 LPSN 物種資訊，檢查未出現在 LPSN 的條目</li>
<li>檢查出現分號、括號、空格以外的符號的條目</li>
<li>利用這些方法檢查完畢後，就順道把自己的發現寄給他們，當作對資料庫維護團隊的感謝吧。</li>
</ul>
<p>最後，分享一個我原本以為是因為以下原因而產生的 typo …..</p>
<blockquote>
<p>VIFM01000001 Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis Bacteria;Myxococcota;Myxococcia;Myxococcales;Myxococcaceae;Myxococcus</p>
</blockquote>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_ptt.png?raw=true" alt="這難道不是因為某個老梗產生的物種名稱嗎......"></p>
<p>拿去 Goolge 才知道，還真的有名字這麼長的生物<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. *Genome biology and evolution*, 12(12), 2289-2302.">3</span></a></sup>，長到維基百科側欄都破圖了。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_wiki.png?raw=true" alt="名字太長了，網頁都破圖囉。"></p>
<p>Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis 命名自其被分離的地點，位於威爾斯安格爾西島的 Llanfair­pwll­gwyn­gyll­go­gery­chwyrn­drobwll­llan­tysilio­gogo­goch 小鎮，分離地點附近還有一間四星級飯店😮。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/living-tree-project-database-curation_map.png?raw=true" alt="分離地點附近有間四星級飯店"></p>
<p>註</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">All-Species Living Tree Project (LTP)  相關文獻，Yarza &amp; Munoz. (2014). The all-species living tree project. <em>In Methods in Microbiology</em> (Vol. 41, pp. 45-59). Academic Press. 以及  Yarza et al. (2008). The All-Species Living Tree project: a 16S rRNA-based phylogenetic tree of all sequenced type strains. <em>Systematic and applied microbiology</em>, 31(4), 241-250.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Phylogenetic placement 是指，依據枝節間的親緣關係，將輸入序列置放在既存譜系樹適當位置。由於有納入參考譜系樹，這方法比 de novo  building 更節省計算資源；也因為採用「插入」取代「捨棄」，也比 read mapping/recruitment 保留更多序列。參考下文以理解 phylogenetic placement 的優勢： Janssen et al. (2018). Phylogenetic placement of exact amplicon sequences improves associations with clinical information. <em>Msystems</em>, 3(3), e00021-18.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Chambers et al. (2020). Comparative Genomics and Pan-Genomics of the Myxococcaceae, including a Description of Five Novel Species: Myxococcus eversor sp. nov., Myxococcus llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogochensis sp. nov., Myxococcus vastator sp. nov., Pyxidicoccus caerfyrddinensis sp. nov., and Pyxidicoccus trucidator sp. nov. <em>Genome biology and evolution</em>, 12(12), 2289-2302.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>metagenomics</tag>
      </tags>
  </entry>
  <entry>
    <title>假如事物遵循 80/20 法則，對我們的決策與行動有什麼影響？</title>
    <url>/mayer-2023-the-art-of-clean-code-80-20-principle/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>The principle says that the majority of effects come from the minority of causes.</p>
</blockquote>
<p>本文是<a href="https://www.books.com.tw/products/0010959955">《精通無瑕程式碼：工程師也能斷捨離》</a> 其中一章的心得。</p>
<p>80&#x2F;20 法則是指少數變項左右了多數結果，它既不是能預測結果的物理定律，也不是行事時得遵循的規範。精確來說，80&#x2F;20 法則是一項觀察，它可以讓我們思考，假設自己在乎的事情遵循這種分布，對我們的決策和努力方向有什麼影響。</p>
<p>雖然這原則對近代的讀者而言應該是耳熟能詳，但我覺得作者 Mayer 的解讀引人入勝。文中除了實際案例也有簡單計算來佐證為什麼基於 80&#x2F;20 法則，我們要投資成本在抉擇、必須保持專注、要關心核心的指標等等。因此，我覺得蠻值得寫一則心得來記錄。</p>
<span id="more"></span>

<h1 id="關鍵事物的影響超乎想像"><a href="#關鍵事物的影響超乎想像" class="headerlink" title="關鍵事物的影響超乎想像"></a>關鍵事物的影響超乎想像</h1><p>多數結果是建立在少數因素上，假設這項觀察或原則適用在多數情境，那麼有兩方面的暗示。 首先，在一個領域中，少數人員能佔有多數資源或成果，例如少數人發表了多數的論文，少數人賺進了多數的錢。</p>
<p>其次，在成就這現象的行為中，也只有關鍵的行為與成就有關。 換句話說，若目標是在某領與取得一定的成績，那麼若能夠辨識並投注心力在事物的關鍵環節，便不需要搞得筋疲力盡，也能維持一定成績。</p>
<p>從效益的角度來看，關鍵環節與其他環節的差異更加明顯。假設兩成的努力造就八成的結果，那麼每一成努力造就四成結果，相較之下，在非關鍵事物的投注僅造就四分之一的成果。單位投入下，關鍵事物造就的效益是非關鍵事物的十六倍。那這種比例的差異在實際情形中可能更加懸殊，例如在生物體方面，少數基因轉變主宰了大多數的變化，這些基因的影響力是其他基因的數千倍以上。</p>
<h1 id="選擇能反映結果並指引方向的指標"><a href="#選擇能反映結果並指引方向的指標" class="headerlink" title="選擇能反映結果並指引方向的指標"></a>選擇能反映結果並指引方向的指標</h1><p>當然，除了原則背後的機制以外，作者也解釋了要怎麼透過這些原則指引行動，讓自己在有限的資源，更有效率達成目標，從而有餘裕去完成或享受其他事情。</p>
<p>這涉及了 80&#x2F;20 法則的另一項暗示，除了大部分資源為少數人所佔據，多數的進展也取決於少數的行為。而辨識關鍵行為的重點則是選擇適當的指標來衡量行為效益。</p>
<p>舉例來說，如果目標是擁有健美體態，那麼各式各樣的飲食法與健身菜單都是潛在的選項，而體重、體脂肪、身體測量值都是衡量判斷行為對目標影響的指標。</p>
<p>然而，不是所有指標都能忠實反映行為的影響或指引往後的行為。好比說，他人對身材的稱讚的確能反映此人的體態，不過這些讚美反映的是過往投入成本的效益，而非當下行為的影響。此外，他人評價又受長相、穿搭或其他難以捉摸的因素，未必能從中檢討出能讓自己體態變好的方向。</p>
<p>另一方面，體脂與肌肉尺寸則是反映行為結果忠實的指標，但很難在每次訓練中即時回饋自己到底做了多好。相較之下，訓練量（負重乘以次數）即是其中一個能及時反應行為的指標，肌肉量與耐力提昇就能提升更多訓練量，也能從當下行為反應到成效。</p>
<p>以作者用語總結，假如體態是衡量成功的依據，讚美並不是衡量進展的指標，體脂和肌肉量是呈現過往投資的 lagging indicator。而我們要關注的則是能反映當下行為影響的 leading indicator，後者能指引我們做有效的努力以達成目標，也能幫助我們在出錯時檢討問題所在。</p>
<h1 id="透過學習減少摸索與排序指標的成本"><a href="#透過學習減少摸索與排序指標的成本" class="headerlink" title="透過學習減少摸索與排序指標的成本"></a>透過學習減少摸索與排序指標的成本</h1><p>然而，排序任務、選定指標、標記價值、學習技術也需要成本（想想看演算法課裏頭那些時間複雜度不一的排序方法），這些成本有可能攤平投資在關鍵行為與項目的效益。</p>
<p>因此，需要借重他人的經驗來減少摸索與排序的成本。在此書中，作者舉了寫作和寫程式兩個案例供讀者參考。對於作家而言，最重要的行為是寫作，而衡量寫作的指標則是「寫了多少句子&#x2F;幾本書&#x2F;幾個故事」；而對程式設計師而言，最重要的行為是寫程式，衡量寫程式的指標則是「寫了多少行程式碼&#x2F;提出多少修訂&#x2F;完成多少專案」</p>
<p>雖然這些指標看起來有點簡化，但簡化不代表單調或沒意義。相反地，越少原則表示越容易追蹤與遵循，即使是盲目地寫程式和寫作，也起碼有以下好處：</p>
<ul>
<li>你能把自己的觀點、意見、想法、風格與巧思等所有你存在過、活過、學習過的證據儲存在可交流的媒介</li>
<li>有了資訊，便能做為籌碼與他人交流，用以兌換經驗</li>
<li>即使不算精通，持續寫起碼能造就熟練，讓你能更快完成同樣或類似的任務</li>
<li>經驗節省的時間能反過來投資寫作和寫程式，或是物色更好的方法</li>
</ul>
<h1 id="保持專注"><a href="#保持專注" class="headerlink" title="保持專注"></a>保持專注</h1><blockquote>
<p>a critical strategy for moving up the Pareto curve is to stay in the game longer while participating in fewer games</p>
</blockquote>
<p>值得注意的是，前述好處的前提是專注。假設各項領域皆呈 80&#x2F;20 法則的分布，那麼投注與報酬呈指數關係。若將投注分散在不同領域，則綜合成長幅度會少於全數投資在單一領域的成長幅度。</p>
<p>畢竟 80&#x2F;20 法則是指多數取決於少數，若這項原則適用各領域，那麼因為分布不均，要懂得取捨；由於輕重不一，得學會排序。取捨與排序又需要經驗累積，這有賴持之以恆的專注。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>作者在這章最後有提幾項老生常的建議，我覺得最值得提醒自己的是這個：</p>
<blockquote>
<p>Don’t do things that reduce value.  These are things like smoking, eating unhealthily, sleeping little, drinking alcohol, and watching too much Netflix. Avoiding things that drag you down is one of your biggest leverage points. If you skip doing things that harm you, you’ll become healthier, happier, and more successful.  And you’ll have more time and money to enjoy the good things in life: relationships, nature, and positive experiences.</p>
</blockquote>
<p>他提到的行為是否有害見仁見智，可是不惹自己麻煩卻是很好的主意。畢竟我們不會每次能做出有效的投資，避開風險能保留更多選擇或資源以把握下次機會。</p>
]]></content>
      <tags>
        <tag>development</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND | Longest Increasing Subsequence (LGIS)</title>
    <url>/longest-increasing-subsequence/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給一正整數列，求其最長的遞增與遞減子數列。例如數列 5, 1, 4, 2, 3 的最長遞增數列為 1, 2, 3，最長遞減數列則為 5, 4, 3。</p>
<blockquote>
<p>Given: A positive integer n≤10000 followed by a permutation π of length n.</p>
<p>Return: A longest increasing subsequence of π , followed by a longest decreasing subsequence of π.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/lgis/">https://rosalind.info/problems/lgis/</a>)</p>
<span id="more"></span>

<h1 id="知識點"><a href="#知識點" class="headerlink" title="知識點"></a>知識點</h1><p>Synteny block 是物種基因體間基因順序彼此一致的片段。這些片段在演化過程中沒有因為重排（genome arrangement）而分離或反轉，暗示著坐落其中的基因不只位置相鄰，功能也可能彼此關聯。</p>
<p>由於基因體動輒包含數億對鹼基，即使比較的對象是親緣關係相近的物種，仍有可觀的計算量與複雜性。相較之下，synteny block 的數量遠少於鹼基數，卻同樣能對基因體的功能和結構提供一些線索。因此，透過比較 synteny block 來研究推演物種的演化過程也不失為一種可行的方式。</p>
<p>舉例來說，假設甲物種與乙物種共享 5 個 synteny blocks，並且依照它們在甲基因體的排列順序命名為 1, 2, 3, 4, 5。接著標記乙基因體上對應的 synteny blocks，便能概括兩者基因體的差異程度，或是推測基因體的結構變化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">甲：1, 2, 3, 4, 5</span><br><span class="line">乙：3, 2, 1, 4, 5  &lt;-- 可能發生一次轉置</span><br></pre></td></tr></table></figure>

<p>儘管以符號標記 synteny blocks 可直觀呈現基因體差異，不過隨著比較對象和內容增加，可以使用距離指標來簡化基因體差異分析。</p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/0/05/Human-mouse_synteny.jpg"><br>（人類與老鼠的染色體 synteny blocks 分布圖，<a href="https://en.wikipedia.org/wiki/Synteny%EF%BC%89">https://en.wikipedia.org/wiki/Synteny）</a></p>
<p>在 <a href="https://5uperb0y.com/counting-point-mutations/">“Counting Point Mutations”</a> 當中已介紹 Hamming distance 來評估發生點突變的序列間的差異。在這題則引進最長遞增&#x2F;遞減子數列的概念，透過 synteny block 的順序來定量基因體間的差異。最長遞增&#x2F;遞減子數列的長度越長，表示兩基因體越相似；長度越短，則表示可能發生較多次基因體重排等結構上的變化。</p>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>由於找最長遞增子數列的方式也能用在找最長遞減子數列，所以我將專注討論最長遞增子數列的解法。</p>
<p>假設數列皆如 1, 2, 3, 4,… 嚴格遞增，那麼尋找最長遞增數列並不困難。然而，對於數列元素順序凌亂的狀況，如 2, 5, 3, 1, 4, …，隨著數列長度增加，會越來越難直觀看出答案。</p>
<p>造成困難的主因在於，在檢查某項數字時，我們難以確定它是延續某個既有的遞增子數列，還是作為新的遞增子數列的開端。在檢查完所有數字之前，也無從得知當前檢查的數字是否為最終答案的一部份。</p>
<p>以數列 2, 5, 3, 1, 4 為例，2 能與 5 或 3 組成遞增子數列，但該怎麼判斷要納入何者，以組成最長的遞增子數列？又或在數列 3, 5, 1, 2, 4 的案例中，該依據什麼資訊來決定放棄包含 3, 5 的子數列，而轉為建立新的子數列 1, 2, 4？</p>
<p>綜上所述，可以將讓我們左右為難的因素歸納如下，</p>
<ol>
<li>當前數字大於先前數字時，不確定要忽略它還是將其延伸至既有的遞增子數列。</li>
<li>當前數字小於先前數字時，不確定要忽略它還是以它為起點建立新的遞增子數列。</li>
</ol>
<p>為了解決這問題，可以使用當前數列的最長遞增子數列長度為依據，來衡量納入當前數字和建立新數列的效益，假如行動能增加遞增子數列的長度則為之。</p>
<p>由於每次檢查都可能推翻先前的答案，所以要比對整個數列後才能得知最終結果。以數列 3, 5, 1, 2, 4 為例，由左至右檢查數字來構築最長遞增子數列：</p>
<table>
<thead>
<tr>
<th>檢查數字</th>
<th>當前最長遞增子數列</th>
<th>遞增數列長度</th>
<th>判斷</th>
<th>行為</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>[3]</td>
<td>1</td>
<td>起始數字</td>
<td>納入當前數字</td>
</tr>
<tr>
<td>5</td>
<td>[3, 5]</td>
<td>2</td>
<td>5 &gt; 3，延長遞增數列</td>
<td>納入當前數字</td>
</tr>
<tr>
<td>1</td>
<td>[3, 5]</td>
<td>2</td>
<td>1 &lt; 5，不能延長現有遞增數列</td>
<td>忽略當前數字</td>
</tr>
<tr>
<td>2</td>
<td>[3, 5], [1, 2]</td>
<td>2</td>
<td>2 &gt; 1，形成新的遞增數列，與現有數列等長</td>
<td>建立當前數列</td>
</tr>
<tr>
<td>4</td>
<td>[1, 2, 4]</td>
<td>3</td>
<td>4 &gt; 2，延長新建立的遞增數列，長度大於 [3, 5] 與 [1, 2]</td>
<td>納入當前數字</td>
</tr>
</tbody></table>
<p>為了實現這套算法，需要紀錄以下資訊</p>
<ul>
<li><code>lis_len</code>：紀錄截至當前數列位置，最長遞增子數列的長度，用於衡量是否要納入新數字或建立新數列。</li>
<li><code>prev</code>：該數字在遞增子數列的前一項的位置，用於追蹤遞增子數列的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis_len = [<span class="number">1</span>] * <span class="built_in">len</span>(l)    <span class="comment"># 因為每個數字自成數列，所以在開始計算前，遞增子數列的長度至少為 1。</span></span><br><span class="line">prev = [-<span class="number">1</span>] * <span class="built_in">len</span>(l)      <span class="comment"># 在開始計算前，還沒有遞增子數列的位置資訊，所以預設為 -1。</span></span><br></pre></td></tr></table></figure>

<p>假設現在檢查第 i 個數字，那麼我們需要把它與數列之前所有數字（<code>l[j]</code>, i &gt; j）比較，才能涵蓋到所有可能性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[j] <span class="keyword">and</span> lis_len[j] + <span class="number">1</span> &gt; lis_len[i]:</span><br><span class="line">            lis_len[i] = lis_len[j] + <span class="number">1</span></span><br><span class="line">            prev[i] = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>簡言之，在當前數字大於先前數字時（<code>l[i] &gt; l[j]</code>），有兩種可能的行動：</p>
<ul>
<li>將當前數字 <code>l[i]</code> 納入以 <code>l[j]</code> 結尾的遞增子數列，形成長度為 <code>lis_len[j] + 1</code> 的遞增子數列。</li>
<li>忽略先前的數字，不更動 <code>l[i]</code> 所屬的遞增子數列，讓長度維持 <code>lis_len[i]</code></li>
</ul>
<p>為了找到最長的遞增子數列，應該選擇能增加子數列長度的行動。換句話說，若 <code>lis_len[j] + 1 &gt; lis_len[i]</code>，那麼就該把 <code>l[i]</code> 納入以 <code>l[j]</code> 結尾的遞增子數列，並且更新 <code>lis_len[i] = lis_len[j] + 1</code>。</p>
<p>與此同時，也透過 <code>prev</code> 紀錄當前數字 <code>l[i]</code> 在遞增子數列的前一項的位置 <code>prev[i] = j</code>，以利在檢查全部數字之後，從輸入的數列重建出最長的遞增子數列。</p>
<p>透過這樣的比較，可以確保 <code>lis_len</code> 每一項都記錄了截至當前位置能獲得的最常遞增子數列長度。因此，<code>lis_len</code> 的最大值便是整個數列的最長遞增子數列長度；該值在 <code>lis_len</code> 的位置，也對應到遞增子數列最後一項的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_pos = <span class="built_in">max</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(l)), key=<span class="keyword">lambda</span> x: lis_len[x]) </span><br></pre></td></tr></table></figure>

<p>由於prev陣列記錄了當前位置的數字在最長遞增子數列中前一項的索引位置,因此我們需要依序讀取prev中的值l[prev[i]],並將讀取出的數列反轉,才能獲得正確的最長遞增子數列順序。</p>
<p>由於 <code>prev</code> 記錄了當前位置的數字在最長遞增子數列中前一項的位置，所以回溯 <code>prev</code> 得到的數列順序與正確結果相反。仍需將讀取出的數列反轉，才能得到最長遞增子數列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = []</span><br><span class="line"><span class="keyword">while</span> final_pos != -<span class="number">1</span>:</span><br><span class="line">    output.append(l[final_pos])</span><br><span class="line">    final_pos = prev[final_pos]</span><br><span class="line"><span class="keyword">return</span> output[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>完整的功能實現如下，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lgis</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Longest Increasing Subsequence</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lis_len = [<span class="number">1</span>] * <span class="built_in">len</span>(l)</span><br><span class="line">    prev = [-<span class="number">1</span>] * <span class="built_in">len</span>(l)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(l)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> l[i] &gt; l[j] <span class="keyword">and</span> lis_len[j] + <span class="number">1</span> &gt; lis_len[i]:</span><br><span class="line">                lis_len[i] = lis_len[j] + <span class="number">1</span></span><br><span class="line">                prev[i] = j</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    final_pos = <span class="built_in">max</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(l)), key=<span class="keyword">lambda</span> x: lis_len[x]) </span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">while</span> final_pos != -<span class="number">1</span>:</span><br><span class="line">        output.append(l[final_pos])</span><br><span class="line">        final_pos = prev[final_pos]</span><br><span class="line">    <span class="keyword">return</span> output[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>只要將數列倒序輸入這個副程式，再反轉回傳結果，即可獲得最長遞減子數列，因此不用額外寫一個專門的副程式。由於題目提供的輸入為純文字檔，所以在執行程式前要記得將文字轉換為整數，並在輸出答案時再將整數轉換回文字以利後續排版。若省略型態轉換的步驟，則程式會依照字母排序，結果自然會與預期有所出入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rosalind_lgis</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        nums = [ <span class="built_in">int</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> f.readlines()[<span class="number">1</span>].strip().split() ]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([ <span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> lgis(nums) ]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([ <span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> lgis(nums[::-<span class="number">1</span>])[::-<span class="number">1</span>] ]))</span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>這道題的解法是動態規劃的案例。對我來說，最困難的不是熟悉動態規劃的概念，而是判斷適用動態規劃的情境，還有選擇合適的資訊存儲和判斷式。雖然與資訊科學無關（但跟生物有點關係），練習題目時，一直想起高中生物老師耳提面命的話，</p>
<blockquote>
<p>蓋棺才能論定</p>
</blockquote>
<p>每個人多少有想追求的目標與想累積的經歷，當中免不了要面對兩難的人生抉擇：接受新的職位，還是待下去？繼續打拼，還是止損停利？與他人合作，還是獨行江湖？即使擁有預知能力，可以判斷當下決策帶來的影響，也很難保證長期而言，會帶來最高的效益。</p>
<p>於是，我們也只能依照當下的條件，選擇最契合個人方向與渴望的行動，直到人生告一段落再也沒有任何可能性的時候，才有機會判斷哪些舉動與決策對於當初訂立的目標最有幫助。只是知道了又如何？雖然其他人可以從這些經驗得到啟發，可是當事人也沒機會用到自己一生濃縮的最佳解。</p>
<p>何況每個階段的追求也可能大相逕庭，處心積慮規劃了老半天，才在某個陽光明媚的早晨發現，自己渴望 B 而不是 A 的情況應該也不少見。</p>
<p>因此，當初生物老師在聯考後第一堂課不檢討考卷，而花了老半天講些莫名其妙的話的時候，可能不是在勉勵我們「別因挫折而氣餒，能否達成目標還說不定呢！」（對，我們班上很多人沒考好）。他也許是期望我們就用力活著，去體驗挫敗、毫無意義、徒勞無功之類說不上是好是壞的情感，不用煩惱纏繞腦中的時程、途徑、機會、指標、最佳化等有的沒的東西。</p>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>解開生命之謎：運用量子生物學，揭開生命起源與真相的前衛科學</title>
    <url>/mcfadden-and-ai-khalili-2016-life-on-the-edge/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我覺得英文書名（life on the edge）比中文書名更能反映作者的生物觀點。無機物和生命體在肉眼可見的範圍皆遵循牛頓力學，但其差異在於部分粒子的變動能否影響整體的行為。無機物的特性（熱漲冷縮、結晶、……）源於數量龐大的粒子分攤掉個別粒子的隨機特性，因此個別粒子無法影響整體。</p>
<p>但是生命卻可以營造合宜環境，隔離或駕馭不規則擾動，保持個別粒子的特性，進而擴增到整個生命體驅動大大小小的反應，而這種特性可以用量子力學描述。換句話說，生命是在量子力學或古典力學支配的兩種秩序中間的微妙平衡，死亡意味著這平衡被打破，喪失微觀秩序和巨觀秩序的連結。</p>
<span id="more"></span>

<p>薛丁格在《生命是什麼》中提及基因包含的原子數量不足以用熱力學原則（秩序源於大量不規則行為的平均）說明其遺傳精確性，因此得援用量子力學解釋。繼承此信念的物理學家在生物體內找尋能應用量子力學的場合，因為量子效應僅出現在微觀尺度，又容易受細胞內隨機運動的粒子影響而失效，所以這類反應系統應該只涉及數目少、質量小的粒子，而且能藉由孤立空間或其他方法排除干擾。此外，反應系統需在維繫生命運作的關鍵位置上維持平衡，使微觀層次的變動得牽動巨觀層次。</p>
<p>此書前半部討論的酵素活性位、植物光系統、嗅覺受器以及磁導航器官皆屬此例，它們是維持生命的重要反應，又僅涉及電子或質子等小粒子轉移。作者用大量篇幅回顧這些領域的研究成果，接著點出傳統理論的缺陷，再舉出量子效應在其中扮演重要角色的證據，最後用比喻的方式引介量子生物學詮釋，幫助讀者理解抽象概念。</p>
<p>為了呼應其生物觀點，作者在後半部將量子理論應用到生物演化、大腦意識和生命起源等議題上，試圖將之推廣為為生命運作的基石。不過相較於前半段內容有較多實驗和文獻支持，這部份把量子理論套用在巨觀階層的種種模型仍屬推測。</p>
<p>雖然含有大量物理術語，可是畢竟這是介紹如何應用量子力學解釋生物現象的科普作品，不是量子物理課本。即使沒有讀通（但可了解作者嘗試讓我們更容易理解的努力），也能評估這樣的應用有何優點和限制，並且留意到一些值得思考的問題：</p>
<ul>
<li>書中提到的是經實驗佐證的理論還是大膽的猜測？</li>
<li>這些有證據的理論是挑戰了傳統學說，還是其解釋含糊的細節？</li>
<li>是生物體依賴量子效應，還是量子效應出現在生物體中？</li>
<li>微觀尺度的量子效應是否影響巨觀層次？</li>
<li>量子效應是反應的先決條件，還是從眾多選擇演化而來的結果？</li>
</ul>
<p>生命起源相關的議題集中在第一、二、九和十章，當中介紹的生命起源機制奠基於RNA世界說，只是傳統理論難以解釋該如何從有機分子中產生自我複製體，所以想像了一個能利用量子效應同時展現各種結構的「原酶」，能比化學重組更有效率地測試可能結構。當某個結構出現自我複製功能時，原酶就會喪失量子效應，維持穩定並持續複製下去。然而傳統理論的挫敗無法證明這個理論是對的，而且這想法只停留在模型階段還沒有任何證據支持，因此應謹慎看待。</p>
<p>作者在最後對建造人工細胞的提議類似《再創世紀》裡面提到的方法，沒有推翻以往研究者的成果：湊齊已知生命需要的功能元件、酵素和分子，安裝在脂肪隔間裡。不過強調要考慮量子效應，否則人工生命體沒辦法運作。</p>
<p>題外話：簡中版的書名叫《神秘的量子生命》，乍看之下讓人聯想到劉慈欣小說《球狀閃電》裡的量子幽魂，一眼之下還以為是什麼靈修著作，和正體版一樣都沒有凸顯此書前半部嚴謹的敘述，反而把重點放在仍有許多討論空間的後半部，還過度延伸些作者一直澄清不該和科學混淆的靈魂、哲學、神學概念，這點實在讓人感到困惑。</p>
]]></content>
      <tags>
        <tag>what is life</tag>
      </tags>
  </entry>
  <entry>
    <title>夏子的冒險</title>
    <url>/mishima-1951-natsukos-adventure/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>二十歲的松浦夏子是個言出必行的女孩，她有著一旦下定決心便不肯輕言放棄的頑固個性，七歲那年，她受夠了菠菜，她的筷子再也不曾沾過這種蔬菜；等到十五歲時，聽聞他人評論紅色不適合她，夏子便立誓不再穿紅色系的衣服，任誰來勸說也無法動搖她的決心。</p>
<p>（三島由紀夫（1951），夏子的冒險。）</p>
<span id="more"></span>

<p>夏子有張典型的南方人的臉孔——烏黑的頭髮、飽滿的雙唇、挺立的鼻樑、慵懶而性感的眼神、剽悍而狂熱的氣質。儘管夏子身邊不乏追求者，她卻對那些汲汲營營於追逐金錢地位的都市青年感到乏味。她像觀察昆蟲般審視每個男人，將他們分門別類：這個只顧著怎麼爬上更高的職位，那個對教授、處長等頭銜著迷；還有些人以為只要開著跑車和送上禮物就能博得她的歡心。</p>
<p>上班族普遍乏味無趣，藝術家看似與眾不同卻也俗不可耐、少爺郎態度窩囊又過於天真。雖然這些男人的職業、背景、外表與人格各有不同，他們卻無一例外地缺乏強烈的熱情和迷人的神采。有次，一位名叫阿誠的青年端著一組房屋模型，向夏子描述著如果他們結婚成家，往後的日子該會有多少憧憬。</p>
<p>然而，他所幻想的正是夏子最唾棄的人生，被判處名為「家庭」的有期徒刑，關押在由玫瑰花、瓦屋頂和紅磚門柱所築起的囹圄之中，重複如拷問般無聊而制式的家常對話三十年，直到對磁磚的裂痕和天花板的木紋皆瞭若指掌。</p>
<p>因此，儘管夏子熟稔吊人胃口的技巧，也經常對追求她的男性予以無關痛癢的憐憫，卻從沒有將他們放在心上，總是無情地拒絕眾人的追求。她堅信無論跟隨哪個男人走，‧最終的下場無非淪為獨自在家打理家務的黃臉婆，或是在酒宴上陪笑的交際花。兩種命運在她眼中都一樣乏味得無藥可救。</p>
<blockquote>
<p>唉，不管跟誰走，都不可能為愛賭上性命或是冒著生命危險。男人開口閉口總在抱怨時代糟糕、社會糟糕，卻沒發現最糟糕的其實是自己的眼中毫無熱情……</p>
</blockquote>
<p>就這樣，與其把自己獻給男人，不如把生命獻給神。於是，她在一日早晨向家人宣布，她打算進修道院。夏子早已對修道院與修女的故事耳熟能詳。函館的特拉普修道院的管教嚴謹、紀律分明，修女們必須穿著層次有序的外套、聖衣與胸圍，生活的色彩只剩下黑色與白色。在那裡，她那媚人的肉體遲早會消散，只留下純淨的靈魂，日復一日地隨鐘聲起床禮拜、祝禱、彌撒。對夏子而言，再也沒有什麼比在修道院內度過單調無聊的一輩子更值得挑戰、更無路可退、更令人膽怯顫慄的體驗了。</p>
<p>得知這消息，她的雙親、姑姑與祖母自然是大力反對，尤其是她的父親更是百思不解，從小便不情願做禮拜的夏子為什麼突然想要進修道院，還揚言自殺威脅家人不得阻撓她。深知夏子執拗性格的家人知道說再多話也是徒勞，反而改變想法，或許修道院的苦行能讓這任性的孩子學到一些教訓，於是轉而支持夏子的決定。</p>
<p>儘管抱著讓孩子見見世面的想法，但放不下心的母親、祖母和姑姑還是決定帶著大包小包行李，陪同夏子宜路前往函館近郊的修道院。送行的人群不勝其數，喧嘩聲迴響在月台，引來其他旅客側目。夏子對此並不在意，因為原先對熱情絕望的她，在送行隊伍的最末端，留意到一名拎著行李箱扛著獵槍的青年，他那雙熱絡地綻放光芒的雙眼，正目瞪口呆地望著踏上火車台階的她。那雙眼牢牢烙印在夏子心中，伴她進入夢鄉，讓她面紅耳赤、動心不已……</p>
<blockquote>
<p>夏子早上喜歡躺在床上，把枕邊的小鏡子拿到臉前，和自己進行沒營養的對話。<br>「妳已經醒了？」鏡中的她說。<br>「醒了。」<br>「今天一定會有什麼好事發生喔。」<br>「是嗎，真令人期待。是什麼事呢？」<br>「不能告訴妳。」」<br>「那我們晚上睡覺前再見吧。」<br>晚上，在梳妝臺前，<br>「妳背叛了我。什麼好事也沒發生。」<br>「ㄚ這個青年如何？」<br>「那種笨蛋完全不行。」<br>「可是如果愛上那個人，妳也能得到幸福。」</p>
</blockquote>
<p>之後，夏子在轉乘的渡輪上閒晃時，又撞見月台上的青年。這次，她仔細打量著他的五官，雖然他那雙深邃的雙眼看似在眺望海面，但實際上是聚焦在一個更遙遠、沉重而龐大的目標。他眼中燃燒著野性的熱情與非比尋常的堅定意志，正是熱情的證明。</p>
<p>看著那名青年，夏子不禁感慨，直到她即將離開俗世的最後一天，才終於見到自己嚮往已久的目光。儘管她已下定決心，內心深處還是渴望那名青年能把她從無趣的日常生活中拯救出來。就在這時，一陣海風吹過，把夏子手中的扇子吹過欄杆，落入波濤之中。那名青年全程目睹了整個經過，試圖伸手去撿，卻徒勞無功。</p>
<p>「我叫井田毅。」他說，除此之外，他也知道那把扇子是夏子準備加入修道院的餞別禮物，過了今天之後，他們就再也沒機會碰面了。於是，毅邀請夏子在函館市區見面，一起度過夏子在俗世的最後一天。夏子瞞著家人溜出旅館，和毅從市內的旅社漫步到函館山，沿路經過綠意盎然的神社，穿過蒼鬱樹林，兩人邊散步邊談天。在這一路上，夏子也終於知道毅扛著獵槍隻身來到北海道的原因：他眼中燒著的熾熱火光是被復仇給點燃，而他要尋求的對象，是一頭兇殘的食人熊。</p>
<p>毅自小追隨父親打獵，在父親因腦溢血過世之後，他為了排遣喪父之痛，獨自一人揹著獵槍來到北海道旅行。他在愛奴人的部落寄宿時，結識了十藏一家人，以及十藏美麗的養女秋子。在愛奴部落的那段日子裡，毅聽著十藏訴說他們獵捕熊的冒險故事，也得知秋子的身世——秋子是一名棄嬰，她的雙親在遺棄她不久便遇難身亡。毅與秋子在這段期間日漸親密，兩人相約下次見面時就要結為連理。不料，毅才回到東京便收到駭人的消息：秋子和她的姊妹們上山採藥時遭食人熊襲擊，秋子逃生不及最終被殘忍分屍而死。</p>
<p>部落挑選了十二名資深的獵人展開獵捕，卻毫無斬獲。備受打擊的毅努力工作累積長假，一聽到北海道某座牧場被熊襲擊的傳聞，他立刻向公司請假前往北海道，他早已下定決心，無論如何都要為秋子報仇。聽完毅這番不幸的經歷，夏子深深著迷於毅那強烈而純正的動機，於是打定主意要與他同行。她急忙回到旅館，趁著親人洗澡時偷溜出門，僅留下一張字條說明自己的去向，卻隱瞞了出走的理由。</p>
<blockquote>
<p>「我果然沒有看走眼。」<br>她暗想。此人可以理直氣壯做到世間認為最無意義的事情。他可以獻身於世人最瞧不起的感情。</p>
</blockquote>
<p>儘管夏子提出如此大膽的要求，毅還是不敢妄想一名素不相識的少女願意參與自己的復仇行動。因此，他雖然與夏子約定九點出發，卻在八點半就提早離開了。不過，夏子早已看透毅的的想法，事先打聽到毅的去向。在那班夜車的車廂裡，毅因為寒冷直打哆嗦，他拉起領子縮著脖子防寒的同時，也落寞地看著對面的空位低聲自語，似乎想驅趕腦中少女的身影。就在列車即將啟程之際，一聲溫柔的嗓音打斷毅的沉思，「這個位子有人坐嗎？」。毅抬起頭，夏子就站在他面前。</p>
<p>在札幌，兩人與毅在當地報社工作的朋友野口會合。此時毅仍想獨自前往，於是請野口幫忙牽制夏子，好讓自己能趁著她發電報報平安的空檔溜走。不料，夏子再次識破毅的計倆，她深知毅遲早會回頭找野口商議獵熊計畫，所以硬是纏在野口身邊不放，還要求他陪著自己在札幌市區閒晃、看電影、參觀植物園、漫步在白楊林道等。</p>
<p>夏子這番舉動反而讓野口對她產生迷戀之情，於是將毅想支開夏子的所有計畫全盤托出。得知確切消息的夏子難耐心中的喜悅，在野口家靜候毅上門。毅一回來便撞見和野口待在一起的夏子。從毅慍怒的表情，夏子察覺他的一絲醋意，這讓她喜不自勝。於是主動將事發經過和毅解釋清楚，才化解了他心中的疑慮。在百般無奈之下，毅只得帶上夏子一同前往據說遭熊襲擊的白老牧場。</p>
<p>然而，當他們抵達目的地時，已經晚了一步。牧場草地被鮮血染紅，馬匹的屍首與骨骸散落在被踐踏過的土塊、淤泥與碎裂的柵欄之間。從地上的四趾足印看來，兇手正是那頭殺害秋子的食人熊。夏子盯著毅滿懷怒意的眼睛，她明白在那視線裡絲毫容不下自己的存在。</p>
<p>當晚，夏子和毅於牧工小屋共寢，在冒險的緊張氛圍與一次次不經意的親密接觸下，讓毅對夏子產生了強烈的慾望，不過夏子斷然拒絕了毅的求愛。對她而言，最著迷的莫過於毅那副只為復仇而存在的模樣，她暗自祈禱在殺死那頭熊之前，毅能保持這樣的生存態度，不要因她而動搖與分心。</p>
<p>於此同時，待在旅館的松浦一家看完夏子留下的字條後心急如焚，要報警好像操之過急，要親自尋人也豪無線索可循。收到夏子派來的電報後，她們原本打算趕赴札幌接回夏子，但細想後卻感到進退兩難。若離開旅館，他們就收不到夏子下一次的消息；可若繼續守在這，又難以將她接回，天知道這任性的孩子會在外頭遭遇哪些麻煩。</p>
<blockquote>
<p>萬事和稀泥的姑姑，半帶哭腔地吸著鼻涕說，「我一個人留下來就是了。小夏如果不回來，我就代替她進修道院贖罪。從此永遠都不出來。以後妳們想起我時，就從二樓的陽臺眺望我所在的修道院那片天空吧。」</p>
</blockquote>
<p>情急之下，她們心生一計，先用重金委託旅館經理代為接收夏子的電報，三人立刻起身趕赴札幌。儘管她們的行動慢了一步，卻透過關係得到札幌日報總編輯的協助。一行人決定就地成立搜尋夏子的總部，一五一十地向向總編輯解釋夏子逃跑的前因後果。</p>
<p>正巧野口也在這時回到報社，他自告奮勇地向松浦一家和總編輯編說明事發的經過。聽聞夏子竟然為了一名男子而私奔，讓她們感到十分擔憂與錯愕。即使野口再三向她們保證男子的為人，也無法化解他們的不安與疑慮。在一番激烈的討論後，她們竟做出荒謬的決定，野口有義務出面把夏子帶回來。畢竟，如果不是因為野口對夏子的私情，夏子怎麼會有機會從札幌逃走呢？</p>
<p>在白老的牧場，野口打聽到了夏子的下落。當他前往鄰近的 Y 牧場時，竟然碰見了獨自一人的夏子。她向野口吐露想回家的念頭，野口才知道原來這段期間曾發生一段令夏子不悅的插曲。</p>
<p>在前往 Y 牧場的途中，夏子與毅認識了牧場主人的女兒不二子。不二子不但樣貌出眾，更有一股與外貌不符的野性和不可思議的氣質。在牧場寄宿的幾天哩，不二子不僅主動幫毅縫補衣服，還曾摸著他的臉說要幫忙刮鬍子，種種舉動親密得有些反常。夏子既不擅長料理，也不曉得如何做針線活，眼見不二子取代自己替毅打理生活起居，她不禁感到失落和不是滋味。更令夏子惴慄不安的是，她在不二子身上，隱隱約約看到她想像中秋子的模樣。</p>
<blockquote>
<p>那個女孩名叫不二子。第一次碰面，正好就是在今天野口在河岸遇到抓魚少年的那附近。當時兩人彎過河岸一角，就發現打赤腳的女孩坐在河中岩石上。<br>女孩洗完頭髮正在晾乾。頭髮已半乾，披散在肩上。河水非常冷。於是女孩把洋裝的裙襬撩起，赤足沒有浸在水中，而是放在距離她坐的岩石約有一尺遠布滿清台的石頭上。樹梢灑落的陽光照在濡濕發亮的潔白裸足上，彷彿穿了蕾絲襪子。而且這個不可思議的女孩，正在吟唱莫名其妙的歌。</p>
</blockquote>
<p>這是夏子有生以來第一次清晰地意識到自己所欠缺的東西。跟著野口回到牧場後，夏子當著眾人的面，賭氣地對毅說想回家，還咕噥說何不讓不二子代替自己陪著毅去獵捕那頭獵熊也未嘗不可。說著說著，夏子忍不住落下了委屈的眼淚。見狀夏子突如其來的情緒潰堤，毅和野口一時之間手足無措。此時，不識趣的不二子闖了進來，她擦拭著夏子的眼淚還開起了玩笑。夏子瞪著不二子質問她是否已經愛上了毅。</p>
<p>不二子聽完夏子的質問不禁笑了起來，雖然她自己或許沒能拿捏好與毅之間的關係距離，可是與其跟著不怎麼喜歡的對象去獵捕野獸，她反而更有興趣去幫助站在一旁備感無奈的野口。畢竟，如果夏子真的執意跟著毅，那麼任務失敗的野口在回到報社後，不免要被痛罵一頓還可能丟失飯碗。</p>
<p>不久，從報社派來的電報得知，那頭殘暴的四趾熊在支笏湖現身，還造成一人重傷。毅研判那頭熊已回到根據地，短時間內應該不會再大範圍移動了。為了把握這個良機，眾人再次啟程，一行人前往位於千歲的醫院探望那名遇襲的傷患。</p>
<p>由於千歲是通往札幌的中繼站，所以不二子和野口也一同前往。從傷患的口述，他們得知四趾熊的活動範圍，毅打算請求支笏湖周圍的愛奴部落協助，也委託野口到札幌向當地獵友會尋求支援。於是，毅和夏子一陸深入部落，而不二子和野口則與回到札幌。</p>
<p>野口與不二子回到報社後，總編輯眼看夏子沒跟著回來，不知道如何向她的親屬交代，隨即對著野口大罵一頓。所幸不二子替野口說情，才讓野口免於被開除的下場。隨後，兩人也向松浦一家人解釋，她們的寶貝閨女早已深深愛上了那名青年。雖然一開始她們對於夏子的出逃感到惶恐與不安，可是在聽了毅復仇的動機以後，她們也終於理解夏子迷戀那名青年的理由。是以，與其因為阻止小倆口造成雙方的遺憾，松浦一家人覺得不如盡全力促成他們的計畫，這樣才能盡早讓夏子脫離險境。</p>
<p>於是，松浦一家決定拜訪札幌獵友會的分會長，說服他協助獵捕那頭四趾熊。然而，分會長回絕了她們的邀請。他認為，打獵是動物與人彼此將對方視為獵物的廝殺，直到一方的心跳停止才肯罷休。他說，毅想要追捕的，不是有血有肉的生命，而是無形的惡意；他想了結的，不是野獸搏動的心臟，而是自己仇怨的內心。</p>
<p>不過隨著關於那頭熊在支笏湖的古太內部落肆虐的消息傳來，分會長對於這頭獵物的興趣也越來越深，最終，他興奮地向松浦一家宣布：「決定了。我去，我去一趟。」</p>
<p>另一方面，毅和夏子則搭乘末班車前往支笏湖的古太內部落尋求援助，由於帶著女人，他們處處碰壁，無人願意伸出援手。經歷一番狩獵的失利和人情的冷暖，夏子不僅感到身心俱疲，還逐漸湧起失望的情緒。追捕食人熊已不復當初的新鮮感，取而代之的是更多的等待與煎熬。</p>
<p>兩人在古太內部落一籌莫展，只好回到蘭越拜訪秋子的父親十藏。夏子明白，既然毅帶著她同行，大概也不想再重返傷心地，讓夏子跟著他一起困在傷痛的回憶之中。儘管夏子記得毅曾說「哪怕只剩我一個人，也要殺了那頭熊。」恐怕只是誇誇其談，但是當毅不得不向人求助的時候，夏子仍私心懇盼他能再固執點，堅持那股獨自復仇的決心。</p>
<p>十藏領著上門拜訪的夏子與毅到佛堂前，讓他們膜拜秋子的遺像。夏子覺得秋子的容貌意外平凡，絲毫沒有像見到不二子那樣帶給她十足的不安感。不過看著怒視秋子疑照的毅，夏子後知後覺地明白，驅使著毅那股執著的，不單單是那頭殘暴的食人熊，還有這名平凡女孩的死亡，和永遠挽不回的青春回憶。</p>
<p>這讓她感到五味雜陳。夜裡，她悄聲對躺在一的毅力說：</p>
<blockquote>
<p>「現在你的腦中只想著秋子。我可不要當死人的替身。我是夏子，不是秋子。」……夏子像要諄諄勸諭弟弟似的，聲音變得溫柔沉靜。<br>「你知道嗎，在我們的初夜，我可沒辦法當你舊情人的替身喔。」</p>
</blockquote>
<p>翌日，十藏親自前往古太內部落，想說服他們加入獵熊的行動，卻仍一無所獲。他回來後對毅埋怨部落裡的人毫無鬥志，連自家的牲畜被熊擄走也不敢起身反抗。正當一切一籌莫展，他們倆下定決心要獨自與食人熊搏鬥時，意料外的客人駕著車來訪。除了答應幫忙的獵友會分會長，就連野口，還有夏子的媽媽、祖母和姑姑一行人居然都齊聚一堂。一問之下才得知，野口承諾要準備一則獵殺熊的報導，而松浦一家人則放不下心，非得親自見到迷倒夏子的男人是什麼德性。</p>
<p>在分會長的周旋下，總算說服了古太內部落的年輕人組成獵捕小組，他們推測那殘暴的四趾熊仍徘徊在部落附近，於是決定放出羊群作為誘餌，分隊長與十藏擔任前哨，負責通報食人熊的動向，其餘年輕人在村子口警戒，而夏子和毅則埋伏在羊舍屋頂，打算趁那頭熊被羊群吸引時，給予牠致命一擊。至於松浦一家和村長夫人則藏匿在村長家，以免遭受危險。</p>
<p>因為夏子能在最近距離看著毅專注的眼神，所以她感到前所未有的幸福。然而這種感受沒持續太久，他們便從羊隻的騷動得知那頭熊已闖入村子，並逐漸逼近松浦一家的藏身處。眼見四趾熊撞斷木柱闖進屋內，夏子失了方寸，抓著毅的臂膀哀求他出手相救。但毅早有定見，非到時機成熟不會行動。夏子自知此時沒有她插手的餘地，打算獨自前去救母親。</p>
<blockquote>
<p>「現在不准下去。」<br>「可是！」<br>「太危險了。」<br>「可是我媽——」<br>「我說不准去就是不准去！」</p>
</blockquote>
<p>毅揮拳打暈夏子，阻止她魯莽行事，同時命令其他埋伏的青年保持耐性，直到熊出現在射程範圍才准攻擊。他們盯著熊從屋內現身，沿著樹林走向被繩索綑綁的羊隻。牠扯斷繩索，扛起一隻羊，緩步隱沒在樹林，正好進入毅的視野，隨著毅的槍擊，所有人也同時開火。毅小心翼翼上前確認那頭熊已經斷氣，才向大家宣布那頭食人熊已被擊殺。</p>
<p>聽到槍響，分會長、十藏、野口還有剛剛躲藏起來的親屬都聚集到熊屍周圍。隨後部落人們手持火把圍繞著獵熊小組，一圈又一圈，畢竟他們從沒看過體格如此碩大的熊。屍檢時，分會長取出那顆致命的子彈，彷彿冥冥之中有安排，毅的那顆子彈正好穿過食人熊的心臟，造成致命的傷害。</p>
<p>終於報仇血恨的毅有些恍惚地站在熊屍旁，傳統獵人夢寐以求的頭銜與戰利品對他一點也沒有吸引力，他只想忘掉這一切，包含他兩年來對秋子的情思。當他向夏子吐露這想法時，這一刻成為他們兩人內心最親密的時光，不須祝福與稱許來點綴。</p>
<p>慶功宴之後，野口滿意地帶著「情侶獵熊獲得勝利榮冠」的新聞回到札幌，這則報導一砲而紅，讓他賺進大筆獎金。而夏子的家人在這場危機後，也認同毅作為女婿的資格。在眾人的祝福與送行下，夏子與毅乘著渡輪返回東京。因為睡不著，兩人來到當初相遇的甲板，望著朝陽從海面緩緩升起。</p>
<blockquote>
<p>「回到東京後，什麼時候結婚。」<br>毅把手搭在夏子的肩頭說。<br>「這個嘛，隨時都可以。」</p>
</blockquote>
<p>毅沒有因為夏子冷淡的回應而作罷，仍喋喋不休地說著回到東京的規劃。他懊惱著該怎麼弭補請假期間的工作耽誤，期盼有朝一日能赴美國工作，還為往後的開銷列了預算。畢竟，夏子也需要一套美麗的衣服，暫時沒有孩子也沒關係，他們倆人可以享受每周去看電影和跳舞等的消遣。等到他在職場上有所成就，他們遲早可以買台車、買棟房，「到時候，到時候……」</p>
<p>聽著就職、旅行、置產和裝潢等話題，夏子卻感到心寒，「曾經魅惑她的那雙眼去哪了呢？」她哀傷地看著毅自顧自地勾勒兩人未來的模樣，她覺得他身上某種東西似乎隨著食人熊一起死去了。再也受不了這廉價希望帶來的窒息感，「失陪一下」她離開毅回到大廳，在成排行李袋之間打轉。夏子的母親、祖母和姑姑看著夏子異常的舉動，問道：</p>
<blockquote>
<p>「妳在找什麼？」<br>「時刻表。……從青森開往函館的船是幾點出發？」</p>
</blockquote>
<p>「怎麼，你忘了什麼東西嗎？」</p>
<blockquote>
<p>她猛然轉身，用那種充滿個性、具有某種特徵的斷定口吻說，<br>「我還是決定進修道院。」<br>三人目瞪口呆，放下茶匙。唯有三個咖啡杯冒出的熱氣，在這神秘的沉默中，像青煙一樣冉冉上升……</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>不道德教育講座</title>
    <url>/mishima-1958-lectures-on-immoral-education/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>1958年，三島由紀夫在《明星週刊》連載不道德教育講座，針對當代日本的文化、事件與風俗，提出有違常人價值觀的看法，例如「應該盡量說謊」、「要打從心底瞧不起老師」、還倡議「千萬不要遵守諾言」。</p>
<p>據他所述，老掉牙的說教作品無趣又矯情，與其重述時下倡導的道德教育，不如談些大逆不道的誇張故事還來得有趣。畢竟，讀者在看了這些荒謬情節之後，沒有產生群起效法的念頭，反倒被激起高尚的品德也說不定。</p>
<p>坦白講，讀過三島由紀夫其他詞藻華美、情節扭曲的小說之後，很難想像這些專欄文章出自同一人之手。《不道德教育講座》裡頭雖然有些看法引人深思，但也充滿反串、強詞奪理、偏見和誇飾的論述，簡直就像是穿越回二十世紀中葉的 PTT 八卦版鄉民。</p>
<span id="more"></span>

<p>舉例來說，三島由紀夫在此書鼓勵讀者盡早擺脫處男，畢竟沒性經驗的男生滿腦子猥褻想法，根本純潔不起來。他也鼓吹喝湯時要發出聲響干擾別人，因為這些奇怪規範是出自於盲從的社會羊群，「傲然的孤郎無須起而效尤」。</p>
<p>在〈應該由文弱陰柔當道〉當中，他諷刺日本人表面崇尚陰柔氣質，骨子裡還是被陽剛氣概所吸引。文末說道自己現在練了一身肌肉，即使收到徵兵單也無所謂畏懼，但好家在他的年紀已經收不到兵單了。這是什麼「還好我退了」的發言啊？</p>
<p>另一篇〈偷盜的奇妙功效〉則批評那些貪圖物質利益、手段又拙劣的小偷根本在丟盜賊的臉，鼓勵大家即使作奸犯科也要有宏大目標與卓越手段。三島由紀夫還以身作則，講了一則他巧妙偷走陌生人昂貴鋼筆的小故事，最後在那邊靠北：「呵呵，你看到這篇文章，我也不會還給你喔！」</p>
<p>除了這些驚世駭俗的言論與觀點，這選集還可以看到表面上是要問卦或討論什麼嚴肅議題，結果只是三島由紀夫想要曬貓：</p>
<blockquote>
<p>我是個愛貓成癡的人。因為，貓這種傢伙實在有點自私又忘恩，還有大部分的貓都只是忘恩之徒，而不會像卑劣人類會恩將仇報。</p>
</blockquote>
<blockquote>
<p>我立刻聯想到，人類最應該像貓看齊。因為再沒有比貓更冷淡、更無情、更韌性，並且絕不任由人類擺弄的動物了！牠恐怕也是最不容易被催眠成功的動物吧。因此，我也想要模仿貓，盡量讓自己變得冷淡、薄情、麻木不仁、自主獨立……。而且，只在想吃魚的時候，才願意發出撒嬌的喵喵聲。</p>
</blockquote>
<blockquote>
<p>比如，有隻貓剛從廚房偷吃了一條魚，來到簷廊下曬太陽，接著若無其事地擦抹乾淨，就是「Who knows?」的最佳體現。</p>
</blockquote>
<p>此書選錄的文章裏頭，我最喜歡的是「應當打從心底瞧不起老師」、「應當追隨流行」和「肉體的無常」這三則對教育、流行和健身的討論。</p>
<h2 id="應當打從心底瞧不起老師"><a href="#應當打從心底瞧不起老師" class="headerlink" title="應當打從心底瞧不起老師"></a>應當打從心底瞧不起老師</h2><p>由於尊師重道的觀念以及教師與學生間年齡、地位與知識的落差，學生面對老師時，不免產生崇敬、害怕或依靠等感受。若這層關係僅止於知識的傳授也罷，可是某些教師的控制欲可能干預了學生的價值觀與人生抉擇，蔑視了個體決定自我前途的責任與權利。</p>
<p>老師在知識上未必全面，在情感上脫離青春期太遠，未必能設身處地體會學生的困擾。其次，決策的後果無論利弊都得由個人承受，老師作為局外人不須擔負選擇的重量，所作所為也不見得貼近學生的需求。因此，對於人生，老師的位置似乎不適合多做什麼，他們可以傳授知識和了解學生，但各自的人生還是得放手讓學生去面對。</p>
<p>而學生這方，也不能期待老師有能力或義務理解自己。畢竟，無論大人或小孩，各年齡層皆有各自的煩惱，都需要費很多心力來解決。因此，不只不該依賴老師，還要有超越老師的鬥志才行。不管老師表現出輕視的態度還是關愛的態度也好，都可以盡情睥睨他們，只要盡可能從課堂中撈取知識油水就夠了。至於其他奇奇怪怪的刁難或干涉，可以當作往後人生的預習，畢竟這些老師可能是那些惡質成年人當中最容易對付的。</p>
<h2 id="應當追隨流行"><a href="#應當追隨流行" class="headerlink" title="應當追隨流行"></a>應當追隨流行</h2><p>流行的事物往往被貼上膚淺、易逝和俗套等標籤，三島由紀夫在這篇討論了上流階層輕視流行的現象，並且指出流行的可貴正是這些「不去思考本質」的特性。誠然，流行的事物之所以能迅速普及，正是因為其通俗易懂而沒有深度；之所以短暫亦逝也是因為其輕佻膚淺。</p>
<p>然而，比起引發了區域衝突甚至世界大戰的各式意識形態，這些膚淺的文化反而保留了更多人類美好的回憶片段。流行的循環性也會讓它在短暫的生命以後，以全新的樣貌出現在人們的生活中，意外地延續流行的壽命。</p>
<h2 id="肉體的無常"><a href="#肉體的無常" class="headerlink" title="肉體的無常"></a>肉體的無常</h2><p>由於我自己也有在健身，所以很好奇三島由紀夫對健身的看法。三島由紀夫自小體格矮小且單薄，直到在三十歲後讀到健美雜誌了解到這項運動後才開始健身。從網路上可取得的寫真照看來，在那個營養和運動科學才逐漸發展，大眾健身尚不普及的年代，其實也算練得有模有樣了。</p>
<p>曾想像「如果自己強壯起來，那麼或許……」的人，在慘澹的街燈下走回家，看著自己透過店面玻璃映出的單薄身影時，難免會懷疑自己到底在幹嘛吧？肉體總有一天會衰老、練壯了可還長同一副臉、何況現在也沒練很壯、蛋白質好貴、吃掉的東西怎麼全都變成熱逸散在大氣中……之類的。</p>
<p>然而，這些懷疑不構成輕視自己肉體的理由。相反地，當你流著汗走回家時，應該要對自己更有自信一點，因為健壯體格短暫無常的特性，反映了人類這種生物荒謬的存在。我們只有一次人生，每分每秒每次呼吸都是絕無僅有，不管活得漂亮瀟灑還是醜陋掙扎，最終同樣要塵歸塵土歸土，隨宇宙熱寂而默然。</p>
<p>這點跟肌肉一樣。體格是與生俱來，有的人骨架好，有的人長肉快，但所有人都需要經過刻苦訓練與飲食自律才能練出健壯的體魄。沒有人能夠永遠維持精壯，每一次臥推和深蹲都是用力活在當下的證據，都是努力延長「現在」的嘗試。</p>
<p>因此，三島由紀夫才說「在現代社會裡，肌肉發達不過是可憐又滑稽的東西。可也因為如此，我才會對積極鍛鍊出強健的體魄不遺餘力。」</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以前是從楯之會的維基百科條目了解三島由紀夫的生平，在還沒讀過其作時，已對其人有一堆印象。直到最近被討論串的<a href="https://www.ptt.cc/bbs/Gossiping/M.1677326783.A.D04.html">留言</a>（「 20多年前看過《潮騷》，青春純愛故事，字裡行間聞得到海的味道」）打動，才開始接觸他的作品。</p>
<p>由於我是從三島由紀夫的娛樂小說和散文作品入門，所以有機會認識這位作家別於外人給定標籤的一面。雖然不是每本書都看得懂，至少這本書我是看得蠻開心的。像讀〈應當打從心底瞧不起老師〉的時候，會想要是早點讀到就好了；但也有像〈肉體的無常〉那樣親身經歷才能體會的感動。最後要坦白，我其實也抄了一些講話很靠北的段落，但那屬於適合自娛的陰暗笑點，就不放上來了 :)</p>
]]></content>
  </entry>
  <entry>
    <title>三島由紀夫書信教室</title>
    <url>/mishima-1968-yukio-mishima-letter-classroom/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這本書是由五個角色書信往來所構成的故事，他們分別是厭惡市儈作風的文藝青年炎丈流、故意寫英文情書來評價心儀對象的美艷寡婦冰真間子、收藏著五百條領帶和收養五隻貓的風流男士山鳶夫、對工作毫無熱誠只等著嫁人的粉領族空美津子，以及執著於奶油蛋糕和彩色電視機的丸虎一。</p>
<span id="more"></span>

<p>炎丈流與空美津子因通信來往而萌生情愫。眼見情侶倆關係日漸密切，暗戀炎丈流的空美津子找上損友山鳶夫，想寫封黑函來拆散這對情侶。不料，山鳶夫亦在彼此閒談與奚落的互動中，愛上了空美津子。於是基於一番妒意，暗中幫助炎丈流與空美津子，替他們向雙方的家長說情，促成這對情侶的婚事。</p>
<p>得知消息的空美津子，寫了封信大罵山鳶夫，還斷言要與之絕交。所幸，丸虎一在無意間勸和兩人，讓故事的結局兩對情侶皆成眷屬，而丸虎一也如願得到他想要的彩色電視和奶油蛋糕。</p>
<p>雖然作者對感情的見解有趣以及對損友關係的描述恰到好處，但這本書最大的看點還是丸虎一那充滿現代感的垃圾話，喜歡到我幾乎把他寫的每封信都抄了下來。</p>
<p>好比說，他因為借不到錢（向冰真間子）買彩色電視機又被對方揶揄一番，憤而威脅對方要到處宣傳她的學生英文很爛。</p>
<blockquote>
<p>要是不願意請客，我會在東京到處宣傳您英文補習班的每一個學生英文都很糟糕。</p>
</blockquote>
<p>又因看不到彩色節目，憂鬱纏身，寫了封信邀請冰真間子陪他殉情，只因對方老得無法作為戀愛與結婚對象：</p>
<blockquote>
<p>不光如此，我每看一個鐘頭節目，必定會吃掉一包奶油花生，也就是同時進行「看、寫、吃」這三件事，這樣一來，我相當於活了別人的三輩子。<br>不過，悲慘的現實卻是我只能觀看黑白節目，連一台彩色電視機都買不起。既然已經活了別人的三輩子，不如趁著青春年華好時光，在眾人的惋惜之下離開人——今晚忽然如此有感而發，倍覺空虛，於是選中了您陪我殉情。</p>
</blockquote>
<p>或是最終替朋友出氣的方式也令人拍案叫絕：</p>
<blockquote>
<p>最近收到一封冰真間子女式的信，信裡寫道「山鳶夫實在惹人厭，一想到他就讓人反胃！你遇到那個傢伙時，記得代我朝他吐口水」，可是這陣子沒機會見到您，又不好拖延真間子女士的交代，所以隨信附上一張沾有我口水的紙，請您把它放在臉上抹一抹。</p>
</blockquote>
<p>三島由紀夫說他們的通信內容「既可視為書信格式，也可當成寫作範本」。然而，當代人的情感生活往往比小說人物單純，我們觀念也相對開放，所以要用到這些信件的場合不多。諸如「力邀殉情的信」和「已非處子之身的坦白信」可能已充滿時代感。</p>
<p>不過，三島由紀夫在最後一章給讀者的信中，還是總結了寫信的要點：</p>
<blockquote>
<p>寫信時一定要先了解一個前提條件，那就是收信人根本不在乎寫信人的一切。這是最重要的關鍵。<br>一個洞悉世態者深知人們對其他人毫不在意，唯有攸關自身利害得失的時候才會產生興趣，儘管這是一種苦澀的人生哲學。<br>直到你深切體悟，世上的每一個人只顧朝著自私自利的目標邁進、除了極少數的例外幾乎不會在意其他人，這時你的文字才有躍然紙上的力量，能夠寫出撼動人心的書信。</p>
</blockquote>
<p>我覺得這道理無論哪個時代或哪種通訊媒介，只要人類仍是人類便依然適用。</p>
]]></content>
  </entry>
  <entry>
    <title>Vim｜嘗試修改 Vimium 來關閉網頁 pop-up</title>
    <url>/modify-vimium-to-label-and-close-pop-up/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>彈出視窗是以鍵盤瀏覽網頁的最大阻礙。這些視窗的內容不外乎會員邀請、推薦連結、蓋板廣告與網站公告等，是網站而定，通常沒辦法以 tab 來點擊，之前介紹的 Vimium 功能也沒辦法為這些視窗上的連結打標籤。由於彈出視窗並非廣告，所以下載 adblock 也無法阻擋之。所以往往只能乖乖移動滑鼠關閉之。</p>
<p>因為這些彈出視窗設計有別於html 內建的元素，所以有些更糟糕的案例是連關閉按鈕都沒有顯示在頁面上，強迫使用這點開網頁才能關閉之。</p>
<p>在得知 Vimium 點擊連結的方便之後，我嘗試修改 Vimium 的程式碼，讓他可以為原先沒辦法點擊的連結標註標籤</p>
<span id="more"></span>

<h1 id="想法與策略"><a href="#想法與策略" class="headerlink" title="想法與策略"></a>想法與策略</h1><p>Vimium 能為網頁中可點擊的元素標註標籤，讓用戶得以用這些標籤的快捷鍵點開連結，不用經手滑鼠或用tab 遍歷。其原理是透過html元素，辨識可能可點擊的元素，例如連結、按鈕等。</p>
<p>然而，網頁中仍能有自訂元素，這些元素的名稱和行為未必與 html 原生元素一致，所以 Vimium 只能嘗試搜索可能可點擊的元素名稱，例如 buttom 或是 link，間接推論這些元素可點擊。不過實際的網頁往往不會使用這麼直白的名稱，可能使用縮寫或是帶好來命名這些元素，導致 vimium 無法標註這些元素。</p>
<p>讀了<a href="https://ithelp.ithome.com.tw/articles/10091999">Vimium 介紹與支持 Plurk (噗浪)</a>之後，覺得最直觀的想法是 修改 Vimium 程式碼的判斷式，看能不能找到彈出視窗共同的特徵，例如名稱、類別或是辨識碼等，拓展 Vimium 能辨識的元素，讓程式也能夠為彈出視窗標記快捷鍵。</p>
<p>不過這篇文章距今已十年，Vimium 也經歷多次改版，所以可能要找一下 github page 找到辨識網頁元素的區域在何處。所幸在<a href="https://stackoverflow.com/questions/53918093/how-can-i-make-my-element-clickable-for-vimium">這篇文章</a>找到了一些參考。</p>
<p>我嘗試各大新聞網都失敗，只有知乎成功，因此以下會用知乎為例，說明要怎麼修改程式碼讓 Vimium 可以關閉彈出連結。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_before.png?raw=true" alt="Vimium 無法辨識知乎登入視窗的關閉符號"></p>
<h1 id="調查彈出視窗是否有共同的特徵"><a href="#調查彈出視窗是否有共同的特徵" class="headerlink" title="調查彈出視窗是否有共同的特徵"></a>調查彈出視窗是否有共同的特徵</h1><p>下一步是觀察彈出視窗的網頁元素的構建方式，歸納出彈出視窗的共通特徵，以便讓 Vimium 辨識。首先，在瀏覽器按 <code>F12</code> 開啟開發人員視窗來檢視網頁原始碼，接著於彈出視窗依序點擊右鍵和檢查，即可鎖定對應位置的網頁原始碼。</p>
<p>我檢查了幾個網站後發現，每個網頁的彈出視窗設計都不一樣，例如元素的組成、對應的滑鼠行為(e.g. hover or click)，乃至於元素的 class 與 id 也因網頁而異。這意味著，也許沒有共通的值可以辨識這些自訂元素，只能針對常用的網頁來做修改。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_check.png?raw=true"></p>
<h1 id="下載擴充套件程式碼"><a href="#下載擴充套件程式碼" class="headerlink" title="下載擴充套件程式碼"></a>下載擴充套件程式碼</h1><p>下載擴充套件的方式可參考<a href="https://stackoverflow.com/questions/16680682/how-to-modify-an-extension-from-the-chrome-web-store">此文</a></p>
<ol>
<li>安裝 <a href="https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin">Chrome extension source viewer</a></li>
<li>點開 Vimium 頁面</li>
<li>點擊 “Chrome extension source viewer”</li>
<li>點擊 “Download as zip”<br><img data-src="https://lh3.googleusercontent.com/dCvSGp9T3LZP6PLfzgxNpxlX5qxizpjKN8g9R3eNKTg98e4MfAEDc5IRVFGr5O4VtC4nq62HNKpGxkNaDLscK1VXLw=w640-h400-e365-rj-sc0x00ffffff" alt="於擴充套件頁面點擊 &quot;CRX&quot; 即可下載套件原始碼（圖：Chrome extension source viewer 頁面）"></li>
</ol>
<h1 id="修改程式碼並套用於瀏覽器"><a href="#修改程式碼並套用於瀏覽器" class="headerlink" title="修改程式碼並套用於瀏覽器"></a>修改程式碼並套用於瀏覽器</h1><p>解壓縮後，接著點開，在這段加入<br><a href="https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992">https://github.com/philc/vimium/blob/v1.67.4/content_scripts/link_hints.js#L987-L992</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isClickable &amp;&amp; className &amp;&amp; className.<span class="title function_">toLowerCase</span>().<span class="title function_">includes</span>(<span class="string">&quot;zdi&quot;</span>))</span><br><span class="line">  possibleFalsePositive = isClickable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>開啟 Chrome，點選工具列的擴充功能圖示</li>
<li>點選「管理擴充管理」</li>
<li>點選「載入未封裝項目」</li>
<li>重新整理頁面，查看是否順利修改</li>
</ol>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/modify-vimium-to-label-and-close-pop-up_after.png?raw=true" alt="修改 Vimium 的程式碼後，關閉視窗的符號被標上標籤了。"></p>
<h1 id="困難與限制"><a href="#困難與限制" class="headerlink" title="困難與限制"></a>困難與限制</h1><p>實作之後才發現，許多網站不是用 Html 既有物件來構建彈出視窗，而是自訂許多 class 與 id，再透過 Javascript 控制。這些自定義物件的行為由 Javascript 控制，每個網頁的命名、行為與能見度都不一樣，所以 Vimium 也無法一次搞定所有可能性。</p>
<p>換句話說，本文陳述的嘗試只適用於常用的網站，好比說常看的新聞網或社群論壇等，不能一勞永逸地克服所有彈出視窗。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>目前，彈出視窗仍是鍵盤瀏覽網頁的最大阻礙，原因是彈出是往往是自訂元素。，諸如 Vimium 等擴充套件也不易辨識多樣的自訂元素。鍵盤的可及性受限於網頁元素的設計共識，所以政府對於無障礙網頁設計才有相關的規範與建議吧。</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>MiTalk 2022：在講台上</title>
    <url>/mitalk-6-thu-2022/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>兩年前，我曾以聽眾的身分報名 MiTalk，如今總算有點結果可以參加口頭報告。趁著記憶猶新，我想紀錄此次工作坊的所見所得，並且借題敘述一些尚未獨立成篇的想法。</p>
<p>其中一個感悟是，以報告者的身分參加會議能增加聽講的敏感度和觀察面向。當聽眾時，關注的項目往往是相關研究或新奇題材。而經歷了準備報告的過程後，即使對講題不感興趣，也會留意講者的投影片設計、敘事結構、肢體語言和危機處理。</p>
<p>這些是準備報告的共同課題，所以每次聽講也能從多樣的示範中學習適合自己的解決辦法。</p>
<span id="more"></span>

<h2 id="談談口頭報告的緊張感"><a href="#談談口頭報告的緊張感" class="headerlink" title="談談口頭報告的緊張感"></a>談談口頭報告的緊張感</h2><p>坦白講，因為緊張和焦慮，我幾乎無法專心在其他人的報告內容。不過，雖然這次聽講人數較多，可是我覺得報告的緊張感比以前輕微，所以想花點篇幅來整理自己做了什麼來緩解緊張情緒。</p>
<h3 id="剖析緊張的根源"><a href="#剖析緊張的根源" class="headerlink" title="剖析緊張的根源"></a>剖析緊張的根源</h3><p>「講得不好怎麼辦？」、「被發現不是個咖怎麼辦？」、「講錯怎麼辦？」，我覺得，這些焦慮和維護個人價值的渴望有關。當我們把行為、評價與個人價值掛勾，便會擔憂行為失當是否影響個人價值，開始想像一些可怕的圖景，讓自己在事情發生前變得緊張不安。這種擔憂會因注意到自己無法控制他人想法而加劇，導致自己的決策受他人的想法擺布，也為了滿足全數人的期待而疲憊不堪。</p>
<h3 id="嘗試認知轉換"><a href="#嘗試認知轉換" class="headerlink" title="嘗試認知轉換"></a>嘗試認知轉換</h3><p>既然很多心理掙扎源於認知與行動的不協調，所以改變認知的模式是有機會緩解報告的不安感。首先，可以嘗試讓口頭報告與他人評價脫鉤。我的老師常提醒我，口頭報告（或是發表期刊論文）固然有宣傳和證明自己等作用，但除了功利價值，「發表」既是對前人的感謝也是對來者的祝福。</p>
<p>畢竟，無論我們基於什麼目的從事科學，都需要閱讀大量文獻。當我們從前人的心血獲得發現與見解，從而滿足研究的動機以後，將結果發表出來就是最好的回饋，表達我們從過去得到什麼靈感，並發展出可以給未來的東西。因此，再微不足道的發現與努力，再笨拙的傳達方式，都無損一個人表達感謝的誠意與熱情。</p>
<p>其次，也可以學著讓他人評價與個人價值脫鉤。由於評價是建立在對價值的判斷，兩者的關係也因人而異。每次報告，聽眾的背景和期待都不一樣，即使是同樣的內容也可能激起不同迴響。若透過他人評價來穩固個人價值，等於把定義自我的自由讓給這些無法控制的變項。</p>
<p>那要如何爭取定義自我的自由呢？可行的策略是在準備報告時，先為自己設立幾個目標，避免被他人評價牽著走。這些目標反映了個人最在乎的事情，所以達成目標的過程也是自我實踐與定義的過程。例如這次我給自己設定的目標有，</p>
<ul>
<li><strong>健康</strong>：不管準備得怎麼樣都不熬夜</li>
<li><strong>情緒</strong>：即使當下緊張或焦慮，也要專注於當下，不要為了未來而恐慌或為過去懊悔</li>
<li><strong>科學</strong>：用「如果往後有更完整的資料，我也能把握機會」的心態去分析資料</li>
<li><strong>報告</strong>：嘗試用新的簡報版型、敘事結構和陳述方式</li>
</ul>
<p>列了目標以後，我會提醒自己，不管別人怎麼想，只要達成預先設定的目標就是我的勝利。另外，在報告前，我也透過和朋友聊天、在附近走走、穿上不同風格的衣服或與民宿老闆閒聊等策略，提醒自己具有多元面貌，不只是一個在台上報告的人。</p>
<p>至於犯錯、出糗或聽到批評等，我則將之聯想為 bug 和 warning。寫程式的時候，警告訊息往往用紅色字體呈現，但要注意的是字裡行間的訊息，而不是色彩給我們的原始感受。對於生活中碰到的 bug 和 warning，我試著用這樣的聯想，讓自己能跟寫程式的時候一樣勇敢按下 Run，從錯誤訊息提供的線索，找到克服困難的途徑。</p>
<h3 id="緩解即刻的感受"><a href="#緩解即刻的感受" class="headerlink" title="緩解即刻的感受"></a>緩解即刻的感受</h3><p>認知轉換需要時間練習，上台前即時湧起的感受仍需要一些精神勝利法或不理性的敘事結構來克服。以下列幾個我用過的手段，這些方法通常能穩定心情一段時間，讓我能更專注在準備報告。</p>
<ul>
<li><strong>「呼~」</strong>：呼吸，然後什麼都不要想，專注體會當下所有情緒感受，不做任何評價。這方式的假設是，儘管每個人擁有的時間有限，但我們能提升對生活的意識來增加經驗的厚度。由於每次情緒波動都是別於平常的經驗。因此，不管接下來發生什麼事，透過調整呼吸來品味當下的感受，都能為我們賺來生活的體驗。</li>
<li><strong>「反正我們都會死」</strong>：反正我們都會死，現場所有人的掙扎與聲嘶力竭都會風化在歷史，隨太陽燃盡，最後在宇宙熱寂裡靜默。所以目光放遠一點，我們在台上不是對著觀眾還是南瓜什麼的呢喃，而是面對一座座顫抖的墓碑自白。現在發生什麼事也無所謂，反正再過$10^{150}$年，我們都會分解成孤單的光子，平均散佈在宇宙中，再沒機會碰到彼此。</li>
<li><strong>「就這十分鐘而已」</strong>：這招從國小用到大，伴我對抗打手心、罰站、訓斥等麻煩。簡言之，就是不斷提醒自己任何感受都會消退，也提醒自己要發生的事情根本很快就過了。像報告只有十分鐘，就算支支吾吾了十分鐘也會過去，而十分鐘有多短？短到課堂間睡個覺都不夠呢。（不過應用此方法時，盡量別想像棒式之類的經驗。）</li>
<li><strong>「宇宙某處正在發生生死存亡的戰爭」</strong>：這是一種珍惜的心態。想像宇宙某處正在發生星系間的戰爭，下一秒銀河系可能要被當作質量兵器砸毀在其他星系群了，這或許是最後一次報告，不管怎樣都要好好地享受。即使幸免於難，對於自己能在地球上安穩穩地站著，活在重力常數為 $6.67 \times 10^{-11}m^{3}kg^{-1}s^{-2}$ 的宇宙中也是感激不盡。</li>
<li><strong>「輪我了」</strong>：求學過程有碰過多堂枯燥的課程，每次聽課都覺得折磨，又不能不出席。被荼毒多年，如今終於輪到我上台報仇，難得有老師待在台下機會，應該要大方講，以洩先前當學生之恨。</li>
<li>最後再補充一個比較積極的方法，這也是我覺得最有效的方式：想像想傾訴的對象坐在台下，然後把這場演講獻給他們。當自己總算做出點什麼時，往往忍不住想對著某些人說「你看！」吧？</li>
</ul>
<p>如果曾支持自己的人坐在台下，我會想讓他們知道，多虧了他們的關懷與支持，我才有辦法做出東西來。我覺得，這種想像讓我更能以分享與交流的心態去演講，而不會總擔憂自己做得不好而裹足不前。</p>
<h2 id="如何回答自己不熟悉的問題？"><a href="#如何回答自己不熟悉的問題？" class="headerlink" title="如何回答自己不熟悉的問題？"></a>如何回答自己不熟悉的問題？</h2><p>回答問題時，除了能簡要答覆自己熟悉的部分，若對問題不熟悉，也要盡可能回饋對方自己的見解，才能彼此互惠。這次 MiTalk ，我對自己回答問題的方式不太滿意，所以留意了各講者答覆不熟悉議題的策略（就是講者會停頓一下、發出「摁～」聲音或眼睛朝右上方看的那種問題），期待自己往後能預先準備，不會因為緊張而妨礙與聽眾交流的機會。</p>
<h3 id="Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉"><a href="#Case-1：聽眾詢問某現象在-A-方面的解釋，但你對-A-不熟悉" class="headerlink" title="Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉"></a>Case 1：聽眾詢問某現象在 A 方面的解釋，但你對 A 不熟悉</h3><ol>
<li>承認對 A 不熟悉</li>
<li>承諾可從 B 方面解釋</li>
<li>提出 B 方面的見解</li>
</ol>
<h3 id="Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"><a href="#Case-2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法" class="headerlink" title="Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法"></a>Case 2：聽眾詢問異常數據的解讀，例如離群值、反例、差異不顯著等，但你還沒有想法</h3><ol>
<li>解釋數據的統計與數理意義</li>
<li>坦白目前仍在思考生物解釋</li>
<li>表示此問題值得探討，說明可能的探討方向</li>
</ol>
<h3 id="Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性"><a href="#Case-3：聽眾詢問研究材料的背景知識，但你沒關注該特性" class="headerlink" title="Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性"></a>Case 3：聽眾詢問研究材料的背景知識，但你沒關注該特性</h3><ol>
<li>坦白該部分並非專長</li>
<li>說明已知的資訊</li>
<li>承認目前專注的部分</li>
<li>承諾往後可能怎麼做</li>
</ol>
<h3 id="Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"><a href="#Case-4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制" class="headerlink" title="Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制"></a>Case 4：聽眾詢問研究限制是否使結果無法推廣，但你暫時無法解決該限制</h3><ol>
<li>承認該限制暫時無法克服</li>
<li>提出即使存在限制，在部分資料或條件下仍表現關注的現象</li>
<li>承諾未來可能怎麼解決之</li>
</ol>
<h3 id="Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"><a href="#Case-5：聽眾詢問研究材料的細節，但你沒記住那麼多細節" class="headerlink" title="Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節"></a>Case 5：聽眾詢問研究材料的細節，但你沒記住那麼多細節</h3><ol>
<li>概略回答問題</li>
<li>承認沒有詳記所有資訊</li>
<li>提供參考資料給聽眾</li>
</ol>
<h3 id="Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"><a href="#Case-6：聽眾詢問研究發現的細節，但你沒有注意到這個發現" class="headerlink" title="Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現"></a>Case 6：聽眾詢問研究發現的細節，但你沒有注意到這個發現</h3><ol>
<li>承認自己僅探討了感興趣的項目</li>
<li>依照自己理解推論該細節可能跟研究現象有何關係</li>
<li>感謝對方提出這方面的見解</li>
<li>承諾會回到實驗室思考對方的問題</li>
</ol>
<h3 id="Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"><a href="#Case-7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究" class="headerlink" title="Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究"></a>Case 7：聽眾詢問新奇概念或延伸想法，但你沒有做過相關測試或研究</h3><p>若只回答：「自己沒有細究」會很可惜。畢竟，如果聽眾對研究題材沒興趣的話，也不會浪費時間提問了。既然講者是在場對主題最熟悉的人，即使沒做過相關研究，聽眾也會期待講者的閱歷和經驗能對延伸問題給出什麼新奇想法。因此，可以大膽依照自己的知識做有理據的猜測。</p>
<h2 id="After-phD-PI-or-Boss"><a href="#After-phD-PI-or-Boss" class="headerlink" title="After phD: PI or Boss?"></a>After phD: PI or Boss?</h2><p>這節主辦單位邀情王永福博士、張瑞仁博士、曾景鴻博士介紹他們的公司以及分享在博士後踏入創業之路的動機。</p>
<p>如果重來，會選擇創業還是當PI？<br>別人不會端著錢要你做沒意義的事情。</p>
<p>我覺得這個問題相當於比較產業與學術的職業特質。 先前讀過 Vincent Vanhoucke 的分析，他指出，當工程師和當研究員需要不一樣的心態。相較於工程師，研究員要面對未知是否有解的難題。很多時候，研究結果無法指向解答，只生出更多疑問。這意味著，科研的進展不代表應用的進展，投注整個生涯若能促成概念轉換已相當傑出，更多的研究只在概念上延伸微小的範圍，甚至沒有一絲漣漪地沉澱在歷史長河。</p>
<p>面對意義的喪失，有些人離開學界。例如，王博士即認為他仍會選擇創業，因為學術研究的回饋感較低，很常在實驗室沒日沒夜，卻對自己究竟解決了什麼重要問題感到困惑。相較之下，業界處理的是具體而且迫切的問題，每次都有明確的目標和衡量標準。此外，王博士也認為創業能獲得資金自由，從而保障研究自由，可以自己決定研究方向，不必靠計畫維繫實驗室運作。而張博士則認為只有產業才能與實務問題接軌，因為學術發現局限於文獻，規模、可行性與市場潛能都未經檢驗，若要實踐理想，仍得踏入產業界。</p>
<p>然而，也有些人選擇留在學界，嘗試增加與產業的連結來賦予職涯意義。例如陸永祥老師在擔任助理教授時意識到，自己雖然有許多期刊發表，但這些研究僅圍繞在自己創造出來的問題，並沒有解決這世界面臨的任何難題。因此，陸老師決定踏入產業界，在各大商業發表會中擷取靈感，了解當前社會的需求，藉此引導研究計畫開展，從而結合了研究志業與實務意義。</p>
<p>這幾個例子也呼應曾博士所述，創業與學術的抉擇跟個性有關，你的個性會決定你怎麼選擇職業，怎麼在職涯中追尋意義、成就與滿足。</p>
<h3 id="phD-的訓練對創業有幫助嗎？"><a href="#phD-的訓練對創業有幫助嗎？" class="headerlink" title="phD 的訓練對創業有幫助嗎？"></a>phD 的訓練對創業有幫助嗎？</h3><p>三位講者的共識是，phD 對專業技術與抽象思考有幫助，但對經營面的幫助有限。創業要管理的財務和人事問題比經營實驗室更為複雜，這些都不是就讀博士班容易接觸的事情。因此，張博士認為，創業與否的關鍵在商機，商機比起主題、決心和學位更重要。如果時機對了，對商機感興趣便能主動出擊。畢竟，培育 phD 和培育老闆要注重的素養有別，花費大量時間攻讀學位後，仍需要從頭累積經營經驗，此時無論商機或是能力都可能過時了。</p>
<p>所以三位講者建議，若有良好的機會（例如家庭背景、產業需求、新穎技術、貴人等），要抓住時機創業；若境況太差（資金不足、對產業陌生、能力不足等），需要累積點什麼，這時就讀 phD 或進入欲創業的領域，才對往後創業有幫助。換句話說，為了創業而就讀博士班不是好理由。因此，王博士也希望大家思考繼續進修的動機是什麼，並期許大家不要為了趕上別人而莽撞地決定讀博士班。</p>
<h3 id="為什麼選擇創業這條辛苦的路？"><a href="#為什麼選擇創業這條辛苦的路？" class="headerlink" title="為什麼選擇創業這條辛苦的路？"></a>為什麼選擇創業這條辛苦的路？</h3><p>我覺得張博士的答覆很有趣：「找不到方向或沒機會創業的人更辛苦吧？」</p>
<h3 id="業界研究人力和業務人力的比例為何"><a href="#業界研究人力和業務人力的比例為何" class="headerlink" title="業界研究人力和業務人力的比例為何"></a>業界研究人力和業務人力的比例為何</h3><p>曾博士提供了一個經驗法則，公司最高齡員工的年紀與業務人員的比例正相關。</p>
<h2 id="小型工作坊"><a href="#小型工作坊" class="headerlink" title="小型工作坊"></a>小型工作坊</h2><h3 id="Networking-and-Ecosystem"><a href="#Networking-and-Ecosystem" class="headerlink" title="Networking and Ecosystem"></a>Networking and Ecosystem</h3><p>講者：謝志豪老師 &amp; 吳育瑋老師</p>
<p>共現網路不等於交互作用網路，而交互關係也會隨著規律事件或突發事件而變動。謝老師的工作是利用時間序列資料，推論交互作用隨時間變化的網路。</p>
<p>然而，時間序列分析對採樣頻率有一定要求，一項研究至少數十到數百個樣本才夠。然而受限於經費，往往沒有辦法獲得那麼龐大的資料，所以主持人便詢問是否有克服採樣量不足的方法，而謝老師的答覆則是：「沒有，你還是得去採樣。」</p>
<p>這答覆挺實際的，理論強如克卜勒和牛頓也需要第谷和佛蘭斯蒂德。雖然現在分析工具很多，但沒資料仍是寸步難行。若想解決科學問題卻受經費限制，那只能拉長時間，例如謝老師創建浮游生物資料庫的期許是在「30年後」能為人所用，而不是現在就生出大量樣本，或用少數樣本配合數據模型獲得驚人結果。</p>
<p>因為先前摸過時間序列資料，所以我想了解不同的時間尺度怎麼影響網路推論，也想了解採樣時間不一的問題要怎麼克服。謝老師回覆，時間尺度跟關切的問題有關，不同尺度得出的交互作用網路也有別，無法彼此推論。</p>
<p>至於採樣時間不一的問題是目前時間序列分析的限制，常見的手段是利用內插法來推論特定時間的測量值，但不是每個狀況都適合使用內插法。因此，如果時間差異很大，採用較大的時間尺度還有可能應用此演算法。</p>
<p>而吳老師則簡介他在應用網路分析的心得，例如網路指標的用途不止是簡化數據，也是為了不讓分析者被資料視覺化的形式欺瞞。另外，他也推薦我們讀 Faust. (2021). Open challenges for microbial network construction and analysis. The ISME Journal, 1-8. 了解目前生物網路分析面臨的挑戰（不過謝老師補充，其實有數則問題已經被他解決了）。</p>
<h3 id="Probiotics"><a href="#Probiotics" class="headerlink" title="Probiotics"></a>Probiotics</h3><p>講者：徐瑋萱老師、李保宏老師、陳彥伯老師 </p>
<p>人體益生菌的進展分為消化、免疫、代謝與神經益生菌等世代。目前，台灣業界著重消化與免疫益生菌，但國外正積極發展第三、四代益生菌的市場。不過，益生菌的應用場合也不只人體，還可應用於寵物皮膚炎治療、牲畜疾病防治、土壤改良與環境工程（carbon sink，改善二氧化碳濃度飆升的問題）。此外，益生菌的形式亦未必要為活菌，死菌不僅較容易保存，也能避免他人竊取菌株私自培養。</p>
<p>在益生菌發展中，徐老師有個有趣發現：益生菌可能透過胞泌體影響其他微生物的生理過程，從而降低病原菌的毒性或生長能力。這現象的潛力在於，針對發炎性腸炎的疾病，也許不需透過菌群移植或單菌接種來改善群落結構，只要改變群落的功能就可以達到治療疾病的效果。</p>
<p>此外，益生菌的胞泌體還可能透過神經或其他組織運輸到其他部位，影響遠端部位的生理機能，例如遷移到腦部可能改善精神狀況或記憶相關疾病等。不過關於這些胞泌體的專一性和作用機制都仍不明朗，還需要許多研究確認之。</p>
<p>不過，目前益生菌的研究手段和方向受限於法規，例如基因改造技術便不得用於食品級的益生菌。而透過誘導突變再篩選菌株等菌種改良方式雖可用於食品，但無法獲取有機認證。</p>
<h2 id="邀請演講"><a href="#邀請演講" class="headerlink" title="邀請演講"></a>邀請演講</h2><h3 id="陳可萱老師與林宛柔老師：植物共棲真菌"><a href="#陳可萱老師與林宛柔老師：植物共棲真菌" class="headerlink" title="陳可萱老師與林宛柔老師：植物共棲真菌"></a>陳可萱老師與林宛柔老師：植物共棲真菌</h3><p>陳老師的研究主題是苔類真菌相。苔類受注目的理由除了能於極端環境生存以外，也跟苔類欠缺其他植物常見的菌根菌有關。儘管欠缺近似菌根菌的結構，苔類仍有許多共棲真菌。這些共棲真菌與苔類的關係是陳老師的研究焦點，例如判斷共棲真菌是長在死掉的植物（腐生）還是長在活的植物（共生、內生、寄生），或是了解真菌與苔類共棲於組織內或組織周圍等。</p>
<p>由於苔類從新生到死亡等不同生長階段的組織會出現在同一株當中（Senescence gradient，衰老梯度），所以可以做為探討真菌不同食性的研究題材。其中一種研究食性的方式是，透過C&#x2F;N穩定同位素技術，判斷真菌和植物間是否有營養交換。假如兩者有互換碳與氮，那可能兩者為共生關係；若真菌單方面擷取碳，但植物沒有獲得氮，則可能真菌寄生在植物上。</p>
<p>除了演化與生態應用，由於苔類與共棲生物密切相關，既然苔類能耐受極端環境，其上的生物應該也有相當的耐受性，所以苔類可能作為搜索極端環境生物的標的。其次，苔類可容納各種生物生存，所以或許可以利用這種特性，將苔類作為媒介，把生物接種到不同環境中。</p>
<p>相較於自營性植物共棲真菌，林老師的研究題材是水晶蘭和阿里山水晶蘭等異營性植物的共棲真菌。完全異營性植物只仰賴共棲真菌提供的營養，所以植物與真菌的關係更為密切。這種營養的依賴性可能反映在異營植物與其共棲真菌的演化歷史上。</p>
<p>由於水晶蘭和阿里山水晶蘭型態相近，生存環境也類似，所以林老師想探討兩植物的親緣關係，並了解共棲真菌是否跟兩種植物的分野有關。而研究結果發現，相較於水晶蘭，阿里山水晶蘭與錫杖花的親緣關係較密切。即使生存於相同環境，水晶蘭和阿里山水晶蘭的共棲真菌組成在屬的分類階層仍大不相同，暗示著水晶蘭與阿里山水晶蘭的分野可能跟共棲真菌有關。</p>
<h3 id="張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性"><a href="#張峰勳博士：分化棲位的決定性群落構建過程增加-β-diversity-和生物量的正相關性" class="headerlink" title="張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性"></a>張峰勳博士：分化棲位的決定性群落構建過程增加 β diversity 和生物量的正相關性</h3><p>張博士的研究探討多樣性與群落功能性的關聯。群落的功能性是指各族群的代謝與生理功能之集合，可用生物量、呼吸率和物質消耗率等方式估計。目前已知，α diversity 和 γ diversity 與功能性正相關，但 β diversity 與功能性的關係則尚未明朗。</p>
<p>此研究的假說是分化生態棲位的決定性篩選會增加 β diversity，使得群落的功能多樣性隨分類組成分化而增加。相較於低功能多樣性的群落，高功能多樣性的群落更能應用環境中的不同資源，代謝共通產物也會越多。根據此假說，分化棲位的決定性群落構建過程會加強 β diversity 與功能性的正相關性。 （推理方式：deterministic heterogenize selection→niche diversification→β diversity↑→functional diversity↑→exploit resources→function effects ↑→function indices ↑）</p>
<p>為了探討此假說，張博士使用 Bray-Curtis dissimilarity 度量 β diversity，用 β mean pairwise taxa index (bea-MPTI) 評估決定性分化過程，以 biomass 評估功能性，來檢驗 β diversity、deterministic processes 和 functioning 三者的關聯。</p>
<p>我對此研究很感興趣，也有一些猜想。首先，我會想了解正相關性是否只出現在某種尺度內，例如：(1) 資源有限的情況下，群落多樣性增加應該也不會增加functioning，(2) 功能多樣性隨群落多樣性增加的幅度飽和，應該也會讓functioning 增長的趨勢停滯。其次，如果假設 niche diversification 導致功能性上升，也許使用採計親緣關係的 UniFrac 也能獲得類似的結果。</p>
<p>最後，在 α 和 γ diversity 和 functioning 正相關的情況下，β diversity 還能跟 functioning 呈負相關嗎？依照我的理解，α diversity 、β diversity 和 γ diversity 三者有關，當metacommunities 間 β diversity 為零，那 γ diversity 就等於 α diversity；若 metacommunities 間的 β diversity 為一，那 γ diveristy 應該是 α diversity 之和。按照這層關係，在 α diversity 固定的情況下，γ diversity 上升會伴隨 β diversity 上升，所以當 γ diversity 跟功能性正相關時，β diversity 也會跟功能性正相關。</p>
<p>我在想 β diversity 和 functioning 呈負相關的一個可能是，α diversity 和 β diversity 呈負相關。換句話說，若某種生態過程會使得群落間組成逐漸相似，但最大化單一棲地的多樣性，那麼就可能觀察到 β diversity 和 functioning 呈負相關。例如說在 local dispersal limitation 微弱的初級演替環境，頻繁的遷移雖然會讓各族群的組成逐漸相似 (β diversity↓)，也會增加各群落的族群數 (α diversity↑)，提升 metacommunity 的 functioning。</p>
<p>按照這想法推測，隨著各群落的規模觸及環境負荷極限，可能出現heterogeneous selection，例如發生 lottery competition，各群落的優勢族群取決於隨機事件，增加了 β diversity。又或發生 homogeneous selection，例如先前遷入的族群造成 priority effects，限制了後續能於各區域生存的族群多樣性，使得 β diversity 下降。在沒有更多遷入族群的情況下，這兩種情況都使得 α diversity 下降，但後者降低 γ diversity，降低 metacommunity 的 functioning，於是 β diversity 又和 functioning 正相關了。</p>
<h3 id="其他印象深刻的內容"><a href="#其他印象深刻的內容" class="headerlink" title="其他印象深刻的內容"></a>其他印象深刻的內容</h3><ul>
<li><strong>何攖寧老師</strong>：雖然獨立於培養的方法可以普查環境微生物，但為了驗證假說、生產應用和探索功能等需求，仍有培養細菌的需求。而冰河溶解、大地震、工業汙染等突發事件造成的菌群變化，更強調現地即時指引樣本微生物培養的重要性，畢竟突發事件相當罕見，時間過了就沒辦法研究了。</li>
<li><strong>邱名鍾博士</strong>：邱博士提到隨寄生蟲感染而上&#x2F;下調的宿主基因非常多，這些基因不僅反映了宿主受影響的生理功能和途徑，也反映了寄生蟲和宿主軍備競賽的過程。</li>
<li><strong>林玉儒老師</strong>：林老師講了「鬼花飄香」的故事，研究人員從已滅絕的魏氏岳槿之植物標本取得核酸，再找出產生香味的關鍵基因，將這段基因插入酵母菌生產香味分子以重現魏氏岳槿的氣味（完整故事可見科學人報導）。</li>
<li><strong>陳彥伯老師</strong>：「這項研究很感謝在行政院農委會任職的學妹協助，本來跟學妹約好要在台上 cue 她的，但今天學妹卻沒來。」</li>
<li><strong>陳立賢老師</strong>：「我們以蔥根製作的面膜並不會有蔥油餅敷在臉上的油膩感。」</li>
<li><strong>汪碧涵老師</strong>：「我們每次 reject，都往點數更高的期刊投。」</li>
<li><strong>謝志豪老師</strong>：「這裡不解釋，若對network感興趣，可以去讀書。」</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>兩年前參加 MiTalk 時，碩班研究正好碰到瓶頸。當時聽了許多老師討論他們的求學經歷，卻仍然困惑自己是否適合做研究。於是，我期許自己能透過研討會增廣見聞，在跟人討論的過程中激勵自己。如今帶著一點結果再次參加 MiTalk，算是朝當時立下的目標稍稍前進一步了。</p>
<p>我現在覺得不具備做好某件事的特質，不是放棄的理由。我很喜歡《原子習慣》提倡的概念，要成為怎樣的人取決於動機和行動，這實在是很 existentialism。確實，研究了未必有明確結果，報告後的回饋也不一定如預期，考到什麼學校也不保證能讀到畢業，當到計畫主持人或工廠老闆還是可能有多種麻煩要應對。</p>
<p>然而，這些行動無論成敗都是定義自己的過程。當你為了瞭解 metagenomics，在 compiler 輸入 print(“Hello world”) 那刻，就成了生物資訊學家；當你為了解釋群落演替，在紙上畫了數個方格模擬動物遷徙的時候，就成了理論生態學家；當你開始反思自己的研究，為了某個癥結輾轉難眠，你也已經是個學者了。</p>
<p>至於能在生物資訊、理論生態或是學者的路走去哪、走多遠或走出什麼道路，端看每次行動的抉擇。但我想在這個過程需要時間琢磨。因此，我現在對自己的期許是要有耐心，漸漸不再擔憂自己欠缺什麼條件，而是想辦法做到當下能做到的事情，剩下交給時間。</p>
]]></content>
      <tags>
        <tag>ecology</tag>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜調整工作目錄的路徑</title>
    <url>/nextflow-change-path-to-work-directory/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 會為分析流程的每一步建立工作目錄，再以工作目錄為中心接收資料、儲存暫存檔和匯出結果。工作目錄預設在 nextflow 腳本執行路徑下的 <code>work/</code>，可透過添加執行選項、調整參數設定、設置環境變項等三種方式自訂工作目錄的路徑。</p>
<span id="more"></span>

<h1 id="添加執行選項"><a href="#添加執行選項" class="headerlink" title="添加執行選項"></a>添加執行選項</h1><p>執行 Nextflow 腳本時，加上 <code>-w</code> 便能指定工作目錄的存放路徑與名稱，是優先度最高的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -w <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="調整參數設定"><a href="#調整參數設定" class="headerlink" title="調整參數設定"></a>調整參數設定</h1><p>其次，也能在<a href="https://www.nextflow.io/docs/latest/config.html">設置檔內定義工作目錄</a>，再使用 <code>-c</code> 導入設置檔。（除此之外，使用 <code>-params-file</code> 導入參數或是直接將<code>workDir</code> 定義在 nextflow 腳本內都是無效的手法。）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.json</span></span><br><span class="line">workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -c config.json</span><br></pre></td></tr></table></figure>

<p>要留意的是，雖然在設置檔內常使用 <code>params.var</code> 的方式來定義變項，但 <code>workDir</code> 不等同 <code>params.workDir</code>，因此以下兩種寫法都無法調整工作目錄的存放路徑。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">params.workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line">params <span class="punctuation">&#123;</span></span><br><span class="line">    workDir = <span class="string">&quot;/path/to/workdir&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="設置環境變項"><a href="#設置環境變項" class="headerlink" title="設置環境變項"></a>設置環境變項</h1><p>第三種方法則是在 nextflow 的執行環境重設環境變數，是優先度最低的方式。（Nextflow 相關的環境變項可參照 <a href="https://www.nextflow.io/docs/latest/metadata.html">Workflow introspection</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> NXF_WORK=<span class="string">&quot;/path/to/workdir/&quot;</span></span><br><span class="line">$ nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>工作目錄的內容有助於追蹤程式錯誤，為了管理方便，可透過執行指令、內製變項和環境變項來調整工作目錄的路徑。</p>
<p>除了工作目錄外，或許也有人想調整 <code>.nextflow</code> 等暫存目錄的位置，但根據<a href="https://github.com/nextflow-io/nextflow/issues/1747">開發者所述</a>，目前應該是無法更動。</p>
<blockquote>
<p>The <code>.nextflow</code> has to be in the launching directory to properly maintain the history of the executions.</p>
</blockquote>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>網際牛仔與無障礙空間（上）：如何以鍵盤瀏覽網頁？</title>
    <url>/navigate-websites-with-keyboard/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>為什麼想以鍵盤瀏覽網頁？滑鼠是為簡化繁瑣的鍵入指令而生，也與圖形介面的發展相輔相成。因此，當代網頁本來就適合以滑鼠瀏覽，純靠瀏覽器有限的快捷鍵反倒綁手綁腳。</p>
<p>然而，有時擁有自己的風格比起事情做的有效率還重要。本文就是我對於「用鍵盤瀏覽網頁」這項風格的探索與總結。</p>
<blockquote>
<p>Style over Substance. It doesn’t matter how well you do something, as long as you look good doing it. （格調重於成效，只要你作風有形，事情幹得怎麼樣並不要緊。） </p>
<p style="text-align:right" > The core rulebook for Cyberpunk 2020 </p>
</blockquote>
<span id="more"></span>

<h1 id="「覺得酷」的學習成本有多高？"><a href="#「覺得酷」的學習成本有多高？" class="headerlink" title="「覺得酷」的學習成本有多高？"></a>「覺得酷」的學習成本有多高？</h1><p>就我的使用經驗，是否要用鍵盤瀏覽網頁是風格問題而不是效率問題。因為瀏覽網頁不像編輯文件一樣要頻繁移動游標，點擊和拖曳等行為的頻率也較低，所以沒那麼講究要降低手部位移的幅度。畢竟，有時網頁看一半，漱杯飲料或嗑片餅乾的移動幅度，都比單手改持滑鼠的移動幅度還要大。</p>
<p>儘管如此，我認為除了營造風格以外，善用快捷鍵能減少滑鼠在精密操作時的磨耗感，例如開啟狹窄的右鍵選單、滾動長頁面或點擊尺寸很小的按鈕，這些瑣碎操作不見得會影響瀏覽網頁的效率，但會大幅降低查找資料的心情（對，就是 kimochi 問題）。</p>
<p>更重要的是，體驗鍵盤瀏覽網頁的成本極低，只要學會以下三組快捷鍵，就能流暢地逛平常習慣的網頁了。本文也將以這三組快捷鍵為主軸，簡介如何利用 Windows 系統、Chrome 瀏覽器與 Vimium 套件的快捷鍵，以鍵盤瀏覽網頁。</p>
<ol>
<li>設定開啟瀏覽器的快捷鍵</li>
<li>學會開分頁(<code>Ctrl</code> + <code>T</code>)、關分頁 (<code>Ctrl</code> + <code>W</code>)、切換分頁 (<code>Ctrl</code> + <code>Tab</code>)</li>
<li>安裝 Vimium 或其他 Vim-like 瀏覽器套件</li>
<li>學會用 Vim-like 套件的功能點擊連結 (<code>f</code> + <code>&lt;index&gt;</code>)</li>
</ol>
<p>既然要用鍵盤瀏覽網頁，那首要的目標自然是透過鍵盤開啟瀏覽器。然而，Chrome 與 Windows 雖然有不少快捷鍵，卻似乎沒有能開啟瀏覽器的快捷鍵。幸好，Windows 支援用戶為檔案或程式建立捷徑 (Shortcut) 和設定快捷鍵 (Shortcut key)，所以能在需要時快速開啟檔案或程式，不必再移動到它們（或其捷徑）的所在目錄。</p>
<p>瀏覽器的捷徑可從執行檔自行建立（<strong>chrome.exe - Shortcut</strong>），或是使用安裝時自動建立的捷徑（ <strong>Google Chrome</strong>）。建立瀏覽器的捷徑之後，便能為其設定快捷鍵。</p>
<ol>
<li>右鍵點擊「捷徑」</li>
<li>點選「內容 (Properties)」</li>
<li>點選「快捷鍵」</li>
<li>按下自訂快捷鍵，例如 <code>Ctrl</code> + <code>Alt</code> + <code>C</code></li>
<li>點選「確定」套用設定</li>
</ol>
<h1 id="暢遊-Google-search"><a href="#暢遊-Google-search" class="headerlink" title="暢遊 Google search"></a>暢遊 Google search</h1><p>Chrome 完整的快捷鍵列表可參考<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hant&co=GENIE.Platform=Desktop">google 說明</a>。以下我嘗試從用戶角度，說明有哪些常用快捷鍵值得留意，而這些快捷鍵又有哪些使用的情境。</p>
<h2 id="如何透過搜尋引擎查找關鍵字？"><a href="#如何透過搜尋引擎查找關鍵字？" class="headerlink" title="如何透過搜尋引擎查找關鍵字？"></a>如何透過搜尋引擎查找關鍵字？</h2><p>假設今天想查詢某項資訊，可考慮以下三種方式來輸入關鍵字，再點擊 <code>Enter</code> 執行搜索：</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>開啟新分頁並移至新分頁的網址列</strong></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>移至網址列</td>
<td><code>Alt</code> + <code>D</code> or <code>Ctrl</code> + <code>L</code> or <code>F6</code></td>
</tr>
<tr>
<td>於網址列搜尋 Google</td>
<td><code>Ctrl</code> + <code>E</code> or <code>Ctrl</code> + <code>K</code></td>
</tr>
</tbody></table>
<p>由於以上方法皆透過網址列搜尋關鍵字，一旦網頁跳轉到搜索結果，該列便會轉變為網址。此時若想修正錯字或更改關鍵字，可以使用 <code>/</code> 切換到 Google search box，在該位置編輯關鍵字，就不用重新輸入一遍或編輯藏在長串網址當中的關鍵字。</p>
<p>跳轉到搜索結果後，便能使用以下快捷鍵滑動或跳動網頁，尋找自己需要的資訊。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>連續滑動網頁</td>
<td><code>↑</code> and <code>↓</code></td>
</tr>
<tr>
<td>向下跳數列</td>
<td><code>Space</code> or <code>PageDown</code></td>
</tr>
<tr>
<td>向上跳數列</td>
<td><code>Shift</code> + <code>Space</code> or <code>PageUp</code></td>
</tr>
<tr>
<td>移動至網頁最上端</td>
<td><code>Home</code></td>
</tr>
<tr>
<td>移動至網頁最底端</td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="如何開啟特定連結？"><a href="#如何開啟特定連結？" class="headerlink" title="如何開啟特定連結？"></a>如何開啟特定連結？</h2><p>假如你已找到感興趣的結果，接下來得移動游標到連結位置才能開啟。Chrome 預設以 <code>Tab</code> 和　<code>Shift + Tab</code> 在連結間切換。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移動至下一個連結</td>
<td><code>Tab</code></td>
</tr>
<tr>
<td>移動至上一個連結</td>
<td><code>Shift</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<p>另一種方式是啟用無障礙設定裡的「使用文字游標瀏覽頁面」。在這模式裡，用戶能以 <code>←</code>、<code>↑</code>、<code>↓</code>、<code>→</code> 操作文字游標，讓網頁能像文檔一樣瀏覽。</p>
<ol>
<li><code>Alt</code> + <code>E</code> ，開啟瀏覽器設定選單</li>
<li><code>S</code>，選取「設定」</li>
<li><code>/</code>，進入搜索框</li>
<li>查詢「無障礙設定」</li>
<li>使用 <code>Tab</code> 移動到游標瀏覽功能開關</li>
<li><code>Enter</code>，開啟或關閉功能</li>
</ol>
<p><em>(或是以 <code>F7</code>快速切換文字游標瀏覽模式。記得關掉提醒通知，往後啟用模式才不用一再確認。）</em></p>
<p>當游標移動到連結位置，即可使用以下快捷鍵，決定要於哪個分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟連結</td>
<td><code>Enter</code></td>
</tr>
<tr>
<td><strong>於新分頁開啟連結</strong></td>
<td><code>Ctrl</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新分頁開啟連結並移至新分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td>
</tr>
<tr>
<td>於新視窗開啟連結並移至新視窗</td>
<td><code>Shift</code> + <code>Enter</code></td>
</tr>
</tbody></table>
<h2 id="如果我還沒找到滿意的結果，要怎麼前往下一頁？"><a href="#如果我還沒找到滿意的結果，要怎麼前往下一頁？" class="headerlink" title="如果我還沒找到滿意的結果，要怎麼前往下一頁？"></a>如果我還沒找到滿意的結果，要怎麼前往下一頁？</h2><p>很遺憾的，目前 Chrome 或 Google Search <strong>沒有直達下一頁的快捷鍵</strong>，只能持續押著 <code>Tab</code> 直到頁面底部。那使用 <code>Shift</code> + <code>Tab</code> 從頁面底部開始找起呢？可行，但不見得比較快，因為頁面底部除了「下一頁」與「上一頁」按鈕外，還有隱私權、服務條款、活動紀錄與地理位置等連結要通過。</p>
<p>開啟連結是使用鍵盤瀏覽網頁的最大障礙，因為用戶必須先滑動視窗找到對應的連結，再移動游標通過一樣內容到該連結的位置。換句話說，用戶至少要跑兩次迴圈才能找到並打開連結。</p>
<p>既然如此，那為什麼不一開始就使用 <code>Tab</code> 來逛網頁呢？其實可以，但非常惱人。</p>
<p>首先，游標移動不若視窗滑動迅速。其次，連結在網頁上的順序未必與游標移動的順序一致，使得用戶無法預期瀏覽的方向。以 Google search 為例，一則搜尋條目在視覺上的結構為頁庫存檔選項、翻譯選項與連結文字。然而，游標移動的順序卻是連結文字、頁庫存檔選項、翻譯選項，導致需要連續按三次 <code>Tab</code> 才能移動到下一個連結。</p>
<blockquote>
<p><a href="https://5uperb0y.com/">https://5uperb0y.com</a> ▼ 翻譯這個網頁<br>5uperb0y’s blog</p>
</blockquote>
<p>第三，不是每個網頁都會醒目標示游標的位置，以至於用戶不僅無法確認游標移動的順序，還可能找不到游標的位置。就拿我這個網站為例，可以試試使用 <code>Tab</code> 來找到任一文章的連結，我相信按了十幾下可能都還沒辦法確認游標位置，所以也很難開啟特定連結。</p>
<p>在本文其他節，我會介紹能迴避這些問題的取巧手段和擴充套件。但在此處，我們先假設所有搜索都能在第一頁找到答案，並繼續了解如何透過快捷鍵管理分頁與視窗。</p>
<h2 id="如何管理瀏覽器分頁？"><a href="#如何管理瀏覽器分頁？" class="headerlink" title="如何管理瀏覽器分頁？"></a>如何管理瀏覽器分頁？</h2><p>如今我們已經會使用快捷鍵搜尋和瀏覽網頁，然而隨著點擊而累積的分頁又該如何管理呢？雖然列出了許多選項，但我常用的僅有粗體標示者。</p>
<h3 id="開啟與關閉分頁"><a href="#開啟與關閉分頁" class="headerlink" title="開啟與關閉分頁"></a>開啟與關閉分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>shortcut</th>
</tr>
</thead>
<tbody><tr>
<td>開啟新分頁並移至新分頁</td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td><strong>關閉當前分頁</strong></td>
<td><code>Ctrl</code> + <code>W</code> or <code>Ctrl</code> + <code>F4</code></td>
</tr>
<tr>
<td>依關閉順序，重新開啟已關閉之分頁</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td>
</tr>
</tbody></table>
<h3 id="切換與移動分頁"><a href="#切換與移動分頁" class="headerlink" title="切換與移動分頁"></a>切換與移動分頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至指定分頁</td>
<td><code>Ctrl</code> + <code>[1-8]</code></td>
</tr>
<tr>
<td>移至最後分頁</td>
<td><code>Ctrl</code> + <code>9</code></td>
</tr>
<tr>
<td><strong>移至下一分頁</strong></td>
<td><code>Ctrl</code> + <code>PageDown</code> or <code>Ctrl</code> + <code>Tab</code></td>
</tr>
<tr>
<td>移至上一分頁</td>
<td><code>Ctrl</code> + <code>PageUp</code> or <code>Ctrl</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>後挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageDown</code></td>
</tr>
<tr>
<td>前挪分頁順序</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>PageUp</code></td>
</tr>
<tr>
<td>挪動分頁為獨立視窗</td>
<td><code>Shift</code> + <code>W</code></td>
</tr>
</tbody></table>
<h3 id="搜索或開啟曾瀏覽的網頁"><a href="#搜索或開啟曾瀏覽的網頁" class="headerlink" title="搜索或開啟曾瀏覽的網頁"></a>搜索或開啟曾瀏覽的網頁</h3><table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td><strong>上一頁</strong></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>開啟搜尋歷史</td>
<td><code>Ctrl</code> + <code>H</code></td>
</tr>
</tbody></table>
<h2 id="如何管理瀏覽器視窗？"><a href="#如何管理瀏覽器視窗？" class="headerlink" title="如何管理瀏覽器視窗？"></a>如何管理瀏覽器視窗？</h2><p>除了分頁，Chrome 亦支援以快捷鍵開啟視窗或調整視窗大小。不過這些快捷鍵我也不常用到，頂多會用無痕視窗查詢特殊關鍵字或測試 SEO 和網頁有沒有問題。值得留意的是，<code>ALT</code> + <code>Space</code> 是開啟視窗右鍵選單的快捷鍵，所以縮小或放大都有提示，不須記憶。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>開新視窗</td>
<td><code>Ctrl</code> + <code>N</code></td>
<td>寫作時參照文件</td>
</tr>
<tr>
<td>開新無痕視窗</td>
<td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td>
<td>查詢關鍵字、測試網頁</td>
</tr>
<tr>
<td>將當前視窗縮至最小</td>
<td><code>ALT</code> + <code>Space</code>, then <code>N</code></td>
<td>操作桌面的檔案或軟體</td>
</tr>
<tr>
<td>將當前視窗開至最大</td>
<td><code>ALT</code> + <code>Space</code>, then <code>X</code></td>
<td>很少用</td>
</tr>
</tbody></table>
<p>相較於 Chrome，Windows 提供了更多調整視窗尺寸的途徑。因此有助於在寫程式或編輯文件時，雙開文件並分配視窗在螢幕上的位置，以便邊參閱資料邊修改文件。下圖是視窗間的關係，點擊 <code>Win</code> 與下圖的方向鍵，即可在不同形式的視窗間切換。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           上半視窗（點選 ↓ 會回到原始視窗）</span><br><span class="line">              ↑</span><br><span class="line">左半視窗 ←  最大視窗 → 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">左半視窗 ⇆ 原始視窗 ⇆ 右半視窗</span><br><span class="line">              ⇅</span><br><span class="line">           最小視窗          </span><br></pre></td></tr></table></figure>

<p>至於要在視窗間切換或取回縮小的視窗，可以使用 <code>Alt</code> + <code>Tab</code> 進入選單，再配合方向鍵選取。</p>
<h1 id="快捷鍵組合技"><a href="#快捷鍵組合技" class="headerlink" title="快捷鍵組合技"></a>快捷鍵組合技</h1><p>前一節介紹了 Chrome 內建的快捷鍵，但諸如好手氣、右鍵搜索、於無痕視窗開啟等功能都沒有對應的快捷鍵。因此，這一節要介紹如何組合基本的快捷鍵，實踐這些方便功能。</p>
<h2 id="「透過-Google-搜尋」"><a href="#「透過-Google-搜尋」" class="headerlink" title="「透過 Google 搜尋」"></a>「透過 Google 搜尋」</h2><p><strong>方法一：透過「開新分頁」</strong></p>
<ol>
<li>標示 (highlight) 欲搜索的字串</li>
<li><code>Ctrl</code> + <code>C</code>，複製字串</li>
<li><code>Ctrl</code> + <code>T</code>，開啟並移動游標至新分頁的網址列</li>
<li><code>Ctrl</code> + <code>V</code>，貼上字串至網址列</li>
<li><code>Enter</code>，執行搜尋</li>
</ol>
<p>若要在同一分頁搜尋，可以使用 <code>Ctrl</code> + <code>E</code>&#x2F;<code>K</code>&#x2F;<code>L</code> 取代 <code>Ctrl</code> + <code>T</code>。</p>
<p><strong>方法二：透過「右鍵選單」</strong><br>若使用 windows 電腦，可使用選單鍵開啟右鍵選單，執行相關功能。</p>
<ol>
<li>標示欲搜索的字串</li>
<li><code>☰</code>，透過選單鍵(menu key)開啟選單</li>
<li><code>S</code>，執行「透過 Google 搜尋」</li>
</ol>
<h2 id="「好手氣」"><a href="#「好手氣」" class="headerlink" title="「好手氣」"></a>「好手氣」</h2><p>Google search 首頁有個好手氣的按鈕，能直接進入第一個搜尋的網頁。我們可以使用 Google search 的無障礙連結來達到類似目的。</p>
<ol>
<li>輸入搜尋內容</li>
<li><code>Tab</code>，開啟無障礙輔助提示，此時應該會停在「跳至主內容」</li>
<li><code>Enter</code>，確認跳至「主內容」，通常會直接將游標移動到第一個連結</li>
<li><code>Enter</code>，進入第一個連結</li>
</ol>
<p>由於 Google 有時會在第一則搜尋條目前安插精選摘要、廣告或是錯字提醒的窗格，所以這招並非總是見效。儘管如此，仍比遍歷 Google search 的功能窗格更為便捷。</p>
<h2 id="「在無痕視窗中開啟連結」"><a href="#「在無痕視窗中開啟連結」" class="headerlink" title="「在無痕視窗中開啟連結」"></a>「在無痕視窗中開啟連結」</h2><p>Chrome 介紹了各種開啟連結的方式，唯獨不支援在無痕視窗開啟連結的方式，所以此處同樣要利用選單鍵的來開啟右鍵選單。</p>
<ol>
<li>移動游標至連結</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>G</code>，執行「在無痕視窗中開啟連結」</li>
</ol>
<h2 id="「另存為圖片」"><a href="#「另存為圖片」" class="headerlink" title="「另存為圖片」"></a>「另存為圖片」</h2><p><strong>方法一：透過「另存網頁」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code>，開啟圖片於新分頁並切換至新分頁</li>
<li><code>Ctrl</code> + <code>S</code>，另存新檔</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<p><strong>方法二：透過「右鍵選單」</strong></p>
<ol>
<li>移動游標至圖片</li>
<li><code>☰</code>，透過選單鍵開啟選單</li>
<li><code>V</code>，執行「另存為圖片」</li>
<li>選取存儲目錄並存放圖片</li>
</ol>
<h2 id="拖曳當前分頁為獨立視窗"><a href="#拖曳當前分頁為獨立視窗" class="headerlink" title="拖曳當前分頁為獨立視窗"></a>拖曳當前分頁為獨立視窗</h2><p>Chrome 沒有相關的快捷鍵，不過我們可以透過「於新視窗開啟分頁」的快捷鍵來模擬。然而與滑鼠拖曳最大的差別在於，重啟後不會保留已填入的資料，也不會刪除舊的分頁。</p>
<ol>
<li><code>Ctrl</code> + <code>L</code> (or <code>Alt</code> + <code>D</code>)，移至網址列</li>
<li><code>Shift</code> + <code>Enter</code>，於新視窗開啟連結</li>
</ol>
<h1 id="以取巧的方式迴避點擊連結的障礙？"><a href="#以取巧的方式迴避點擊連結的障礙？" class="headerlink" title="以取巧的方式迴避點擊連結的障礙？"></a>以取巧的方式迴避點擊連結的障礙？</h1><p>本文前半部曾提到，點擊連結是用鍵盤瀏覽網頁最大的困難。在這一節，我嘗試用瀏覽器搜尋功能（<code>Ctrl</code>+<code>F</code>）可以迅速跳轉位置的特性，解決游標移動效率不彰的問題。</p>
<h2 id="如何直達特定連結？"><a href="#如何直達特定連結？" class="headerlink" title="如何直達特定連結？"></a>如何直達特定連結？</h2><p>直達特定連結有以下五個步驟：</p>
<ol>
<li>辨識：目視想要開啟的連結</li>
<li>編碼：觀察連結文字或網址，從中挑選獨一無二的子字串作為頁內搜尋的關鍵字。</li>
<li>搜尋：<code>Ctrl</code>+<code>F</code>，搜尋關鍵字以找到連結位置</li>
<li>跳轉：若選對關鍵字，游標會直接移動到連結。若否，則使用 <code>Enter</code> 和 <code>Shift</code> + <code>Enter</code>前後查詢連結</li>
<li>開啟：<code>Enter</code>，開啟連結（若想要在新分頁開啟連結，可以先　<code>Esc</code> 退出，再執行開分頁搜索的行為）</li>
</ol>
<p>為連結編碼（或說選用關鍵字）時，可挑選網域的子字串。由於網域通常會採用較獨特的名稱，所以較不容易與其它連結衝突，能避免查詢時無法一步到位。此外，Google search 會將來自相同網站的相似內容以巢狀結構編排，不會讓單一網站的內容佔滿搜尋結果。這項特性讓頁內搜索時不會一次出現很多結果，同樣提升了搜尋的精準度。</p>
<h2 id="如何前往下一頁？"><a href="#如何前往下一頁？" class="headerlink" title="如何前往下一頁？"></a>如何前往下一頁？</h2><p>頁內搜索的訣竅同樣能運用於前往下一頁。Google search 最下方的結果分頁有兩個潛在標的，第一個是「下一頁」本身，這個詞彙相當獨特，所以搜尋時不容易被結果條目干擾。然而它的長度較長（若以注音輸入法要按九個按鈕），所以可能要先複製字串或是用<a href="https://key.chtouch.com/cv.aspx?p=3120">window使用者造詞</a>將這些代表「下一頁」的關鍵字存為快捷鍵，減少輸入時間。（使用者造詞可以降低到只要按四個按鈕）</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋 <code>下一頁</code></li>
<li><code>Ctrl</code> + <code>Enter</code></li>
</ol>
<p>第二個搜索標的則是表示頁數的數字，原則上這些數字會是整個頁面最後一個數字，所以我們可以從頁面底部反向搜索這些數字來直達連結。只是 Chrome 的最後一列可能顯示用戶地址資訊，其中郵遞區號會影響查詢。目前，我還沒找到關閉這些訊息顯示的方法。</p>
<ol>
<li><code>Ctrl</code>+ <code>F</code>，搜尋任意數字</li>
<li><code>Shift</code> + <code>Enter</code>，往回找到最後一個搜尋結果，最差要往回查兩次才能越過郵遞區號到達頁面數字</li>
<li><code>Ctrl</code> + <code>Enter</code>，開啟下一頁</li>
</ol>
<p>由於不是每個網頁都有前往下一頁的對應按鈕，所以 Chrome 沒有下一頁的關鍵字也蠻合理的。不過我猜這項特性也跟搜尋引擎的理念有關。假設在關鍵字正確的情況下，Google Search 總是能推薦最佳的內容。那麼，只要用戶下對關鍵字，就能從第一個連結取得想要的結果。</p>
<p>若第一頁沒出現想要的結果，表示下錯關鍵字或議題太冷門，再怎麼瀏覽都很難找到想要的資訊。因此，基於對搜尋演算法的信任，下一頁的需求其實不高，這項缺陷算是變相鼓勵用戶改善搜索的效率而非瀏覽的效率。</p>
<h2 id="如何複製文字？"><a href="#如何複製文字？" class="headerlink" title="如何複製文字？"></a>如何複製文字？</h2><p>較費時的做法是啟用文字游標瀏覽模式，再移動游標至目標文句，再使用 <code>Shift</code> + 方向鍵選取並複製。搜尋快捷鍵則能節省游標移動的時間，</p>
<ol>
<li><code>Ctrl</code> + <code>F</code>，搜尋目標文句</li>
<li><code>Esc</code>，脫離頁內搜尋窗格</li>
<li><code>Shift</code> + 方向鍵，選取要複製的文句</li>
<li><code>Ctrl</code> + <code>V</code>，複製</li>
</ol>
<p>如果要複製的文字篇幅較長，這方法甚至會比滑鼠來得有效且可靠，因為使用滑鼠選取時，要同時壓著鼠鍵並滑過狹長的文字區域，這過程有如遊玩電流急急棒一樣。相較之下，使用上下鍵卻可以一次複製一整列，還不用擔心手滑取消掉選取的區域。但如果目標文句較短的話，輸入搜尋關鍵字的時間都足以重新打字一遍了，這方法便顯得沒什麼效率。</p>
<h1 id="使用-Vimium-解放鍵盤的潛能"><a href="#使用-Vimium-解放鍵盤的潛能" class="headerlink" title="使用 Vimium 解放鍵盤的潛能"></a>使用 Vimium 解放鍵盤的潛能</h1><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的擴充套件，借鑒了 Vim 編輯器的操作邏輯與鍵位設置，大幅改善了在 Chrome 的鍵盤瀏覽體驗。</p>
<h2 id="為什麼-Vim-的功能改善鍵盤瀏覽體驗？"><a href="#為什麼-Vim-的功能改善鍵盤瀏覽體驗？" class="headerlink" title="為什麼 Vim 的功能改善鍵盤瀏覽體驗？"></a>為什麼 Vim 的功能改善鍵盤瀏覽體驗？</h2><p>從鍵盤輸入電腦的訊號不外乎指令（例如開分頁、複製、下一頁)和文字（例如中文、英文與符號），由於指令數量遠大於按鈕的數量，若要確保鍵盤尺寸在雙手便於敲擊的範圍，勢必得存在兼具兩種定位的按鈕。而專為鍵盤設計的 Vim 與 Windows 與 Chrome 等仰賴鍵鼠相輔者的差異正體現在讓電腦區分鍵入訊號的方式。</p>
<p>鍵鼠相輔的圖形介面保留了文字鍵的獨立性，讓滑鼠與功能選單取代部分指令（例如游標移動），而且只有在一併輸入 <code>Ctrl</code>、<code>Alt</code>、<code>Home</code> 等特殊控制鍵時，這些文字鍵才會發揮指令的功能。然而，這些特殊控制鍵分布於鍵盤兩側，編輯複雜文件時，雙手往往要在滑鼠、文字鍵區與控制鍵等區域間來回移動。</p>
<p>與之相對，Vim 則透過切換模式來區分鍵入訊號。文字鍵在 Insert 模式用於輸入內容，在 Normal 模式則用於下達指令，所以無論要鍵入指令還是文字，所有操作都圍繞在 f 與 j 那列按鍵 (home row)，降低了操作時雙手位移的幅度。</p>
<p>但是，Vim 的這些特性為什麼可以改善用鍵盤瀏覽網頁的體驗？</p>
<p>Vim 的 Normal 模式有許多便於移動與跳轉指標的指令，這些有用的指令在鍵鼠系統裡多被滑鼠取代，導致鍵盤不足以支持瀏覽網頁的需求。然而，除了輸入關鍵字外，瀏覽網頁時其實少有編輯文字的需求，也就沒有下達指令與輸入文字的衝突。這種情況可以類比為 Vim 的 Normal 模式，如果能透過 vimium 之類的套件，移植 Vim 好用的指令到這些閒置的文字鍵，便能充分發會鍵盤的潛能。</p>
<h2 id="Vimium-解決了鍵盤開啟連結的麻煩"><a href="#Vimium-解決了鍵盤開啟連結的麻煩" class="headerlink" title="Vimium 解決了鍵盤開啟連結的麻煩"></a>Vimium 解決了鍵盤開啟連結的麻煩</h2><p>雖然 Vimium 還有許多功能（這些功能可透過輸入 <code>?</code> 查詢），但我覺得在改善瀏覽網頁方面，快速開啟連結是最方便也最重要的功能。</p>
<p>若使用 Chrome 內建的快捷鍵，必須透過遍歷或是搜尋來找到連結。當網站連結編排不友善時，遍歷的時間會延長非常多。相較之下，Vimium 引進了 Vim Easymotion 功能，用戶只要鍵入 <code>f</code>，Vimium 便會自動為連結標記關鍵字，只要輸入關鍵字就能直接開啟標註的連結。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="按下 `f` 即可自動標註連結，再按下標註的字母即可開啟連結。由於每個連結至多標註兩個字母，所以視窗內的連結都可以在輸入三個鍵以內開啟。"></p>
<p>學會以 Vimium 開啟連結，再配合 Windows 與 Chrome 內建直觀的快捷鍵，其實就足以查資料、逛論壇或是到社群平台串門子了。若對於效率有要求，還可以再讀 Vimium 的說明，學習以 home row 為核心的鍵盤操作。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>網頁瀏覽是少量文字編輯，加上大量查詢、瀏覽、點擊與切換等指令的循環。鍵鼠系統已能流暢地瀏覽網頁，所以是否要單用鍵盤瀏覽網頁是風格問題，我對此議題的總結如下，</p>
<ul>
<li><strong>格調重於成效</strong>：「社會組織是一部大型機器，每個人都是維繫機器運作必要的鏍絲釘。」雖然必要，但無可避免被取代。有時小小的不一樣，可以讓自己多少脫離被束縛與異化的感受。</li>
<li><strong>搜索取代遍歷</strong>：鍵盤操作較不直覺，但很精準，行為可以直接反映想法，不用經過滑鼠拖曳或是<code>Tab</code>切換的過程。</li>
<li><strong>自訂創造風格</strong>：按鍵數量有限，但可透過模式切換、特殊控制鍵、輸入順序、指令組合等方式來擴充可容納的指令。儘管擁有選項，卻不存在預設值，若想使用鍵盤就得思考和選擇，決定什麼才適合現今的自己。</li>
</ul>
<p>在實務上，只要學習 Vimium 的快搜鍵 <code>f</code> 加上瀏覽器內建按鍵（例如方向鍵），就可以應對網頁瀏覽的多數需求了。</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜程式碼區塊的跳脫符號 (escape characters)</title>
    <url>/nextflow-escape-characters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹程式碼定義變項的符號與 nextflow 內建語法衝突時，有哪些選項可以解決之。</p>
<span id="more"></span>
<h2 id="Nextflow-管理程式的單位"><a href="#Nextflow-管理程式的單位" class="headerlink" title="Nextflow 管理程式的單位"></a>Nextflow 管理程式的單位</h2><p>Process 是 Nextflow 管理程式的單位，其中必然包含 script 區塊來定義想執行的程式。除了 script 區塊，還有 directives（環境設置）、inputs（輸入資料）、outputs（輸出資料）等非必要但有助流程控管的區塊。</p>
<p>在執行程式前，Nextflow 會解讀 script 區塊帶有 <code>$</code> 前綴的變項，代入 inputs、parameters 或 config files 的對應內容。<br>以 process fastQC 為例，nextflow 將 <code>fq</code> (input) 的內容代入 <code>$&#123;fq&#125;</code> (script) 後才執行程式，再將輸出結果透過 <code>fqc</code>(output) 傳遞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process fastQC &#123;</span><br><span class="line">    publishDir &quot;$&#123;params.outdir&#125;/qc&quot;, mode: &#x27;copy&#x27;, overwrite: true</span><br><span class="line">    input:</span><br><span class="line">        path fq</span><br><span class="line">    output:</span><br><span class="line">        path &quot;*_fastqc.&#123;zip,html&#125;&quot; into fqc</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    fastqc --nogroup -q $&#123;fq&#125;</span><br><span class="line">    &quot;&quot;&quot;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程式碼與nextflow-語法衝突"><a href="#程式碼與nextflow-語法衝突" class="headerlink" title="程式碼與nextflow 語法衝突"></a>程式碼與nextflow 語法衝突</h2><p>值得留意的是，perl 或 bash 等語言也使用 <code>$</code> 標記變項（例如：<code>$i</code>、<code>$path</code>）。Nextflow 無法區分以 <code>$</code> 為前綴的變項是定義在 script 內（script 變項），還是得自於 inputs, parameters 或 config files（nextflow 變項）。</p>
<p>因此，如果程式碼出現以 <code>$</code> 定義或呼叫的 script 變項 ，nextflow 便有可能因為無法在 inputs、parameters 或 config files 找到對應內容而報錯。</p>
<p>舉以下案例來說，<code>title</code>&#x2F;<code>$title</code> 是使用 bash 定義的 script 變項。然而，nextflow 卻誤判該變項的來源，以至於找不到其內容（<code>No such variable</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># printPath.nf</span><br><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title=&quot;The current directory is,&quot;</span><br><span class="line">    echo &quot;$title \n $PWD&quot;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    printDir().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run printPath.nf</span><br><span class="line">Error executing process &gt; &#x27;printDir&#x27;</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">    No such variable: title -- Check script &#x27;printDir.nf&#x27; at line: 4</span><br></pre></td></tr></table></figure>

<p>對於這個問題，主要的解法是透過更換標記符號來區分 script 變項和 nextflow 變項。</p>
<h2 id="更換-nextflow-變項的標記符號"><a href="#更換-nextflow-變項的標記符號" class="headerlink" title="更換 nextflow 變項的標記符號"></a>更換 nextflow 變項的標記符號</h2><p>第一種方法是改以三個單引號夾註程式碼，提示 nextflow 改以 <code>！&#123;&#125;</code> 標記 nextflow 變項。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更換-跳脫-script-變項的標記符號"><a href="#更換-跳脫-script-變項的標記符號" class="headerlink" title="更換 (跳脫) script 變項的標記符號"></a>更換 (跳脫) script 變項的標記符號</h2><p>若 script 變項不多，也可以在 <code>＄</code> 前面加上反斜線(<code>\$</code>)，提示 nextflow 忽略 <code>$</code> 符號。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processs printDir &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br></pre></td></tr></table></figure>
<pre><code>title=&quot;The current directory is,&quot;
echo &quot;\$title \n $PWD&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="更動跳脫字元"><a href="#更動跳脫字元" class="headerlink" title="更動跳脫字元"></a>更動跳脫字元</h2><p>由於 nextflow 的底層是 groovy，所以除了 script 與 nextflow 的語法衝突，也可能碰到 script 與 groovy 語法衝突的狀況。</p>
<p>以下兩個案例都在 script 區塊使用反斜線來編輯文字。由於反斜線是 groovy 預設的跳脫符號，所以執行這些 processes 時也可能發生編譯錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sepReplace.nf</span><br><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    sepReplace().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run sepReplace.nf</span><br><span class="line">(skip)</span><br><span class="line">Command error:</span><br><span class="line">    .command.sh line3: unexpected EOF while looking for matching `&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>或是<a href="https://github.com/nextflow-io/nextflow/issues/67">這個案例</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># strRemove.nf</span><br><span class="line">process strRemove &#123;</span><br><span class="line">    outpur:</span><br><span class="line">        stdout</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    echo &quot;Hello lg:en&quot; | sed &quot;s/.*lg:\(.*\).*/\1/&quot;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    strRemove().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run strRemove.nf</span><br><span class="line">Script compilation error</span><br><span class="line">- file : /path/to/workdir/strRemove.nf</span><br><span class="line">- cause: Unexpected character: &#x27;\&#x27;&#x27; @ line 4, column 7.</span><br><span class="line">       &#x27;&#x27;&#x27;</span><br><span class="line">         ^</span><br></pre></td></tr></table></figure>

<p>碰到這種情形，首先要使用 <code>$/</code> 和 <code>/$</code> 夾註程式碼，提示 groovy 改以 <code>$</code> 作為跳脫符號，以區分 script 和 groovy 語法。</p>
<p>接著，在 script 變項的 <code>$</code> 前面再加一個 <code>$</code> (<code>$$</code>)，提示 nextflow 忽略 <code>$</code> 符號，以區分 script 和 nextflow 語法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    $/</span><br><span class="line">    str=&quot;A,B,C&quot;</span><br><span class="line">    echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br><span class="line">    /$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封裝為腳本"><a href="#封裝為腳本" class="headerlink" title="封裝為腳本"></a>封裝為腳本</h2><p>不過，如果程式碼用到大量變項，前述方法會讓程式碼顯得囉嗦又不易讀。此時，可以考慮將程式碼封裝為腳本，再從 script 區塊呼叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># sepReplace.sh</span><br><span class="line">str=&quot;A,B,C&quot;</span><br><span class="line">echo $$str | sed &quot;s/,/\&quot;/g&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process sepReplace &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    $baseDir/sepReplace.sh</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為 nextflow、bash、perl 都以 <code>$</code> 標記變項，所以執行 process 時可能會無法正確辨識 script 區塊內的變項來源而報錯。可能的解決途徑如下，</p>
<ul>
<li><strong>nextflow 變項少</strong>：以三個單引號夾註程式碼，再以 <code>！&#123;&#125;</code> 標記 nextflow 變項</li>
<li><strong>script 變項少</strong>：以 <code>\</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>出現反斜線</strong>：以 <code>$/</code> 和 <code>/$</code> 夾註程式碼，再以 <code>$</code> 跳脫 script 變項的 <code>$</code></li>
<li><strong>程式碼龐雜</strong>：將程式碼封裝為腳本，再從 process 呼叫腳本</li>
</ul>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜模仿 docstring 來註解 process and workflow</title>
    <url>/nextflow-extract-docstring-from-a-module/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介紹使用 docstring 的好處，並且探討如何在 Nextflow 使用多行註解模仿 python 的 docstring，從而改善撰寫與維護開發文件的流暢性。</p>
<span id="more"></span>

<p>python 的 docstring 是 function 的強大特性，能讓開發者在參數類別之外，補充關於 function 的用途、假設條件以及運作原理等額外資訊。透過 <code>__doc__</code> 屬性，docstring 能夠被其他程式讀取，實現開發文檔自動化等功能。</p>
<p>更重要的是，docstring 位於 function 內部，這讓開發者更動程式碼後，能夠輕易地同步更新文檔，減少文檔與程式碼不一致的情形。</p>
<p>然而，Nextflow 目前並不支援 docstring 功能。不過，我們可使用多行註解（即介於 <code>/*</code> 與 <code>*/</code> 之間的文字）來模仿 docstring 的效果。這對於協助開發者了解當前的 module（無論是 process 或 workflow）都很有幫助。</p>
<p>鑒於 Nextflow 的註解無法像 python docstring 那樣透過物件方法呼叫，我寫了一支小腳本來<a href="https://github.com/5uperb0y/nf-tools/tree/main/src/get_docstring">節錄這些資訊</a>。</p>
<p>簡言之，我將位於 module 名稱與 directive 之間的多行註解定義為 Nextflow 的 docstring，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process &lt;name&gt; &#123;</span><br><span class="line">	<span class="comment">/* your comments */</span></span><br><span class="line">	directives</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	your code</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這支腳本運用正則表達式（感謝 chatgpt 幫忙想出裏頭可怕的正則表達式）來抓取 docstring，將其與 module 類型（即 workflow 或 process）和名稱一併輸出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python get_docstring.py workflow.nf</span><br><span class="line">process FASTQC</span><br><span class="line">this text is from FASTQC</span><br><span class="line">workflow VARIANT_CALLING</span><br><span class="line">this text is from VARIANT_CALLING</span><br></pre></td></tr></table></figure>
<p>如此一來，我們就能取得 docstring 的內容，不僅方便瀏覽 module 功能，也便於自動生成文檔。</p>
<p>雖然目前功能還蠻陽春的，但之後也許可以新增其他實用功能，例如支援以名稱篩遠 docstring，或是使用 groovy 開發，使之能在 Nextflow 內部調用。</p>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜如何為輸入的資料建立辨識碼</title>
    <url>/nextflow-combine-data-into-a-tuple-with-key/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 Nextflow 的框架，channel 媒介了 process 間的資料傳遞。雖然資料進出 channel 遵循先進先出 (first-in, first out, FIFO) 原則，但隨後 nextflow 會平行處理這些資料，所以 process 釋出資料的順序取決於執行速率，而不是原先輸入的順序（見下例）。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demoEmitOrder.nf</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val num</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;num&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    nums = channel.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    nums.view()</span><br><span class="line">    A(nums).view() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoEmitOrder.nf</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Nextflow 這項特性使得輸入彼此相依的資料時要格外留意，因為可能在定序產物品管時，發生不同樣本的順逆序列（例如：a_r1.fa 與 b_r2.fa 合併）的狀況；又或是使用 GATK 這類需要參考基因體的工具時，無法為 <code>.fasta</code> 找到對應 <code>.dict</code> 和 <code>.fai</code> 檔的情形。</p>
<p>因此，本文將介紹如何將想要一起輸入的檔案以及其辨識碼組合成 tuple （例如：<code>[&quot;ID&quot;, &quot;ID_r1.fastq&quot;, &quot;ID_r2.fastq&quot;]</code>），確保成對資料同進同出，還能透過辨識碼與其它資料合併。</p>
<span id="more"></span>

<h1 id="準備測試資料"><a href="#準備測試資料" class="headerlink" title="準備測試資料"></a>準備測試資料</h1><p>首先建立雙端定序產物與人體基因體序列的測試資料，用以示範成對資料和多筆資料各自要如何組合成 tuple。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> data</span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;_r&#123;1,2&#125;.fq           <span class="comment"># 示範成對資料</span></span><br><span class="line">$ <span class="built_in">touch</span> data/&#123;a..c&#125;.&#123;fasta,dict,fai&#125;    <span class="comment"># 示範多筆資料</span></span><br></pre></td></tr></table></figure>

<p>接著，在 nextflow script (<code>*.nf</code>) 定義這些資料以建立 input channel。此處這麼做是為了簡便，但其實也可以將資料路徑寫到 JSON 檔，在執行 nextflow script 時，透過 <code>-c</code> 或 <code>-params-file</code> 讀入。要留意的是，欲組合在一起的資料於 nextflow 變項的順序要一致，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">inDir = <span class="string">&quot;/path/to/data&quot;</span></span><br><span class="line">id = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">fq1 = [<span class="string">&quot;$inDir/a_r1.fq&quot;</span>, <span class="string">&quot;$inDir/b_r1.fq&quot;</span>, <span class="string">&quot;$inDir/c_r1.fq&quot;</span>]</span><br><span class="line">fq2 = [<span class="string">&quot;$inDir/a_r2.fq&quot;</span>, <span class="string">&quot;$inDir/b_r2.fq&quot;</span>, <span class="string">&quot;$inDir/c_r2.fq&quot;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="透過-nextflow-operator"><a href="#透過-nextflow-operator" class="headerlink" title="透過 nextflow operator"></a>透過 nextflow operator</h1><p>假設已經把辨識碼與輸入資料定義成前一節的形式，而且要組合在一起的資料於 nextflow 各變項內的順序也相同，那麼可以先建立包含全數資料的 tuple，再使用 <code>transpose</code> operator 轉置。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.of([id, fq1, fq2]).transpose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/combine-data-into-a-tuple-with-key_transpose.png?raw=true" alt="`transpose` 能轉置 channel 的組成。"></p>
<p>由於 channel 遵循 FIFO 原則，所以使用 <code>view()</code> 瀏覽結果時，確認資料釋出與輸入順序一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure>
<h1 id="透過-bash-in-process"><a href="#透過-bash-in-process" class="headerlink" title="透過 bash in process"></a>透過 bash in process</h1><p>假設辨識碼為檔名的一部份，那麼也可以用 bash script 擷取字串，並在 output channel 將擷取到的辨識碼與輸入的資料組合成 <code>tuple</code>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process addID &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path fq1</span><br><span class="line">        path fq2</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        tuple env(id), path(fq1), path(fq2)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        id=\$(basename -s _r1.fq $&#123;fq1&#125;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    addID(channel.fromPath(fq1), channel.fromPath(fq2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於經 process 處理，資料釋出順序已偏離輸入順序，紀錄的路徑也轉移到 process 的工作目錄了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r1.fq, /path/to/work/c2/3169d4c100067150f54629d968b7fb/a_r2.fq]  </span><br><span class="line">[c, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r1.fq, /path/to/work/2a/f8e10f5efe89d9c99d5814f5c7a151/c_r2.fq]  </span><br><span class="line">[b, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r1.fq, /path/to/work/9b/b8295d80236b0871e5a197845b0ec1/b_r2.fq]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="透過-channel-factory-限定成對資料"><a href="#透過-channel-factory-限定成對資料" class="headerlink" title="透過 channel factory (限定成對資料)"></a>透過 channel factory (限定成對資料)</h1><p>如果辨識碼是檔名的一部份，而且資料又如雙端定序產物兩兩一組，那麼也可以使用 <code>fromFilePairs</code> 建立 <code>tuple</code>。簡言之，nextflow 會搜尋指定目錄下含有成對詞綴的檔案（此例為 <code>_r1.fq</code> 與 <code>_r2.fq</code>），擷取詞綴前的字串，將成對資料組合成帶有辨識碼的 <code>tuple</code>。</p>
<p>預設是組合成 <code>[&quot;id&quot;, [&quot;path 1&quot;, &quot;path 2&quot;]]</code> 形式，所以此處使用 <code>flat:true</code> 攤平巢狀結構。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromFilePairs(<span class="string">&quot;$inDir/*_r&#123;1,2&#125;.fq&quot;</span>, <span class="attr">flat:</span><span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a_r1.fq, /path/to/data/a_r2.fq]</span><br><span class="line">[b, /path/to/data/b_r1.fq, /path/to/data/b_r2.fq]</span><br><span class="line">[c, /path/to/data/c_r1.fq, /path/to/data/c_r2.fq]</span><br></pre></td></tr></table></figure>
<h1 id="結合-channel-operator-和-groovy-closure"><a href="#結合-channel-operator-和-groovy-closure" class="headerlink" title="結合 channel operator 和 groovy closure"></a>結合 channel operator 和 groovy closure</h1><p><code>fromFilePairs</code> 僅適用成對資料，若是多筆資料則要組合 nextflow operator 和 groovy closure 來完成。</p>
<ol>
<li>以 <code>fromPath</code> 建立 channel 時，搜尋不同詞綴的檔案</li>
<li>以 groovy <em>getBaseName</em> 擷取檔名，再用 nextflow <code>map</code> 將檔名與檔案路徑組合成 tuple（例如：<code>a.fasta</code>→<code>［&quot;a&quot;, &quot;a.fasta&quot;]</code>）</li>
<li>以 <code>groupTuple</code> 組合含有相同辨識碼的 tuple（例如：<code>[&quot;a&quot;, &quot;a.fasta&quot;]</code> 與 <code>[&quot;a&quot;, &quot;a.dict&quot;]</code> 組合成 <code>[&quot;a&quot;, [&quot;a.fasta&quot;, &quot;a.dict&quot;]]</code>）</li>
<li>以 <code>map</code> 配合 groovy <em>flatten</em> 攤開巢狀 <code>tuple</code></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">workflow &#123;</span><br><span class="line">    channel.fromPath([<span class="string">&quot;$inDir/*.dict&quot;</span>, <span class="string">&quot;$inDir/*.fasta&quot;</span>, <span class="string">&quot;$inDir/*.fai&quot;</span>])</span><br><span class="line">        .map&#123;it -&gt; tuple(it.getBaseName(), it)&#125;</span><br><span class="line">        .groupTuple()</span><br><span class="line">        .map&#123;it -&gt; it.flatten()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此處假設檔名等同辨識碼，若辨識碼是檔名的子字串或其它組合，那就要參考 groovy 的字串處理方式。這裡使用 groovy 是為了要在 nextflow script 完成任務，若不限此條件，那也可以新增 process，改用熟悉的腳本語言來處理字串（參考 bash script 的方法）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a, /path/to/data/a.fasta, /path/to/data/a.dict, /path/to/data/a.fai]</span><br><span class="line">[b, /path/to/data/b.fasta, /path/to/data/b.dict, /path/to/data/b.fai]</span><br><span class="line">[c, /path/to/data/c.fasta, /path/to/data/c.dict, /path/to/data/c.fai]</span><br></pre></td></tr></table></figure>

<h1 id="怎麼讀取資料"><a href="#怎麼讀取資料" class="headerlink" title="怎麼讀取資料"></a>怎麼讀取資料</h1><p>前述建立的 <code>tuple</code> 可用以下方式讀入 process，也可以用 <code>join</code> 組合，確保成對或多筆資料能夠在 process 同進同出。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process readInput &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        tuple val(id), path(fq1), path(fq2)</span><br><span class="line">        tuple val(id), path(fasta), path(dict), path(fai)</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fq1&#125;, $&#123;fq2&#125;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;id&#125;, $&#123;fasta&#125;, $&#123;dict&#125;, $&#123;fai&#125;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>最後使用一張表總結將資料組合為 <code>tuple</code> 的方法。</p>
<table>
<thead>
<tr>
<th>比較項目</th>
<th>operator</th>
<th>bash in process</th>
<th>fromFilePairs</th>
<th>operator &amp; closure</th>
</tr>
</thead>
<tbody><tr>
<td>檔案數</td>
<td>不限</td>
<td>不限</td>
<td>兩筆</td>
<td>不限</td>
</tr>
<tr>
<td>定義</td>
<td>需定義檔案路徑</td>
<td>需定義檔案路徑</td>
<td>檔案存放路徑</td>
<td>檔案存放路徑</td>
</tr>
<tr>
<td>釋出順序</td>
<td>輸入順序</td>
<td>完成順序</td>
<td>輸入順序</td>
<td>輸入順序</td>
</tr>
<tr>
<td>檔案位置</td>
<td>輸入路徑</td>
<td>工作目錄</td>
<td>輸入路徑</td>
<td>輸入路徑</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜資料是怎麼在 Process 間傳遞？</title>
    <url>/nextflow-how-data-is-passed-between-processes-through-channels/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Process 是 nextflow 管理分析流程的基本單位，可包含能在 linux shell 執行的程式碼（例如 linux command, python code）、腳本（例如自訂的 hello-world.sh）與軟體（例如 GATK 或 FastQC）。 Process 之間彼此獨立，各有各的工作目錄，也可以分別設定其執行環境（例如 docker container 或 conda environment）。</p>
<p>Channel 則媒介了 process 間的資料交流，若不透過 channels 串接，process 間的檔案或變項無法共享。舉凡字串、數值、檔案路徑乃至標準輸出等，皆有對應的 qualifier 讓 nextflow 知道怎麼處理得自於 channel 的各式資料。</p>
<span id="more"></span>
<p>在以下案例，我在 process A 定義了兩條字串，並透過不同途徑傳遞給 process B。</p>
<p>首先，string 1 被寫入檔案 (<code>str.txt</code>)，再以 path qualifier 告訴 Nextflow，把檔案路徑用軟連結 (symbolic link) 掛到 process B 的工作目錄。至於 string 2 則被定義為變項 (strAsEnv, a bash variable)，再以 env qualifier 告訴 nextflow 把變項寫到 process A 工作目錄內的 <code>.command.env</code>。</p>
<p>接著，分別以 strInFile 及 strAsEnv 命名由 process A 輸出 channel，傳遞給 process B 印出。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供 process B 所需的字串</span></span><br><span class="line">process A &#123;</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;str.txt&quot;</span>, <span class="attr">emit:</span> strInFile</span><br><span class="line">        env strAsEnv, <span class="attr">emit:</span> strAsEnv</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;string 1&quot; &gt; &quot;str.txt&quot;</span></span><br><span class="line"><span class="string">        strAsEnv=&quot;string 2&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 印出 process A 提供的字串</span></span><br><span class="line">process B &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        path strInFile</span><br><span class="line">        val strAsEnv </span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        echo &quot;\$(cat $&#123;strInFile&#125;) is retrieved from a file passed by a queue channel&quot;</span></span><br><span class="line"><span class="string">        echo &quot;$&#123;strAsEnv&#125; is retrieved from a environment variable passed by a value channel&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 執行 process A &amp; B</span></span><br><span class="line">workflow &#123;</span><br><span class="line">    A()</span><br><span class="line">    B(A.out.strInFile, A.out.strAsEnv).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoChannel.nf </span><br><span class="line">Launching `demoChannel.nf` [compassionate_shannon] - revision: 319cfe997a</span><br><span class="line">executor &gt;  <span class="built_in">local</span> (2)</span><br><span class="line">[f3/e5a365] process &gt; A [100%] 1 of 1 ✔</span><br><span class="line">[b0/f79f8e] process &gt; B [100%] 1 of 1 ✔</span><br><span class="line">string 1 is retrieved from a file passed by a queue channel</span><br><span class="line">string 2 is retrieved from a environment variable passed by a value channel</span><br></pre></td></tr></table></figure>
<p>各 process 的工作目錄預設建立在執行路徑下的<code>work</code>，直接觀察工作目錄內的暫存檔有助於了解 path 與 env 兩種資料傳遞方式的差異<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案">1</span></a></sup>。</p>
<p>在 process A 的工作目錄 ([f3&#x2F;e5a365]) 裡，除了輸出的 str.txt，還有 <code>.command.env</code>。Nextflow 在執行時會將所有用 env qualifier 標記的變項定義式（即　<code>var=value</code> 這種格式）寫入 <code>.command.env</code>，以利隨後可輸出到其它 process。（可查看 <code>.command.sh</code> 查看寫入變項定義式的程式碼）</p>
<p>目前，只有 bash 變項才能透過 env qualifier 輸出，其它語言的變項只能透過某些方式存成檔案輸出（例如 R 的 RDS 檔）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /work/f3/e5a365e3bb7b645cf4e13cf15eb235</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">-rw-r--r-- 1 user group   18 Jan  5 22:26 .command.env      <span class="comment"># environment variables of process A</span></span><br><span class="line">-rw-r--r-- 1 user group  146 Jan  5 22:26 .command.sh       <span class="comment"># commands to execute process A</span></span><br><span class="line">-rw-r--r-- 1 user group    9 Jan  5 22:26 str.txt           <span class="comment"># output of process A</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.env</span><br><span class="line">strAsEnv=string 2</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .command.sh　 <span class="comment"># nextflow 執行 process 的腳本，只擷取跟 `.command.env` 相關的部分</span></span><br><span class="line"><span class="comment"># capture process environment</span></span><br><span class="line"><span class="built_in">set</span> +u</span><br><span class="line"><span class="built_in">echo</span> strAsEnv=<span class="variable">$&#123;strAsEnv[@]&#125;</span> &gt; .command.env</span><br></pre></td></tr></table></figure>

<p>而在 process B 的工作目錄可留意到 str.txt 的資料型別為 <code>l</code> (link)，檔案名稱也標示了來源。值得留意的是，如果使用 <code>cat</code> 或 <code>cp</code> 等指令通常不會有什麼問題，但如果用 <code>ls</code> 顯示檔案大小時，要注意預設顯示的是軟連結的大小，而非原檔的大小。相似的狀況也可能發生在使用 <code>find</code> 搜尋時，因為限制了搜索標的為檔案而意外地排除軟連結的情形。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/work/b0/f79f8e550a4e1af11e2b03af8b4aa4$ <span class="built_in">ls</span> -al</span><br><span class="line">lrw-r--r-- 1 user group   62 Jan  5 22:26 str.txt -&gt; /work/f3/e5a365e3bb7b645cf4e13cf15eb235/str.txt</span><br></pre></td></tr></table></figure>

<p>綜上所述，要怎麼利用 channel 傳遞資料端視資料型別而異。無論想傳遞表格、文檔還是變項，都可以將其寫入檔案，再以 path qualifier 讓 nextflow 依據檔案路徑在下游 process 的工作目錄建立軟連結。若想傳遞的是 bash 變項，那還可以使用 env qualifier 將變項定義式記錄在當前 process 的工作目錄供後續取用。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處只列舉 process A 和 B 工作目錄內檔名或型別有別的檔案<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜如何改善用戶的命令列使用體驗</title>
    <url>/nextflow-improve-user-experience-on-cli/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 的命令列介面對開發者而言已相當全面，但對一般用戶而言，仍有可以改善的空間。本文介紹一些 Nextflow 的內建功能，可以因應不同的專案結構，改善用戶的命令列使用體驗。</p>
<span id="more"></span>
<h1 id="如何執行-Nextflow-腳本？"><a href="#如何執行-Nextflow-腳本？" class="headerlink" title="如何執行 Nextflow 腳本？"></a>如何執行 Nextflow 腳本？</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run /path/to/workflow.nf\</span><br><span class="line">		 -c  /path/to/params.config\</span><br><span class="line">		 -params-file /path/to/params.json\</span><br><span class="line">		 [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>
<p>Nextflow 的命令包含幾個關鍵選項，</p>
<ul>
<li><code>run</code>：啟動腳本的選項，用於執行特定的 Nextflow 腳本</li>
<li><code>-c</code>：pipeline 的設置檔案，可調整運算環境、計算資源和日誌檔等 pipeline 相關參數，也能批次導入腳本中以 <code>params</code>定義的參數</li>
<li><code>-params-file</code>：參數批次檔，經由 <code>-params-file</code> 導入的參數優先於 <code>-c</code> 導入的參數。</li>
<li><code>--something</code>：由命令列輸入的參數，可滿足特定的運算需求，具最高優先度。</li>
</ul>
<h1 id="可能的改進空間"><a href="#可能的改進空間" class="headerlink" title="可能的改進空間"></a>可能的改進空間</h1><p>Nextflow 的命令列設計對開發者而言相當全面，但從一般用戶的角度來說，仍有一些使用上的挑戰。這些挑戰中，最明顯的是腳本與設置檔的選擇問題。對於只包含單一腳本與配置檔案的專案而言，清楚的使用說明與文件標示足以確保腳本正確使用。然而，一旦涉及多個腳本與配置檔案，容易造成使用者困惑，尤其是在必須針對不同計算環境或分析場域選擇適當設置檔的情境。</p>
<p>其次，雖然 <code>-params-file</code> 提供了參數輸入的靈活性，允許用戶批次輸入樣本並且自訂 pipeline 的參數，但這同時也將 pipeline 的核心參數和樣本相關的參數混合在一起，有可能會造成一定程度的混淆。</p>
<p>再者，自定義參數檔需要以 JSON 格式輸入，可能對一些用戶不夠友善。</p>
<h1 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h1><h2 id="預設設置檔"><a href="#預設設置檔" class="headerlink" title="預設設置檔"></a>預設設置檔</h2><p>為了簡化設置檔的指定過程，可善用 Nextflow <a href="https://www.nextflow.io/docs/latest/config.html#configuration-file">讀取參數的機制</a>，將預設參數寫在腳本內部，或是存放在腳本同層目錄下的 <code>nextflow.config</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。">1</span></a></sup>。 如此一來，若用戶未使用 <code>-c</code> 指定，Nextflow 會自動讀取這兩個參數來源以執行腳本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workflows</span><br><span class="line">|- main.nf</span><br><span class="line">|- nextflow.config</span><br></pre></td></tr></table></figure>


<h2 id="管理多元設置"><a href="#管理多元設置" class="headerlink" title="管理多元設置"></a>管理多元設置</h2><p>跨平台與情境的設置檔可以透過 Nextflow 的 <a href="https://www.nextflow.io/docs/latest/config.html#config-profiles">Configuration Profile</a> 來管理，從而避免因少量參數異動而建立多個設置檔。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiles &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        process.executor = &#x27;docker&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    k8s &#123;</span><br><span class="line">        process.executor = &#x27;k8s&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用時，可以在命令列指定相應的 profile 切換執行環境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf -profile <span class="string">&quot;k8s&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="採用表格輸入"><a href="#採用表格輸入" class="headerlink" title="採用表格輸入"></a>採用表格輸入</h2><p>為了改善輸入檔案與 pipeline 參數的管理，可以考慮使用表格形式紀錄輸入檔案的資訊，將 pipeline 相關參數另外以命令列傳入，達到區分樣本相關資訊與 pipeline 核心參數的效果。</p>
<p>讀入表格資料的方式可參考 <a href="https://nextflow-io.github.io/patterns/process-per-csv-record/">Process per CSV record</a>。假設有批定序資料要分析，其檔案路徑記錄在 <code>input.csv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;uuid&quot;,&quot;fq1&quot;,&quot;fq2&quot;</span><br><span class="line">&quot;smp1&quot;,&quot;/path/to/smp1_r1.fq&quot;,&quot;/path/to/smp1_r2.fq&quot;</span><br><span class="line">&quot;smp2&quot;,&quot;/path/to/smp2_r1.fq&quot;,&quot;/path/to/smp2_r2.fq&quot;</span><br></pre></td></tr></table></figure>
<p>則讀取方式可寫作：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">input_ch = Channel.fromPath(params.input) |</span><br><span class="line">	| splitCsv(<span class="attr">header:</span><span class="literal">true</span>) \</span><br><span class="line">	| map &#123; row -&gt; tuple(row.uuid, file(row.fq1), file(row.fq2)) &#125;</span><br></pre></td></tr></table></figure>
<p>用戶便能透過 CSV 格式管理批次輸入的資料，並透過命令列指定其餘參數。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf --input input.csv --output /path/to/output</span><br></pre></td></tr></table></figure>

<h2 id="使用入口腳本"><a href="#使用入口腳本" class="headerlink" title="使用入口腳本"></a>使用入口腳本</h2><p>在包含多個 pipeline 的專案中，可以在專案根目錄新增 <code>main.nf</code> 腳本。在這個入口腳本中，可以編寫一些幫助函數，協助用戶了解所有可用的 pipeline，或是讓用戶透過別名來快速呼叫特定的 pipeline，實踐各式各樣的客製功能。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (params.help) &#123;</span><br><span class="line">	<span class="comment">// print help messages</span></span><br><span class="line">	<span class="comment">// select pipeline to run by user-input key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣做的好處是，用戶可以用統一的名字呼叫 pipeline，不用記憶各支腳本的路徑。而且，用戶可以使用 <code>--help</code> 等參數來了解專案中各 pipeline 的用途與使用方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>綜合以上的改進方案後，用戶可以在不深入研究專案目錄結構的情況下，了解該專案能提供的分析及其使用方式，免除指定設置檔的負擔，並且以慣用的表格來管理輸入檔案。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run project --workflow &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>

<p>若需要額外的封裝和彈性，也能在 Nextflow 框架之外，開發一個能包裝其 API 的軟體，進一步簡化用戶的操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wapper &lt;name&gt; --input input.csv [--something &lt;value&gt;]</span><br></pre></td></tr></table></figure>

<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Nextflow 還不支援在腳本內指定設置檔路徑，所以暫時只有這兩套預設方式。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜輸入 empty channel 會發生什麼事？</title>
    <url>/nextflow-input-with-an-empty-channel/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上週碰到一個離奇的 bug，有支 nextflow 腳本可以順利執行，但會無聲無息地略過其中一個 process。該腳本執行後於終端吐出的訊息類似以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf</span><br><span class="line">[3c/9ab742] process &gt; a1 [100%] 1 of 1 ✔</span><br><span class="line">[8e/4eg429] process &gt; a2 [100%] 1 of 1 ✔</span><br><span class="line">[-        ] process &gt; b1</span><br><span class="line">[2f/0c0b71] process &gt; c1 [100%] 1 of 1 ✔</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><code>a1</code> 與 <code>a2</code> 輸出的 channel 經 <code>join</code> 之後輸入 <code>b1</code>，而 <code>c1</code> 則獨立於其他三個 process。</li>
<li>nextflow 沒有任何錯誤訊息（即終端看不到紅色的字）</li>
<li>nextflow 沒有為 <code>b1</code> 開啟工作目錄，所以也無從查看 <code>.command.log/err/out</code> 等與腳本執行相關的資訊</li>
<li>查看 <code>.nextflow.log</code> 只能找到啟動 <code>b1</code> 的訊息：<code>[main] DEBUG nextflow.processor.TaskProcessor - Starting process &gt; b1</code>，但沒有其他執行細節。</li>
</ul>
<h1 id="解決策略"><a href="#解決策略" class="headerlink" title="解決策略"></a>解決策略</h1><p>由於 nextflow 幾乎沒有給出任何提示，所以只能自己想辦法在腳本內安排中斷點印出 channel 的內容。當時的策略是先不用 <code>join</code>，而是單獨輸入 <code>a1</code> 與 <code>a2</code> 的輸出，以便用 <code>stdout</code> 和 <code>view()</code>檢查各個 channel 是否與我們預期相同。</p>
<p>結果問題還真的出在 channel 的合併，原來 <code>a1</code> 與 <code>a2</code> 的輸出結果沒有共同的 key，所以執行 <code>join</code> 操作後會生成一個 empty channel。</p>
<h1 id="Empty-channel"><a href="#Empty-channel" class="headerlink" title="Empty channel"></a>Empty channel</h1><p>在 Nextflow 裏頭，可使用 <code>channel.empty()</code>建立 empty channel，其作用相當於對 process 傳遞終止訊號（參考 <a href="https://javadoc.io/static/io.nextflow/nextflow/0.28.2/nextflow/Channel.html">Nextflow Channel Class 的說明</a>）。</p>
<p>舉例來說，以下這支 nextflow 腳本會依序印出同一時間輸入的數對。雖然 <code>a_ch</code> 含有四項數字，但因為 <code>b_ch</code> 其中一項為 empty channel 的終止訊號，所以這個 process 只遞交並執行了三次<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="執行腳本時，nextflow 會先以 `nextflow.processor.TaskProcessor` 啟動 process，透過 `nextflow.executor.LocalHandler` 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 `.nextflow.log`。">1</span></a></sup>。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demoEmptyChannel.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($&#123;a&#125;, $&#123;b&#125;)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>, <span class="string">&quot;a4&quot;</span>)</span><br><span class="line">    b_ch = channel.of(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>).concat(channel.empty()).concat(channel.of(<span class="string">&quot;b4&quot;</span>)) <span class="comment">// append items with concat() and channel.of()</span></span><br><span class="line">    p(a_ch, b_ch).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoEmptyChannel.nf</span><br><span class="line">[a8/4b2c55] process &gt; p (3) [100%] 3 of 3 ✔</span><br><span class="line">(a3, b4)</span><br><span class="line">(a2, b2)</span><br><span class="line">(a1, b1)</span><br></pre></td></tr></table></figure>

<h1 id="使用-ifEmpty-為輸入-channel-設定預設值"><a href="#使用-ifEmpty-為輸入-channel-設定預設值" class="headerlink" title="使用 ifEmpty 為輸入 channel 設定預設值"></a>使用 <code>ifEmpty</code> 為輸入 channel 設定預設值</h1><p>為了避免 process 被跳過或是沒有執行的狀況，<a href="https://www.nextflow.io/docs/latest/operator.html#operator-ifempty">nextflow 官方文件</a>建議以 <code>ifEmpty</code> 為 channel 設定預設值。如以下案例，由於 <code>b_ch</code> 為 empty channel，經 <code>ifEmpty</code> operator 賦予預設值，使得 process 能順利運行。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demoIfEmpty.nf</span></span><br><span class="line">process p &#123;</span><br><span class="line">    <span class="symbol">input:</span></span><br><span class="line">        val a</span><br><span class="line">        val b</span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;($a, $b)&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>&#125;</span><br><span class="line">workflow &#123;   </span><br><span class="line">    a_ch = channel.of(<span class="string">&quot;a1&quot;</span>)</span><br><span class="line">    <span class="comment">// &lt;defalut value&gt; if ch.isempty() else ch</span></span><br><span class="line">    b_ch = channel.empty()</span><br><span class="line">    p(a_ch, b_ch.ifEmpty(<span class="string">&quot;b_default&quot;</span>)).view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run demoIfEmpty.nf</span><br><span class="line">[47/459729] process &gt; p (1) [100%] 1 of 1 ✔</span><br><span class="line">(a1, b_default)</span><br></pre></td></tr></table></figure>

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 的 process 會跳過含有 empty channel 的任務，若想避免這種狀況在非預期的情形發生（例如 <code>join</code> 失敗），可使用 <code>ifEmpty</code> 為 process 的輸入 channel 設定預設值。</p>
<h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul>
<li><a href="https://stackoverflow.com/questions/70888844/nextflow-how-to-fail-if-channel-is-empty-ifempty">NextFlow: How to fail if channel is empty ( .ifEmpty() )</a></li>
<li><a href="https://stackoverflow.com/questions/64042860/check-if-nextflow-channel-is-empty">check if nextflow channel is empty</a>)</li>
<li><a href="https://github.com/nextflow-io/nf-hack18/blob/master/asciidocs/07_processes.adoc">Nextflow Workshop Hackaton 2018: 07_processes</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">執行腳本時，nextflow 會先以 <code>nextflow.processor.TaskProcessor</code> 啟動 process，透過 <code>nextflow.executor.LocalHandler</code> 一一提交輸入 channel 的內容給 process 執行。詳細的流程可參閱 <code>.nextflow.log</code>。<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜怎麼從運行中的腳本取回參數？</title>
    <url>/nextflow-retrieve-configuration-when-workflow-runs/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在執行腳本前，Nextflow 會讀取設置檔 (configuration files) 中的參數，將之代入腳本的對應位置後再執行程式。這項特性有助於使用者管理複雜流程的輸入值與環境設定，也將具體數值從流程邏輯抽離，讓開發者專注於流程的梳理與串接。</p>
<p>然而，隨著流程腳本改版，設置檔的內容也可能跟著改變，是否有方法能記錄執行流程時使用的設置檔，以利往後重現分析或追蹤歷次設定？</p>
<p>在這篇文中，我首先介紹了 nextflow 導入參數的方式，再陳述取回參數的可行策略，並附上這些策略的最簡範例供參考。</p>
<span id="more"></span>

<h2 id="Nextflow-導入參數的方式"><a href="#Nextflow-導入參數的方式" class="headerlink" title="Nextflow 導入參數的方式"></a>Nextflow 導入參數的方式</h2><p>以下是 nextflow 導入參數的常見方式，若一參數被多種方式定義，則會以順位較小者為準。</p>
<table>
<thead>
<tr>
<th>順位</th>
<th>方式</th>
<th>範例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>於命令列輸入</td>
<td><code>nextflow run workflow.nf --something value</code></td>
</tr>
<tr>
<td>2</td>
<td>以 <code>-params-file</code> 導入</td>
<td><code>nextflow run workflow.nf -params-file params.json</code></td>
</tr>
<tr>
<td>3</td>
<td>以 <code>-c</code> 導入</td>
<td><code>nextflow run workflow.nf -c params.config</code></td>
</tr>
<tr>
<td>4</td>
<td>於 nextflow 腳本內宣告</td>
<td><code>params.something = value</code></td>
</tr>
</tbody></table>
<h2 id="使用-params-取回參數"><a href="#使用-params-取回參數" class="headerlink" title="使用 params 取回參數"></a>使用 <code>params</code> 取回參數</h2><p>其中一個方法是讀取 <code>params</code> 的內容，<code>params</code>是 nextflow 的<a href="https://www.nextflow.io/docs/latest/script.html?highlight=implicit#implicit-variables">隱變項</a>，採用 <code>[key1:value1, key2:value2,...]</code>格式存儲以不同方式導入的參數。</p>
<h3 id="params-json"><a href="#params-json" class="headerlink" title="params.json"></a>params.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;paramsDerivedConfig&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;provided using the -params-file option&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="params-config"><a href="#params-config" class="headerlink" title="params.config"></a>params.config</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">params &#123;</span><br><span class="line">    configDerivedConfig = <span class="string">&quot;specified using the -c option&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getConfig-nf"><a href="#getConfig-nf" class="headerlink" title="getConfig.nf"></a>getConfig.nf</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">params.inScriptConfig = <span class="string">&quot;defined within the script itself&quot;</span></span><br><span class="line">process retrieveConfigFromParams &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$params&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf --commandSpecifiedConfig <span class="string">&quot;specified on the command line&quot;</span> -params-file params.json -c params.config</span><br><span class="line">[configDerivedConfig:specified using the -c option, config-derived-config:specified using the -c option, paramsDerivedConfig:provided using the -params-file option, params-derived-config:provided using the -params-file option, commandSpecifiedConfig:specified on the <span class="built_in">command</span> line, command-specified-config:specified on the <span class="built_in">command</span> line, inScriptConfig:defined within the script itself, in-script-config:defined within the script itself]</span><br></pre></td></tr></table></figure>

<h2 id="從輸入路徑取回參數"><a href="#從輸入路徑取回參數" class="headerlink" title="從輸入路徑取回參數"></a>從輸入路徑取回參數</h2><p>然而，前述方法只能取回以 <code>params</code> 存儲的參數，若想取得 <code>process</code>, <code>docker</code>, <code>report</code> 等<a href="https://www.nextflow.io/docs/latest/config.html?highlight=params#config-scopes">其它設置 (configuration scope)</a>，可以讀取位於 <code>$launchDir</code> 的 <code>.nextflow.log</code>，從中獲得當初執行腳本時輸入的 <code>*.config</code> 路徑，再將設置擋複製出來。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">process getConfig &#123;</span><br><span class="line">    output:</span><br><span class="line">        stdout</span><br><span class="line">    shell:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    str=$(grep &quot;User config file:&quot; &quot;!&#123;launchDir&#125;/.nextflow.log&quot;)</span></span><br><span class="line"><span class="string">    config=$&#123;str##*:&#125;</span></span><br><span class="line"><span class="string">    echo $&#123;config&#125;</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">workflow &#123;</span><br><span class="line">    getConfig().view()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nextflow run getConfig.nf -c params.config</span><br><span class="line">/home/user/workflow/params.config</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>若能從運行中的 nextflow 腳本取回輸入參數，將有助於往後重現分析或追蹤設置。目前，nextflow 有兩個隱變項能協助我們達成這項任務，</p>
<ul>
<li><code>params</code>：記錄了不同管道導入的參數，可以在 <code>*.nf</code> 檔各處呼叫以取得書入的參數和設定。</li>
<li><code>launchDir</code>：雖然本身與參數無關，但此變項記錄了腳本執行位置，其中的 <code>.nextflow.log</code> 記錄了 <code>*.config</code> 路徑。讀取該檔即可獲取輸入的參數和設定。</li>
</ul>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜背景執行 workflow 的方法</title>
    <url>/nextflow-run-in-background/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般而言，若想要背景執行 linux 指令，可在指令末端添加 <code>&amp;</code>，或是透過 <code>ctrl + z</code> 配合 <code>bg %n</code> 將執行中的指令挪到背景執行。然而，nextflow 腳本卻不適用這種做法（version &gt;&#x3D; 21.10.6），指令挪到背景後會陷入停止狀態。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf &amp;</span><br><span class="line">[1] 533</span><br><span class="line">Launching `workflow.nf` [sick_waddington] - revision: 123b1ec198</span><br><span class="line">[2]+  Stopped                 nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<p>一旦陷入停止狀態，會變得異常難清，要用 <code>kill %n &amp;&amp; fg</code> 才能一次清掉（參考<a href="https://gitter.im/nextflow-io/nextflow/archives/2020/09/16">論壇的討論</a>）。</p>
<span id="more"></span>
<h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p>即使透過 <code>.sh</code> 來執行 nextflow 腳本也會遭遇相同的狀況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># run_workflow.sh</span><br><span class="line">nextflow run workflow.nf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./run_workflow.sh &amp;</span><br><span class="line">N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [trusting_hamilton] - revision: 936bafe285</span><br><span class="line">[1]-  Stopped                 <span class="built_in">nohup</span> nextflow run paramInput.nf</span><br><span class="line">[2]+  Stopped                 ./run_workflow.sh</span><br></pre></td></tr></table></figure>

<h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>此時，若要背景執行 nextflow 腳本，可在指令或是腳本內添加 nextflow 內建的 <code>-bg</code> 選項。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nextflow run workflow.nf -<span class="built_in">bg</span></span><br><span class="line"> N E X T F L O W  ~  version 21.10.6</span><br><span class="line">Launching `workflow.nf` [furious_kowalevski] - revision: 936bafe285</span><br><span class="line">[8b/21d003] Submitted process &gt; sayHi</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure>

<p>這選項觸發的行為類似 <code>nohup</code>，能確保用戶退出 terminal 後仍能持續執行 nextflow 腳本（可參考官方<a href="https://www.nextflow.io/docs/latest/cli.html#execution-as-a-background-job">文件</a>及<a href="https://www.nextflow.io/blog/2021/5-more-tips-for-nextflow-user-on-hpc.html">部落格</a>）。</p>
<p>除此之外，添加 <code>-bg</code> 也會輸出 <code>.nextflow.pid</code> 檔，紀錄此指令的 pid，以便用戶追蹤 nextflow 腳本的執行狀況。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>若隨時將指令切到前台，並且用 <code>jobs</code> 查看執行狀態，也可以在指令末端補 <code>&amp;</code>。只是這樣退出 terminal 後，nextflow 腳本也跟著結束了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nextflow run workflow.nf -<span class="built_in">bg</span> &gt; log.txt &amp;</span><br></pre></td></tr></table></figure>

<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>至於為什麼 nextflow 有這特性，我仍沒有頭緒。我試著比較添加 <code>-bg</code> 前後，<code>.nextflow.log</code> 和 <code>.command.run</code> 等檔案的內容，卻沒有發現相關差異。</p>
<p>另外，雖然官方說明 <code>-bg</code> 的行為類似 <code>nohup</code>，但卻無法用 <code>nohup</code> 達到同樣效果。可能還需要對 nextflow 和 linux 有更深的理解才能解釋吧。</p>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Nextflow｜利用 `publishDir` 匯出分析檔案</title>
    <url>/nextflow-the-mode-of-publishdir/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Nextflow 透過 channel 媒介 process 間的檔案傳遞，讓輸出入檔案以軟連結集中到 process 的工作目錄。不過若想從工作目錄取出分析的最終結果，有賴 <code>publishDir</code> directive 的協助。</p>
<span id="more"></span>

<p><code>publishDir</code> 能匯出 process 輸出檔案到指定目錄，其語法與注意事項如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">process demoPub &#123;</span><br><span class="line">    publishDir <span class="string">&quot;/path/to/output&quot;</span></span><br><span class="line">    <span class="symbol">output:</span></span><br><span class="line">        path <span class="string">&quot;example.txt&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    touch &quot;example.txt&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workflow &#123;</span><br><span class="line">    demoPub()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有且僅有定義在 output channel 的檔案會匯出到指定目錄</li>
<li><code>publishDir</code> 應使用絕對路徑 </li>
<li>預設會在指定目錄建立輸出檔案的軟連結</li>
<li></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt -&gt; /project/work/workdir    </span><br></pre></td></tr></table></figure>

<h1 id="修改-publishDir-匯出檔案的方式"><a href="#修改-publishDir-匯出檔案的方式" class="headerlink" title="修改 publishDir 匯出檔案的方式"></a>修改 <code>publishDir</code> 匯出檔案的方式</h1><p>若想修改預設模式可以寫成</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">mode:</span> <span class="string">&quot;copy&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">├── work</span><br><span class="line">|   └── workdir</span><br><span class="line">|       └── example.txt</span><br><span class="line">└── publishDir</span><br><span class="line">    └── example.txt</span><br></pre></td></tr></table></figure>
<p>除了 “copy”，nextflow 亦有其它匯出檔案的方式，它們分別對應了 linux 的 symbolic link, copy, 與 hard link。詳情可參考軟連結、硬連結與複製的差異，此處僅列出與使用檔案較為相關的特性。</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>symlink</th>
<th>copy</th>
<th>link</th>
</tr>
</thead>
<tbody><tr>
<td>linux指令</td>
<td>symbolic link</td>
<td>copy</td>
<td>hard link</td>
</tr>
<tr>
<td>適用對象</td>
<td>檔案與目錄</td>
<td>檔案與目錄</td>
<td>檔案</td>
</tr>
<tr>
<td>原檔更新</td>
<td>隨之更新</td>
<td>不隨之更新</td>
<td>隨之更新</td>
</tr>
<tr>
<td>容量大小</td>
<td>連結大小</td>
<td>與原檔一致</td>
<td>與原檔一致</td>
</tr>
<tr>
<td>刪除原檔</td>
<td>連結遺失</td>
<td>不受影響</td>
<td>不受影響</td>
</tr>
</tbody></table>
<h1 id="篩選輸出的檔案"><a href="#篩選輸出的檔案" class="headerlink" title="篩選輸出的檔案"></a>篩選輸出的檔案</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.txt&quot;</span></span><br><span class="line">publishDir <span class="string">&quot;path/to/backup&quot;</span>, <span class="attr">pattern:</span> <span class="string">&quot;*.md&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>pattern</code> 篩選，可以達到分流輸出檔案的目的。</p>
<h1 id="更動輸出名稱"><a href="#更動輸出名稱" class="headerlink" title="更動輸出名稱"></a>更動輸出名稱</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishDir <span class="string">&quot;path/to/output&quot;</span>, <span class="attr">saveAs:</span> <span class="string">&quot;new_name&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>saveAs</code> 重新命名，可用於重新命名、依照檔名調整輸出目錄等。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Nextflow 最大的特色是以 channel 傳遞資料，process 是從前一步驟的工作目錄獲得資料，而非讀取輸出目錄的資料夾。換句話說，無論建立 output channel 還是匯出檔案到 publishDir，nextflow 都是以 process 的工作目錄為中心。由於每批次處理都會新建工作目錄，所以也確保了 process 輸出的檔案不會彼此覆寫，減少命名中間檔和管理暫存目錄的勞力（這些都由 nextflow 代勞了）。</p>
]]></content>
      <tags>
        <tag>nextflow</tag>
      </tags>
  </entry>
  <entry>
    <title>少棒的基礎</title>
    <url>/nishi-2015-junior-baseball-coaching-book/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>相較於影片，要以圖文解釋複雜動作有許多限制，所以此書的重點不在於老生常談的技術內容，而是引進刻意練習的帶隊觀念。</p>
<p>訓練的目的是在比賽中獲勝。而比賽取勝則是我方投、打、傳、接等基本技巧，以及戰術、補位和佈陣等團體默契勝過對方。</p>
<p>流於形式的訓練無法讓技術進步，惟有發現真正的不足，思考進步方法並付諸實行，才是訓練的根本意義。</p>
<span id="more"></span>

<h1 id="以提升實力為目標進行訓練"><a href="#以提升實力為目標進行訓練" class="headerlink" title="以提升實力為目標進行訓練"></a>以提升實力為目標進行訓練</h1><p>訓練的目的是讓球技進步並在比賽中展現成果。和比賽相比，訓練佔了球員大部分的時間，為了讓訓練契合進步這個目的，訓練必須有效率，讓有限的時間更加充實。</p>
<p>想要進步的衝動源於有所不足的自覺，但進步的關鍵在於思考。球員必須思考練習的目的，從中察覺自己的弱點，並時刻檢討是否因練習而進步。</p>
<p>若否，則要找出原因，而非一味加重練習量。先了解自己的不足並專項特訓才有機會克服弱點，逐步達到原先辦不到的事。</p>
<p>此外，雖然球員可以在比賽中累積經驗，但不能僅憑密集的賽事提升能力，因為比賽多屬成果驗收，欠缺讓球員進步的時間。</p>
<h1 id="技術有意識可控制和不可控制的部分"><a href="#技術有意識可控制和不可控制的部分" class="headerlink" title="技術有意識可控制和不可控制的部分"></a>技術有意識可控制和不可控制的部分</h1><p>每個球員都有個性，優於無意識的習慣難以改變，所以明確的建言很危險。若球員無法體會教練的指導，過於明確的指示會使球員只注意到建言的表面，而忽略沒提到的重點。</p>
<p>此外，當球員專注於達到教練的標準時，也會為了矯正無法改變的錯誤而顧此失彼。</p>
<p>是以，指導球員時要採用類比或感性的詞彙，讓球員理解技術的意象而非規範。至於較明確的技術，可以在不影響個性的前提下，從可以意識的部分開始改進。</p>
<p>（可以參考《魔球》這段話：「這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。(p. 226)」）</p>
<h1 id="養成球員自我思考的習慣"><a href="#養成球員自我思考的習慣" class="headerlink" title="養成球員自我思考的習慣"></a>養成球員自我思考的習慣</h1><p>團隊意識、自主思考是運動的重要資產。</p>
<p>運動是自主思考並採取行動的活動，所以別等待指示。比賽時雖然有教練和隊友提點，球員仍要主動思考下一步並提前準備，以期反應時間縮短。</p>
<p>能力可及便自主行動，不可及就勇於發問，別讓問題懸著，重點是要充分表達自己的想法。賽場上要彼此協調互相指揮，在訓練時判斷錯誤也不要緊，重點是養成表達意見的習慣。</p>
<p>培養比賽默契的方法是建立共識，例如討論一份補位方法、暫停時機，並且在賽場上互相提醒，大喊、比手勢等等。</p>
<p>最後，沒有進步也會有收穫。身為教練，不該為辦不到的事情責備球員，但是要追究能力可及卻不願努力的事。</p>
<h1 id="高掛球鞋後讀"><a href="#高掛球鞋後讀" class="headerlink" title="高掛球鞋後讀"></a>高掛球鞋後讀</h1><p>大學花太多時間在打壘球，畢業時感到無盡的空虛，那段光陰似乎對人生一點幫助也沒有，還增添不少苦澀。所以我總跟朋友講：「早知道就進實驗室，去打工、找實習，做啥不好。」</p>
<p>重新翻這本書，也只是想說服自己有從打球學點有用的東西。但是，棒壘球要怎麼搭上我現在的職業呢？我後來發現《少棒的基礎》提倡的帶隊觀念和刻意練習的精神相符，都主張進步需要訓練和回饋並重。</p>
<p>所以，也許可以說我從打球體會了刻意練習吧？另外，因為屢戰屢敗又沒什麼人和資源，也漸漸習慣從爛咖的角度思考要怎麼克服障礙，例如學會厚臉皮鑽漏洞之類的非典型途徑。</p>
<p>可是這些東西得靠打球才學得到嗎？我想不是。因此，與其苦惱過去有什麼價值，不如積極規劃往後的人生。若真想探討所作所為的意義，那麼打球只是成為我自己的必要條件而已。</p>
<p>好吧，現在已經沒有球員可以訓練，我得學著成為自己的教練。</p>
<h1 id="留言"><a href="#留言" class="headerlink" title="留言"></a>留言</h1><blockquote>
<p>Stanley Huang，2020年2月2日 晚上8:46<br>同意這句<br>這就是為什麼差勁的打者反而會成為最棒的打擊教練。他們不會逼你學他們，因為他們當年太爛了。<br>或許也可以說，差勁的打者反而知道大家問題可能出在哪，所以更能對球員的問題感同身受</p>
</blockquote>
<p>超級boy，2020年2月3日 下午2:17</p>
<p>應該說，教學時若要求球員的動作與教練一致，那球員很有可能為了達到標準而顧此失彼。由於差勁的打者不會逼你學他們，所以能避開這項教學錯誤。</p>
<p>至於能否對球員的問題感同身受，我覺得跟球技無關，而是跟教練的背景有關。所以不同類型的教練能幫助到不同類型的球員。</p>
]]></content>
  </entry>
  <entry>
    <title>ROSALIND｜Open Reading Frames (ORF)</title>
    <url>/open-reading-frames/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一條以 FASTA 格式儲存的 DNA 序列，依據它的 open reading frames，列出所有可能由這條 DNA 序列轉譯出的蛋白質序列。</p>
<blockquote>
<p>An open reading frame (ORF) is one which starts from the start codon and ends by stop codon, without any other stop codons in between. Thus, a candidate protein string is derived by translating an open reading frame into amino acids until a stop codon is reached.</p>
<p>Given: A DNA string s of length at most 1 kbp in FASTA format.</p>
<p>Return: Every distinct candidate protein string that can be translated from ORFs of s. Strings can be returned in any order.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/orf/">https://rosalind.info/problems/orf/</a>)</p>
<span id="more"></span>

<h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>在合成蛋白質時，核醣體會以三個核苷酸一組讀取 RNA 序列，添加各組核苷酸對應的胺基酸。核醣體開始讀取 RNA 序列的位置，會影響核苷酸的分組方式以及隨後轉譯出的蛋白質種類。由於 RNA 密碼子的長度為三，所以依據開始讀取序列的位置，每條 RNA 都會有三種劃分核苷酸的方式。</p>
<p>如下所示，這樣將核酸序列依照密碼子長度劃分，讓核醣體讀取的方式，被稱作 reading frame。每個 reading frame 都定義了一個從不同核苷酸開始讀取的密碼子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AAA GGG CCC</span><br><span class="line">A AAG GGC CC</span><br><span class="line">AA AGG GCC C</span><br></pre></td></tr></table></figure>

<p>相較於 RNA，DNA 兩股序列的任一股都可能轉錄為 RNA 並且轉譯為蛋白質。因此，每條 DNA 有六種可能的 reading frame，其中三種來自順向股，另外三種則來自逆向股的 reverse complemnt。DNA 這六種 reading frame 對應的蛋白質序列叫做 six-frame translating sequences。</p>
<p>以下表格呈現了 DNA 序列 <code>AAAGGGCCC</code> 的 six-frame translating sequences，感興趣的人可以到<a href="https://www.bioline.com/media/calculator/01_13.html">這個網頁</a>試試看怎麼計算。</p>
<table>
<thead>
<tr>
<th></th>
<th>translation in forward direction</th>
<th>translation in reverse direction</th>
</tr>
</thead>
<tbody><tr>
<td>frame 1</td>
<td>KGP</td>
<td>GPF</td>
</tr>
<tr>
<td>frame 2</td>
<td>KG</td>
<td>GP</td>
</tr>
<tr>
<td>frame 3</td>
<td>RA</td>
<td>AL</td>
</tr>
</tbody></table>
<p>Open reading frames (ORFs) 則是指 DNA 序列中，可能轉錄為 RNA 並且轉譯為蛋白質的片段。具體地說，ORFs 是由起始密碼子（<code>ATG</code>）延伸至終止密碼子（<code>TAG</code>、<code>TGA</code>、<code>TAA</code>）的區域。</p>
<p>辨識基因體 ORFs 和 six-frame translating sequences 是尋找蛋白質譯碼基因的重要步驟。在許多臨床與研究場合，DNA 資料比起 RNA 或蛋白質資料更容易取得（或更經濟實惠），研究人員只能依賴 ORFs 和 six-frame translating sequences 來預測蛋白質譯碼基因，已進行功能分析或是基於蛋白質序列比較的親緣關係分析。</p>
<p>例如在癌症基因檢測中，通常只對部分腫瘤熱點的 DNA 進行定序，再透過變異分析和註解來研究致病或治療相關的基因體功能變化。在微生物總基因體研究（metagenomics）中，也是透過定序環境 DNA 以及隨後的物種註解來普查群落的組成。</p>
<p>此外，在缺乏足夠基因體註解資訊的情況下，ORFs 和 six-frame translating sequences 能成為尋找新的譯碼基因或預測基因功能的依據。而相較於 six-frame translating sequences，ORFs 更有機會反映真實的蛋白質譯碼基因，所以使用 ORFs 進行後續分析時，能減少數據分析的雜訊，降低計算的複雜性。</p>
<h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>這題要求從 FASTA 檔案讀取一條 DNA 序列，再列出它所有的 ORFs 對應的蛋白質序列。這一種情況與<a href="https://5uperb0y.com/translating-rna-into-protein/">轉譯 mature mRNA 那題</a>的情境不同。在真核生物的基因體中，有許多不參與蛋白質表現的 DNA，例如內含子、偽基因和調控子等非譯碼 DNA （non-coding DNA，它們有些不會被轉錄，有些則在轉錄後被切除，這導致 DNA 序列和實際會被轉譯出蛋白質的 mature mRNA 序列有所不同。</p>
<p>即使 mRNA 能忠實地保留 DNA 的大部分序列，read frame 也取決於起始密碼子的位置。以 DNA 序列 <code>ATGCATGTAA</code> 為例，從前後兩個起始密碼子轉譯會產生兩種不同的蛋白質序列，它們各自來自不同的 read frame。因此，直接從 DNA 序列預測蛋白質序列時，必須考慮所有可能的 read frames，以確保不遺漏任何潛在的 ORFs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 從第一個起始密碼子開始轉譯</span><br><span class="line">ATG CAT GTA A</span><br><span class="line"># 從第二個起始密碼子開始轉譯</span><br><span class="line">. ... ATG TAA</span><br></pre></td></tr></table></figure>

<p>在此提供一個辨識 ORFs 的策略：</p>
<ol>
<li>由 5’ 到 3’ 一一讀取 DNA 序列。</li>
<li>讀到起始密碼子時，暫存它的座標，再記錄當下的 read frame。</li>
<li>如果碰到多個起始密碼子，都按步驟 2. 依照所在的 read frame 儲存它們的座標。</li>
<li>一旦碰到終止密碼子，就取出對應 read frame 的起始密碼子座標，直到取出所有暫存的座標。</li>
<li>ORFs 正是終止密碼子與起始密碼子之間的區域</li>
<li>持續讀取 DNA 序列直到最後一個核苷酸為止。</li>
</ol>
<p>接著再用同樣的流程讀取反向互補序列，就能得到 DNA 所有 read frame 的 ORFs。最後根據 DNA 密碼表把 ORFs 序列轉換為對應的蛋白質序列即可滿足題目要求。</p>
<h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>因為完成這題所需的幾項功能在先前的文章已經解釋過了，所以接下來我只會解釋要怎麼用 python 實作 ORFs 的辨識。解題的完整程式碼可參考<a href="https://github.com/5uperb0y/rosalind/blob/main/code/orf/orf.py">我的 github</a>。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>題目</th>
<th>連結</th>
</tr>
</thead>
<tbody><tr>
<td>讀取 FASTA 檔案</td>
<td>Finding a Shared Motif</td>
<td><a href="https://5uperb0y.com/finding-a-shared-motif/">Link</a></td>
</tr>
<tr>
<td>取得反向互補序列</td>
<td>Complementing a Strand of DNA</td>
<td><a href="https://5uperb0y.com/complementing-a-strand-of-dna/">Link</a></td>
</tr>
<tr>
<td>轉譯RNA序列</td>
<td>Translating RNA into Protein</td>
<td><a href="https://5uperb0y.com/translating-rna-into-protein/">Link</a></td>
</tr>
</tbody></table>
<p>我使用 orf_locs (list) 儲存所有 ORFs 的座標。為了暫存不同 read frame 上發現的起始密碼子座標，我建立了一個由 3 個 lists 組成的 list，start_locs。其中的三個 list 分別對應 DNA 序列三種可能的 read frame (0, 1, 2)。</p>
<p>在讀取 DNA 序列的過程中，透過將當前核苷酸的位置索引值對 3 取模數 ($position \mod 3$)，可以得知當前所在的 read frame 索引值。一旦遇到起始密碼子，將其座標存入 start_locs 對應 read frame 的 list；直到碰到終止密碼子，才把 start_locs 對應 list 的起始密碼子座標清空，與當前終止密碼子的座標組成 ORFs 區段，存入 orf_locs。</p>
<p>讀取完整條序列後，再根據 ORFs 座標擷取所有 ORFs 對應的 DNA 子序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">orf</span>(<span class="params">dna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Identifies all open reading frames (ORFs) from all read frames in a DNA sequence</span></span><br><span class="line"><span class="string">    that start with &#x27;ATG&#x27; and end with a stop codon (&#x27;TAA&#x27;, &#x27;TAG&#x27;, &#x27;TGA&#x27;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dna (str): A DNA sequence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        list: A list of ORF sequences.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    orf_locs = []</span><br><span class="line">    start_locs = [[], [], []]</span><br><span class="line">    <span class="keyword">for</span> pos, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(dna):</span><br><span class="line">        frame = pos % <span class="number">3</span></span><br><span class="line">        codon = dna[pos: pos + <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> codon == <span class="string">&quot;ATG&quot;</span>:</span><br><span class="line">            start_locs[frame].append(pos)</span><br><span class="line">        <span class="keyword">elif</span> codon <span class="keyword">in</span> [<span class="string">&quot;TGA&quot;</span>, <span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;TAA&quot;</span>]:</span><br><span class="line">            <span class="keyword">while</span> start_locs[frame]:</span><br><span class="line">                orf_locs.append((start_locs[frame].pop(), pos))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> [ dna[i:j] <span class="keyword">for</span> i, j <span class="keyword">in</span> orf_locs ]</span><br></pre></td></tr></table></figure>

<h1 id="討論：open-reading-frame-的定義"><a href="#討論：open-reading-frame-的定義" class="headerlink" title="討論：open reading frame 的定義"></a>討論：open reading frame 的定義</h1><p>Open reading frame 一詞的字面意思是：”Frames that remain open to keep ribosome reading”，指的是核酸序列中未被終止密碼子中斷的一段區域。由於 ORFs 主要用於預測蛋白質譯碼基因，所以也衍伸出許多能用於設計演算法的操作型定義 (Sievar et al., 2018)</p>
<ul>
<li>定義1：ORFs 是指長度為 3 的倍數，而且介於起始密碼子和終止密碼子之間的序列。</li>
<li>定義2：ORFs 是指長度為 3 的倍數，而且介於兩組終止密碼子之間的序列。</li>
<li>定義3：ORFs 是介於核酸裁切位點之間的序列。</li>
</ul>
<p><img data-src="https://ars.els-cdn.com/content/image/1-s2.0-S0168952517302299-gr1.jpg"></p>
<p>（當中橘色線條標記的區域即為各種定義下的 ORFs，圖片來源：Sieber et al., 2018.）</p>
<p>在這些定義中，第一種最為常見，包含這道題目都採用起始和終止密碼子來定義 ORFs 的範圍。定義 1 適用於基因體結構相對單純的原核生物，但在應用於真核生物時會有些問題。</p>
<p>首先，位於內含子中的終止密碼子會導致 ORFs 短於實際可以轉譯出蛋白質的序列。其次，由於起始密碼子既作為開始轉譯的訊號，也是甲硫胺酸的密碼子，定義 1 在實務上難以區分這兩種狀況。</p>
<p>相較之下，定義 2 只考慮終止密碼子，因此可以避免起始密碼子帶來的混淆問題。此外，定義 2 所構成的 ORFs 能夠較全面涵蓋到外顯子的位置，因此 Sievar et al. 推薦使用定義 2。至於第三種定義，則要仰賴基因體註解資訊（通常是在基因預測之後的步驟），而且只能用於真核生物，並不是偵測 ORF 演算法的常見方式。</p>
<p>Sieber et al. (2018). The definition of open reading frame revisited. Trends in Genetics, 34(3), 167-170.</p>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND | Ordering Strings of Varying Length Lexicographically (LEXV)</title>
    <url>/ordering-strings-of-varying-length-lexicographically/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定字符序列 $\mathscr{A}$，求由這些字符組成且長度小於等於 k 的所有字串。這些字串須依照 $\mathscr{A}$ 字典序排列。</p>
<blockquote>
<p>Given: A permutation of at most 12 symbols defining an ordered alphabet $\mathscr{A}$ and a positive integer n (n≤4).</p>
<p>Return: All strings of length at most n formed from $\mathscr{A}$, ordered lexicographically. (Note: As in “Enumerating k-mers Lexicographically”, alphabet order is based on the order in which the symbols are given.)</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/lexv/">https://rosalind.info/problems/lexv/</a>)</p>
<span id="more"></span>

<p>這題是 <a href="https://5uperb0y.com/enumerating-k-mers-lexicographically/">“Enumerating k-mers lexicographically”</a> 的變體。在原始題目中，只需列出長度為 k 的所有可能字串，這些字串都能直接從長度為 k - 1 的字串延伸而來。</p>
<p>都是從長度為 k - 1 的字串延伸而來。是以，最終解是遞迴的直接產物，也能追溯到遞迴的基本狀況。</p>
<p>然而，這題則要求列出所有長度「小於等於 k」的字串，例如 $\mathscr{A}$ 為 <code>[&quot;A&quot;, &quot;B&quot;]</code> 而且 k &#x3D; 2 時，則輸出應包含 <code>[&quot;A&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;BA&quot;, &quot;BB&quot;]</code>。</p>
<p>雖然 “AA” 和 “AB” 是透過添加字符組成，但是 “A” 和 “B” 則否，輸出結果之前來自不同的關係。為了解決這問題，每次遞迴不只要生成指定長度的字串，還要保留每次遞迴的中繼結果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lexv</span>(<span class="params">elements, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Ordering Strings of Varying Length Lexicographically</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> elements</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> elements:</span><br><span class="line">            output.append(e)</span><br><span class="line">            output.extend([<span class="string">f&quot;<span class="subst">&#123;e&#125;</span><span class="subst">&#123;k_str&#125;</span>&quot;</span> <span class="keyword">for</span> k_str <span class="keyword">in</span> lexv(elements, k - <span class="number">1</span>) ])</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>卡西尼號與行星保護</title>
    <url>/planetary-protection-rules-and-the-end-of-cassini-probe/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>歷經20年的太空旅行，美國航太總署（NASA）的卡西尼號（Cassini）太空船今天將最後的訊號傳回地球後，高速衝撞土星，以分解蒸發的壯烈方式，結束13年的土星任務。</p>
</blockquote>
<p>卡西尼號是艘軌道探測船，任務結束後沒有能量脫離行星軌道，所以不能像飛掠探測器一樣（航海家 II）飛向深空。它會留在土星系統中，最終因為故障或其他緣故減速而失控墜入土星或其他衛星。</p>
<p>然而土星的衛星中有幾個可能有生命存在（尤其是土衛六泰坦），所以主動讓卡西尼號墜入較無生命可能的土星中，以免滅菌不徹底的機體造成汙染。不過，這種壯烈的自殺已經不是第一次了，2003 年伽利略探測船也為保護木衛二歐羅巴而撞入木星濃厚的大氣層中。</p>
<p>雖然這邊只提到墜毀階段，其實所有的太空任務都有防止生物汙染其他天體的措施，不過依照天體性質和任務類別可以分為五類。此處，我把重點聚焦在分類的依據和理由，而不是防範措施（詳細作法可以在厚厚的行星保護指導手冊中找到。）</p>
<h2 id="第一類任務"><a href="#第一類任務" class="headerlink" title="第一類任務"></a>第一類任務</h2><p>第一類任務是飛掠、繞行或登陸月球、水星和多數小行星，這些天體沒有足夠的液態水維持生命，所以除了例行消毒外，探測船並不需特別處理。</p>
<h2 id="第二類任務"><a href="#第二類任務" class="headerlink" title="第二類任務"></a>第二類任務</h2><p>第二類任務則涉及那些可能沒有生物，但是對於生命起源研究有重要參考價值的天體。例如：土衛六、金星、類木行星和彗星。</p>
<p>2014年羅賽塔號登陸彗星就是第二類任務。那次任務檢測到了胺基酸、醇類等有機物，它們很可能透過彗星撞擊為早期地球帶來形成生命的必要分子。（這些有機物質可能是彗星經過星際塵埃時沾上，或是經過恆星附近起反應形成的。順道一提，首次在星際中發現胺基酸的是師大的管一政教授喔！）</p>
<p>雖然金星現在因為失控的溫室效應已經成為高溫煉獄，但是在太陽還沒今天熾熱、溫室效應也沒失控前可能存在一段宜居的時候。另外金星大氣層中有個溫度合宜，且有硫化物補給的區間，若當初有生命誕生，也許能在此續命。相關任務有 2015 年 ESA 的金星快車（繞行任務）和先前蘇聯因大氣壓扁而早夭的登陸任務。</p>
<p>土衛六和土星因為可能有液態水、有機物存在所以同屬二類，但是土衛六多了可棲息的表面以及大氣層中的有機反應，所以研究價值還好過土星。本次墜毀的卡西尼號曾在 2005 年釋放惠更斯探測器登陸土衛六，可惜登陸不久便失聯了，所幸有留下空降時和登陸當下的照片，大家可以找看看，我覺得看起像是乾涸的水庫……</p>
<h2 id="第三類任務和第四類任務"><a href="#第三類任務和第四類任務" class="headerlink" title="第三類任務和第四類任務"></a>第三類任務和第四類任務</h2><p>第三類是火星和歐羅巴（木衛二）的「繞行」、「飛掠」任務，這兩天體是太陽系內最有可能找到地外生命證據（無論死活）的地方，執行第三類任務的太空船都要經過嚴密滅菌才行。</p>
<p>火星過去可能有水流、磁場和大氣層，這些都是利於生命誕生維持的要素；即便是今日，生物也可能在岩石與冰層間的夾縫中生存。另一個誘人的證據是1984年找到的火星隕石 ALH84001，上頭有疑似細菌化石、生物代謝排遺。</p>
<p>歐羅巴冰層下可能有液態水層，這些水層不僅和岩層接觸促進物質互動（而土衛六可能是隔絕水層），也能隔絕致命輻射保護生命體。</p>
<p>由於這兩顆天體可居，即便沒有原生種，也擔心地球生物在上頭大肆繁殖影響後續監控，所以火星與歐羅巴的「登陸」升級為第四類任務。</p>
<p>雖然我們猜測火星很可能有生物，可是1976年的海盜I&#x2F;II登陸任務卻沒有發現關鍵證據。因為第四類任務的預備很麻煩，所以為了往後探測任務方便，又把它分為三個子類，滅菌等級漸增：非適居區登陸（防止地球細菌汙染火星）、生命探測任務（防止地球細菌干擾實驗）、適居區登陸（防止雙向汙染）。</p>
<h2 id="第五類任務"><a href="#第五類任務" class="headerlink" title="第五類任務"></a>第五類任務</h2><p>至於第五類則是所有回收太空船到地月系統的任務，涵蓋月球是因為它是將來重點開發區域，若受到地外生物汙染，登陸月球會升級到二三類任務，太空船多了一堆滅菌要求會讓開發變得十分不方便。前陣子 NASA 招募的行星保護官就是要專職這種任務的調查工作。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後提一提行星保護的規範。最早是寫在聯合國於 1967 年制定的《關於各國探索和利用包括月球和其他天體在內外層空間活動的原則條約》當中的第九條：<br>各締約國從事研究、探索外層空間（包括月球和其他天體）時，應避免使其遭受有害的污染，以及地球以外的物質，使地球環境發生不利的變化。<br>詳細指導方針則由國際科學理事會下轄的太空研究委員會負責負責。</p>
<p>由於當時台灣還沒退出聯合國所以也簽了這條約，想看詳細內容可以去網路上查中文的手寫文本。雖然台灣至今仍沒有進行任何登陸任務，不過得知我們也曾籌畫整個宇宙開發的小小部分，仍有莫名的參與感。</p>
]]></content>
      <tags>
        <tag>life in the universe</tag>
      </tags>
  </entry>
  <entry>
    <title>可能反映與嬰兒飲食相關的腸道菌相演替機制的現象</title>
    <url>/phenomena-reflecting-successional-mechanisms-of-gut-microbiota-in-infant-diet/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>人體腸道菌群建立攸關個體健康，為理解與菌群相關的致病機制並精進目前的干預治療手段，腸道微生物學應逐步從關聯分析邁向機制研究。</p>
<p>過往累積的數據已辨識出許多影響菌相的外在因素，為了發掘導致現象的機制，本文試圖以生態理論和調控原理連結觀察與機制，探討可能反映飲食作用機制或菌群演替原則的現象與問題，期望可以指引出往後研究的方向。</p>
<p>（此文是「生物調控原理」課程的報告。這門課以系統論與建模思維，重新介紹遺傳學、生物化學、細胞生物學課程中講授的觀念。我嘗試用課堂上學到的方式，思考微生物學的研究。那時候趕著交報告，沒有很完整發展想法，也沒辦法用資料實證。現在看來除了點子天真了，可行性也受限於總基因體定序資料的精密度。儘管如此，我相信老師的建議是對的：「有想法就寫出來跟大家分享，即使只幫到一個人、只幫到自己也好。」）</p>
<span id="more"></span>

<h1 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h1><h2 id="腸道菌群建立攸關個體健康"><a href="#腸道菌群建立攸關個體健康" class="headerlink" title="腸道菌群建立攸關個體健康"></a>腸道菌群建立攸關個體健康</h2><p>人類腸道菌的建立期間，個體的組織器官亦逐漸成熟，兩者的交互作用攸關消化系統、免疫系統乃至神經系統的健全 (Sommer and Bäckhed, 2013)。因此，嬰兒腸道菌群建立不僅關乎生命早期的健康狀態，也可能因影響宿主的生理平衡，從而增加往後罹患哮喘、一型糖尿病或發炎性腸病等疾病的風險 (Tamburini et al., 2016)。</p>
<h2 id="了解演替機制是干預治療的前提"><a href="#了解演替機制是干預治療的前提" class="headerlink" title="了解演替機制是干預治療的前提"></a>了解演替機制是干預治療的前提</h2><p>由於菌相失調與疾病的關聯，益生元、益生菌或是糞菌移植等針對腸道菌群的干 預療法日益蓬勃 (Petrof et al., 2013)，但相較於實務性的醫療成果，目前對於治療機制 的理解有限(Walter et al., 2018)，難以解釋不同徵狀下干預手段的療效差異，例如糞菌 移植能有效治療困難梭狀桿菌 (Clostridium difficile) 的反覆感染，卻不一定適用於其他疾病 (Qazi et al., 2017)。</p>
<p>為解決前述困難，除了釐清腸道菌群與疾病的關係，也需要深 入理解正常情況下菌群的演替機制。因為有效的治療意味著能精確地鑑別菌群類別，適當地設計干預方式，並準確地預期療效，這些條件奠基於對生態網路和演替動態的理解，兩者的前提皆為辨識腸道物種組成和闡明菌群相關因素 (Fischbach, 2018)。</p>
<h2 id="從關聯分析邁向機制研究"><a href="#從關聯分析邁向機制研究" class="headerlink" title="從關聯分析邁向機制研究"></a>從關聯分析邁向機制研究</h2><p>有賴顯微鏡、培養方法乃至核酸基礎的總體基因體學分析技術，腸道菌群的物種和功能組成日益明朗，總體基因體關聯分析 (MWAS, Metagenome-wide association studies) 也已辨識出許多與腸道菌相有關的外在因素，為了達成前述的目標，腸道菌群研究得逐步邁向機制研究。</p>
<p>人體微生物研究受限於干預手段不足、採樣手法限制還有臨床資訊混雜等因素，無法直接測試由假說衍伸的機制，必須仰賴流行病學或自然實驗方法，比對帶有不同特徵的研究定群，再從組間差異推論研究變項的涵意。</p>
<p>動植物生態學已累積相當多可供測試的假說和預測 (Prosser et al., 2007)，調控原理的課程也示範了從物理、化學至分子生物皆適用的原則，可作為指引腸道菌群研究的理論架構。</p>
<h2 id="嬰兒菌群建立可用以理解群集演替"><a href="#嬰兒菌群建立可用以理解群集演替" class="headerlink" title="嬰兒菌群建立可用以理解群集演替"></a>嬰兒菌群建立可用以理解群集演替</h2><p>相較於成人，嬰兒腸道菌相的變化幅度較大。嬰兒的腸道菌相在出生時即因分娩方式而異，隨後受母乳或配方奶等飲食形塑進一步分異，繼而併同器官組織發育逐年演替。</p>
<p>菌相變化最終在出生離乳後漸漸趨緩，在產後二至三年形成近似成人的腸道菌組成 (Milani et al., 2017)，藉由採集這段期間的排遺樣本，可以觀察腸道物種和功能組成的動態變化，歸納腸道菌隨年齡增長的演替模式。</p>
<p>此外，由於嬰兒的飲食和行為較成人單純，有利於衡量特定臨床因素與菌相的關係，透過檢視腸道菌群在分娩、離乳或是用藥後的菌相轉變，得以推論不同行為作用於腸道菌群的機制，或是腸道菌群因擾動而產生的反應 (Fischbach, 2018)。</p>
<h2 id="飲食行為是適合用以探討外在因素影響"><a href="#飲食行為是適合用以探討外在因素影響" class="headerlink" title="飲食行為是適合用以探討外在因素影響"></a>飲食行為是適合用以探討外在因素影響</h2><p>儘管有許多環境、遺傳和行為因素攸關嬰兒腸道菌群建立 (van Best et al., 2015)，本文將聚焦於飲食行為相關的菌群演替。因為嬰兒消化系統和免疫系統的成熟固然影響深遠，但一方面分析時難為發育的影響劃分明確的始末，另一方面既有資料也鮮有嬰兒發育狀態的臨床紀錄。</p>
<p>手足、寵物、居處皆和腸道菌相關，然而這些關聯卻不易推論作用機制。患病服藥雖然能追蹤干擾開始的時間，也得以從藥理學推論作用機制，但研究結果可能受疾病干擾，其數據亦不若飲食普及。</p>
<h2 id="本研究的目的是以理論連結相關現象與作用機制"><a href="#本研究的目的是以理論連結相關現象與作用機制" class="headerlink" title="本研究的目的是以理論連結相關現象與作用機制"></a>本研究的目的是以理論連結相關現象與作用機制</h2><p>綜上所述，本文將以與嬰兒飲食相關的菌群演替為研究對象，利用生物調控原理課程中講述的觀念，還有目前動植物生態學累積的理論，探討從關聯研究結果推論作用機制的可行方式。<br>本文首先將介紹菌群建立的生態學觀點，並且解釋群集演替的基本原則，繼而檢視飲食影響腸道菌的可能途徑，提出可能反映機制的相關現象。</p>
<h1 id="嬰兒腸道菌的建立可視為群集演替"><a href="#嬰兒腸道菌的建立可視為群集演替" class="headerlink" title="嬰兒腸道菌的建立可視為群集演替"></a>嬰兒腸道菌的建立可視為群集演替</h1><h2 id="人體共棲菌的生態學觀點"><a href="#人體共棲菌的生態學觀點" class="headerlink" title="人體共棲菌的生態學觀點"></a>人體共棲菌的生態學觀點</h2><p>二十世紀初人類的衛生觀念基於巴斯德和柯霍等人確立的細菌致病學說 (the germ theory of disease)，認為特定病原菌破壞人體健康狀態而導致疾病，所以當時的防疫觀念著重消毒，試圖透過全面滅菌降低細菌傳播。</p>
<p>在細菌致病學說指引下，透過系統地搜索病原菌，結合同時期發展的疫苗、化學療法和抗生素，降低了許多疾病的致死率。此外，細菌致病學說納入了病毒致病因素後，拓展為更為成熟的微生物致病學說，持續引領晚近的人體微生物學研究 (Institute of Medicine (US) Forum on Microbial Threats, 2006)。　</p>
<p>儘管微生物致病的典範取得了巨大的成功，這種以病原為中心的觀點 (pathogen-centered) 過度強調疾病與特定物種的關係，忽略了物種與物種、物種與宿主間交互作用變動造成的疾病，也沒有考慮到物種的多重屬性。</p>
<p>研究也指出體內微生物的組成和神經疾病、肥胖、過敏相關，這意味著微生物不只單純棲息於體內，它們可能參與人體生理的大小反應。</p>
<p>新興疾病的醫療危機以及微生物與宿主的生理相關性揭示了微生物與宿主間的複雜關係，於是學界漸漸重視微生物致病的其他因素，例如：微生物的變化、微生物與環境的關係、微生物間的作用網路、免疫系統與微生物間的互動、……等，模糊了人類與病原菌之間壁壘分明的界線。</p>
<p>換句話說，學界引進了生態學的思考方式，將人體視為棲息地 (human-as-habitat perspective) 而不是廝殺的戰場 (body-as-battleground perspective or the War matephor)，微生物是人體的一部份而非外來的異客，身體狀態是細菌與人體細胞共同作用的外顯特徵，而健康則是生態系平衡的紅利 (ecosystem service) 不是固有的狀態 (Costello et al., 2012)。</p>
<h2 id="腸道菌群建立可視為接連的狀態改變"><a href="#腸道菌群建立可視為接連的狀態改變" class="headerlink" title="腸道菌群建立可視為接連的狀態改變"></a>腸道菌群建立可視為接連的狀態改變</h2><p>援引化學熱力學的概念，腸道菌群的建立過程可以比擬為菌相在內外因素影響下接連的狀態改變 (Gilbert and Lynch, 2019)。</p>
<p>化學反應的熱力學因素決定反應是否可能發生，而動力學因素則左右反應發生的難易；群集演替的熱力學因素代表環境壓力及群集互動可容忍的菌相，而動力學因素則是意味著菌群在耐受環境擾動能力。化學反應中的位能低意味著穩定 (stable) ，活化能高意味著惰性 (inert)；群集演替中的菌相差異大謂之穩定，組成的變化範圍小謂之惰性。</p>
<p>然而菌群狀態不若化學反應中的分子穩定，即使被視為成熟的成人腸道菌群也有一定程度的波動。腸道菌群的狀態是指菌相變化侷限於相當的範圍內，歷經輕微干擾後也能順利恢，一旦干擾過大則會脫離先前的波動範圍，轉向另一個狀態 (Fierer et al., 2012)。</p>
<p>其次，有別於代謝途徑可列出明確的反應步驟，菌相變化卻發生在腸道菌群的不同屬性上，不易劃分菌群演替的過程。往往得借重生態學指標將抽象複雜的群集特徵以具體易懂的數字呈現，繼而聚焦所關注的層面研究，因此儘管菌群可能發生了數種變化，但研究中卻只以其中一項作為菌相的代表。</p>
<h1 id="四項群集生態學原則驅動菌群演替"><a href="#四項群集生態學原則驅動菌群演替" class="headerlink" title="四項群集生態學原則驅動菌群演替"></a>四項群集生態學原則驅動菌群演替</h1><p>基因調控、訊息傳遞與代謝反應等生理過程的狀態變化源於分子間的碰撞、結合與形變，其機制與動態得以物理化學原理解釋。然而腸道菌相轉變卻是族群消長、種間互作和環境干擾共同作用的結果，涉及不同尺度和類別的因素，因此衍生出紛雜的名詞、模型與概念以解釋群集的演替模式。</p>
<p>為了整合歧異的理論架構，Vellend, (2010)彙整既有的群集生態學理論，歸納出選擇 (Selection)、播遷 (Dispersal)、多樣化 (Diversification)和漂變 (Drift) 四項演替的基本動力。</p>
<h2 id="選擇-Selection"><a href="#選擇-Selection" class="headerlink" title="選擇 (Selection)"></a>選擇 (Selection)</h2><p>選擇是指由於不同細菌對於特定環境的適存度差異（例如繁殖速度、營養利用或環境耐受等），使得相異環境中群集物種組成比例不一的現象。</p>
<p>以人類腸道菌為例，儘管真細菌涵蓋數十個不同菌門，成年人的腸道菌群組成卻以厚壁菌門 (Firmicutes)、擬桿菌門(Bacteroidetes) 及變形菌門 (Proteobacteria) 為主 (The Human Microbiome Project Consortium et al., 2012)。</p>
<p>此外，人體各部位的共棲菌相在出生時有相當的個體差異，但是隨著年齡增長，同一部位的菌群物種組成日異相近，不同部位的菌群物種組成卻逐漸分異 (Chu et al., 2017)。</p>
<p>由於不同器官的構造、濕度、酸鹼值和營養來源差異，這些菌相因部位而異的現象，可反映選擇參與人體共棲菌的建立過程。</p>
<p>為了以選擇解釋不同臨床因素與菌相的關係，人體微生物研究中往往假定菌群已歷經環境選擇，接著檢視總體基因體中與目標因素相關的功能途徑數量在組間是否有明顯差異。</p>
<p>例如在評估母乳影響的研究中，即假設母乳寡糖為，以代謝寡糖的基因為特徵，詮釋哺餵母乳與餵食奶粉的嬰兒腸道菌相差異。</p>
<h2 id="播遷-Dispersal"><a href="#播遷-Dispersal" class="headerlink" title="播遷 (Dispersal)"></a>播遷 (Dispersal)</h2><p>播遷是指生物自其他棲地遷入並成功在既有群集中繁衍生存的現象。儘管孕婦體內少數的微生物可能藉由臍帶血或羊水等途徑定殖於胎兒(Perez-Muñoz et al., 2017)，但大量接觸環境微生物仍然始於分娩。</p>
<p>既有研究指出，新生兒的腸道菌相因分娩方式而異(Dominguez-Bello et al., 2010)，自然產嬰兒有較多於母親產道發現的物種，而剖腹產嬰兒則有較多成人皮膚上發現的物種，表示出生時的腸道菌相與微生物的潛在來源相關，意味著播遷差異是影響新生兒菌相的主因。</p>
<p>為了辨識與播遷相關的群集變化，通常會比較細菌潛在來源和播遷區域兩處的菌相，再藉由物種組成相似性推論是否有播遷的可能。</p>
<p>Pannaraj et al., (2017) 即比較母乳細菌與嬰兒腸道細菌的物種組成，發現腸道菌群與母乳菌群的相似程度與母乳攝取量正相關，支持細菌通過母乳定殖於嬰兒腸道的假說。</p>
<p>由於播遷涉及遷移和繁衍兩種行為，因此群集受播遷影響取決於族群的柏謙能力以及環境的抗力。</p>
<h2 id="多樣化-Diversification"><a href="#多樣化-Diversification" class="headerlink" title="多樣化 (Diversification)"></a>多樣化 (Diversification)</h2><p>多樣化是指菌群因突變與選擇壓力演化出不同性狀或特徵的現象。由於細菌的繁殖速率和突變率，在動植物上須要歷經長遠時間的演化現象可以在數十年內在腸道菌群中發生。儘管近期的研究漸漸留意到多樣化的作用，由於本文回顧的文獻中較少但討多樣化相關案例，故本文暫不討論多樣化的作用。</p>
<h2 id="漂變-Drift"><a href="#漂變-Drift" class="headerlink" title="漂變 (Drift)"></a>漂變 (Drift)</h2><p>漂變是指群集中無關乎物種特性的隨機數量變化。當選擇壓力較小或是族群規模不大時，因為物種間的差異不致於產生適存度差異或是無法承受隨機造成的滅絕事件，導致群集的物種組成取決於不同族群的自然消長和隨機事件，此時群集演替即由漂變主導。</p>
<p>儘管漂變於群集演替的重要性，但是因為諸多外在因素干擾，不易辨識其作用的相關證據。嬰兒在添加副食後，腸道菌群多樣性歷經短暫的降低 (Vallès et al., 2014)，漂變也許能解釋為何期間受影響的多屬低豐度菌屬。</p>
<h1 id="飲食影響腸道菌群演替的可能途徑"><a href="#飲食影響腸道菌群演替的可能途徑" class="headerlink" title="飲食影響腸道菌群演替的可能途徑"></a>飲食影響腸道菌群演替的可能途徑</h1><p>雖然飲食可能與其他臨床因素相關，因此相異飲食的菌相差異未必是飲食內容造成，但是本文意在探討飲食自身與腸道菌相演替的機制，因此將聚焦嬰兒飲食中有哪些物質可能影響腸道菌的四項演替原則。</p>
<h2 id="母乳的內容"><a href="#母乳的內容" class="headerlink" title="母乳的內容"></a>母乳的內容</h2><p>有別於配方奶的成分，母乳除乳糖、脂肪及蛋白質等嬰兒發育所需的營養素外，也含有生長因子、細胞素和激素等能調節免疫系統或促進組織發育的物質 (Ballard and Morrow, 2013)，這些物質可能不直接影響腸道菌群，但會作用在腸道及其周邊的組織，改變腸道菌的棲息環境。</p>
<p>另外，母乳寡糖 (HMOs, human milk oligosaccharides) 則有多項可能的功能，例如作為益生元促進特定細菌生長定殖、防範病原黏附於腸壁、以及平衡免疫細胞等 (Bode, 2012)。</p>
<p>這些生物活性物質 (bioactive components) 可能造成腸道菌群面臨選擇壓力，故得以在哺餵母乳的嬰兒腸道優勢菌屬為可代謝母乳寡糖的菌屬。</p>
<p>此外，既有研究已在母乳中發現多樣的細菌 (Togo et al., 2019)，意味著母乳可能是嬰兒腸道菌的潛在來源或是其它共棲菌的播遷媒介，代表母乳除了透過選擇，也可能透過播遷方式影響腸道菌群。</p>
<p>其他環境微生物的播遷和母乳菌群播遷的差異在於，母乳中的細菌可能已適應母乳營造的環境，故相較於環境微生物，母乳菌群同時經選擇和播遷影響嬰兒腸道菌群。</p>
<h2 id="奶粉、副食品以及成人餐食"><a href="#奶粉、副食品以及成人餐食" class="headerlink" title="奶粉、副食品以及成人餐食"></a>奶粉、副食品以及成人餐食</h2><p>奶粉、副食品和成人餐食欠缺母乳中的生物活性物質，非哺餵母乳的嬰兒往往有類似的特徵，即腸道中有較多梭菌屬(Clostridium) 或擬桿菌屬 (Bacteroides) 的細菌，腸道菌群也比較成熟。</p>
<p>儘管不同的營養成分和相異的菌屬有關 (Singh et al., 2017)，既有研究仍指出，嬰兒腸道菌群在離乳期間的變化可能非源於添加副食，而是因為停餵母乳 (Bäckhed et al., 2015)，暗示著這些飲食的選擇效應可能沒有母乳強烈，因此彼此相關的菌群特徵相似，同時飲食時無法造成明顯菌相轉變。</p>
<h2 id="飲食以直接或間接方式影響腸道菌"><a href="#飲食以直接或間接方式影響腸道菌" class="headerlink" title="飲食以直接或間接方式影響腸道菌"></a>飲食以直接或間接方式影響腸道菌</h2><p>總結嬰兒成長期間接觸的飲食內容，可以歸納出直接和間接兩種影響腸道菌相的方式。</p>
<p>母乳中的巨噬細胞和免疫球蛋白可抑制病原菌播遷，而母乳中的細菌則有機會定殖腸道，兩者皆直接作用於腸道菌群，沒有改變環境中可負荷的菌群種類，可歸為群集演替的動力學因素。</p>
<p>而母乳寡糖或調節生理機能的物質則改變了腸道環境，影響環境中可能負荷的菌群種類，故歸類為群集演替的熱力學因素。</p>
<p>飲食的間接影響又可再區分為短暫影響和長期影響。假如飲食透過改變環境中的可用資源，增加環境中的選擇壓力，原則上在轉換飲食後這類影響便逐漸消退。</p>
<p>然而，假如飲食透過永久改變腸道組織營造選擇壓力，則此項影響在轉換飲食後可能會持續作用在腸道菌群中。</p>
<h1 id="可能反映機制的現象"><a href="#可能反映機制的現象" class="headerlink" title="可能反映機制的現象"></a>可能反映機制的現象</h1><p>既已介紹了看待菌群的方式，也說明了菌群演替的基本原則，在了解飲食影響腸道菌群演替的途徑後，接著將要列舉幾則可能反映不同飲食作用機制的現象。</p>
<h2 id="嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異"><a href="#嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異" class="headerlink" title="嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異"></a>嬰兒哺餵母乳或哺餵奶粉之腸道菌相差異</h2><p>既有研究往往透過哺餵母乳和餵食奶粉的嬰兒相互對照，檢視相異飲食者的腸道菌相差異，藉此推論不同飲食的作用機制。</p>
<p>儘管各項研究的結果仍有差異 (Davis et al., 2017)，相較於餵食配方奶的嬰兒，哺餵母乳者的腸道菌多樣性較低 (Bezirtzoglou et al., 2011)，而菌群中能代謝母乳寡糖雙歧桿菌屬 (Bifidobacterium) 和見於母乳的乳酸桿菌屬 (lactobacillus) 之物種比例較高 (Bäckhed et al., 2015; Stewart et al., 2018) 。</p>
<p>通過樣本的物種組成預測採樣時間，從而得出菌群年齡 (Microbiota age) 後也發現，純哺餵母乳者的腸道菌年齡往往低於非純餵母乳者 (Ho et al., 2018)。</p>
<p>如前所述，這些差異反映了母乳透過選擇影響腸道菌群，卻無法反映菌群在飲食持續干擾下的動態變化，這些得仰賴長期追蹤的時間序列資料，但時間資料卻會受年齡增長因素干擾，因此為了瞭解菌群在飲食干擾下的影響，有必要觀察切換飲食之際的菌相轉變。</p>
<h2 id="離乳期的腸道菌相轉變"><a href="#離乳期的腸道菌相轉變" class="headerlink" title="離乳期的腸道菌相轉變"></a>離乳期的腸道菌相轉變</h2><p>除了比較不同飲食的嬰兒之腸道菌相差異，追蹤離乳前後的菌相轉變亦可能反映飲食的作用機制。在一段純母乳哺育的時期以後，由於哺餵障礙或營養需求改變，嬰兒開始服用副食品並逐漸減少母乳攝取 (Li et al., 2008) ，期間腸道菌群歷經一轉變，最後改變趨緩直至。如前所述，母乳可能是效果強烈的選擇因子，離乳後選擇的效力會減弱，是否會使得漂變的比重提升，進而導致個體間的菌群差異較哺餵母乳時期的時候大？或是添加飲食帶來了多樣的營養素，增加了可用資源創造許多生態棲位使得選擇壓力下降，漂變的效力上升，使得個體間的菌群差異如 de Muinck and Trosvik, (2018) 觀測到的在添加副食後增加？</p>
<h2 id="相異分娩方式之嬰兒的飲食相關菌相差異"><a href="#相異分娩方式之嬰兒的飲食相關菌相差異" class="headerlink" title="相異分娩方式之嬰兒的飲食相關菌相差異"></a>相異分娩方式之嬰兒的飲食相關菌相差異</h2><p>儘管研究分娩方式和飲食型態的研究相當豐富，但關注兩者關聯的研究卻相對稀少。相較於自然產嬰兒，剖腹產的腸道菌群多樣性較低，而兩者物種組成也不相同。</p>
<p>倘若母乳以當中帶有的菌種影響腸道菌相，則是否會因為腸道中既有的物種組成不同，導致播遷受阻？Hill et al., (2017) 在剖腹產的嬰兒中觀察到母乳哺餵時長不一的嬰兒之菌相差異，但在自然產中卻沒觀察，也許此項發現可支持前述推論。</p>
<h2 id="過往哺餵母乳的經歷和當前哺餵母乳的狀態"><a href="#過往哺餵母乳的經歷和當前哺餵母乳的狀態" class="headerlink" title="過往哺餵母乳的經歷和當前哺餵母乳的狀態"></a>過往哺餵母乳的經歷和當前哺餵母乳的狀態</h2><p>既有研究指出母乳哺餵的經歷，例如哺乳期長短或純餵母乳歷時等皆於腸道菌相有關 (Azad et al., 2016) 如前所述，母乳的間接影響可能藉由改變腸道組織而有持續性的效果，比較母乳哺餵的經歷和當前哺餵狀態各自影響的菌群或許可以辨識出母乳作用的機制差異。</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>本文以生態學的觀點看待腸道菌群，以狀態變化的觀念描述嬰兒菌群演替，接著透過群集生態學原則探討飲食的直接和間接影響，最後列舉了四項可能反映飲食影響腸道菌機制的觀察：比較相異飲食者的菌相差異、比較離乳前後的菌相差異、比較相異分娩方式者之菌相對飲食的反應、比較過往母乳哺餵經歷和當前母乳哺餵狀態對菌相的影響。儘管本文沒有呈現完整的實驗設計以驗證特定的機制，仍提出了潛在的研究方向，後續研究可以從這些問題出發，補足未竟的細節，以理解飲食影響人類腸道菌群的演替模式和機制。</p>
<h1 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h1><p>Azad, M.B., Konya, T., Persaud, R.R., Guttman, D.S., Chari, R.S., Field, C.J., Sears, M.R., Mandhane, P.J., Turvey, S.E., Subbarao, P., et al. (2016). Impact of maternal intrapartum antibiotics, method of birth and breastfeeding on gut microbiota during the first year of life: a prospective cohort study. BJOG Int. J. Obstet. Gynaecol. 123, 983–993. </p>
<p>Bäckhed, F., Roswall, J., Peng, Y., Feng, Q., Jia, H., Kovatcheva-Datchary, P., Li, Y., Xia, Y., Xie, H., Zhong, H., et al. (2015). Dynamics and Stabilization of the Human Gut Microbiome during the First Year of Life. Cell Host Microbe 17, 690–703.</p>
<p>Ballard, O., and Morrow, A.L. (2013). Human Milk Composition: Nutrients and Bioactive Factors. Pediatr. Clin. North Am. 60, 49–74.</p>
<p>van Best, N., Hornef, M.W., Savelkoul, P.H.M., and Penders, J. (2015). On the origin of species: Factors shaping the establishment of infant’s gut microbiota. Birth Defects Res. Part C Embryo Today Rev. 105, 240–251. </p>
<p>Bezirtzoglou, E., Tsiotsias, A., and Welling, G.W. (2011). Microbiota profile in feces of breast- and formula-fed newborns by using fluorescence in situ hybridization (FISH). Anaerobe 17, 478–482. </p>
<p>Bode, L. (2012). Human milk oligosaccharides: Every baby needs a sugar mama. Glycobiology 22, 1147–1162.</p>
<p>Chu, D.M., Ma, J., Prince, A.L., Antony, K.M., Seferovic, M.D., and Aagaard, K.M. (2017). Maturation of the infant microbiome community structure and function across multiple body sites and in relation to mode of delivery. Nat. Med. 23, 314–326. </p>
<p>Costello, E.K., Stagaman, K., Dethlefsen, L., Bohannan, B.J.M., and Relman, D.A. (2012). The application of ecological theory toward an understanding of the human microbiome. Science 336, 1255–1262.</p>
<p>Davis, E.C., Wang, M., and Donovan, S.M. (2017). The role of early life nutrition in the establishment of gastrointestinal microbial composition and function. Gut Microbes 8, 143–171. </p>
<p>Dominguez-Bello, M.G., Costello, E.K., Contreras, M., Magris, M., Hidalgo, G., Fierer, N., and Knight, R. (2010). Delivery mode shapes the acquisition and structure of the initial microbiota across multiple body habitats in newborns. Proc. Natl. Acad. Sci. U. S. A. 107, 11971–11975.</p>
<p>Fierer, N., Ferrenberg, S., Flores, G.E., González, A., Kueneman, J., Legg, T., Lynch, R.C., McDonald, D., Mihaljevic, J.R., O’Neill, S.P., et al. (2012). From Animalcules to an Ecosystem: Application of Ecological Concepts to the Human Microbiome. Annu. Rev. Ecol. Evol. Syst. 43, 137–155.</p>
<p>Fischbach, M.A. (2018). Microbiome: Focus on Causation and Mechanism. Cell 174, 785–790.</p>
<p>Gilbert, J.A., and Lynch, S.V. (2019). Community ecology as a framework for human microbiome research. Nat. Med. 25, 884.</p>
<p>Hill, C.J., Lynch, D.B., Murphy, K., Ulaszewska, M., Jeffery, I.B., O’Shea, C.A., Watkins, C., Dempsey, E., Mattivi, F., Tuohy, K., et al. (2017). Evolution of gut microbiota composition from birth to 24 weeks in the INFANTMET Cohort. Microbiome 5, 4. </p>
<p>Ho, N.T., Li, F., Lee-Sarwar, K.A., Tun, H.M., Brown, B.P., Pannaraj, P.S., Bender, J.M., Azad, M.B., Thompson, A.L., Weiss, S.T., et al. (2018). Meta-analysis of effects of exclusive breastfeeding on infant gut microbiota across populations. Nat. Commun. 9, 4169.</p>
<p>Institute of Medicine (US) Forum on Microbial Threats (2006). Ending the War Metaphor: The Changing Agenda for Unraveling the Host-Microbe Relationship: Workshop Summary (Washington (DC): National Academies Press (US)).</p>
<p>Li, R., Fein, S.B., Chen, J., and Grummer-Strawn, L.M. (2008). Why Mothers Stop Breastfeeding: Mothers’ Self-reported Reasons for Stopping During the First Year. Pediatrics 122, S69–S76. </p>
<p>Milani, C., Duranti, S., Bottacini, F., Casey, E., Turroni, F., Mahony, J., Belzer, C., Palacio, S.D., Montes, S.A., Mancabelli, L., et al. (2017). The First Microbial Colonizers of the Human Gut: Composition, Activities, and Health Implications of the Infant Gut Microbiota. Microbiol. Mol. Biol. Rev. 81, e00036-17.</p>
<p>de Muinck, E.J., and Trosvik, P. (2018). Individuality and convergence of the infant gut microbiota during the first year of life. Nat. Commun. 9.  </p>
<p>Pannaraj, P.S., Li, F., Cerini, C., Bender, J.M., Yang, S., Rollie, A., Adisetiyo, H., Zabih, S., Lincez, P.J., Bittinger, K., et al. (2017). Association Between Breast Milk Bacterial Communities and Establishment and Development of the Infant Gut Microbiome. JAMA Pediatr. 171, 647–654. </p>
<p>Perez-Muñoz, M.E., Arrieta, M.-C., Ramer-Tait, A.E., and Walter, J. (2017). A critical assessment of the “sterile womb” and “in utero colonization” hypotheses: implications for research on the pioneer infant microbiome. Microbiome 5, 48. </p>
<p>Petrof, E.O., Claud, E.C., Gloor, G.B., and Allen-Vercoe, E. (2013). Microbial ecosystems therapeutics: a new paradigm in medicine? Benef. Microbes 4, 53–65. </p>
<p>Prosser, J.I., Bohannan, B.J.M., Curtis, T.P., Ellis, R.J., Firestone, M.K., Freckleton, R.P., Green, J.L., Green, L.E., Killham, K., Lennon, J.J., et al. (2007). The role of ecological theory in microbial ecology. Nat. Rev. Microbiol. 5, 384–392. </p>
<p>Qazi, T., Amaratunga, T., Barnes, E.L., Fischer, M., Kassam, Z., and Allegretti, J.R. (2017). The risk of inflammatory bowel disease flares after fecal microbiota transplantation: Systematic review and meta-analysis. Gut Microbes 8, 574–588. </p>
<p>Singh, R.K., Chang, H.-W., Yan, D., Lee, K.M., Ucmak, D., Wong, K., Abrouk, M., Farahnik, B., Nakamura, M., Zhu, T.H., et al. (2017). Influence of diet on the gut microbiome and implications for human health. J. Transl. Med. 15, 73. </p>
<p>Sommer, F., and Bäckhed, F. (2013). The gut microbiota — masters of host development and physiology. Nat. Rev. Microbiol. 11, 227–238.</p>
<p>Stewart, C.J., Ajami, N.J., O’Brien, J.L., Hutchinson, D.S., Smith, D.P., Wong, M.C., Ross, M.C., Lloyd, R.E., Doddapaneni, H., Metcalf, G.A., et al. (2018). Temporal development of the gut microbiome in early childhood from the TEDDY study. Nature 562, 583. </p>
<p>Tamburini, S., Shen, N., Wu, H.C., and Clemente, J.C. (2016). The microbiome in early life: implications for health outcomes. Nat. Med. 22, 713–722. </p>
<p>The Human Microbiome Project Consortium, Huttenhower, C., Gevers, D., Knight, R., Abubucker, S., Badger, J.H., Chinwalla, A.T., Creasy, H.H., Earl, A.M., FitzGerald, M.G., et al. (2012). Structure, function and diversity of the healthy human microbiome. Nature 486, 207–214.</p>
<p>Togo, A., Dufour, J.-C., Lagier, J.-C., Dubourg, G., Raoult, D., and Million, M. (2019). Repertoire of human breast and milk microbiota: a systematic review. Future Microbiol. 14, 623–641.</p>
<p>Vallès, Y., Artacho, A., Pascual-García, A., Ferrús, M.L., Gosalbes, M.J., Abellán, J.J., and Francino, M.P. (2014). Microbial Succession in the Gut: Directional Trends of Taxonomic and Functional Change in a Birth Cohort of Spanish Infants. PLoS Genet. 10.</p>
<p>Vellend, M. (2010). Conceptual synthesis in community ecology. Q. Rev. Biol. 85, 183–206.</p>
<p>Walter, J., Maldonado-Gómez, M.X., and Martínez, I. (2018). To engraft or not to engraft: an ecological framework for gut microbiome modulation with live microbes. Curr. Opin. Biotechnol. 49, 129–139.</p>
]]></content>
      <tags>
        <tag>ecology</tag>
      </tags>
  </entry>
  <entry>
    <title>PSYCHO-PASS 心靈判官</title>
    <url>/psycho-pass-anime-and-novel/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《PSYCHO-PASS 心靈判官》系列包含電視版一／二季、劇場版、改編漫畫與小說（台灣僅代理本傳和標本事件前傳。），以下是電視、劇場版和本傳小說的心得。</p>
<span id="more"></span>

<h1 id="小說"><a href="#小說" class="headerlink" title="小說"></a>小說</h1><p>雖然融合了cyberpunk和動作元素，《心靈判官》的本質仍是反烏托邦小說，透過虛構一個由電腦系統主宰民眾職業、婚配甚至罪刑的究極官僚社會，再描述當中發生的種種矛盾以彰顯個人意志對人類的重要性。</p>
<p>故事背景是世界陷入經濟崩潰和政府解體的２２世紀，唯有採用希貝兒系統的日本倖免。希貝兒是由強化大腦連結成的平行運算系統（以下簡稱「系統」），挑選不受既有規範、情感、交際影響的超常人格者為成員，利用人類優於機械的圖像、氣質、……等判斷直覺，替代電腦執行判斷。</p>
<p>其宗旨是促成大多數國民的最大幸福，幸福在此定義成「不須面對抉擇」，由希貝兒代替人民作出最佳選擇。系統愈健全，裁決就愈精準，離理想社會也將更進一步。要讓民眾放心地接受系統裁示得先讓他們信任系統，所以為達成目的，它必須完善系統運作，甚至不擇手段提升效能。</p>
<p>然而追求完美並不可行，較實際的作法是掩飾失敗，讓人民誤以為完美。用虛擬顯影建立都市整潔形象，或隱匿不利資訊（其他可能的社會體制、存在免罪體質者），把反動分子和低層民眾驅趕到刻意留下的廢墟區，冠上汙名轉移市民焦點。對於無法處置或隱瞞的案例，如免罪體質罪犯，則納入系統周延判斷能力，同時消滅之。</p>
<p>儘管書中沒直接提到，但穩定的秩序也應是順利運作的前提。系統藉由監控全體國民精神狀況，揪出潛在犯案者處置，危害小者收容治療，無根治希望者就地處決。由此可知系統沒有定義什麼是「邪惡」、「正義」、「罪愆」與「懲戒」，維持治安就像免疫系統排除病原一樣，不論犯行，端看有無害處。刑警們是向百姓展示維安實力的棋子，他們辦理的案件也只是須優先解決的病灶。</p>
<p>角色和系統的認知落差即故事展開處。主角群由具潛在犯身分的執行官和監督前者的監視官組成，隸屬系統底下的刑事局，負責追查案件，並依系統判斷處置人犯。這些執行官是體制的受害者，因種種原因被剝奪正常人生和從前的生存態度，本作藉由他們質疑系統正當性和討論社會議題。例如前刑警征陸仍抱有舊時代的正義觀，對於以心靈指數定罪卻輕視證據的態度不以為然；前監視官狡齒則不忘殺死對方的是自己而非系統的指示。</p>
<p>各角色多少有表達異議，但最重要的提問者卻是反派槙島聖護，他在幕後策畫一連串案件，藉此質問人民一味聽從指示的扭曲社會中，是否仍存在個人意志和主體性。就像用案件發表一場演說，首先在金原祐治案中展示他的手段：不直接參與犯案，而是給予具有強烈動機的普通人超越法律或倫理的力量，觀察人們會不會基於自我意識越矩行動。<br>　　接著協助病態粉絲御堂將剛殺死偶像篡奪虛擬形象，可是御堂沒有善用這些理想形象，反而滿足於成為他人，在眾多虛假的面貌中迷失自我。另外，被殺掉的偶像能被粉絲取代，這不意味著「……每個人都是空虛的，不再有人需要他人，不論是什麼才能都能找到替代品，任何人都是替代者的替代者，……」那一個人還有什麼獨特性嗎？　</p>
<p>「刺激會帶來活力，那是與死毗鄰的危險報酬」、「……不知道絕望，就不會有希望。」王陵瑠華子支解屍體為素材，模仿父親的畫作，繼承其警惕世人的意志；泉宮寺豐久策畫人類狩獵，想在生死交關中強烈地感受到活著。槙島藉兩起案件拋出這議題：危險和壓力固然是痛苦的根源，但它們也是生存的證據；認知現實的晦暗與殘忍能喚醒理性與良知。用藥物控管心理狀況，紓解壓力並排除所有不良因子的同時，是不是也抹煞了生命？</p>
<p>泉宮寺豐久被處決後，槙島出現在主角常守朱面前，作勢要殺了她朋友。由於槙島是免罪體質者，心理指數不因犯案提升，所以常守朱不能用主宰者制裁，得用傳統火器擊斃他。但用其他武器的含意不只是違反規定，還代表她不能把殺人的責任推給制度，得獨自扛下。</p>
<p>「……，人只有在基於自我意志行動時才有價值。」</p>
<p>這就是槙島最後的提問：自主的個體得親自選擇未來並為此煩惱，同時承擔選擇的後果，害怕背負責任與風險而將之推給社會、推給希貝兒系統的民眾還稱得上人嗎？<br>　　<br>情節至此，已完整陳述這世界的矛盾，後半段則要揭露系統真相，指出其不得不為的理由，並且讓成長的常守朱從中得出最終結論。</p>
<p>槙島綁架常守朱的朋友是想觀察她會不會為了救人而自願背負不義，但是常守朱心中顯然還有其他顧慮：開了槍就等於破壞至今穩固社會的體制。然而她還是閉著眼睛開槍，似乎在逃避什麼，和狡齒的對話也曾提過「殺死對手的不是主宰者，而是我的殺意……」，所以推測初次面對矛盾狀況的她比較接近不敢攻擊。</p>
<p>事件過後她才漸漸堅定信念。她肯定體制的成效和必要，但不贊同其功利價值觀，想從中找回正義的理念；她亦承認反派對系統的質疑，但不認同視人命為草芥的態度，即便在系統支配的社會生存，人類仍然有寶貴的價值。</p>
<p>人們並非被動地活在規範中，如結尾所述：「不是法律守護人，而是人民要守護法律。」「我們憎恨罪惡，尋求正確人生的心情累積形成的就是法律。那不是條文，不是系統，而是存在於任何人心中，脆弱卻有無可替代的心情。相較於憤怒或憎恨的力量，可說是無比脆弱、極易碎裂。因此，為了不讓過去所有想創造出更美好世界者的祈禱變得毫無意義，我們必須堅守法律，不可輕言放棄。」常守朱想在全面破壞與死守體制兩種瘋狂之中，試著走出實際的路，所以她要阻止狡齒復仇，以免破壞體制，也主張加開法庭審理以維護法治。</p>
<p>從建立世界觀，點出爭議，到最終和解，《PSYCHO-PASS 心靈判官》已進行了一次漂亮的論辯。然而有些美中不足的是，因為以警察劇為軸，所以結尾只做出關於正義與法律的思辨，但角色的提問還涵蓋很多東西：自小被系統決定人生的騰秀星有選擇的自由嗎？「盲從系統決定的適性，滿足於被強加的幸褔」還可以保有夢想嗎？在系統呵護下，不需合作也能達成目標，彼此連結是否變得無關緊要？</p>
<p>這些議題也許會持續出現在往後的續作中，只是受限於主角的身分和性格，應該永遠都不會提出解答。</p>
<h1 id="電視版第一季"><a href="#電視版第一季" class="headerlink" title="電視版第一季"></a>電視版第一季</h1><p>我先看了電視版才補完小說，《PSYCHO-PASS心靈判官》的動畫節奏拿捏得很好，每集都斷在令人在意的地方，數集描述一個事件，同時也逐步醞釀最後的大陰謀。人設吸引人、配樂又好聽，雖然動作戲不多，但是懸疑推理的氛圍看得也很過癮。</p>
<p>小說和電視版最大的差異在於小說比較積極營造反烏托邦氣氛，一開頭就說明日本在系統治理下成了「理想的社會」，並且提到廢墟區的功能、人們依適性選擇職業、參考電腦配對發展婚姻（電視版要到第二季才提到。）。另外刪除六合塚來歷以及國營企業命案兩個支線，並且加入番外篇描述其他成員間的關係。</p>
<p>小說把角色心理描寫得更細，亦補充說明一些電視版較含糊的地方，例如「為什麼不拘捕犯人追查共犯？」、「霜月明明認為王陵琉華子很可疑卻推好友入火坑？」、「全身義體化的泉宮寺豐久還測得到心靈指數嗎？」、「為什麼用人腦而不是用電腦當主機？」</p>
<p>其他零零碎碎的相異處還很多。我印象比較深刻的是介紹標本事件時，電視版的六合塚在吃泡麵，可是小說中卻在喝能量飲料，沒有提到六合塚喜歡更變態的東西。</p>
<h1 id="電視版第二季"><a href="#電視版第二季" class="headerlink" title="電視版第二季"></a>電視版第二季</h1><p>在希貝兒系統建立前，日本政府曾打算藉由監控人民行動和經濟活動預測犯罪，設施完成後在交通網路試作。然而這項建設卻被厚生省蓄意干擾，使得監控系統失靈，導致嚴重交通事故頻傳，最終棄置原先計畫轉而採納厚生省支持的希貝兒先知系統。反派鹿矛圍桐斗正是其中一場意外的倖存者，但他並非一個體，而是由罹難者的遺體和大腦拼湊成的集合體。</p>
<p>因為系統自知的其心理指數超標，若採計集體心理指數將不得不審視自己的統治合法性，故默認集合體的心理指數為空，讓自己可不受監督，維護體制完整，可是這麼做也使他們無法監測同為集合體的鹿矛圍，對其舉動束手無策。</p>
<p>鹿矛圍的目的是逼迫系統計算集體心理指數，將系統自身列為制裁的對象，然後用主宰者毀滅之；另一方面，也能藉此得知自己的心理指數是多少。他利用降低心理指數的技術，培養出一批接近免罪體質的犯罪者，由於系統無法透過收編他們解決問題，又不能坐視動亂不管，只能選擇對付鹿矛圍。</p>
<p>倘若循體制內作法，會危及執法的正當性；若無視規則私下解決，便間接承認系統侷限，同樣會重挫民眾信心，動搖社會的基礎。面臨兩難的系統分為兩派：東金母子黨打算越過程序殺人滅口，凌虐小朱祖母嫁禍鹿矛圍，想激怒常守朱除掉他。其餘成員則採納常守朱的建議：承認集體心理指數的同時，自主汰除不良分子，讓心理指數穩定在正常範圍內。</p>
<p>最終東金母子挫敗，鹿矛圍雖然戰死但成功迫使系統納入監督體制。系統暫時度過危機，卻也種下新危機的種子：個體和集體心理指數不一定一致，純淨的心可能聚集成混濁墮落的組織，純淨的群體也可能由罪大惡極者組成，為了制裁一個團體，要傷害其中無辜的個人。目前仍無法計算社會的集體心理指數，一旦社會心理量化的那天來臨，或許會因此引發更大的混亂。</p>
<p>第二季的野心很大，試圖討論集體與個體心靈指數關係以及執法者的統治正當性，只是劇情安排和人物刻劃搞砸導致風評很差，但這是和第一季相比的結果，單獨看的話其實還可以。</p>
<p>剛看完時覺得這回的反派不夠有力，雖然鹿矛圍立意明確、計畫縝密，但和槙島聖護「英雄式預言者式的氣質，創造愉快交談空間的能力，對任何事物都能抒發己見的智力」的領袖氣質相比，還有很大落差。</p>
<p>從犯案動機來看，鹿矛圍是純粹功能導向的。首先挾持酒酒井監視官測試自己可否操作主宰者，於藥局人質事件中驗證監視官一樣會被制裁，繼而引誘刑事局落入埋伏奪取主宰者，最後藉由濫發主宰者造成運算負荷，推算出系統核心位置，帶領一批人發動總攻擊。完美、精準而且確實，但少了槙島那種質問世人的戲劇性。</p>
<p>而且槙島在第一季有很多表達意見的場合，除了主線另有狡齒的私仇這條支線；可是鹿矛圍似乎礙於篇幅沒辦法充分表現，只能作為被追捕的對象成為角色間的話題。</p>
<p>不只反派，其他人物也刻畫不足。加入和常守朱意見相左的霜月監視官可能是想營造觀念衝突，但霜月不管做什麼都被打臉，僅成了為主角實力背書的祭品（還有觀眾唾棄的對象）。而犯罪指數史上最高的東金執行官，剛開始似乎有填狡齒缺的氣勢，但劇情跑到最後被證明只是一個病態的嬤控。至於六合塚和新人物雛河翔則沒什麼存在感，默默地做事默默地被淡忘。</p>
<p>再來提主角常守朱。先前宜野座、征陸、狡齒各司其職，但這一季宜野座被削弱得比較圓滑，其他人物又沒什麼影響力，所以前一季的所有屬性都灌到常守朱身上，化解觀念衝突也減少了劇情張力，最後看起來就像她一個人在東京開無雙。</p>
<p>要挑毛病的話，還可以從犯案方法、追捕手段、……等找瑕疵，但覺得點到為止即可，若不是寫心得比較兩季動畫，我根本不會看得這麼細，音樂播放、槍戰開始的時候我就陷在故事裏了。僅提一點之前覺得是bug，但後來覺得沒問題的地方：最後對峙時，系統排除惡性成員降低心理指數，讓鹿矛圍無法攻擊它。可是若鹿矛圍真想瓦解系統，為何不用其他冷兵器攻擊？</p>
<p>我想一想，鹿矛圍不是單純想毀掉系統，他要讓系統自毀，也就是毀於自己的審判機制，這樣才能強調他的訴求「執法者也要被監督」。</p>
<h1 id="劇場版心得"><a href="#劇場版心得" class="headerlink" title="劇場版心得"></a>劇場版心得</h1><p>劇場版時間點接在第二季後，但可以獨立觀看。這次的舞台在海外，東南亞聯合政府打算從日本引進希貝兒系統，借重其監控設施和無人武裝弭平內亂。刑事局一課逮捕來自該國的恐怖分子後，發現逃亡的前執行官狡齒涉入動亂，於是派遣常守朱前往調查。</p>
<p>在調查中意外揭發東南亞聯合政府軍方隱匿己方異常的犯罪指數，濫用系統鎮壓反對派。東窗事發後，政府方早一步捉拿常守朱欲除之後快，所幸來自刑事一課在危急時趕上，一舉掃蕩軍中的潛在犯。原來，這一切都在系統的策畫中，為了平定鬥爭局面需要利用政府軍的力量，故先前刻意縱容，一旦時局較穩定則解決這些惡徒，收回控制權。</p>
<p>雖然劇場版也有要討論的議題，例如統治的合法性、動亂國家的悲哀、手段正當性……等，但都沒辦法充分展開推論。另外人物塑造不深刻，前頭把反抗軍首領講得很重要，很能鼓舞人心，後頭卻草草地收了他。政府軍上校看起來是個有故事的人，卻什麼主張都沒有提就被殺了。</p>
<p>所以這部的重點還是小朱和狡齒重逢、宜野座與狡齒的man talk以及滿滿的武打駁火吧，至於劇情深度和合理性就其次了。</p>
<p>明年的三部劇場版分別以霜月／宜野座（罪與罰）、征陸／須鄉（Frist Guardian）、狡齒（恩仇的彼端）為主軸。征陸的故事應該會描述系統建立前的社會景況，而霜月那部正好補充這角色先前不足的形象。希望不只是單純動作戲，也能從不同角度考察希貝兒治理的世界，畢竟心靈判官的設定其實有很多題材可以發揮啊！</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>R/Rstudio console 的指令長度限制</title>
    <url>/r-console-upper-limit-on-the-string-length/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>TL:DR：輸入 R&#x2F;Rstudio console 的指令之容量上限為 4095 bytes。若超出上限，console 會忽略超出的部分，顯示 + 提醒使用者補完剩餘指令。</p>
<span id="more"></span>

<p>今天測試定序前處理的 pipeline 時，發現總是無法順利讀檔。為了 debug，我把所有檔案的輸入路徑存為一個字串，並複製到 R console，重跑其中一個 function。結果 console 上印出一個 + 號，function 仍無法運作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> parse_path<span class="punctuation">(</span><span class="string">&quot;....&quot;</span><span class="punctuation">)</span> <span class="comment"># 這是長度約三千多個字符的字串</span></span><br><span class="line"><span class="operator">+</span></span><br></pre></td></tr></table></figure>
<p>我第一個反應是檢查括弧的數量和位置是否正確，接著仔細看檔案路徑中有沒有跳脫字符。然而，怎麼檢查都沒有留意到語法錯誤，於是開始丟各種長度和內容的字串測試。</p>
<p>後來，我發現只要刪除部分字串，function 又可以順利執行了，所以我猜 R 的字串可能有長度上限？循著這猜想，我在網路上找到不少面臨相似問題的人，例如：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28399710/storing-long-strings-dna-sequence-in-r">storing long strings (DNA sequence) in R</a></li>
<li><a href="https://stackoverflow.com/questions/54974996/how-to-bypass-rstudio-console-upper-limit-on-character-string-length">How to bypass RStudio console upper limit on character string length?</a></li>
</ul>
<p>最終，我才在<a href="https://community.rstudio.com/t/does-console-impose-an-upper-limit-on-the-length-of-strings/12872">這則問題</a>找到答案：輸入的字串被刪節確實是因為其大小超出限制，但並非超出 character 存儲上限，而是超出 R&#x2F;Rstudio console 的上限。</p>
<p>舉例來說，我們可以用 paste0 和 rep 建立長字串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>再使用 nchar 統計字串長度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span>seq<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure>
<p>然而，若把字串印出，再完整貼到 console 裏執行。由於字串大小超出 console 上限，所以 nchar 便無法順利運作了。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> nchar<span class="punctuation">(</span> <span class="string">&quot;ABCDEFGABCDEFGABCDEFG......&quot;</span> <span class="punctuation">)</span></span><br><span class="line"><span class="operator">+</span> </span><br></pre></td></tr></table></figure>

<p>當然，字串也有其容量上限，這上限應該是取決於記憶體容量。這狀況，R 會直接告訴我們容量不足，而不是顯示讓人困惑的 +。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">100000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error<span class="operator">:</span> cannot allocate vector of size <span class="number">745058.1</span> Gb</span><br></pre></td></tr></table></figure>
<p>有趣的是，數字再大一點時數字會以科學記號表示，不符合 rep 的輸入規範，也會顯示錯誤。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> seq <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1000000000000000000000</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">Error <span class="keyword">in</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;ABCDEFG&quot;</span><span class="punctuation">,</span> <span class="number">1e+21</span><span class="punctuation">)</span> <span class="operator">:</span> invalid <span class="string">&#x27;times&#x27;</span> argument</span><br></pre></td></tr></table></figure>
<p>這些道理我都懂，可是，我的 pipeline 是以腳本執行啊，怎麼還會碰到這問題？經過一番苦思，發現 bug 出在我的程式邏輯上，跟本文提到的限制一點關係都沒有。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/r-console-upper-limit-on-the-string-length.png?raw=true" alt="meme, it&#39;s my fault, not R&#39;s"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Reversal Distance (REAR)</title>
    <url>/reversal-distance/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定 5 對長度為 10 的數列，計算將各對數列互相轉換所需的最少反轉次數。</p>
<blockquote>
<p>A reversal of a permutation creates a new permutation by inverting some interval of the permutation; (5,2,3,1,4) , (5,3,4,1,2) , and (4,1,2,3,5) are all reversals of (5,3,2,1,4) . The reversal distance between two permutations π and σ , written drev(π,σ) , is the minimum number of reversals required to transform π into σ (this assumes that π and σ have the same length).</p>
<p>Given: A collection of at most 5 pairs of permutations, all of which have length 10.</p>
<p>Return: The reversal distance between each permutation pair.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/rear/">https://rosalind.info/problems/rear/</a>)</p>
<span id="more"></span>

<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><p>染色體特定片段前後翻轉的現象稱為 inversion，它是基因體重排最常見的形式。計算兩條染色體透過 inversion 互相轉換所需的最少次數，可視同求解兩數列之間的反轉距離（reversal distance）。</p>
<p>假設我們有一個起始數列和一個目標數列。若兩數列完全相同，則反轉距離為 0，不須進行任何反轉操作。但如果兩者不一致，可先列出起始數列經過一次反轉後可能產生的所有數列，再檢查目標數列是否出現在新生成的數列中。</p>
<p>如果找到目標數列，就回報所需的反轉次數；如果沒找到，就列出這些數列再次返喘後可能產生的所有數列。</p>
<p>重複上述過程，列出經過 n 次反轉後可能產生的所有數列，並且檢查目標數列是否出現其中，直到找到目標數列或窮盡所有可能為止。</p>
<p>為了實現這個算法，首先需要一個副程式，用於列出一個數列經過一次反轉後可能產生的所有數列。簡言之，在數列上任選兩個位置，用 <code>[::-1]</code> 反轉居於其間的子數列，再連結反轉數列與剩餘數列。</p>
<p>這些數列可以儲存在 list、tuple、或 set 等資料型別中。我選擇使用 set 是因為它能自動排除重複的數列，減少多餘的比較。其次，與 list 和 tuple 相比，判斷一個元素是否在 set 之中只需要常數時間，能減少比較的時間成本。最後，set 支援交集、聯集和差集等操作，在比較數列集合時有比較多彈性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate all possible subsequences of a tuple by reversing segments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        l (tuple): Input tuple, e.g., (1, 2).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        set: Set of tuples with reversed segments, e.g., &#123;(1, 2), (2, 1)&#125;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        l[:i] + l[i:j][::-<span class="number">1</span>] + l[j:]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，計算反轉距離還需要以下三項資訊：</p>
<ul>
<li>curr：記錄準備與目標數列比較的數列集合</li>
<li>visited：記錄已經檢查過的數列集合</li>
<li>dist：記錄當前的反轉次數</li>
</ul>
<p>具體的流程和程式碼如下：</p>
<ol>
<li>檢查目標數列是否出現在 curr 中。若有找到目標數列，則回報當前的反轉次數  dist。</li>
<li>若沒有找到，則依序反轉 curr 中每個數列，但要排除掉已經檢查過的數列visited。</li>
<li>將新生成的反轉數列納入已檢查過的數列集合 visited，以免重複比較。</li>
<li>將所有可能的反轉結果更新到 curr，以便下一輪比較。同時，將當前反轉次數 dist 的值加 1。</li>
<li>更新完畢後，回到步驟 1. 繼續搜索，直到找出目標數列（回傳 dist），或是檢查過所有可能性仍未找到目標數列（回傳 -1）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate the minimum number of reversals required to transform tuple s1 to tuple s2.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        s1 (tuple): Starting tuple.</span></span><br><span class="line"><span class="string">        s2 (tuple): Target tuple.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: Minimum number of swaps required, or -1 if transformation is not possible.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    curr, visited = &#123;s1&#125;, &#123;s1&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="keyword">if</span> s2 <span class="keyword">in</span> curr:</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_step = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> curr:</span><br><span class="line">                next_step.update(swap(e).difference(visited))</span><br><span class="line">                visited.update(next_step)</span><br><span class="line">            curr = next_step</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><p>這題的觀念其實不難理解，但真正的挑戰在於計算效率。隨著數列長度和反轉次數增加，算法的時間複雜度會呈指數增長。依照題目要求的數列長度測試，我的電腦大約只能處理到 4-5 次反轉，再多的反轉次數就無法在合理的時間內算出來。</p>
<p>想要評估計算反轉距離的成本可以考慮以下三個因素：比較成本（$c$, Cost）、可能的數列數量（$n$, Number）、檢查的深度（$d$, Depth or Distance），即 $cn^d$。為了提升計算效率，可以從這三項因素著手。</p>
<ul>
<li>降低每次比較的成本，例如以 set 取代 list。</li>
<li>降低可能的數列數量，例如排除已檢查過的數列或是只生成有用的數列等。</li>
<li>降低檢查深度，例如同時從數列的前端和後端開始檢查。</li>
</ul>
<p>這些方式都能提升計算效率，但適用的情境不盡相同。如果數列長度很短，可能的反轉結果會比較少，反轉距離也不長，那麼關鍵就在於降低每次比較的成本。反之，如果像這題一樣需要處理較長的數列，那麼重點就轉移到了控制可能的數列數量和檢查深度上。</p>
<p>雖然排除已檢查過的數列能起到一定作用，但問題在於反轉距離還是太長了，相較於指數增長的待檢查數列，重複數列的數量顯得微不足道。</p>
<p>另一種策略是在生成可能的反轉數列時，只生成有機會轉換為目標數列的數列。這方法若能有效降低 $n$ 值，便能容忍更長的反轉距離以及比較數列的長度。</p>
<p>然而，這想法雖然理想，但它的困難在於不容易找到正確的篩選規則來判斷一個數列是否有可能轉換為目標數列。即使找到一項不錯的規則，但也很難保證這規則不會遺漏某西可能性，導致它雖然能在有限時間內回應，卻未必是最優解。</p>
<p>最後一種手段則相對值觀，就是分別從數列的前後端開始搜索，這樣可以將檢查的深度減半。如題目要求，對於長度為 10 的數列，即使窮舉，最多經過 9 次反轉便能轉會為任意數列。</p>
<p>如前所述，反轉距離大於 4 - 5 次就達到當前計算能力的極限，從兩端同時搜索，正好能將檢查深度控制在極限以內。</p>
<p>雙向排查的程式碼如下所示。為了降低主程式的複雜度，我新增了副程式 get_next_steps，用於生成數列集合的每個元素在經過一次反轉後可能產生的所有數列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next_steps</span>(<span class="params">curr, visited</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates next steps by swapping elements in `curr`, excluding those in `visited`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        curr (set): Current states.</span></span><br><span class="line"><span class="string">        visited (set): States to exclude.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        set: Next possible states.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    next_steps = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> curr:</span><br><span class="line">        next_steps.update(swap(e).difference(visited))</span><br><span class="line">    <span class="keyword">return</span> next_steps</span><br></pre></td></tr></table></figure>

<p>其餘部分則與只從一端開始檢查的方式相似，只是要有兩組 curr 和 visited 分別存儲從前後端檢查數列的資訊。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    f_curr, f_visited, b_curr, b_visited = &#123;s1&#125;, &#123;s1&#125;, &#123;s2&#125;, &#123;s2&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> f_curr <span class="keyword">and</span> b_curr:</span><br><span class="line">        <span class="keyword">if</span> f_curr.intersection(b_curr):</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            f_curr = get_next_steps(f_curr, f_visited)</span><br><span class="line">            f_visited.update(f_curr)</span><br><span class="line">        <span class="keyword">if</span> b_curr.intersection(f_curr):</span><br><span class="line">            <span class="keyword">return</span> dist</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            b_curr = get_next_steps(b_curr, b_visited)</span><br><span class="line">            b_visited.update(b_curr)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h1><p>說點題外話，這題算得上 Rosalind 平台的東巴了，我想半天解不出來，看了討論區才知道原來有那麼多人也覺得出題方在整人。儘管題目提示 “Don’t be afraid to try an ugly solution.”，但真想用暴力法解題，是絕對沒辦法在規定時間內通過測試的。</p>
<p>以下是我找到的另一種基於雙向搜索的解法，雖然它沒有處理起始數列與目標數列無法互相轉換的狀況，但整體想法卻清晰易懂。這方法首先將輸入的數列轉換為 set 以利比較，接著判斷兩者是否有交集。如果有，則直接回傳當前的反轉距離；反之，則為每個數列集合中的元素生成所有可能的數列，再判斷新生成的數列集合彼此是否交集。如果仍沒有交集，就遞迴呼叫這個副程式，持續搜索下一層，直到找到交集為止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2, dist=<span class="number">0</span></span>):</span><br><span class="line">   s1 = &#123;s1&#125; <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">tuple</span>) <span class="keyword">else</span> s1</span><br><span class="line">   s2 = &#123;s2&#125; <span class="keyword">if</span> <span class="built_in">isinstance</span>(t, <span class="built_in">tuple</span>) <span class="keyword">else</span> s2</span><br><span class="line">   <span class="keyword">if</span> s1.intersection(s2):</span><br><span class="line">        <span class="keyword">return</span> dist</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">        next_s1 = &#123; swap_e <span class="keyword">for</span> e <span class="keyword">in</span> s1 <span class="keyword">for</span> swap_e <span class="keyword">in</span> swap(s1) &#125;</span><br><span class="line">        next_s2 = &#123; swap_e <span class="keyword">for</span> e <span class="keyword">in</span> s2 <span class="keyword">for</span> swap_e <span class="keyword">in</span> swap(s2) &#125;</span><br><span class="line">        <span class="keyword">if</span> s1.intersection(next_s1) <span class="keyword">or</span> s2.intersection(next_s1):</span><br><span class="line">            <span class="keyword">return</span> dist + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> next_s1.intersection(next_s2):</span><br><span class="line">            <span class="keyword">return</span> dist + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> rev_dist(next_s1, next_s2, dist + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>從期望的結果反推現在要採取的行動</title>
    <url>/reverse-engineering-actions-from-desired-outcomes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>準時到就是遲到</p>
</blockquote>
<p>國慶連假期間，台北市立圖書館總館舉辦了兩場留學講座。我大概在開始前十分鐘進場，結果進門便看見講師一面在白板上振筆疾書，一面說明需要準備哪些申請文件。</p>
<p>「不是下午兩點開始嗎？」我心想，還打開手機確認自己有沒有搞錯時間，不過我的疑惑很快就得到答案了。</p>
<p>「你們這些早到的人很聰明，可以趁人少的時候跟講師或其他同學交流，也能提早準備課程所需的東西。」講師說。</p>
<p>「雖然學校會跟你們講申請的收件截止日是幾月幾號，但不要傻傻地等到那時候才寄出資料，因為你無法保證快遞公司或是郵局能順利把申請資料送到指定學校，也無法保證自己不會遺漏應附的文件，所以一定要預留數周的前置時間。</p>
<p>「其次，有些學校採取隨到隨審制度 (Rolling admission)，收滿為止。等到截止日才寄出資料恐怕已經額滿，那時候有多好的條件也沒機會了。」講師說。</p>
<p>這是當天的第一個教訓，我再也不會相信甘道夫了。</p>
<p>（講師：洪健庭，社團法人中華民國愛公益協會公關主任）</p>
<span id="more"></span>

<h1 id="留學申請-PDCA-架構"><a href="#留學申請-PDCA-架構" class="headerlink" title="留學申請 PDCA 架構"></a>留學申請 PDCA 架構</h1><p>雖然代辦可以在申請初期提供許多幫助，節省蒐集和閱讀資料的時間，但是許多代辦其實不熟悉你要申請的領域，甚至沒有出國或留學的經驗，這樣你還願意把未來交付給他們嗎？</p>
<p>因此，自己的人生要自己作主，把校系申請當作專案管理，全力和來自印度、中國、日本等國家的學生競爭。</p>
<h2 id="Planing"><a href="#Planing" class="headerlink" title="Planing"></a>Planing</h2><p>申請學校的前要了解申請流程和文件。首先，你需要一張表格記錄目標校系的申請門檻、學雜費用、計畫內容等資訊，清單內要有夢幻、穩健和保底等不同層級的校系，不要孤注一擲或裹足不前。</p>
<p>接著要準備五份文檔：自傳、推薦信（要求的數量 + 預備的數量）、履歷、自我介紹信和研究報告 (essay or writing sample)，這些文件是你能力和努力的證明，所以在還沒申請前就要思考怎麼充實，申請期間也需要經過多次修改才能完善。</p>
<p>最後還有英文成績單和個人基本資料，這些都是無法改變的東西，記得提早準備好，不要拖到截止日前還要匆匆忙忙的。一旦學校的申請系統開放，就陸續上傳資料，即使沒有錄取，這些資料保留在系統中可以免去往後補充資料的麻煩。</p>
<h2 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h2><p>要排好時間規劃，英文不可能一次考過，老師們也會耽擱你的推薦信，申請也未必能準時送達，所以你必須做風險管控，確保事情不會搞得一團糟。</p>
<h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><p>不要當完美主義者，要當漸進主義者，從錯誤中學習和成長。每年都期待明年會更好，可是等待和準備期間，時間也溜掉了。即使自己不在乎，也不能無視父母年紀漸長，可能有長期照護等問題，早點出國才不會有後顧之憂。</p>
<p>所以不要打嘴砲，不要給自己藉口，能做的事現在就去做，爛得不堪入目也沒關係，因為遲早會在失敗中得到經驗。丟臉的不是犯錯，是從來不願意付諸實踐。</p>
<h2 id="Act"><a href="#Act" class="headerlink" title="Act"></a>Act</h2><p>深思熟慮才叫行動，其他都是亂來。</p>
<h1 id="社會資本和人脈"><a href="#社會資本和人脈" class="headerlink" title="社會資本和人脈"></a>社會資本和人脈</h1><p>台灣人留學的地區以英美為大宗，所以要善用人數優勢打團體戰，不要單打獨鬥。出國前就建立好人脈，和戰友分享資訊，和強者保持聯絡。出國後更要參與學長姐舉辦的迎新說明會等活動，融入留學生的圈子裡。即使往後不出國，交些會出國的朋友也能交流經驗拓展視野。</p>
<p>除了留學生彼此互助，我們的政府也能幫到不少忙，但不是等到出事情才急急忙忙找別人，平常就要跟可能幫助自己的人打交道。盡可能出席節日、國慶、路跑、過年、聖誕等吃得到家鄉滷肉飯的活動，有餘力便自願承擔接待外賓或協助翻譯等服務以與當地的官員打好關係。</p>
<p>人們往往彼此分享資訊或介紹工作，所以隨著人脈拓展，機會也逐漸增加，所謂的貴人，就是幫助你不一定獲益，卻仍願意伸出援手的人。但要提升遇到貴人的機率，得先學習如何有效幫人，所以有些資訊未必用得到，但記得保留起來幫助別人。前述累積社會資本和人脈的行為即是為了在需要的時候能夠在自助之餘得到人助。</p>
<h1 id="選校評估"><a href="#選校評估" class="headerlink" title="選校評估"></a>選校評估</h1><h2 id="了解自己"><a href="#了解自己" class="headerlink" title="了解自己"></a>了解自己</h2><p>出國留學前一定要了解自己。重點不是你是哪個科系畢業或有多少豐功偉業，而是要搞清楚出國的動機，有動機才會有明確的目標，有明確的目標才有持續的動力，有動力的話，出國這件事才會從空想變得可行。</p>
<h2 id="碩博班選校策略差異"><a href="#碩博班選校策略差異" class="headerlink" title="碩博班選校策略差異"></a>碩博班選校策略差異</h2><p>因為碩士多半要自費，錢要用在刀口上，所以如果打算快攻碩士學位，出國時要選擇排名大於前一學歷的名校，務必在畢業後得到一個響亮的稱號。但就讀博士班很辛苦，所以要選提供全額獎學金的學校，往後的生活和學業才有保障。</p>
<h2 id="選校方式"><a href="#選校方式" class="headerlink" title="選校方式"></a>選校方式</h2><p>建立一個表格，詳列目標校系的申請門檻、英檢成績還有費用等資訊，才不會搞得一蹋糊塗。此外，如果不同學校位在同個地理區，跨校聽演講、學技術、參加研討會都很方便，所以不要只看要申請的學校，關心一下周遭有什麼其他學校，調查潛在的可利用資源。</p>
<h2 id="也要關注國內的教師"><a href="#也要關注國內的教師" class="headerlink" title="也要關注國內的教師"></a>也要關注國內的教師</h2><p>想要留學的話不要只把目光放在國外的學校，也要普查國內在該領域耕耘的老師，了解一下他們讀了什麼學校和什麼科系。因為這些老師們成功從那些學校畢業，而且成功在競爭中找到教職存活到現在，可以作為選校的參考依據。</p>
<h1 id="自我介紹信"><a href="#自我介紹信" class="headerlink" title="自我介紹信"></a>自我介紹信</h1><h2 id="自我介紹信的用途"><a href="#自我介紹信的用途" class="headerlink" title="自我介紹信的用途"></a>自我介紹信的用途</h2><p>在申請季之前就該寄自我介紹信向教授們問招生資訊或研究議題，讓對方感受到你的熱誠。而且自我介紹信是所有文件當中最容易準備的，所以一定不要放過這個機會。</p>
<h2 id="自我介紹信的寫法"><a href="#自我介紹信的寫法" class="headerlink" title="自我介紹信的寫法"></a>自我介紹信的寫法</h2><p>自我介紹信的主旨要明確，務必開門見山讓對方了解寫信的用意。此外，因為詐騙信件很多，為了不被教授或招生負責人誤會，標題要令人產生點開信件的念頭。（也許能參考農場標題或拋出問題請教對方，說不定能勾起教授們解題的好奇心）</p>
<p>初次聯絡時只談研究議題或申請相關的事務，不要談錢。如果對方沒有回覆，可以擇期寄信提醒，但要體諒對方可能需要時間處理你的事情，如果在公務繁忙時一再寄信催趕可能會收到反效果。</p>
<p>為了避免這種狀況一定要掌握外國人的作息，例如英國人早上十點到中午十二點，下午兩點到四點是工作時間，上至院長下至打掃阿姨，只要掌握對方的作息就能接觸到對方。</p>
<h2 id="自我介紹信的格式"><a href="#自我介紹信的格式" class="headerlink" title="自我介紹信的格式"></a>自我介紹信的格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To: address</span><br><span class="line">Subject: Applicant (no. register ID) a question about application yyyy</span><br><span class="line"></span><br><span class="line">Dear Professor OOO</span><br><span class="line"></span><br><span class="line">This is Mr. XXX (name) from Taipei city, Taiwan.</span><br><span class="line"></span><br><span class="line">I would like to apply for *** (programs or courses)</span><br><span class="line"></span><br><span class="line">May I have more information about the application process?</span><br><span class="line"></span><br><span class="line">Sincerely,</span><br><span class="line"></span><br><span class="line">XXX</span><br><span class="line">Department</span><br><span class="line">Contact information</span><br></pre></td></tr></table></figure>

<h2 id="自我推薦不要侷限於電子郵件"><a href="#自我推薦不要侷限於電子郵件" class="headerlink" title="自我推薦不要侷限於電子郵件"></a>自我推薦不要侷限於電子郵件</h2><p>隨著時代進步，自我推薦的管道也不再限於電子郵件，只要有和申請對象接觸的機會，任何途徑都不要放過。</p>
<p>除了官方網站，臉書、推特、Instagram、Youtube等社群網站也是許多學校投放獎學金或申請資訊的地方。若已有預計申請的校系名單，務必追蹤他們廣宣的平台，既能接收攸關申請的最新消息，也能熟悉該校的環境與文化，在入學前就取得往後與對方交流的素材。由於這些媒體的管理員可能同時是該校的員工或學生，積極在網站上按讚留言，可以增進自己和該校的連結（這些網站平常沒什麼人看，外國粉絲這樣熱情，他們的小編應該會很感激你）。</p>
<h1 id="支持文件-supporting-documents"><a href="#支持文件-supporting-documents" class="headerlink" title="支持文件 (supporting documents)"></a>支持文件 (supporting documents)</h1><h2 id="自傳-state-of-purpose"><a href="#自傳-state-of-purpose" class="headerlink" title="自傳 (state of purpose)"></a>自傳 (state of purpose)</h2><p>申請時填寫的線上系統是強調的是過去，但 SOP 強調的是未來，所以要展現你的潛力。你必須在 SOP 中回答兩個問題：你能為學校帶來什麼好處？學校有什麼資源能協助發揮你的潛力？</p>
<h2 id="推薦信"><a href="#推薦信" class="headerlink" title="推薦信"></a>推薦信</h2><p>要先寫好推薦信草稿以免推薦人臨時趕不出來，即使對方好整以暇地，草稿也能作為對方撰寫的參考方向。總之要要替推薦人著想，提供完整的參考資料和上傳指南，文檔用 word 等格式方便修正。</p>
<h2 id="履歷-curriculum-vitae"><a href="#履歷-curriculum-vitae" class="headerlink" title="履歷 (curriculum vitae)"></a>履歷 (curriculum vitae)</h2><p>履歷平常要準備，裡頭不外乎教育、發表、得獎、研究經歷、線上經驗（交換、交流、研討會）、線下經驗（證照、競賽、個人網站）等能證明自己的事蹟。如果成績好的話就把成績放進去，成績不好別拿石頭砸自己腳。語言能力不錯也記得補充，畢竟在還無法實地確認你的能力前，英檢成績就是你唯一的證明（或標籤）。</p>
<h2 id="研究報告-essay-or-writing-sample"><a href="#研究報告-essay-or-writing-sample" class="headerlink" title="研究報告 (essay or writing sample)"></a>研究報告 (essay or writing sample)</h2><p>研究報告展現個人的表達能力、理解能力、領域專精程度還有研究的熱誠。考量讀者的專注力，把代表作論文寫成千字摘要即可。若沒有論文發表，回顧文獻、書評、研究計畫甚至是大學期間曾撰寫過的任何文章都可以整理成研究報告。即使是中文撰寫的也可以翻譯為英文，這樣至少不會沒東西給人家看。</p>
<h1 id="獎學金"><a href="#獎學金" class="headerlink" title="獎學金"></a>獎學金</h1><h2 id="申請獎學金的心態"><a href="#申請獎學金的心態" class="headerlink" title="申請獎學金的心態"></a>申請獎學金的心態</h2><p>公費留考或校方提供的獎學金看似鉅額，但扣除飲食交通、房屋租賃以及購書學習等開銷也所剩無幾，一份獎學金其實根本不夠花。所以，拿錢的時候千萬不要手軟。如果有需求就要盡量拚獎學金，有本事拿多少就不要退讓。因為這些獎學金有許多人競爭，你不申請便被中國或印度等國家的對手拿走（或任何你不願意看到他們拿到獎學金的人拿走）</p>
<p>由於錄取後獲得獎學金的機率會提升，所以錄取後要即刻調查獎學金的申請管道。不只系級、院級、宿舍級乃至校級提供的獎學金，國際學生辦公室 (offfice of international affairs) 提供的資訊也要特別關注。</p>
<p>獲得獎學金後，得到的不只是經濟援助，也是榮耀。要學會用獲獎紀錄當成談判與溝通的利器，說服對方你需要其他獎學金，而且你也值得受到更多栽培，產生 1 + 1 &gt; 2 的效果（錢生錢的效果）。</p>
<p>最重要的，找資源的進取心和對自己的信心一定要有。以前多爛都無所謂，獎學金是拚未來的潛力，不是你的過去。</p>
<h2 id="申請獎學金的管道"><a href="#申請獎學金的管道" class="headerlink" title="申請獎學金的管道"></a>申請獎學金的管道</h2><p>外交部、經濟部、僑委會、科技部、教育部、銀行的獎學金多到看不完，要學會蒐集資訊和取得資源。已經在國外留學的學長姐不能給你錢，但可以向他們探聽獎學金的申請管道，重要的消息往往在小圈子裡傳遞。</p>
<h2 id="公費留考的面試經驗"><a href="#公費留考的面試經驗" class="headerlink" title="公費留考的面試經驗"></a>公費留考的面試經驗</h2><p>教育部提供了留學獎金（已出國者，書審）、公費留考（未出國者，甄試和筆試）、百大獎學金（僅博士班），其中公費留考在筆試通過後，將由申請領域內國內各校院長等級以上的大咖來面試，所以平常便該關注國內同領域大咖的動態。</p>
<p>即使心裡很緊張，入場時一定要有氣勢，把玻璃心丟一邊去，拿出你的勇氣來。因為審查委員要確保納稅人的錢投資在有潛力的人身上，在那個場合他們一定電你，把你講得一無是處，這些挑戰都是正常的，笑笑聽過就好。</p>
<p>通常會要求英文對話以確認你能在國外生存，所以沒事多練中英文自我介紹，確保到場不會緊張出糗。此外，公費留考的面試時間通常很短，務必把握有限的機會見人說人話，見鬼說鬼話，投審查委員所好。</p>
<h1 id="一入學就思考畢業後的價值"><a href="#一入學就思考畢業後的價值" class="headerlink" title="一入學就思考畢業後的價值"></a>一入學就思考畢業後的價值</h1><p>現在就想想十年後想成為什麼人，一入學就要為求職做準備（因為找工作本身也需要練習）。無論之後要走產業還是學術，都要學著從嚮往的結果反推現在要採取的行動，那些等到畢業那天才開始思考未來的人往往等著回國吃自己。</p>
<p>因此，不管當初選擇留學有什麼打算，都要預想回國發展的途徑、留在當地的方法以及在其他國家遊走的機會。放開自己的眼界，不要把成長的經驗套用在陌生環境中。</p>
<p>如果想要留在當地工作，務必要利用志工、實習、研究助理等經驗建立個人與當地的連結。因為你的履歷都是在台灣收集的，對方可能對這些經歷沒有共鳴，所以不要奢望一開始便能全職待在國外，從志工開始也是一個起點，漸漸從事兼職繼而獲得全職工作的機會。（從事學術者也類似，最重要的是一定要找到願意收你的老師）</p>
<p>總而言之，走學術要拚發表，走實業要拚經驗，不要把工作和出國當兩回事，兩者是相輔相成的。</p>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>這份筆記其實不只包含上周日的講座，也整理了洪老師之前在中興大學分享的內容。我覺得這系列講座想要傳達的衍生意義有三點：</p>
<h2 id="動起來"><a href="#動起來" class="headerlink" title="動起來"></a>動起來</h2><p>人生是自己的，所以不要僥倖。無論之前怎麼過生活，一旦起了出發的念頭，大腦就要全速運轉，思考接下來要採取的行動，然後全力以赴去做。人生可以接受失敗，只要棺材板還沒蓋上，都有機會從失敗中學習經驗而後東山再起，最遺憾是裹足不前，連自己可以走到哪都不知道。</p>
<p>畢竟一場演講也沒辦法細講留學文件的撰寫方式，但如果你的渴望很強烈，也會自己想辦法在網路上找到這些資訊。</p>
<h2 id="敢於勝利"><a href="#敢於勝利" class="headerlink" title="敢於勝利"></a>敢於勝利</h2><p>除了熱烈的動機、縝密的計畫和積極的作為，心態上也敢於勝利，捨棄玻璃心、怕丟臉和完美主義等壞習慣。儘管志在出國者對知識分子的形象多少有些期許，或許沒意識到包裝自己或拓展人脈等聽起來很俗的事其實很重要，所以不願意分神去做。</p>
<p>然而內心有原則很好，但做事的時候要權宜。如果對自己的本事有信心，就不要怕別人的評價，能夠提升勝率的事情就去做，取得一次勝利就要想辦法全盤皆勝，不要把機會讓給你認為不夠格的人。</p>
<h2 id="回饋社會"><a href="#回饋社會" class="headerlink" title="回饋社會"></a>回饋社會</h2><p>強調務實不是要成為一個自私的人，是要把心思放在值得的人身上。仔細想想平時把體貼、忍讓和謙退用在哪些人身上？在爭取機會的場合軟弱，怎麼對得起一路幫助自己的人，還有那些沒有機會追尋理想的人？</p>
<p>因此，儘管成就自己的過程要狠，但內心要想著怎麼幫助他人，畢竟人類本來就有一堆缺點，世界又這樣不公平，所以需要互助提醒。</p>
]]></content>
      <tags>
        <tag>career</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 鴿子為什麼那麼大？</title>
    <url>/schrodinger-1944-what-is-life-chapter-1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>七十九年前，薛丁格在都柏林三一學院的系列演講為鴿子尺寸提供了光學以外的解釋。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》">1</span></a></sup></p>
<span id="more"></span>

<h2 id="「鴿子為什麼那麼大？」"><a href="#「鴿子為什麼那麼大？」" class="headerlink" title="「鴿子為什麼那麼大？」"></a>「鴿子為什麼那麼大？」</h2><p>這問題乍聽之下或許令人詫異，但其實許多洞見都是從這樣怪誕或荒唐的問題萌發。</p>
<p>日常生活中，大或小的概念是建立在比較的基礎上。在這問題中，真正的目的或許不在了解鴿子的尺寸，而是想知道事物間為何存在懸殊的尺寸差異。事物尺度與其性質的關係是物理學重要的研究方向，而肉眼可見的巨觀層次和原子尺度的微觀層次則是其中的兩個極端。統計物理解釋了這兩大體系之間的關係，為巨觀現象提供微觀尺度的解釋。因此，若以此角度出發，我們可以把問題精確地重塑為：相較於原子，為什麼鴿子那麼大呢？<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」">2</span></a></sup></p>
<p>確實，相較於原子，一隻鴿子的體積非常大。成鴿的平均體重為 0.5 公斤，其組織器官則由碳、氫、氧、氮、硫、磷和其它微量元素構成。假設鴿子僅由氫原子或硫原子組成，可推知一隻成鴿含有的原子數量約在 $10^26$ 到 $10^28$ 之間，這數量遠超過當今對恆星數量的估計值($3 \times 10^{23}$)<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Dokkum & Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.">3</span></a></sup>。</p>
<p>由於鴿子與原子的懸殊比例，鴿子既無法察覺個別原子的動靜，也不受其碰撞、震盪或旋轉影響。這表示，作用於鴿子的原理和作用於原子的原理可能有很大的差異。但這樣的尺度差異對有機體究竟有什麼意義？又為什麼非得如此，才能維持鴿子的存在？</p>
<h2 id="有機體的運作仰賴精確的物理和化學定律"><a href="#有機體的運作仰賴精確的物理和化學定律" class="headerlink" title="有機體的運作仰賴精確的物理和化學定律"></a>有機體的運作仰賴精確的物理和化學定律</h2><p>有機體的運作無處不仰賴事物間精確的配合。以感知和運動為例，有機體要能靈敏接收刺激，同時不失真地傳遞訊息。這些訊息得正確抵達中樞，在歷經複雜決策後，循另一條途徑輸出，以驅動目標肌肉收縮。這個過程的順利，不只需要事件層序分明，也仰賴組織構造的規律。無論是感覺&#x2F;中樞&#x2F;運動神經的緊密連結，粗肌絲與細肌絲的間隔排列，還是細胞內訊息傳遞分子的聚攏，都是完成一項行為的要件。</p>
<p>即使是最簡單的膝跳反射，也需要器官、組織乃至細胞間的緊密配合，更遑論思考、決策與想像等複雜行為對秩序的需求。這意味著，無論生理還是結構層面，維繫有機體的各項事件皆需要相當的精確性；而外在系統對有機體的影響，也要有與之對應的精確性才會發生作用。<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」">4</span></a></sup></p>
<h2 id="物理和化學定律的精確性奠基於大量原子參與"><a href="#物理和化學定律的精確性奠基於大量原子參與" class="headerlink" title="物理和化學定律的精確性奠基於大量原子參與"></a>物理和化學定律的精確性奠基於大量原子參與</h2><p>然而，少量原子無法支持有機體所需的精確性。在微觀尺度，個別原子持續進行隨機的熱運動，其移動、震盪和旋轉皆無法測量與追蹤。不過隨著系統內的原子數量增加，原子狀態（例如速度、方向、電荷等）的多樣性也隨之增加。一旦數量夠多，大量原子的平均狀態，便會呈現為巨觀層次可觀察到的方向性或規律性。</p>
<p>以順磁性為例，石英管中的氧氣雖然會因置於磁場而磁化，可是並非所有氧分子的方向皆與磁場一致。在局部，個別分子的方向其實會隨熱運動不斷轉變，所以沒有固定一致的排列方式。儘管個別分子的方向無法預期，但隨著磁場增強，石英管內順磁性分子與逆磁性分子的數量差距會逐漸增加，使得多數的氧分子與磁場方向一致，共同產生可觀測的磁化現象。 <sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。">5</span></a></sup></p>
<p>另一項案例是布朗運動與擴散現象。在微觀尺度，單一微粒會受水分子碰撞而隨機運動，其移往各方向的機率與溶液濃度無關。不過，因為溶液中高&#x2F;低濃度區域的微粒數量有別，由高往低濃度移動的微粒自然比由低往高濃度移動的微粒多，於是微粒在巨觀層次表現出隨重力沉降或隨濃度梯度擴散等現象。</p>
<p>反之，若組成系統的原子數越小，隨機偏差的幅度就越大。這關係可以測量精確度的極限說明。扭秤是測量作用力強度重要的工具。為了偵測到更微弱的作用力，往往會替扭秤選用更輕盈的槓桿與絲線。不過，隨著扭秤尺寸縮小，原子熱運動對扭秤的影響也隨之增加，使得原子碰撞和待測作用力造成的擺幅難以區分。在這種尺度下，單次測量的意義有限，得靠多次測量來消除隨機偏差的影響。</p>
<h2 id="有機體需要足夠的原子才能受益於定律的精確性"><a href="#有機體需要足夠的原子才能受益於定律的精確性" class="headerlink" title="有機體需要足夠的原子才能受益於定律的精確性"></a>有機體需要足夠的原子才能受益於定律的精確性</h2><p>綜上所述，系統在巨觀尺度的屬性是相異狀態之原子的數量分布不均所致。系統內的原子數越多，數量不均的狀況就越容易與隨機運動區別，呈現的集體現象也就越明確。原子數量與定律精確性的關係可用 $\sqrt{n}$ 法則描述。 $\sqrt{n}$ 法則是指，對一個含有 n 個原子的系統而言，物理或化學定律的誤差範圍約在 $\sqrt{n}$ 內。式子中的平方根意味著，隨著系統含有的原子增加，作用在此系統定律的相對誤差就愈低。</p>
<p>讓我們回到文章開頭提到的問題，為何鴿子那麼大？或說，為什麼鴿子就不能像寡糖或Omega-3一樣小？這是因為，有機體的遺傳、發育和行為等生命特徵需要足夠數量的原子，才有辦法忽視個別原子的隨機運動，表現出統計物理上的宏觀秩序。</p>
<p>讓我們想像一種僅由 100 個原子組成的迷你鴿子。根據 $\sqrt{n}$ 法則，發生在迷你鴿子體內的擴散、催化、接合等反應皆有 10 個原子的不確定性，即有 10% 的相對誤差。</p>
<p>在這尺度，影響鴿子的不再是氣流、重力和光線等巨觀現象，而是電荷、碰撞、量子穿隧等微觀現象。僅僅一個離子，就可能破壞迷你鴿子的結構；即使是少量原子刺激，都會影響鴿子的感官，以致於不能辨明關鍵的環境訊號。既然無法維繫體內運作和對外互動，這樣的生命也就不會是我們定義的「鴿子」了。</p>
<h2 id="古典物理無法解釋遺傳的分子機制"><a href="#古典物理無法解釋遺傳的分子機制" class="headerlink" title="古典物理無法解釋遺傳的分子機制"></a>古典物理無法解釋遺傳的分子機制</h2><p>儘管統計物理似乎為有機體的尺存給出了圓滿的解釋，但此處的議論實為楔子：依照前述討論，有機體的秩序仰賴大量原子參與。不過就當時所知，基因很可能僅由少量原子組成，那麼基因是怎麼表現出遺傳、突變與分裂等在巨觀層次可觀測到的高度秩序？薛丁格主張，這個矛盾或許可用量子力學的概念解釋。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">讀書筆記的內容源於 Schrödinger. (1944) What is life?: with mind and matter and autobiographical sketches。台灣由貓頭鷹出版社翻譯代理：《薛丁格生命物理學講義|生命是什麼？》<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文裡，薛丁格提出的問題是：「（前略）人體為什麼這麼大呢？」<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Dokkum &amp; Conroy. (2010). A substantial population of low-mass stars in luminous elliptical galaxies. Nature, 468(7326), 940-942.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「由外界物體對組織嚴密的物質系統所產生的物理影響，顯然也和相對應思維中的知覺和經驗（它們構成我上面說的思維的素材）相對應。因此，一般說來，我們的系統和其他系統之間的互動必須要有起碼的秩序，（後略）」<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">氧氣磁化的強度除了隨磁場增強以外，也會隨降溫而提升，這現象支持了熱運動持續抵消磁化影響的假說。<a href="#fnref:5" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>what is life</tag>
      </tags>
  </entry>
  <entry>
    <title>讀後感｜生命是什麼 — 如何推論基因的尺寸？</title>
    <url>/schrodinger-1944-what-is-life-chapter-2/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>依照<a href="./schrodinger-1944-what-is-life-chapter-1.md">第一章</a>的推理，生物及其生理過程有賴大量原子參與，來抵銷個別原子的隨機行為，以維持生存所需的宏觀秩序。</p>
<p>乍看之下，這項推論似乎符合當代多數的生物學觀察。畢竟個體由無數細胞組成，而細胞又由多樣的園子、分子和聚合物構築。即使是維繫生存最基本的呼吸作用，也需要大量的分子參與。這些園子的數量大小，吻合統計物理的要求，能讓物理和化學過程順利運作。</p>
<p>然而，在這章當中，我們可以看到維繫遺傳的關鍵因素，基因，相較於其穩定性，卻令人訝異地有著幾乎無法維持嚴格統計定律的數量。</p>
<span id="more"></span>

<h2 id="基因相當穩定"><a href="#基因相當穩定" class="headerlink" title="基因相當穩定"></a>基因相當穩定</h2><p>相較於紙張、磁碟片、或是塗鴉在牆上的紀錄，基因在保存事務上的能力相當穩定。基因的穩定型從色盲、鐮刀行貧血、乃至於哈布斯堡家族鮮明的戽斗等遺傳行疾病更為顯著，即使經過了上千年，這些性狀仍仍能忠實地在世代間傳遞，以致於當今的社會仍要為其奮鬥。</p>
<p>考量其穩定性，究竟需要多少原子才能讓基因維持這樣的穩定性呢？</p>
<h2 id="以染色體影像估算基因的最大尺寸"><a href="#以染色體影像估算基因的最大尺寸" class="headerlink" title="以染色體影像估算基因的最大尺寸"></a>以染色體影像估算基因的最大尺寸</h2><p>一種直觀的估算方法是透過細胞學的觀察為依據。果蠅唾腺細胞的染色體在分裂時會凝聚成顯微鏡可見的棒狀物，這些染色體上有深淺間格的調帶，假設這些條帶是基因的性向，那麼可以ˇ用染色惡體的體積，再除以調代的數量，那麼即可推論基因的尺寸。</p>
<h2 id="以遺傳圖譜估算基因的最大尺寸"><a href="#以遺傳圖譜估算基因的最大尺寸" class="headerlink" title="以遺傳圖譜估算基因的最大尺寸"></a>以遺傳圖譜估算基因的最大尺寸</h2><p>另一種迂迴但是巧妙的手法是透過遺傳方法，推論基因的數量。生物形成配子時，會先行減數分裂。減數分裂過程，同源染色體間的片段可能彼此互換，導致原先坐落相同染色體的性狀，被置換到對偶染色體上。互換會導致子代性狀的機率分布脫離孟德爾的假設，因此透過育種雜交實驗，可從子代性狀的分布推論互換的機率。</p>
<p>假設染色體各處發生互換的機率一致，若性狀間距越大，當中也有較多位點可能發生互換，也表示兩者互換的機率也越高（因為兩者之間有較多位置可能發生互換），反之則表示兩者互換機率愈高，則間距越大。基於這項假設，可以從性狀間的互換率，推論性狀在染色體上的相對位置與距離。</p>
<p>這項任務有助於在遺傳學上譜出基因的相對位置，其在推論基因尺寸的用途則在於。若我們定義基因為乘載性狀的基本單位，若一項性狀能隨互換而遷移，表示這段區域至少包含了能獨立展現性狀的基因。因此，基因的最大尺寸可由染色體的體積，除以可互換而分離的性狀數量來估計。（由於）</p>
<h2 id="基因具有令人訝異的穩定性"><a href="#基因具有令人訝異的穩定性" class="headerlink" title="基因具有令人訝異的穩定性"></a>基因具有令人訝異的穩定性</h2><p>無論透過何種方式推論，原子的最大體積約為 300 Å,而單一原子的尺寸約為 1 Å，這意味著基因所含的原子數頂多在數百萬個之間。透過前一章所推論的，這樣的尺寸顯然過少了。那麼究竟有什麼使得基因能以保有如此問訂的特性</p>
]]></content>
      <tags>
        <tag>what is life</tag>
      </tags>
  </entry>
  <entry>
    <title>尋找太陽系外的行星：天文學家莎拉．西格的愛與探索</title>
    <url>/seager-2021-the-smallest-lights-in-the-universe-a-memoir/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>莎拉．西格教授任職於麻省理工學院，她因在系外行星探測的理論與實踐上的傑出貢獻，於 2014 年獲頒麥克阿瑟獎。我第一次看到她的名字是在《五十億年的孤寂》一書中，此書訪談了第一線天文學家，介紹學界在尋找地外生命的嘗試、成功與挫敗，描繪出天文生物學的發展軌跡。書中不僅多次提到尋找地外生命的挑戰，還討論了社會支持對科研突破的影響。</p>
<p>全書以莎拉的訪談作結（由於書不在手，我只能大略描述），描繪了喪偶莎拉在黎明前拖著獨木舟航向一個對於她自己，或是地外生命探索而言都同樣晦暗不明的未來。</p>
<p>相較於《五十億年的孤寂》，這本書則是莎拉的人生回顧，讓我們得以從她的視角，看到一位科研人員如何因憧憬而投身科研，為什麼堅持下去，以及科研之外的事件如何影響個人的信念和觀點？</p>
<span id="more"></span>

<p>德雷克曾提出一條公式 (Drake Equation) 來估計銀河系內可能存在的外星文明數量，這公式將左右生命起源與演化的各種宏觀因素相乘。因此，對於每個因素的估計，都大大地影響了我們對於地外生命是否存在的信心。</p>
<p>系外行星的數量是公式其中一個變項。在 1960 年代，美國與瑞士的科學團隊分別宣稱透過徑向速度法發現系外行星，飛馬座 51。他們並未直接拍攝到行星公轉的影像，而是透過潛在天體對恆星運動軌跡的影響，來推測行星的存在。簡言之，行星繞行恆星時，恆星其實也繞著彼此的質心運動，導致其與地球的距離週期變化。這種距離變化引發的都普勒效應能在光譜上觀測到，成為支持行星存在的證據。</p>
<p>然而，學界對於這項發現的看法分歧，一方面有人質疑結果的解釋，另一方面則有人認為影響光譜的是其他天體而非行星。換句話說，在二十世紀中葉系外行星是否存在仍有許多爭議，這意味著即使生命可以輕易在一攤有機物濃湯裡萌發，除了地球外可能沒有合適的地方安放這些原料。觀測系外行星的限制在於沒有辦法直接看見它們，即使是當時最好的望遠鏡也只能捕捉到遙遠恆星甚至整個星系散發的微弱光亮。</p>
<p>如今，已有數千顆系外行星被發現，觀測方法也不限逕向運動法，還擴展到凌日法或重力透鏡法等手段。不過，在莎拉決定研究系外行星及其可能性的時候，這領域還處在手段闕如，連研究標的是否存在都還不明朗的階段。究竟是什麼樣的啟發和經歷，讓莎拉被系外行星的研究吸引，從而決定探索宇宙這個人類最大的未知領域？</p>
<p>理由得追溯到她十六歲的時候，擺脫了在派對、嗑藥、溜冰、還有嘉年華的夏季裡格格不入的日子，用打工買下的天文望遠鏡，顫抖地透過鏡片，在寒冷的天空看見木星的那一刻。此後，即使父親強力建議她就讀醫學系，莎拉始終不以為然，打算好好讀書進大學，看一輩子的星星。</p>
<p>隨後，莎拉於多倫多大學取得數學與物理學士學位，打算在進入哈佛大學進修前的長假走一趟獨木舟之旅。在籌備過程中，她結識了生命最重要的伴侶麥克，他們一同規劃行程、練習泛舟並且想像旅途中的景象。莎拉發現他們彼此能自在相處共享某種孤單，於是邀請麥克偕行。他們一路通過陌生的湖泊、湍流還在森林大火中死裡逃生。旅途之後，麥可隨莎拉在波士頓定居，並在莎拉離開哈佛前結婚。她是這麼描述他們的生活與關係：</p>
<blockquote>
<p>我把麥可和我想成宇宙裡的兩個天體，彼此相距遙遠，卻有一種無形的力量將我們綁在一起。我們就像是火星的兩個衛星：佛勃斯和戴摩斯，這兩顆衛星按照不同的軌道運行，彼此的關係卻異常和諧，就像希臘神祉阿瑞斯和阿芙柔黛蒂的雙胞胎兒子一樣，所以才這麼命名。</p>
</blockquote>
<p>她與麥可成婚不久後育有兩子，並獲麻省理工學院的教職。儘管職涯和生活皆有相當的進展，但她的光芒背後仍然伴隨著一些陰影，包含了對研究意義的質疑、與研究夥伴的決裂、意外告終的類地行星搜索計劃、寵物與父親的逝世。</p>
<p>而其中最大陰影，幾乎籠罩生命一切光明的，是她的丈夫麥可在壯年之際罹患癌症。莎拉不得不看著伴侶逐漸衰弱最終病故。麥可的離去不只是情感上的打擊，也破壞了她的生活平衡。以往麥可負責打理家務，讓莎拉能全神貫注在研究項目。如今，她不得不一肩扛起家庭重擔，還要照顧兩位年幼的孩子，又不能落後科研進展。</p>
<p>在這樣的壓力下，莎拉只好聘僱保母與家管協助，雖然這些幫助大幅減輕家務的負擔，卻無法撫平麥可逝世帶來的哀傷。這些困境和學術行政對身兼家務的學者的不友善態度，使得她一度想要放棄。所幸，寡婦俱樂部的朋友陪伴她度過失去丈夫後的春夏秋冬，研究單位的同仁也在她經濟最險峻的情況下大方支持她，讓她沒有放棄學術研究，熬到因研究成果卓越獲獎，獲得一筆足以支持她研究與生活的獎金。</p>
<p>幾年後，莎拉再度結識一位能交心的對象，查爾斯。他意外地走進了她的生活，陪伴莎拉走過生涯最低谷的日子。在書末，年過半百的查爾斯放棄繼承家族事業，與莎拉結為連理並搬入她的家。</p>
<p>莎拉的一生，恰好與她最著名的科研成果──蔽星板計劃──的意象契合。蔽星板是一種輔助觀測系外行星的裝置，它能遮蔽恆星光芒，讓儀器有辦法偵測到周圍行星反射出的微弱光訊號。在莎拉這輩子的追求中，喪夫無疑是巨大的黑暗，但在這片陰影邊緣，微弱的光芒仍引導她看見另一種可能性，如同她對自己踏上天文學的動機的回顧：</p>
<blockquote>
<p>當我想到星星，我幾乎可以感受到一股實質的拉力。我想只是看星星，我想要認識它們，每一顆星星，多如海沙的星星。銀河裡的數億顆恆星照亮了不可勝數的天空，而我想要沐浴在它們的光亮裡。對我來說，星星代表的不只是虛無飄渺的可能性，而是可能實現的機率。在地球上的機率對我可能不利，但你的所在之處可以改變一切。自古至今，每顆星星都代表了另一個機會，能讓我置身於另一個人類從未造訪過的地方。</p>
</blockquote>
<p>讀過幾本研究人員的回憶錄之後，我覺得莎拉．西格這本書的特色在於真實。雖然書腰文案強調了她獲得麥克阿瑟「天才獎」的不凡成就，好像在她經歷了一系列凌亂無章的現實生活和機會渺茫的大膽追求之後，終於得到應有的認可。不過實際上莎拉在接獲得獎消息時，第一個反應是她終於獲得一筆救命財，可以支應單親職業婦女的許多開銷，甚至有時間慢慢喜歡上自己不擅長的家庭瑣事上。</p>
<p>另外，也許是好萊塢影視、又或不明來歷的勵志著作、還是義務教育輔導課營造的印象，凡提起研究人員，總帶有獻身的意味在，好似這些人在某種神啟之後，便下定決心穿著白袍透過望遠鏡或顯微鏡窺探宏觀到至微的宇宙。然而，實際上人們從事什麼職業，又在哪個領域卓越是諸多因素綜合的結果。</p>
<p>相較於其他人，莎拉既有才能也早早立定志向，但她求學也曾經驗了只能透過程式碼觀測星空，與憧憬的生活有巨幅落差的時候；任教過程中遭遇的家庭與事業打擊更是讓她幾度萌生退意。科學家不是像媒體或大眾想像得那樣總是理性自若，同樣會經歷情緒崩潰與歇斯底里。</p>
<p>這本書沒有像其他傳記那樣仔細描述科學發現的過程，而是忠實地呈現了科學家作為人的一面，畢竟，愛恨情仇以及無數說不出的煩惱，無一例外地困擾著追尋星辰的科學家以及其他行業的人們。</p>
]]></content>
      <tags>
        <tag>astrobiology</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Sorting by Reversals (SORT)</title>
    <url>/sorting-by-reversals/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>給定一對數列，計算兩者的最小反轉距離，並依序列出反轉數列的步驟。</p>
<blockquote>
<p>A reversal of a permutation can be encoded by the two indices at the endpoints of the interval that it inverts; for example, the reversal that transforms (4,1,2,6,3,5) into (4,1,3,6,2,5) is encoded by [3,5] .<br>A collection of reversals sorts π into γ if the collection contains drev(π,γ) reversals, which when successively applied to π yield γ .</p>
</blockquote>
<blockquote>
<p>Given: Two permutations π and γ , each of length 10.<br>Return: The reversal distance drev(π,γ) , followed by a collection of reversals sorting π into γ . If multiple collections of such reversals exist, you may return any one.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/sort/">https://rosalind.info/problems/sort/</a>)</p>
<span id="more"></span>

<p>這題的概念與 <a href="https://5uperb0y.com/reversal-distance/">Reversal Distance</a> 相同，只是需要修改程式碼以便記錄和追蹤數列反轉的步驟。首先，在生成反轉數列的同時，我用 dictionary 記錄新生成數列的來源以及被反轉的子數列的首尾位置。這裡把首位座標值加 1 是因為題目的座標系統從 1 開始）。</p>
<p>雖然這些資訊也可以用 list 紀錄，但使用 dictionary 可以透過 key 將資訊分門別類，在取值時會比用 list 時以座標取值明確。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        t[:i] + t[i:j][::-<span class="number">1</span>] + t[j:]: &#123;<span class="string">&quot;parent&quot;</span>: t, <span class="string">&quot;move&quot;</span>: (i + <span class="number">1</span>, j)&#125;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以下這個副程式用於生成數列集合的每個元素在經過一次反轉後可能產生的所有數列。由於修改了 swap 的輸出格式，所以這副程式也要跟著調整，確保之後能取得新生成的數列、這些數列的來源以及反轉步驟等資訊。</p>
<p>雖然以 for 調用 dictionary 的時候，直接寫變項名稱（<code>var</code>）的效果與 <code>var.keys()</code> 一致，不過因為我常常忘記這特性，所以覺得還是清楚列出來比較好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next_steps</span>(<span class="params">current, visited</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        swap_e: details</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> current.keys()</span><br><span class="line">        <span class="keyword">for</span> swap_e, details <span class="keyword">in</span> swap(e).items()</span><br><span class="line">        <span class="keyword">if</span> swap_e <span class="keyword">not</span> <span class="keyword">in</span> visited.keys()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由於記錄了各數列的源頭與反轉方式，所以配合已檢查過的數列清單 visited，即可追蹤數列的反轉步驟。簡而言之，就是拿當前數列去查詢 visited，記錄反轉步驟，再查出該數列的源頭，查詢數列源頭的反轉步驟，直到追蹤到起始數列。</p>
<p>這裡我假設起始數列的資料格式為 <code>&#123;seq: -1&#125;</code>，所以只要檢查到 -1 就表示已經追蹤到起點了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_moves</span>(<span class="params">meet_point, visited</span>):</span><br><span class="line">    moves = []</span><br><span class="line">    current = visited[meet_point]</span><br><span class="line">    <span class="keyword">while</span> current != -<span class="number">1</span>:</span><br><span class="line">        moves.append(current[<span class="string">&quot;move&quot;</span>])</span><br><span class="line">        current = visited[current[<span class="string">&quot;parent&quot;</span>]]</span><br><span class="line">    <span class="keyword">return</span> moves</span><br></pre></td></tr></table></figure>

<p>除了變項名稱以外，我也對計算反轉距離的功能做了一些調整。首先，因應使用 dictionary 記錄數列，比較雙向搜索是否有交集時，得額外取出兩者的 keys 來比對。</p>
<p>其次，我轉而以交錯方式來推進搜索：利用 <code>check_forward</code> 當成開關，這變項決定這次檢查要從哪個方向開始，這樣能確保每次迴圈只會從數列前端或後端推進一步。這樣就不用像我之前寫得那樣，在每個迴圈為各方向的推進檢查兩次。</p>
<p>其餘的步驟與先前的寫法類似，一旦雙向搜索的進度交錯，就分別使用 get_moves 重建反轉步驟。</p>
<p>因為這個副程式預設用 append() 添加元素，所以對於從前端開始的檢查而言，在追蹤完所有反轉步驟後，要將輸出的 list 反轉才能得到正確的順序。結合前後兩端的反轉步驟，即得到兩數列互相轉換所需經過得最少反轉步驟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_dist</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    cur_fwd, vis_fwd = &#123;s1: -<span class="number">1</span>&#125;, &#123;s1: -<span class="number">1</span>&#125;</span><br><span class="line">    cur_bwd, vis_bwd = &#123;s2: -<span class="number">1</span>&#125;, &#123;s2: -<span class="number">1</span>&#125;</span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    check_forward = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> cur_fwd <span class="keyword">and</span> cur_bwd:</span><br><span class="line">        intersection = cur_fwd.keys() &amp; cur_bwd.keys()</span><br><span class="line">        <span class="keyword">if</span> intersection:</span><br><span class="line">            meet_point = intersection.pop()</span><br><span class="line">            <span class="keyword">return</span> dist, get_moves(meet_point, vis_fwd)[::-<span class="number">1</span>] + get_moves(meet_point, vis_bwd)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> check_forward:</span><br><span class="line">                cur_fwd = get_next_steps(cur_fwd, vis_fwd)</span><br><span class="line">                vis_fwd.update(cur_fwd)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_bwd = get_next_steps(cur_bwd, vis_bwd)</span><br><span class="line">                vis_bwd.update(cur_bwd)</span><br><span class="line">            dist = dist + <span class="number">1</span></span><br><span class="line">            check_forward = <span class="keyword">not</span> check_forward</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="and、-和-intersection-的差異"><a href="#and、-和-intersection-的差異" class="headerlink" title="and、&amp; 和 intersection 的差異"></a>and、&amp; 和 intersection 的差異</h2><p>intersection 和 &amp; 是 set 專用的操作符，兩者的功能相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&gt; b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&gt; a &amp; b</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection(b)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然而 &amp; 只允許 set 之前的操作，intersection 則支援 set 和任何 iterable 的比較，所以有可讀性和泛用性的優勢。詳情可參考這則 <a href="https://stackoverflow.com/questions/63827915/and-intersection-difference">stackoverflow 的說明</a> 和<a href="https://docs.python.org/3.8/library/stdtypes.html#frozenset.intersection">官方文件</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line">&gt; a.intersection(&#123;<span class="number">3</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">5</span>&#125;)</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>and 則是邏輯判斷符，不能用來集合運算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 這裡的邏輯是：a is True, then b，所以印出 b。</span></span><br><span class="line">&gt; a <span class="keyword">and</span> b</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 用這案例會更加清楚：&#123;&#125; is False，所以不會印出 b，只有呈現 &#123;&#125;</span></span><br><span class="line">&gt; &#123;&#125; <span class="keyword">and</span> b</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他解題想法"><a href="#其他解題想法" class="headerlink" title="其他解題想法"></a>其他解題想法</h2><p>我覺得這種需要追蹤路徑的問題，如果用 class 來設計結構與方法可能會讓程式碼變得好維護許多。另外，之前在 Reversal Distance 也有列出用遞迴的解題方式，或許有空都可以拿來改寫看看。</p>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜Vimium，學習 Vim 的新途徑</title>
    <url>/start-learning-vim-from-vimium/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> 是 Chrome 的一款擴充套件，它借鑒了 Vim 的鍵位設計與操作邏輯，讓用戶只需要鍵盤便能執行分頁管理、連結點擊與頁面瀏覽等操作。</p>
<p>由於瀏覽器終究不等同編輯器，所以 Vimium 並沒有移植 Vim 所有的功能與指令。然而，即使只納入 Vim 的部分性質，Vimium 仍顯著改善了 Chrome 的鍵盤瀏覽體驗。以點擊連結為例，Chrome 的預設作法是<a href="https://5uperb0y.com/navigate-websites-with-keyboard/">慢慢用 <code>Tab</code> 切到連結位置</a>；Vimium 則會自動標記視窗內的連結，用戶只要鍵入標記字符即可開啟連結。因為最多輸入三個字即可開啟連結，所以有時甚至比滑鼠點擊還迅速。</p>
<p>對於習慣鍵鼠操作卻有心學習 Vim 的用戶而言，一時要以 Vim 取代既有的工作流程，可能是繁瑣且費時的過程。若先從 Vimium 著手，在體驗鍵盤瀏覽網頁的流暢感之餘，也能讓 Vim 操作的抽象性質融入日常生活（例如：查資料與逛論壇）。待初探了 Vim 的設計緣由，再逐步精進其他操作模式，也不失為一種學習 Vim 的可行策略。</p>
<span id="more"></span>

<h1 id="能從-Vimium"><a href="#能從-Vimium" class="headerlink" title="能從 Vimium"></a>能從 Vimium</h1><p>借鑒了 Vim 鍵位設計與操作邏輯，無論是管理分頁、點擊連結或瀏覽頁面都能夠只憑鍵盤操作。</p>
<ul>
<li><strong>習慣在 normal 模式瀏覽文件的方式</strong>：</li>
<li><strong>理解以 home row 為核心的鍵位安排</strong>：Vim 的鍵位設計以 home row（<code>f</code> 和 <code>j</code> 那列）為核心，不用為了點選特殊控制鍵而過度伸展手指（例如：<code>Shift</code> + <code>Alt</code> + <code>F</code>），所有操作都不超過字母鍵盤，減少了手部位移的距離。</li>
<li><strong>學習 vim 實用功能的邏輯與效果</strong>：Vimium 移植了</li>
<li><strong>了解自訂快捷鍵的意義</strong>：相較於滑鼠，快捷鍵操作有更多空間能夠因應個人的需求調整。</li>
<li></li>
<li>能夠更為習慣 normal mode 的瀏覽方式j，</li>
<li>體會以 home row 為中心的指令鍵位安排</li>
<li>習慣使用垂直移動游標，例如 <code>j</code> &amp; <code>k</code></li>
<li>了解 Vim easymotion 跳轉的邏輯與效果</li>
<li>學會使用 <code>/</code> 搜尋文字</li>
<li>體驗指令組合的效果</li>
<li>依據需求自訂快捷鍵</li>
<li>使用書籤功能</li>
</ul>
<h1 id="學會-Vimium-只要三分鐘"><a href="#學會-Vimium-只要三分鐘" class="headerlink" title="學會 Vimium 只要三分鐘"></a>學會 Vimium 只要三分鐘</h1><blockquote>
<p>Press <code>f</code> to master Vimium (and navigate internet without a mouse.)</p>
</blockquote>
<p>Vimium 最大的特色是能透過「標記與跳轉」的模式開啟連結。一旦按下 <code>f</code>，Vimium 便會為視窗內所有可互動的項目（例如連結、欄位與按鈕）標註辨識碼，接著只要輸入辨識碼即可開啟連結。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_easymotion.png?raw=true" alt="鍵入 `f` 後, Vimium 會為視窗內的可互動物件標記辨識碼，鍵入辨識碼即可開啟連結（使用 Vimium 操作 Google search)"></p>
<ul>
<li><code>L</code>：開啟「Vimium」</li>
<li><code>SK</code>：開啟「工具」，透過 Vimium 的連結辨識碼，免除網頁設定欄位快捷鍵的負擔</li>
<li><code>SA</code>：切換至「搜尋列」，可以編輯搜尋內容</li>
</ul>
<p>雖然 Vimium 有一套基於 home row 指令，Chrome 與 Windows 內建快捷鍵已能直觀地管理分頁（例如 <code>Ctrl</code> + <code>T</code>）與滑動視窗（例如方向鍵與空白鍵），要配合瀏覽網頁的需求是綽綽有餘。例如Vimium 配合特殊控制鍵，即可在不同分頁開啟連結。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>於當前分頁開啟</td>
<td><code>f</code>, then ID</td>
</tr>
<tr>
<td>於新分頁開啟</td>
<td><code>f</code>, then <code>Shift</code> + ID</td>
</tr>
<tr>
<td>於新分頁開啟並切換至新分頁</td>
<td><code>f</code>, then <code>Ctrl</code> + ID</td>
</tr>
</tbody></table>
<h1 id="以-Vim-style-瀏覽網頁"><a href="#以-Vim-style-瀏覽網頁" class="headerlink" title="以 Vim style 瀏覽網頁"></a>以 Vim style 瀏覽網頁</h1><p>鍵鼠操作以 <code>Ctrl</code>、<code>Home</code>、<code>PageUp</code> 等控制鍵，</p>
<h2 id="移動游標的方式"><a href="#移動游標的方式" class="headerlink" title="移動游標的方式"></a>移動游標的方式</h2><table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 快捷鍵</th>
<th>Vim 快捷鍵</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>移至頂部</td>
<td><code>gg</code></td>
<td><code>gg</code></td>
<td><code>Home</code></td>
</tr>
<tr>
<td>向上移動半個視窗</td>
<td><code>u</code></td>
<td><code>Ctrl</code> + <code>u</code></td>
<td>-</td>
</tr>
<tr>
<td>向上移動一列</td>
<td><code>k</code></td>
<td><code>k</code></td>
<td><code>↑</code></td>
</tr>
<tr>
<td>向下移動一列</td>
<td><code>j</code></td>
<td><code>j</code></td>
<td><code>↓</code></td>
</tr>
<tr>
<td>向下移動半個視窗</td>
<td><code>d</code></td>
<td><code>Ctrl</code> + <code>d</code></td>
<td>-</td>
</tr>
<tr>
<td>移至底部</td>
<td><code>G</code></td>
<td><code>G</code></td>
<td><code>End</code></td>
</tr>
</tbody></table>
<h2 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h2><p>分頁管理是網頁瀏覽的特殊需求，所以 Vimium 就沒有照搬 Vim 的快捷鍵，而是將那些負責編輯或是功能與其他移動指令相近的按紐分配給分頁管理。<br><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_tab-operation.png?raw=true" alt="Vimium 分頁管理與頁面瀏覽的快捷鍵"><br>比對 Vimium 指令與 Chrome 快捷鍵會發現，後者需要用 <code>Ctrl</code> 和 <code>Alt</code> 等特殊控制鍵去定義。此外，觀察鍵盤位置分布可得知，Chrome 快捷鍵位置集中在兩側，似乎也是為了因應特殊控制鍵的分布以及持滑鼠的手的擺放位置。然而，瀏覽網頁時其實沒有文字輸入的需求，所以文字區塊的鍵盤等於閒置了。</p>
<table>
<thead>
<tr>
<th>行為</th>
<th>Vimium 指令</th>
<th>Chrome 快捷鍵</th>
</tr>
</thead>
<tbody><tr>
<td>開新分頁</td>
<td><code>t</code></td>
<td><code>Ctrl</code> + <code>T</code></td>
</tr>
<tr>
<td>關閉分頁</td>
<td><code>x</code></td>
<td><code>Ctrl</code> + <code>W</code></td>
</tr>
<tr>
<td>上一頁</td>
<td><code>H</code></td>
<td><code>Alt</code> + <code>←</code></td>
</tr>
<tr>
<td>下一頁</td>
<td><code>L</code></td>
<td><code>Alt</code> + <code>→</code></td>
</tr>
<tr>
<td>直達分頁</td>
<td><code>#g0</code></td>
<td><code>Ctrl</code> + <code>#</code></td>
</tr>
<tr>
<td>上一分頁</td>
<td><code>J</code></td>
<td><code>Alt</code> + <code>Shift</code> + <code>Tab</code></td>
</tr>
<tr>
<td>下一分頁</td>
<td><code>K</code></td>
<td><code>Alt</code> + <code>Tab</code></td>
</tr>
</tbody></table>
<h2 id="數值參數"><a href="#數值參數" class="headerlink" title="數值參數"></a>數值參數</h2><p>就目前使用下來的想法，為什麼稱呼 Vimium 的行為為「指令」，而chrome的操作為「快捷鍵」，這是因為 Vimium 移植了 Vim 的機制，視每次操作為單元指令，指令可彼此疊加與重複創造出更複雜的行為。Vim 指令的行為分為 motion, replication factor, and operator。前述提及的所有指令都可算是 motion，亦即移動游標數個單位，例如一個視窗、一列、整個頁面等。這些指令都可以再前面冠上 replication factor 來增加執行次數 <replication factor> <motion>。</p>
<p>而 operator 則是對文字的編輯，這包含了 c (change)、y (yank拖)、d(delete)等，<br>Vimium 保留了 Vim 重複計數 (repeat count or replication factor) 的機制，用戶只要在命令前加上數字，便能指定命令的重複執行次數。</p>
<ul>
<li><code>4t</code>：開啟四個分頁</li>
<li><code>3x</code>：關閉前三個分頁</li>
<li><code>2d</code>：下移一個視窗(半個視窗 * 2)</li>
<li><code>3g0</code>：直達第三個分頁</li>
</ul>
<h2 id="頁面書籤"><a href="#頁面書籤" class="headerlink" title="頁面書籤"></a>頁面書籤</h2><ol>
<li><code>mc</code>，建立分頁內標記，<code>c</code> 可替換為其他小寫字母</li>
<li><code>mC</code>，建立跨分頁標記，<code>C</code> 可替換為其他大寫字母</li>
<li>&#96;&#96;c&#96;，跳轉至標記的位置</li>
</ol>
<h2 id="mode-切換"><a href="#mode-切換" class="headerlink" title="mode 切換"></a>mode 切換</h2><p>其實 Vimium 也有 insert 與 visual 模式，但相當罕用，原因如下：</p>
<ol>
<li>網頁瀏覽唯一的編輯機會是調整網址</li>
<li>若有大量編輯需求，也是在 google doc 或 Rstudio 這種瀏覽器編輯器編輯，裏頭應該有對應的 vim 套件才對</li>
<li>調整網址或更新關鍵字幾乎沒有重複操作或複雜編輯的需求</li>
</ol>
<p>Vimium 的 insert 模式與其說是用於編輯文字，不如說是為了暫時脫離 Vimium 指令模式。Normal 模式的指令與快捷鍵在 Insert 模式無效，在 youtube, gmail 等內建快捷鍵相當完善的網頁時，使用 insert mode 就能用網頁預設的快捷鍵，避免衝突。</p>
<h1 id="設計自己專屬的快捷鍵組合"><a href="#設計自己專屬的快捷鍵組合" class="headerlink" title="設計自己專屬的快捷鍵組合"></a>設計自己專屬的快捷鍵組合</h1><p>鼓勵用戶，Vimium 支援了自訂以下項目的功能，</p>
<p>首先鍵入 <code>?</code> 開啟 “Vimium Help”，再點選 “Options” 進入設定面板，即能看到以下設定</p>
<h2 id="“Excluded-URLs-and-keys”"><a href="#“Excluded-URLs-and-keys”" class="headerlink" title="“Excluded URLs and keys”"></a>“Excluded URLs and keys”</h2><p>這設定能限定特定網域適用的 Vimium 快捷鍵，以避免其覆蓋網頁或瀏覽器預設的快捷鍵。舉例來說，Vimium 的 <code>/</code>（搜尋頁內文字）會覆蓋 Google search 的 <code>/</code>（重返搜尋列）。</p>
<p>如果我已經很習慣使用 <code>Ctrl</code> + <code>F</code> 來查找頁內文字或是使用 <code>/</code> 來編輯搜索關鍵字，可以透過編輯 “Patterns” 和 “Keys”，讓 Vimium 的 <code>/</code> 設定不套用在 Google search 上。</p>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_excluded-urls.png?raw=true" alt="編輯 &quot;Excluded URLs and keys&quot; 來設定 Vimium 快捷鍵的適用範圍（Keys 預設是禁用全數快捷鍵，而 Patterns 可用正則表達式編寫規則）"></p>
<h2 id="“Custom-key-mapping”"><a href="#“Custom-key-mapping”" class="headerlink" title="“Custom key mapping”"></a>“Custom key mapping”</h2><p>這設定能調整預設的快捷鍵以符合用戶的使用習慣。好比說，如果不習慣 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 的操作，可以透過以下方式改成動作遊戲常用的 <code>a</code> <code>s</code> <code>w</code> <code>d</code> (<code>map &lt;key&gt; &lt;command&gt;</code>)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改以 wasd 配置移動視窗</span></span><br><span class="line">map a scrollLeft </span><br><span class="line">map s scrollDown</span><br><span class="line">map w scrollUp</span><br><span class="line">map d scrollRight</span><br></pre></td></tr></table></figure>
<p>進階一點也能為常用網址設置快捷鍵 (<code>map &lt;key&gt; createTab &lt;url&gt;</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鍵入 @tl 以開啟 Google 翻譯</span></span><br><span class="line">map @tl createTab https://translate.google.com.tw/?hl=zh-TW</span><br></pre></td></tr></table></figure>

<h2 id="“Previous-patterns-and-Next-patterns”"><a href="#“Previous-patterns-and-Next-patterns”" class="headerlink" title="“Previous patterns and Next patterns”"></a>“Previous patterns and Next patterns”</h2><p>輸入 <code>[[</code>（上一頁）或 <code>]]</code>（下一頁）之後，Vimium 會搜尋並開啟頁面內含「上一頁」或「下一頁」的連結。這功能完全解決了 Google search 無法迅速跳轉到下一頁搜索結果的問題。然而 Vimium 預設是辨識英文和箭頭符號，所以要應用於中文網站時得自行添加搜索標的。</p>
<ol>
<li>點選 “Show Advanced Options”</li>
<li>編輯 “Previous patterns” 與 “Next patterns” </li>
<li>依照自己常用的網頁添加搜索標的（例如：Google search，上一頁&#x2F;下一頁；ptt.cc，&lt;&#x2F;&gt;；巴哈姆特，◄&#x2F;►）</li>
</ol>
<p><img data-src="https://github.com/5uperb0y/blog-media/blob/main/start-learning-vim-from-vimium_page-navigation.png?raw=true" alt="可以檢查常用網站的上一頁/下一頁來調整快捷鍵偵測的字串"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>《原子習慣》，這些訣竅也適用於學習新事物。</p>
<ol>
<li>善用 <code>f</code> 點擊連結</li>
<li>維持原本的瀏覽網頁</li>
<li>透過 <code>?</code> 查詢指令</li>
<li>學習使用 vim-like 指令瀏覽與管理分頁</li>
<li>配合習慣，自訂適合自己的快捷鍵組合</li>
</ol>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>微國家：獨立建國的簡易操作手冊</title>
    <url>/strauss-2008-how-to-start-your-own-country/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這套書由方法篇和實踐篇組成，作者在方法篇中分析五種可行的建國方式，繼而討論該用何種體制經營之，再列舉許多歷史案例，評論其成敗關鍵，最後探討個人建國的前景。實踐篇則是台灣出版社彙編的建國案例以及兩篇專訪，補充已不再更新的原著。</p>
<span id="more"></span>

<p>微國家並非梵諦岡或安道爾之類主權獨立但領土狹小的國家，也不同於我們這樣陷入爭議但確實存在的政治實體，微國家維基中將之解釋成任何欲取代、模仿或與既有國家共存的政治體，但僅單方面宣稱獨立，不受國際組織或其他國家承認。</p>
<p>雖然因現實條件限制，其規模通常不大且得立足於既有國家的主權範圍內，卻仍表現出構成國家的部分要素，例如公民、政府等，甚至有些微國家會發行自己的貨幣與郵票。顯然前述定義還是難以涵蓋多樣的微國家形式，不過原書其實沒有強調這名詞，其主題是無權無勢的市井小民該如何創建自己的國家，「微國家」只是暫時狀態而非追求的目標。</p>
<p>儘管作者著重於介紹手段，沒有談論建國動機，但是從訪談和議論中可以推測：建立國家的用意不全然是對抗政府，很大一部分是在反思既有的權力結構。當今多數國家仍依循民族主義的想法以共同的語言、風俗和歷史等要素凝聚國民，可是即便在同樣民族之下，國民間仍有許多歧異，各自代表不同的利益和價值觀，然而政府依舊積極地營造認同感，讓人民甘於滿足偽裝成國族的特定受益者（不一定是人民自身），不自覺地背負無關的責任與義務。</p>
<p>於是建立微國家就成為伸張個人主權的行動，表達對個人特質的擁護、對政府體制的懷疑和對隱私財產的堅持。即便無法動搖現狀，在自己的臥室經營模型國家也能起到轉變視角的作用，能從「外國」的視角審視政府以大眾為號召施政的用意和合理性，衡量自己（外國）會受到什麼衝擊，並採取適當行動。</p>
<p>目前建立國家的最大阻力來自既有國家壓迫，弱勢方不僅沒有容身的根據地，也無可靠的武力對抗傳統軍事動員，所以作者建議從依附強權的小國發跡，一方面只須和單一國家交涉減少複雜狀況，另一方面也能藉強國排除其他國家介入，或者與小國競爭強國支持。</p>
<p>不過作者推論這種情況會在幾世紀後隨著大規模殺傷性武器成本下降以及星際殖民普及有所改變，外太空將成為待開拓的新天地，大規模毀滅武器也會削弱倚恃傳統武力的國家之優勢。無法承受破壞的政府將因此妥協，於是愈來愈多野心家投入，掀起建立新國家的浪潮，最終導致民族國家式微。</p>
<p>這推論的前提是大國懾於威脅而向建國者妥協，因此建國者不僅要避免武器被破壞，也得讓大國相信他們擁有相應的報復能力和決心。這當中牽涉到不可捉摸的心理因素，若雙方情報量不對等或是具有同樣決心時，嚇阻的效力就會降低，此時相較於建國者，大國多了輿論操作、傳統兵力、諜報組織等行動自由，故就這點而言對建國者是很不利的。</p>
<p>此外，建國者不只要面對大國，還得與己方派系或其他建國者鬥爭，由於雙方皆不能承受核攻擊，唯一勝算是先發制人，當競爭者數量達到一定程度時，極可能出現莽撞動手的一方，所以即便已與大國達成協議，建國者間還未必能維持平衡。況且武力不是決定國家存續的僅有條件，微型國家的資源、人力和產業規模仍不及傳統國家，能否捱過經濟壓力仍是未知數。</p>
<p>當然，除了用武力當基礎的傳統國家，作者也提出了幾個克服領地或主權問題的建國方案，例如先宣稱獨立再和政府打官司的訴訟途徑，仿效吉普賽人擺脫政府管制的離群索居生活，抑或掛著獅子山及賴比瑞亞的船旗馳騁大海，雖不完整但仍擁有構成國家的部分要件。<br>　<br>最後，不管是採用常規還是非典型方式建立國家都不意味著能隱於世俗擺脫其他國家騷擾，建國是向世人表示自我的存在，因此從草創時期到後續經營都會面臨許多既有利益者挑戰。若不想受人擺布，就得主動排除外在干涉，處理內部爭端，在混亂的世局中掙扎求生。</p>
]]></content>
  </entry>
  <entry>
    <title>在 Window 上使用 VSCode 建立 Tabletop simulator 的 Lua 腳本開發環境</title>
    <url>/tabletop-simulator-lua-vscode-development-environment-building/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="tabletop-simulator-VSCode-開發環境設定"><a href="#tabletop-simulator-VSCode-開發環境設定" class="headerlink" title="tabletop simulator VSCode 開發環境設定"></a>tabletop simulator VSCode 開發環境設定</h1><p>Tabletop Simulator 是一款多人桌遊模擬器，提供強大的 Lua 腳本支援，讓玩家可以開發自訂遊戲。</p>
<p>然而，遊戲內建的腳本編輯器比記事本還難用，所以如果想要編輯複雜的腳本，仍有必要使用外部編輯器。鑒於網路上的資源稀少，我想在本文分享一下建立開發環境的經驗和總結。</p>
<span id="more"></span>

<h1 id="必要軟體安裝與設定"><a href="#必要軟體安裝與設定" class="headerlink" title="必要軟體安裝與設定"></a>必要軟體安裝與設定</h1><p>首先，我們要完成必要軟體的安裝與設定。</p>
<ol>
<li>安裝 Steam 並購買 <a href="https://store.steampowered.com/app/286160/Tabletop_Simulator/">Tabletop simulator</a>。</li>
<li>安裝 <a href="https://code.visualstudio.com/">VSCode</a>。雖然官方推薦的 Lua 開發環境是 Atom，但 VSCode 的功能更加強大，近幾年也比較廣泛被使用（參考 <a href="https://github.blog/2022-06-08-sunsetting-atom/">Github 停止支援 ATOM IDE 的新聞</a>）。</li>
<li>在 VSCode 當中安裝 <a href="https://marketplace.visualstudio.com/items?itemName=rolandostar.tabletopsimulator-lua">Tabletop Simulator Lua</a> 套件。這款套件能從遊戲儲存檔擷取 Tabletop Simulator 的 Lua 腳本，讓我們直接能在 VSCode 中開發，並享有自動補全、檔案瀏覽以及其他擴充套件的功能。</li>
</ol>
<h1 id="連結遊戲與編輯器"><a href="#連結遊戲與編輯器" class="headerlink" title="連結遊戲與編輯器"></a>連結遊戲與編輯器</h1><p>接著要設定遊戲與編輯器的連結</p>
<ol>
<li>在 Steam 中啟動 Tabletop Simulator，並開啟任意一款遊戲（步驟為：<code>Create</code>、<code>Singleplayer</code>、<code>Classic/DLC/Workshop</code>、挑選遊戲）。</li>
<li>打開 VSCode 時，Tabletop Simulator Lua 套件會自動辨識遊戲所在的資料夾（在 Windows 預設為 <code>%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</code>），將遊戲腳本 (<code>*.lua</code>)和設置檔 (<code>.xml</code>) 從遊戲儲存檔 (<code>*.json</code>) 獨立出來，並且放置到暫存資料夾中（預設為 <code>%UserProfile%\AppData\Local\Temp\TabletopSimulator\Tabletop Simulator Lua</code>。</li>
<li>如果套件沒有自動更新或是想要更換其他遊戲時，可以鍵入 <code>Ctrl</code>+<code>Alt</code>+<code>L</code> 更新連結。</li>
</ol>
<h1 id="編輯遊戲腳本"><a href="#編輯遊戲腳本" class="headerlink" title="編輯遊戲腳本"></a>編輯遊戲腳本</h1><p>現在，我們已經可以在 VSCode 當中編輯遊戲腳本了。Lua 腳本是遊戲儲存檔的一部份，而遊戲儲存檔則是一個 <code>JSON</code> 檔，記錄了啟動遊戲所需的所有元素。Tabletop Simulator Lua 的功能即是從儲存檔中擷取 Lua 腳本，並且轉換為適合閱讀與編輯的格式。</p>
<p>編輯完成後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 儲存並重啟腳本。此時，Tabletop Simulator 會將腳本變動更新到遊戲儲存檔，讓遊戲呈現腳本所做的變動。</p>
<p>如果希望在編輯腳本的同時能觀察遊戲畫面，有兩種方式可以達成：</p>
<p>首先，將 Tabletop Simulator 設定為視窗模式（<code>Menu</code>、<code>Configuration</code>、<code>Graphics</code>、取消勾選 <code>Fullscreen</code>）。</p>
<ul>
<li>使用 Windows 視窗分割功能 （<code>Win</code> + <code>←</code>&#x2F;<code>→</code>&#x2F;<code>↑</code>），同時陳列編輯器與遊戲視窗。</li>
<li>下載 Windows PowerToys，這是一個功能強大的 Windows 工具集，其中包含了能將遊戲視窗固定在螢幕上的功能。(<a href="https://learn.microsoft.com/en-us/windows/powertoys/always-on-top">always on top feature</a>)</li>
</ul>
<h1 id="建立專案資料夾"><a href="#建立專案資料夾" class="headerlink" title="建立專案資料夾"></a>建立專案資料夾</h1><p>由於無法指定 Tabletop Simulator 遊戲儲存檔的存放位置，所以想要進行版本控管或專案管理時需要一些權變措施。</p>
<ol>
<li>首先，建立一個新的專案資料夾，例如命名為 <code>project/</code>。專案資料夾的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br></pre></td></tr></table></figure></li>
<li>再次開啟 Tabletop Simulator，選擇任意遊戲並儲存。遊戲會自動建立包含遊戲所有設定與資訊的 JSON 儲存檔 (<code>TS_Save_*.json</code>)，並附上一張遊戲截圖 (<code>TS_Save_*.jpg</code>)。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>由於 Tabletop Simulator 並未提供選擇遊戲儲存檔位置的選項，我們可以先將儲存檔和截圖檔案移至專案資料夾，以便之後進行版本控管。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>接下來，在 Tabletop Simulator 的資料夾內建立一個指向專案資料夾的軟連結，以確保儲存檔可以在遊戲的載入遊戲清單中被找到。由於軟連結會連結到原始檔案，因此我們可以透過軟連結對原始檔案進行修改，並將變動同步到遊戲中。（Windows 系統在 cmd 當中使用 <a href="https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/mklink">mklink 建立軟連結</a>） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%UserProfile%\Documents\My Games\Tabletop Simulator\Saves\</span><br><span class="line">|- project/ -&gt; /path/to/project/</span><br></pre></td></tr></table></figure></li>
<li>再次開啟 VSCode 並啟動 Tabletop Simulator Lua 套件。此時 VSCode 的探索欄應該會出現 Tabletop Simulator Lua 資料夾以及由套件從遊戲儲存檔中提取出來的 Lua 腳本。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br></pre></td></tr></table></figure></li>
<li>將專案資料夾加入 VSCode 的工作空間：選擇 <code>File</code> → <code>Add Folder to Workspace</code>，然後選擇專案資料夾。此時，探索欄的結構會看起來像這樣： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br></pre></td></tr></table></figure></li>
<li>在專案資料夾中建立需要的檔案或資料夾，例如 <code>src/</code>（用來儲存遊戲腳本）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tabletop Simulator Lua/</span><br><span class="line">|- Global.-*.lua</span><br><span class="line">|- Global.-*.xml</span><br><span class="line"></span><br><span class="line">project/</span><br><span class="line">|- README.md</span><br><span class="line">|- .git</span><br><span class="line">|- .gitignore</span><br><span class="line">|- TS_Save_*.json</span><br><span class="line">|- TS_Save_*.jpg</span><br><span class="line">|- src\</span><br><span class="line">    |- script1.lua</span><br><span class="line">    |- script2.lua</span><br></pre></td></tr></table></figure></li>
<li>接著開啟 <code>Global.-*.lua</code>，加入以下命令以指定要導入的腳本。由於套件會自動在工作空間的資料夾尋找副檔名為 <code>.ttslua</code>和<code>.lua</code> 的檔案，所以呼叫時就不需要加入副檔名了。 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script1&quot;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;script/script2&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>現在，已經成功設定 Tabletop Simulator 的 Lua 開發環境，也將遊戲依照專案資料夾的規劃納入版本控管，可以按照自己的習慣開發遊戲腳本了。</p>
<p>只是要記得在修改腳本或遊戲設定後，按下 <code>Ctrl</code> + <code>Alt</code> + <code>S</code> 以同步變動到遊戲儲存檔中，也不要忘記在新增腳本時更新導入的指令。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://tts-vscode.rolandostar.com/">TTS VSCode Docs</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/27">Require and Path</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/21">Best way to commit the main json file?</a></li>
<li><a href="https://github.com/rolandostar/tabletopsimulator-lua-vscode/issues/20">Get&#x2F;Send LUA scripts to&#x2F;from workspace folder</a></li>
</ul>
]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>人際的法則 — 怎麼面對他人求助？</title>
    <url>/templar-2017-the-rules-of-people/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>長大成人是在情感上付出努力得來的</p>
</blockquote>
<h1 id="幫助他人的前提"><a href="#幫助他人的前提" class="headerlink" title="幫助他人的前提"></a>幫助他人的前提</h1><h2 id="幫助他人前，先保護好自己"><a href="#幫助他人前，先保護好自己" class="headerlink" title="幫助他人前，先保護好自己"></a>幫助他人前，先保護好自己</h2><p>幫助他人前，要先保護好自己。人們傾向於向熟識的對象以及有類似經歷的對象求助。雖然我們往往願意傾聽並分享自己的經驗，但如果我們自己都還沒走出困境，那麼選擇幫助他人對彼此都很危險。</p>
<p>首先，受困的對方正專注於自己的痛苦，無法顧及我們的苦處，所以他們的情緒和行為可能在無意間傷害到我們。假如我們沒有保護好自己，那我們可能被對方的無心之過重傷，從而無法做出適當的回應。</p>
<p>例如在聽人訴苦的時候，如果我們自己都沒有堅定的立場，那很有可能將自己套入對方的情境，或是下意識地產生評價，而無法客觀地觀察對方的癥結點。在這種情況下，我們給出的建議也很可能無法幫到對方。</p>
<p>因此，在協助他人前務必要確認自己的狀況良好。若有必要，可以向求助者道歉並說明無法幫忙的理由，嘗試從其他角度支持對方。畢竟我們不會所有層面都脆弱，還是有堅強的地方，可以從此處著手協助對方。另外，量力而為。不要承諾實現不了得幫助，決定幫助他人當下需要確認自己的狀況良好，幫助他人的過程也要讓自己狀況良好。</p>
<p>如果許下實現不了的承諾，將面臨 (1) 自己因協助他人而困擾、(2) 他人的失望、(3) 他人要面對臨時喪失協助的損失（對方原本可以在其他方面獲得進展的）</p>
<h2 id="抱持同理心，取得求助者的信任"><a href="#抱持同理心，取得求助者的信任" class="headerlink" title="抱持同理心，取得求助者的信任"></a>抱持同理心，取得求助者的信任</h2><p>確認自己狀況良好後，還要了解求助者的情感需求。有時，想向他人訴苦求助，但聽完對方的分析和建議後，反而讓自己心情更差。（或是反過來，想幫助他人，但對方沒有好起來）這現象的主要原因在於，協助者沒有照顧到求助者的情感需求。由於求助相當於示弱，如果不是相當痛苦且需要他人協助，沒人願意冒著被傷害的風險暴露自己的弱點。</p>
<p>因此，在獲得實質幫助前，求助者往往需要協助者的承諾（言語、行動、眼神等），承諾求助者不會傷害他們的情感，承諾求助者可以暢所欲言、悲傷欲絕、憤怒抱怨而不會遺棄對方，承諾求助者能夠感受對方的苦處而不會因為一時的失態而看輕對方。</p>
<h1 id="尊重求助者"><a href="#尊重求助者" class="headerlink" title="尊重求助者"></a>尊重求助者</h1><h2 id="不當表達的期待與祝福，可能成為求助者的壓力"><a href="#不當表達的期待與祝福，可能成為求助者的壓力" class="headerlink" title="不當表達的期待與祝福，可能成為求助者的壓力"></a>不當表達的期待與祝福，可能成為求助者的壓力</h2><p>倘若忽略求助者的情感需求而直接提供解決辦法，就好像指責對方的情緒反應很不合理：有解決辦法→沒必要感到悲傷→求助者感到背上→求助者有毛病。因此，面對求助者時，往往要先同理對方的感受，讓他們放心地和我們一同找出解決辦法。例如，一句「你感到很受傷嗎？」或「你生氣嗎？」等關心就可以讓對方明白我們的善意，讓求助者了解協助者願意傾聽和體諒。</p>
<p>與這些問候相反，「別擔心」或「不用哭啦」等否定對方感受的句子，會讓人誤會協助者無法同理求助者的感受，從而把安慰理解為輕蔑（原本的意思：從希望對方擺脫擔心狀態；誤會的意思：根本不用擔心好嗎？你到底在糾結什麼？）</p>
<p>「和我比起來，你好很多啦」或「你看某某某不是也過得好好的？」等告訴對方處境並不像他們所認為那麼糟的句子，則會讓求助者誤會他們沒資格抱怨。（原本的意思：希望對方不用過度擔心；誤會的意思：你的情緒是大驚小怪）</p>
<p>「看開點」或「振作起來」等命令句子，會讓人誤會協助者在看輕他們，從而把安慰理解為不體諒（原本的意思：希望對方看開點或振作起來；誤會的意思：這種廢話我也懂，如果有用我早就做了，何必跟你講那麼多，這種安慰沒有幫助也讓人覺得你根本不在意這件事）</p>
<p>換句話說，倘若自己有自己的困難和價值觀，沒必要在幫助他人時傾訴（可以選在自己的抱怨時機）。幫助他人時，談話的重心就放在對方和對方的感受上。</p>
<blockquote>
<p>一旦對方知道你不會評價他，你們就可以自在地交流。對許多人而言，跟一個不會評價你的人討論某事，就是解決這件事的一種方式——不管是為了貞治解決問題還是只想找個人吐露心事。</p>
</blockquote>
<h2 id="尊重求助者的獨立意志"><a href="#尊重求助者的獨立意志" class="headerlink" title="尊重求助者的獨立意志"></a>尊重求助者的獨立意志</h2><p>然而，很多時候，求助者也許不需要幫助，只是需要讓自己的情感有所宣洩，那麼光是同理對方就可以幫助對方。尤其在情感問題方面，我們往往無法解決他人的情感問題，畢竟那並非我們的情感。情感存在於求助者的內心，往往只能由他們來清理，無法由他人代勞。</p>
<p>那麼求助者究竟期待協助者能做到什麼？也許求助者想要他人的同理、想要透過聊天來梳理想法、想要抒發情緒的對象、真的想要解決問題、想要透過抱怨和否定來推卸責任、想要博取關注等。</p>
<p>重點是求助者不需要不請自來的幫助。一旦忽略求助者的動機，開始為別人構思解決問題時，也就代表 (1) 協助者已經不再傾聽對方了。(2) 協助者透露出救星姿態，彷彿求助者沒能力解決問題（這是否定對方的舉動）。</p>
<p>是以，下次面對他人的求助，可以先確認對方的需求，例如問問對方「你需要幫忙嗎？還是只想說出來讓自己心情好一點？」如果對方只需要一個聽眾，那就好好克制自己想做點什麼的衝動，當自己開始傾聽就已經開始在幫助對方了。</p>
<h2 id="「建議」不總是面對求助的最佳解答"><a href="#「建議」不總是面對求助的最佳解答" class="headerlink" title="「建議」不總是面對求助的最佳解答"></a>「建議」不總是面對求助的最佳解答</h2><p>何況很多情況其實不適合給對方建議，因為我們能接受的線索限於對方提供的資訊，給出的建議可能過於侷限。此外，一項行為有無利害可以從時間長短、人際關係、物質損益等層次分析，而我們又無法獲得對方所有心理狀態，所以很難理解什麼建議最符合對方需求且對對方有利。</p>
<p>其次，我們的經驗有所侷限，沒辦法確認在對方上也能適用，倘若建議無用，很可能讓對方失望且遷怒於我方。再三，我們得尊重對方的人生經驗和努力：</p>
<blockquote>
<p>人們需要自己深思熟慮後做出決定，這樣他們才會全心全意地投入並堅定完成任務。如果你告訴對方該怎麼辦，等於是抽走對方決策過程裡的重要階段，直接到達問題的終點。實際上把問題想通想透，權衡各個選項，考慮不同的意見，這些都是非常重要的。</p>
</blockquote>
<p>尤其是注意力放在自己時，也不適合給對方建議：</p>
<blockquote>
<p>當你給別人建議時會讓你自己好受點。可是我們是要去幫助別人，在這種時候你的感受並不是最重要的。我們得試想對方會怎樣看待他人給予的建議呢？即使你認為他們確實想要接受它，但是怎麼能確定這些建議一定就符合他們的最大利益？</p>
</blockquote>
<blockquote>
<p>給予對方不需要或不合適的建議，其實只是在浪費心力。假設你的朋友跟一個濫情的對象在一起，你認為他們會不知道分開對彼此都好？如果你直接說出你的建議，那只是讓他們無時無刻感到自己的無能為力。這並不會幫助他們離開對方，而你只是成為另一個控制他們的人罷了。他們真正需要的是支持，不是無法落實的指示。</p>
</blockquote>
<h1 id="以對方為本的心態面對求助"><a href="#以對方為本的心態面對求助" class="headerlink" title="以對方為本的心態面對求助"></a>以對方為本的心態面對求助</h1><h2 id="幫助他人的重點在於對方，而不是自己"><a href="#幫助他人的重點在於對方，而不是自己" class="headerlink" title="幫助他人的重點在於對方，而不是自己"></a>幫助他人的重點在於對方，而不是自己</h2><p>綜上所述，當有人來尋求建議時，最應該做的是協助對方找到正確答案。透過詢問來協助對方了解困惑，透過提出不同可能來協助他們描述講不出的策略，協助他們釐清事情的走向，幫助他們了解選擇的後果，尊重他們選擇和承擔責任的尊嚴。</p>
<p>即使對方沒有照著自己認為最佳方案進行，也不需要太介意，因為我們已經盡力協助他們做出選擇了。我們在意對方的選擇的原因終究是我們自己，我們期待對方聽從我們的建議，而這建議對我們也有好處。</p>
<p>但再次回顧幫助他人的重點，幫助他人要關注的終究是對方和其感受，我們無權干涉別人的決定，也最好不要把自己的需求寄託在他人的決定。我們的需求要靠自己去爭取，對方的選擇要由對方自行承擔。協助者是事件的配角，盡其所能做到最好已然足夠。</p>
<h2 id="責任的區隔是種體貼和尊重"><a href="#責任的區隔是種體貼和尊重" class="headerlink" title="責任的區隔是種體貼和尊重"></a>責任的區隔是種體貼和尊重</h2><p>這種責任的區隔不是無情，而是體貼與尊重。即使對方因選擇而受挫，那仍是他們做出的選擇，他們保住了自主權。何況，我們不是對方，只有對方才完全清楚自己要的是什麼，即使他們描述不出來。</p>
<p>此外，這樣也能避免名為幫助的控制。很多時候，提供幫助就是讓對方欠人情，讓自己成為對方的債主，從而獲得控制對方的權力和地位。然而，有來有往才是人們相處的本質。他人拒絕幫忙有可能是要擺脫這種控制或是要維持自己的控制權。因此，當對方拒絕自己的協助時，要意識到對方的反應，了解他們對於這個協助的感受為何，不用太耿耿於懷自己。</p>
<blockquote>
<p>讓每個人都能控制自己的生活是件非常重要的事。如果你總是幫人做決定——即使出於善意——你都是在奪走別人的自主權。</p>
</blockquote>
<blockquote>
<p>如果你總是對已經處在極度焦慮和無助的人們提出強勢的建議，這會讓整個局勢看起來像是你在替他們做決定一樣。他們自身的感受才是最重要的，你的初衷其實無關緊要。</p>
</blockquote>
<blockquote>
<p>最能幫助他人的方式，是讓不想說話的人知道，你並不會強迫他們。如果有人正經歷困難，你能說得最有幫助的話是：「如果你願意聊聊你的事，我很開心；但如果你不想談，我也不會主動問。」這麼做的話，他們在你身邊時就能感到放送，因為他們知道自己不用背負更多的壓力。</p>
</blockquote>
<blockquote>
<p>「否認」是一種重要且寶貴的情緒緩衝。</p>
</blockquote>
<blockquote>
<p>你與他人任何一次互動，都會讓雙方過得更好或更糟，那些互動總會有所影響。</p>
</blockquote>
<p>協助對方做出更好的決定，尊重對方的自主權，透過中性不帶有評價的詢問來了解對方的感受、探索可能的行動選項。</p>
<h1 id="小訣竅"><a href="#小訣竅" class="headerlink" title="小訣竅"></a>小訣竅</h1><ul>
<li>當對方抱怨某人，但我不認同他的抱怨時，可以試著認同他的情緒，但對自己的立場打迷糊仗。例如：「是的，這的確會讓你很生氣。」這樣可以避免無謂的爭端，也可以讓對話繼續下去。</li>
<li>不要對無法改變或無能為力的事情評論，這無濟於事且令人不快。</li>
<li>安撫緊張的人時，不要說「別緊張」。因為對方緊張是因為在乎，是因為把事情做好相當重要，這意味著他們渴望成功而且有企圖心和動力去實踐。因此，不要把期待當成安撫，要讓他們知道我們很高興他們重視這件事，要教他們怎麼克服做事會碰到的難關，要陪伴他們讓他們得到信心。</li>
<li>本性難移，所以能夠改變某人的行為就很棒了。每個人都是過往經歷的產物，所以改變行為就已經是帶給他們改變自身的機會了。在無法改變本性的情況下，唯一能改變的是自己，因為他人行為產生的情緒都在自己身上，而不是他人身上，因此只能靠自己來調整情緒和認知。</li>
<li>「大多數時候，別人的信念是你無法改變的，你再怎麼做都是白費工夫，但這並非意味著讓某些人改變是不可能的。能讓他們改變的必須是一種沉浸式的體驗，他們必須親自感受、經歷，這些都是你無法越俎代庖的。」</li>
<li>理解他人是在幫助自己，每個人都由其人生經歷塑造而成，因此對方讓我方不快的舉動都有其理由。若能了解他人負面的行為，即使改變不了事實或對方本性，也能較容易改變自己的認知，讓自己舒服一點。所以為了自己去了解他人吧。</li>
</ul>
<h1 id="此書其他內容"><a href="#此書其他內容" class="headerlink" title="此書其他內容"></a>此書其他內容</h1><h2 id="評論與建議"><a href="#評論與建議" class="headerlink" title="評論與建議"></a>評論與建議</h2><p>評論與建議的原則是要讓對方知道你的認可，再提供有價值的建議。常用的訣竅是將好的方面歸功於對方，而不好的方面則歸咎於客觀因素。陳述時可以用積極的具體評論為開頭，再敘述負面的評論（待加強處），最後補上統整性的正面評論。切記，評論與建議要注重時機與氛圍，無濟於事的評論（或是對方無法改變的事情）既徒勞無功也會讓人不快，要盡量避免。</p>
<h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><p>感謝的關鍵在讓對方確切地知道我方在感謝什麼，清楚地告訴對方他們哪些作為讓自己感激不盡，表達對方在自己心中的位置。越具體且個性化的感謝，越能讓對方感到你的真心誠意。</p>
<h2 id="讚美"><a href="#讚美" class="headerlink" title="讚美"></a>讚美</h2><p>稱讚的效用包含建立信任、表達關懷與友善、鼓勵對方堅持自己擅長的事、博取支持。真誠地稱讚要發自內心，陳述的內容要具體，可以直接針對對方心裡的訴求（能力認同感或歸屬感）等稱讚，也可以稱讚對方的作為，請對方自述也是一種表達興趣的稱讚手段。</p>
<h2 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h2><p>贏得信任的方法是信任對方：</p>
<ul>
<li>不要私底下散播或談論對方的謠言</li>
<li>在外人面前要站在對方的立場</li>
<li>在對方需要時給予支持與同理</li>
<li>在不辜負他人信任的前提下，盡可能敞開心房合作</li>
<li>無論是否認同對方意見，都要尊重對方的觀點，不能蔑視或嘲諷對方</li>
<li>要認真傾聽</li>
<li>向對方展現他們所關心的事物</li>
<li>滿懷感激</li>
</ul>
<h2 id="道歉"><a href="#道歉" class="headerlink" title="道歉"></a>道歉</h2><p>「對不起」不是重點，重點是對方的想法和做法，重點是緩解雙方的不愉快，關係回到正軌。這可以透過友善的行為開端，然後好好聊聊彼此不愉快之處，討論往後怎麼避免重蹈覆轍。</p>
]]></content>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>The Door into Astrobiology | 天文生物學入門資源</title>
    <url>/the-door-into-astrobiology/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>天文生物學（Astrobiology）是研究生命在宇宙中形成、演化和分布的跨領域學科。由於至今只在地球上發現生物，所以眼下課題就是釐清形成地球生命的機制與先決條件，欲達成這目標不僅得追溯組成生物的原料來源，還需了解有哪些因素影響適居環境的構成，並從演化和地質證據推敲無機物轉變為生物的過程。</p>
<p>利用前述知識，研究者得以探討太陽系其他天體存在生命的可能，當今最具希望者無疑是我們的鄰居火星，不過類木行星的衛星，例如歐羅巴、泰坦，也有孕育生命的潛力。倘若能在這些迥異的環境中發現生命，它將成為地球生命的對照組，有助於釐清「生命是什麼？」這類問題，也會擴張對生命起源條件的想像。目前歐洲和美國太空總署皆有探索生命跡象的太空任務，至於迄今人類科技水準仍無法到達的遙遠恆星系統，則有賴天文觀測及光譜分析技術去尋找生命存在的間接證據。</p>
<p>總而言之，天文生物學不只是天文學加上生物學，它集結了宇宙學、演化學、地球科學、資訊科學、生物化學、比較行星學、分子生物學……等等無數學科，研究對象從五微米大的細胞到十萬光年長的星河，從宇宙爆發到生命誕生。因此，無論喜歡哪種尺度、身懷哪種學術專業，只要想探索生命起源的終極問題，總能在其中找到安身立命的地方。</p>
<p>本文整理了有關天文生物學（Astrobiology）的書籍、線上課、演講等學習資源，並依其內容劃分為通論、生命起源、搜索地外生命、科學史四類，歡迎大家留言補充。</p>
<span id="more"></span>
<h1 id="科普書籍"><a href="#科普書籍" class="headerlink" title="科普書籍"></a>科普書籍</h1><h2 id="通論"><a href="#通論" class="headerlink" title="通論"></a>通論</h2><ul>
<li>田村元秀 (2023) [《天文生物學超入門》] (<a href="https://www.books.com.tw/products/0010968407?sloc=main">https://www.books.com.tw/products/0010968407?sloc=main</a>) [台灣東販]</li>
<li>Jeffrey Bennett &amp; Seth Shostak (2016)：<a href="https://www.books.com.tw/products/CN11331116">《宇宙中的生命》</a> [機械工業]（簡）</li>
<li>Gerda Horneck &amp; 莊逢源 (2010)：<a href="https://www.books.com.tw/products/CN10159991">《宇宙生物學》</a> [中國宇航]（簡）</li>
<li>Peter D. Ward &amp; Donald Brownlee (2017)：<a href="https://www.books.com.tw/products/0010741618">《寂寞的地球：宇宙唯一有複雜生命的行星》</a> [貓頭鷹]</li>
<li>Michael William Ovenden (1964)：<a href="https://www.amazon.com/Universe-Science-Study-Michael-Ovenden/dp/0435550292">《宇宙中的生命》</a> [徐氏]</li>
</ul>
<h2 id="生命起源"><a href="#生命起源" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Sir Paul Nurse (2021)：<a href="https://www.books.com.tw/products/0010909520?sloc=main">《生命之鑰》</a> [三采]</li>
<li>Addy Pross (2018)：<a href="https://www.books.com.tw/products/CN11604089">《生命是什麼：40億年生命史詩的開端》</a> [中信]（簡）</li>
<li>王立銘 (2018)：<a href="https://www.books.com.tw/products/CN11599405">《生命是什麼》</a> [人民郵電]（簡）</li>
<li>Freeman Dyson (2017)：<a href="https://www.sanmin.com.tw/product/index/006310600">《生命的起源》</a> [浙江大學]（簡）</li>
<li>Nick Lane (2016)：<a href="https://www.books.com.tw/products/0010730616">《生命之源：能量、演化與複雜生命的起源》</a> [貓頭鷹]</li>
<li>Erwin Schrodinger (2016)：<a href="https://www.books.com.tw/products/0010708022">《薛丁格生命物理學講義：生命是什麼？》</a>[貓頭鷹]</li>
<li>Christian de Duve (2011)：<a href="https://www.books.com.tw/products/0010516325">《生物決定論：人類一定會出現在地球上嗎？》</a> [左岸文化]</li>
<li>李杰信 (2008)：<a href="https://www.sanmin.com.tw/Product/Index/000791958">《生命的起始點：談生命起源》</a> [科學普及]（簡）</li>
<li>A.G.Cairns-Smith (1995)：<a href="https://www.books.com.tw/products/CN10041905">《生命起源的七條線索》</a> [中國對外翻譯]（簡）</li>
<li>Francis Crick (1993)：<a href="https://book.douban.com/subject/2420069/">《生命：起源和本質》</a> [科學普及]（簡）</li>
</ul>
<h2 id="尋找地外生命"><a href="#尋找地外生命" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Dara Oacute; Briain (2023)： <a href="https://www.books.com.tw/products/CN11895285">《真的有外星人嗎》</a> [中國紡織]（簡）</li>
<li>Ben Miller (2022)： <a href="https://www.sanmin.com.tw/product/index/010759160">《外星人來了？》</a> [中國友誼]（簡）</li>
<li>瀧澤美奈子 (2021)：<a href="https://www.sanmin.com.tw/product/index/010419542">《當天文學遇上生物學》</a> [機械工業]（簡）</li>
<li>Lewis Dartnell (2021)：<a href="https://www.sanmin.com.tw/product/index/010408023">《人人都該懂的地外生命》</a> [浙江教育]（簡）</li>
<li>李傑信 (2021)：<a href="http://《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》">《穿越4.7億公里的拜訪：追尋跟著水走的火星生命》</a>[三民書局]</li>
<li>Jon Willis (2018)：<a href="https://www.books.com.tw/products/CN11579783">《群星都是你們的世界》</a> [中信]（簡）</li>
<li>Димитър Д. Съселов (2017)：<a href="https://www.books.com.tw/products/CN11465684">《超級地球上的生命》</a> [上海科學技術]（簡）</li>
<li>Louisa Preston (2017)：<a href="https://www.books.com.tw/products/CN11440032">《地外生命探索之旅》</a> [中國計量]（簡）</li>
<li>李炎 (2016)：<a href="https://www.sanmin.com.tw/product/index/006090615">《太空生物學》</a> [漢珍]</li>
<li>Bignami G. (2013)：<a href="https://www.books.com.tw/products/CN11062152">《我們就是火星人：尋找宇宙中的地外生命》</a> [科學]（簡）</li>
<li>李冰 (2011)：<a href="https://www.sanmin.com.tw/product/index/001680995">《尋找外星人》</a> [北京師大]（簡）</li>
<li>Donald Goldsmith &amp; Tobias Owen (1999)：<a href="https://www.amazon.co.jp/-/en/Donald-Goldsmith/dp/0201569493">《尋找宇宙生命》</a> [朗文]</li>
</ul>
<h2 id="科學史"><a href="#科學史" class="headerlink" title="科學史"></a>科學史</h2><ul>
<li>Sara Seager (2021)：<a href="https://www.books.com.tw/products/0010882271">《尋找太陽系外的行星：天文學家莎拉．西格的愛與探索》</a>[天下文化]</li>
<li>Ron Miller (2018)：<a href="https://www.books.com.tw/products/CN11600118">《外星生命簡史：人類400年地外生命探索與想象全記錄》</a> [北京聯合]（簡）</li>
<li>Bill Mesler &amp; H. James Cleaves II (2017)：<a href="https://www.books.com.tw/products/CN11438003">《生命的誕生——我們究竟來自哪裡》</a> [人民郵電]（簡體）</li>
<li>Lee Billings (2017)：<a href="https://www.books.com.tw/products/0010741343">《五十億年的孤寂：繁星間尋找生命》</a> [八旗文化]</li>
<li>汪洁 (2017)：<a href="https://www.sanmin.com.tw/Product/index/006841620">《億萬年的孤獨：地外文明探尋史話》</a> [北京時代華文書局]（簡）</li>
</ul>
<h1 id="線上課程"><a href="#線上課程" class="headerlink" title="線上課程"></a>線上課程</h1><h2 id="通論-1"><a href="#通論-1" class="headerlink" title="通論"></a>通論</h2><ul>
<li><a href="https://www.acoea.com/?utm_campaign=6647bde1-a2ee-4363-adb3-ecaa2466dff5&utm_source=so&utm_medium=mail&cid=ab330e43-978b-4e52-8b2a-7347df1555d3">“Introduction to Astrobiology”</a> [Amity University]（Centre of Excellence in Astrobiology）</li>
<li><a href="https://astrobiovideo.com/en/">“Online Courses in Astrobiology”</a> [ International Astronomical Unio]</li>
</ul>
<h2 id="生命起源-1"><a href="#生命起源-1" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Bruce W. Fouke，<a href="https://www.coursera.org/learn/emergence-of-life">“Emergence of Life”</a> [The University of Illinois]（coursera）</li>
<li>Jack Szostak，<a href="https://www.ibiology.org/speakers/jack-szostak/">“The Origin of Life on Earth”</a>（iBiology）</li>
<li>Sarah Maurer &amp; Chris Kempes，<a href="https://www.complexityexplorer.org/courses/103-origins-of-life">“Origins Of Life”</a> [Santa fe institute]（Complexity Explorer）</li>
</ul>
<h2 id="尋找地外生命-1"><a href="#尋找地外生命-1" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Charles Cockell，<a href="https://www.coursera.org/learn/astrobiology">“Astrobiology and the Search for Extraterrestrial Life”</a> [The University of Edinburgh]（coursera）</li>
<li>Charles Cockell， <a href="https://www.youtube.com/channel/UCBTwJSnAqZZczK7stBaYq5w/playlists">“Life in the Universe – the pandemic series”</a>（Youtube）</li>
<li>Chris Impey，<a href="https://www.coursera.org/learn/astrobiology-exploring-other-worlds#syllabus">“Astrobiology: Exploring Other Worlds”</a> [The University of Arizona]（coursera）</li>
<li>David Spergel，<a href="https://www.coursera.org/learn/life-on-other-planets">“Imagining Other Earths”</a> [Princeton University]（coursera）</li>
<li>Lynn Rothschild，<a href="https://cosmolearning.org/courses/astrobiology-and-space-exploration">“Astrobiology and Space Exploration”</a> [Stanford University]（CosmoLearning）</li>
<li>Димитър Д. Съселов，<a href="https://www.edx.org/course/super-earths-and-life">“Super-Earths and Life”</a> [Harvard University]（edX）</li>
</ul>
<h1 id="演講"><a href="#演講" class="headerlink" title="演講"></a>演講</h1><h2 id="通論-2"><a href="#通論-2" class="headerlink" title="通論"></a>通論</h2><p>待補</p>
<h2 id="生命起源-2"><a href="#生命起源-2" class="headerlink" title="生命起源"></a>生命起源</h2><ul>
<li>Christoph Adami，<a href="https://www.ted.com/talks/christophe_adami_finding_life_we_can_t_imagine?language=zh-tw">〈尋找難以想像的生命〉</a>[TEDxUIUC]</li>
<li>Lee Cronin，<a href="https://www.ted.com/talks/lee_cronin_making_matter_come_alive?language=zh-tw">〈讓物質變活〉</a>[TEDGlobal]</li>
<li>Martin Hanczyc，<a href="https://www.ted.com/talks/martin_hanczyc_the_line_between_life_and_not_life?language=zh-tw">〈生命與非生命的界線〉</a>[TEDSalon London]</li>
<li>Nathalie Cabrol，<a href="https://www.ted.com/talks/nathalie_cabrol_how_mars_might_hold_the_secret_to_the_origin_of_life?language=zh-tw">〈探秘火星，解開地球生命之謎〉</a>[TED]</li>
</ul>
<h2 id="尋找地外生命-2"><a href="#尋找地外生命-2" class="headerlink" title="尋找地外生命"></a>尋找地外生命</h2><ul>
<li>Aomawa Shields，<a href="https://www.ted.com/talks/aomawa_shields_how_we_ll_find_life_on_other_planets?language=zh-tw">〈我們如何尋找存在於另一顆行星上的生命〉</a>[TED]</li>
<li>Carolyn Porco，<a href="https://www.ted.com/talks/carolyn_porco_could_a_saturn_moon_harbor_life?language=zh-tw">〈土星的衛星可能有生命存在嗎？〉</a>[TED]</li>
<li>Dave Brain，<a href="https://www.ted.com/talks/dave_brain_what_a_planet_needs_to_sustain_life/transcript?language=zh-tw">〈行星維持生命存在的要素〉</a>[TEDxBoulder]</li>
<li>Freeman Dyson，<a href="https://www.ted.com/talks/freeman_dyson_says_let_s_look_for_life_in_the_outer_solar_system?language=zh-tw">〈在太陽系外圍找尋生命〉</a>[TED]</li>
<li>Garik Israelian，<a href="https://www.ted.com/talks/garik_israelian_what_s_inside_a_star">〈How spectroscopy could reveal alien life〉</a>[TEDGlobal]</li>
<li>James Green，<a href="https://www.ted.com/talks/james_green_3_moons_and_a_planet_that_could_have_alien_life?language=zh-tw">〈可能有生命存在的一個行星和三個衛星〉</a>[TED Talks Live]</li>
<li>Lucianne Walkowicz，<a href="https://www.ted.com/talks/lucianne_walkowicz_finding_planets_around_other_stars">〈Finding planets around other stars〉</a>[TEDGlobal]</li>
<li>Penelope Boston，<a href="https://www.ted.com/talks/penelope_boston?language=zh-tw">〈火星可能有生命存在〉</a>[TED]</li>
<li>Sara Seager，<a href="https://www.ted.com/talks/sara_seager_the_search_for_planets_beyond_our_solar_system/transcript?language=zh-tw">〈尋找太陽系外的行星〉</a>[TED]</li>
<li>Seth Shostak，<a href="https://www.ted.com/talks/seth_shostak_et_is_probably_out_there_get_ready?language=zh-tw">〈準備好，ET (可能) 就在那裡〉</a>[TEDxSanJoseCA]</li>
<li>Tabetha Boyajian，<a href="https://www.ted.com/talks/tabetha_boyajian_the_most_mysterious_star_in_the_universe?language=zh-tw">〈宇宙中最神秘的一顆星〉</a>[TED]</li>
<li>Димитър Д. Съселов，<a href="https://www.ted.com/talks/dimitar_sasselov_how_we_found_hundreds_of_potential_earth_like_planets/transcript?language=zh-tw">〈發現數百顆類似地球的行星〉</a>[TEDGlobal]</li>
</ul>
<h2 id="科學史-1"><a href="#科學史-1" class="headerlink" title="科學史"></a>科學史</h2><ul>
<li>Jill Tarter，<a href="https://www.ted.com/talks/jill_tarter_s_call_to_join_the_seti_search/transcript?language=zh-tw">〈加入SETI計劃〉</a>[TED]</li>
</ul>
<h1 id="知識普及網站"><a href="#知識普及網站" class="headerlink" title="知識普及網站"></a>知識普及網站</h1><ul>
<li><a href="https://www.facebook.com/Abiogenesis-262675454086715/">Abiogenesis</a></li>
<li><a href="https://www.facebook.com/Abiogenesis-Hall-of-Fame-138681233223461/">Abiogenesis Hall of Fame</a></li>
<li><a href="https://www.astrobio.net/">Astrobiology Magazine</a></li>
<li><a href="http://astrobiology.com/">Astrobiology Web</a></li>
<li><a href="https://www.facebook.com/Life-the-Origin-of-245683669160907/">Life, the Origin of</a></li>
<li><a href="https://www.facebook.com/Origin-of-Life-293514407692658/">Origin of Life</a></li>
<li><a href="https://www.zhihu.com/column/gswxzt">古生物新聞</a></li>
</ul>
<h1 id="學術機構"><a href="#學術機構" class="headerlink" title="學術機構"></a>學術機構</h1><h2 id="研究單位"><a href="#研究單位" class="headerlink" title="研究單位"></a>研究單位</h2><ul>
<li><a href="https://www.bmsis.org/">Blue Marble Space Institute of Science</a></li>
<li><a href="https://cool.gatech.edu/">Center for the Origin Of Life</a> [Georgia Institute of Technology]</li>
<li><a href="http://www.elsi.jp/en/">Earth-Life Science Institute</a> [Tokyo Institute of Technology]</li>
<li><a href="https://www.emergence-of-life.de/index.html">Emergence of Life</a></li>
<li><a href="https://www.originscenter.nl/">Origins Center</a> [University of Groningen]</li>
<li><a href="https://origins.harvard.edu/">Origins of Life Initiative</a> [Harvard University]</li>
<li><a href="https://www.simonsfoundation.org/life-sciences/origins-of-life/simons-collaboration-on-the-origins-of-life/">The Simons Collaboration on the Origins of Life</a> [Simons Foundation]</li>
</ul>
<h2 id="社群與學會"><a href="#社群與學會" class="headerlink" title="社群與學會"></a>社群與學會</h2><ul>
<li><a href="https://www.facebook.com/groups/2221810485/">Astrobiology Club</a> [Facebook club]</li>
<li><a href="https://astrobiologysociety.org/">Astrobiology Society of Britain</a></li>
<li><a href="https://saganet.ning.com/">Social Action for a Grassroots Astrobiology Network (SAGANet)</a></li>
<li><a href="http://issol.org/">International Society for the Study of the Origin of Life (ISSOL)</a></li>
<li><a href="https://www.facebook.com/groups/515811491814739/">Virtual Astrobiology Society</a> [Facebook club]</li>
</ul>
<h2 id="研討會"><a href="#研討會" class="headerlink" title="研討會"></a>研討會</h2><ul>
<li><a href="https://www.abgradcon.org/">Astrobiology Graduate Conference</a></li>
<li><a href="https://connect.agu.org/abscicon/home">Astrobiology Science Conference</a></li>
<li>Biennial European Astrobiology Conference</li>
<li><a href="https://issol.org/meetings/">International Conference on the Origin of Life</a></li>
<li><a href="https://www.grc.org/origins-of-life-conference/">Origins of Life Gordon Research Conference</a></li>
<li><a href="https://indico.physik.uni-muenchen.de/event/63/">Molecular Origins of Life</a>, Munich</li>
</ul>
<h1 id="研究中心與學術合作網路"><a href="#研究中心與學術合作網路" class="headerlink" title="研究中心與學術合作網路"></a>研究中心與學術合作網路</h1><h2 id="亞洲及大洋洲"><a href="#亞洲及大洋洲" class="headerlink" title="亞洲及大洋洲"></a>亞洲及大洋洲</h2><ul>
<li><a href="https://www.aca.unsw.edu.au/">Australian Centre for Astrobiology</a></li>
<li><a href="http://abc-nins.jp/en/">Astrobiology Center</a> (in Japan)</li>
<li><a href="https://astrobiologyindia.in/">Astrobiology India</a></li>
<li><a href="https://www.facebook.com/AstrobioPak/">Astrobiology Network of Pakistan</a></li>
<li><a href="https://www.acoea.com/">Centre of Excellence in Astrobiology</a> (in India)</li>
<li><a href="https://logos.ls.toyaku.ac.jp/~astrobiology-japan/en/">Japan Astrobiology Network</a></li>
</ul>
<h2 id="美洲"><a href="#美洲" class="headerlink" title="美洲"></a>美洲</h2><ul>
<li><a href="https://astrobiology.nasa.gov/">Astrobiology at NASA</a></li>
</ul>
<h2 id="歐洲"><a href="#歐洲" class="headerlink" title="歐洲"></a>歐洲</h2><ul>
<li><a href="http://www.eana-net.eu/">European Astrobiology Network Association (EANA)</a></li>
<li><a href="http://life-origins.com/">life-origins.com</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://oolen.org/">Origin of Life Early-career Network (OoLEN)</a></li>
</ul>
]]></content>
      <tags>
        <tag>astrobiology</tag>
      </tags>
  </entry>
  <entry>
    <title>軟體開發文件管理的簡單數學</title>
    <url>/the-simple-math-of-document-management-in-software-development/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>伊藤潤二在其短篇漫畫《藏書幻影》中，描述了一位因為恐懼藏書遺失而決定將家中數十萬本書籍默記在心的書迷。不料，他記住所有藏書的內容後，卻沒有留下絲毫空間給自己的回憶與判斷力，只能終日在書堆中，眼神空洞地翻閱書頁、喃喃自語。</p>
<p>在軟體開發領域，我們同樣面臨對於遺忘的擔憂。需求分析、風險評估與架構決策等資訊，在開發過程中逐步累積，既是團隊經驗的傳承，也是產品應稽的依據。因此，各企業透過各式各樣的文件，紀錄程式碼以外稍縱即逝的寶貴思想與知識；對於醫療檢測產品，政府單位也提供了文件撰寫指引，詳細列出文件應具備的項目，以確保產品的安全性。</p>
<p>然而，市場變化與需求異動帶來的時程壓力，也使得團隊陷入開發延宕的恐慌。長期看來，文件固然能提供產品與團隊價值，但是撰寫文件往往是吃力不討好的工作，一方面它不直接改進產品功能，另一方面撰寫文件的努力不亞於軟體開發本身。因此，在迫切需要功能實現或障礙排除時，文件往往是首先被犧牲的項目。</p>
<p>依照我的經驗，對於如何撰寫文件的倡議，往往基於對內容的保障，未必會考量到維護齊全文件的成本。於是，團隊因為文件與開發的衝突，在棘手的情境間左右為難：要不因為害怕遺漏資訊而導致開發遲滯，又或憂懼逾期交付而造成紀錄不全。</p>
<p>因此，在這篇文章中，我嘗試跳脫基於儲存資訊的文件框架，加入一些專案管理的觀點，來思考解決兩者衝突的策略，從而避免過時、錯誤或不全等貶損文件價值的不利因素。</p>
<span id="more"></span>

<p>無論目標是應對稽核還是與用戶&#x2F;開發者溝通，考量到文件與軟體相輔相成的作用，宜將文件視為產品的一部份，並且在規劃專案時程時，將更新文件的成本納入考慮。</p>
<p>根據軟體的用途和文件的性質，每個軟體迭代所需更新的文件類型和數量也會有所不同。在個人主導的開源專案中，每次軟體發布可能只涉及 README.md 和 CHANGELOG.md 的修改；但若打算申請美國 FDA 的 IVD 認證，即使是簡單的功能升級，也需要維護近十份文件（例如需求、風險、設計、測試和架構等），而且這些文件的更新必須遵循法規程序，額外增加不少行政成本。</p>
<p>如果團隊能在指定時間內順利完成軟體與文件更新，則可確保兩者內容及時；反之，則必有一方與進度脫節。為了避免文件過時，我們可以列出以下不等式：</p>
<p>$$ n \cdot t_{doc} + T_{dev} \leq T_{iter} $$</p>
<ul>
<li>$t_{doc}$：更新一份文件所需要的時間</li>
<li>$n$：軟體每次迭代需要更新的文件數量</li>
<li>$T_{dev}$：軟體該次迭代的開發總時數</li>
<li>$T_{iter}$：軟體迭代週期</li>
</ul>
<p>依據此不等式，每次軟體迭代維護文件所需的時間取決於更新的成本與頻率。假設固定迭代週期與開發時數，那麼低頻率的更新可以容忍較高的更新成本，而低成本的更新可以配合高頻率的更新。</p>
<p>撰寫文件的成本補僅與內容相關，也涉及過程中的調查、驗收與調整的成本；若是法規文件，還涉及更多的審查、簽核和文檔管理等手續。而文件更新的頻率則取決於其精細度，內容愈是詳細且貼近軟體底層的運作，愈有可能因為局部的變動而需要更新；反之，內容愈是抽象且概括描述軟體的架構，則能承受較多次的軟體變更。</p>
<p>我們可以依據這項關係來評估撰寫文件的尺度與範圍。以下是一個假想專案每次軟體迭代各層級物件的更新頻率：</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>API Change Frequency</th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td>100</td>
</tr>
<tr>
<td>Class</td>
<td>10</td>
</tr>
<tr>
<td>Structure</td>
<td>1</td>
</tr>
</tbody></table>
<p>假設這專案的迭代週期為 20 單位時間，開發費時 10 單位時間，每份文件更新需要 1 單位時間。那麼依據不等式，這軟體的文件最多能承受的更新頻率為 10 次。比照更新頻率表，若要避免文件過時，文件的內容最細只能寫到 Class 層級，而 function 層級就超出能力範圍外了。</p>
<p>$$ n &#x3D; \frac{T_{iter} - T_{dev}}{t_{doc}}$$</p>
<p>透過這方法，我們可以根據軟體與團隊的特性，調整文件內容的細緻程度，來配合軟體開發的進度。然而，若文件的抽象程度越高，也意味著犧牲了一定程度的細節。在這種情況下，若仍想保留足夠的細節供往後參考該怎麼做？</p>
<p>原則上，文件內容是否充分取決於當下的品質與隨後的更新。首先，在開發期間透過文件指引、校稿檢查表與同儕審查等方法，可以確保文件具備必要內容並且符合團隊規範；其次，即使發現撰寫當下沒發現的錯誤，之後若能及時修正，也能補充欠缺的資訊。</p>
<p>這意味著文件完整性與更新文件的成本呈負相關。成本愈低，則容許修改文件的頻率也愈高，文件修訂的機會越多，改善其品質的可能性也越大。換句話說，若我們想在有限的時間內，保障文件的內容及時且完整，就需要容許較高的修訂頻率。我們可以考慮改變文件撰寫的媒介或流程，來降低不等式當中的 $t_{doc}$。</p>
<p>不過，將彼此相關的資訊記錄在不同的媒介可能會提升文件間的耦合程度。關聯文件越多，每次修改涉及的文件數也越多，這一方面可能增加忘記更新的機率，另一方面，也會增加每次更新時要盤查的文件數量，從而增加文件更新的成本。目前我尚未對此問題得出結論，不過可以考慮使用修改成本較低的索引文件來串接關聯文件，藉此降低主要文件的更新頻率，又能透過索引文件得知要修改的其他文件。</p>
<p>綜上所述，在專案時程壓力下，團隊往往面臨軟體開發與文件撰寫的衝突。若能再考慮文件應該具備的內容之餘，考量更新文件的頻率和成本，則有機會設計出能配合開發節奏的文件，避免文件過時、錯誤與不全等風險。原則上，若能降低更新文件的成本，便能承受較多次文件更新，間接確保文件的品質與完整性；若更新文件的成本較高，可以考慮調整文件撰寫的尺度，降低更新頻率，以免文件跟不上軟體開發的進度。</p>
]]></content>
  </entry>
  <entry>
    <title>科學溝通能力的重要性</title>
    <url>/the-importance-of-science-communication/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>科學溝通能力究竟有什麼重要性，為何值得投注心力練習？</p>
<p>溝通是學術的一環。科學的進展大抵可以分為「發現新知」和「傳播新知」兩個部分。發覺問題、建立假說，最後設計實驗證明的過程，仰賴研究能力；將新發現以具體而且可信的論證方式傳遞給他人，則仰賴表達能力。</p>
<p>越是非凡的發現，越需要清晰的語言才能充分闡明。因此，除了研究的本領，科學溝通的能力也值得重視。</p>
<span id="more"></span>

<p>在學界內最普及的溝通方式就是撰寫論文，論文不僅是傳達和保留研究成果的媒介，也是評斷個人成就的標準。在論文以外，還有研討會或學者間的非正式交流，讓研究者得以接觸學界前沿的狀況。</p>
<p>除了和他人溝通，研究者在探索問題的途中也得不斷和自己對話，例如撰寫計劃書安排研究進度，或是時時回顧實驗記錄，藉此鞏固概念及引導思考以順利完成研究。</p>
<p>最後，隨著科學的進展，研究成果的影響不會只限於學術圈，而會漸漸擴及社會。然而知識在傳播中可能被誤解，混淆的觀念恐怕扭曲大眾對科研的看法，導致恐慌及失當的決策。這些問題有賴研究者、媒體和社會間有效的溝通才能解決。</p>
<p>換句話說，社會支持著學術圈，學術圈則讓個人有立足空間，個人再反過來影響學界與社會。溝通參與了個人、學術乃至於社會三方面的發展，這也是為什麼值得投入心力在科學溝通能力養成的原因。</p>
]]></content>
      <tags>
        <tag>communication</tag>
      </tags>
  </entry>
  <entry>
    <title>科學論文的結構與撰寫 (Zen of Scientific Writing)</title>
    <url>/the-zen-of-scientific-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>這學期我選修了蔡東湖老師的「科學論文的結構與撰寫」。經過三個月洗禮，雖然研究進度一籌莫展，卻對發表 SCI 論文充滿自信。</p>
<p>我在這篇文章整理了課堂和講義提及的重要原則，但寫作能力其實要在實作中磨練。所以蔡老師建議我們以後閱讀論文，除了科學內涵以外，也要學著提煉文章的結構，收集常用的句型，畢竟：「寫 paper 沒那麼難，你看個五篇就會寫了。」</p>
<p>（科學論文的文章架構和句型模板可以參考廖柏森老師的著作。） </p>
<span id="more"></span>

<h1 id="如何撰寫及發表學術論文"><a href="#如何撰寫及發表學術論文" class="headerlink" title="如何撰寫及發表學術論文"></a>如何撰寫及發表學術論文</h1><p>發表學術論文包含三件事：英文（論文）、科學（學術）和投稿（發表）。</p>
<h2 id="不要讓語言阻撓你的科學"><a href="#不要讓語言阻撓你的科學" class="headerlink" title="不要讓語言阻撓你的科學"></a>不要讓語言阻撓你的科學</h2><ul>
<li>科學家不只要會想、會做還要會寫。重點不是你不會做實驗，你很會做實驗，但不會寫 paper。</li>
<li>語言和科學要分開，我們 focus 在科學，不要被英文困擾。我們要做科學家而不是文學家。</li>
<li>各位一定要相信，自己的英文能力寫兩三篇 SCI paper 足足有餘。</li>
<li>英文的問題，我們 consult English editor。如果要錢，就給他嘛。</li>
</ul>
<h2 id="科學不問對錯，只問合理"><a href="#科學不問對錯，只問合理" class="headerlink" title="科學不問對錯，只問合理"></a>科學不問對錯，只問合理</h2><ul>
<li>科學沒有對或錯，只有合理不合理。所以不要在實驗室追求真理，要追求證據。</li>
<li>拿到 PhD 不代表你有多厲害，那張紙證明的是你的熱情</li>
<li>書是讀越多越厲害，不是讀越久越厲害。</li>
</ul>
<h2 id="投稿是科研的一部份"><a href="#投稿是科研的一部份" class="headerlink" title="投稿是科研的一部份"></a>投稿是科研的一部份</h2><ul>
<li>做研究要有正確的心態，做完實驗朝發表 paper 的方向走。沒發表等於沒做，甚至比沒做更糟糕。想想花了多少時間，死了多少老鼠，辛苦做好久無論如何都要發表。</li>
<li>沒有賣不出去的房子，只有還沒找到的買家和賣多少錢而已。</li>
<li>發表了 research article，代表你對那個領域很熟悉，所以再補一篇 review article。</li>
<li>一邊整理學位論文，一邊準備投稿。你論文都寫出來了，為什麼不寫成 paper？很多事只欠缺堅持。</li>
<li>實驗我做，論文我寫，那沒做的人審什麼？合理性和你的邏輯。</li>
<li>Return 沒有看科學性，要 reject 才有檢視科學。而 revision 是投稿的重頭戲，我們的目標就是朝被接受的方向走，所以感謝 reviewer，在回覆裡面狗腿一下又怎樣。</li>
<li>Paper 被接受不是最高興的，自己的被接受，別人被 reject 更高興。</li>
</ul>
<h1 id="寫作準備"><a href="#寫作準備" class="headerlink" title="寫作準備"></a>寫作準備</h1><blockquote>
<p>Writing is easy. All you do is stare at a blank sheet of paper until drops of blood form on your forehead.（寫作也沒什麼難的，不過是盯著一張白紙直到額頭滲出血來罷了）<br>by Gene Fowler</p>
</blockquote>
<h2 id="挑選期刊"><a href="#挑選期刊" class="headerlink" title="挑選期刊"></a>挑選期刊</h2><ul>
<li>及早決定投稿期刊，及早按照規範寫，省得往後修改的麻煩。</li>
<li>選錯期刊要不被編輯 reject，要不得不到良性回饋，要不接受了卻沒人看。</li>
<li>挑期刊時看看引用過的文獻、查查領域內的排名、找找類似主題的論文。通常，學會期刊是最穩的。</li>
</ul>
<h2 id="不是寫論文，是修改論文"><a href="#不是寫論文，是修改論文" class="headerlink" title="不是寫論文，是修改論文"></a>不是寫論文，是修改論文</h2><ul>
<li>把章節列出來，現在就開始寫，再慢慢修改，一定可以改。</li>
<li>你不可能一口氣寫完一篇論文，一定會改很多次。寫論文修改三十到五十次，稀鬆平常。現在開始寫，改個五十次就一篇 paper 出來，為什麼不寫呢？</li>
<li>每次寫完前要草記接下來你要寫什麼，方便下一次延續你的思路。</li>
</ul>
<h2 id="安排寫作計畫"><a href="#安排寫作計畫" class="headerlink" title="安排寫作計畫"></a>安排寫作計畫</h2><ul>
<li>所謂寫作，就是空出時間寫作。</li>
<li>從何處開始寫都行，至少是個開始。</li>
<li>寫作要設定截止日，留下前置量，管理專注力，維持自律，保持流暢。</li>
<li>只是草稿的文章不要投。然而沒有文章是完美的，盡力修改後就投稿。</li>
</ul>
<h1 id="論文架構"><a href="#論文架構" class="headerlink" title="論文架構"></a>論文架構</h1><blockquote>
<p>All scientists have an unwritten contract with their contemporaries and those whose work will follow to provide observations honestly obtained, recorded, and published. （科學家和當代人與繼承者有個約定，他們將提供正當取得、誠實記錄和嚴謹發表的結果。）<br>CBE Style Manual Committee</p>
</blockquote>
<h2 id="IMRAD-體系"><a href="#IMRAD-體系" class="headerlink" title="IMRAD 體系"></a>IMRAD 體系</h2><p>科學論文遵照 IMRAD 體系，Introduction &#x3D; WHY，Materials and Methods &#x3D; HOW，Results &#x3D; WHAT，Discussion &#x3D; WHAT。</p>
<ul>
<li>WHY：Why did the experiment? What question (problem) was studied?</li>
<li>HOW：How was the problem studied?</li>
<li>WHAT：What were the findings?</li>
<li>WHAT：What do these findings mean?</li>
</ul>
<p>方法與結果成對，簡介與討論配對。簡介要提出問題，討論應回答問題。</p>
<h2 id="論文的類型"><a href="#論文的類型" class="headerlink" title="論文的類型"></a>論文的類型</h2><ul>
<li>科學論文是經同儕審查的論文。不要看人家在大會上報告很威風，會議論文的壽命只有一天，沒有同儕審查都是 non qualified。</li>
<li>但同儕是誰？老師和同學是你的 colleague，不是你的 peer。只有研究相同題目的人才是 peer。</li>
<li>好的科學家會重視研究的整體性，不會把一篇 paper 拆成好幾篇。一篇好的 original article 可以抵五篇 short communication，科學本來就是這麼無情。</li>
<li>什麼都沒有的時候，搬一台電腦到圖書館就可以寫 review paper，所以一定要會寫review。</li>
<li>不知道敵人在哪所以要小心點。會議論文我都亂寫，以免哪天被當重複投稿，要命。</li>
<li>如果你有很厲害的點子，也許能得到諾貝爾獎那種，要盡快用任何形式發表。</li>
<li>筆離開紙就留下版權，你不需要申告，但是需要舉證。</li>
</ul>
<h2 id="撰寫科學論文不是寫小說或散文"><a href="#撰寫科學論文不是寫小說或散文" class="headerlink" title="撰寫科學論文不是寫小說或散文"></a>撰寫科學論文不是寫小說或散文</h2><ul>
<li>自己做的用過去式，別人做的用過去式。所以摘要、結果與方法用過去式，簡介用現在式，討論視情況而定。</li>
<li>科學論文寫得艱澀又冗長就只有一命運，reject。</li>
<li>想要避免抄襲的話，寫筆記要紀錄引用來源，寫論文時別參考文獻。文獻等核對內容的時候才拿出檢查。</li>
</ul>
<h1 id="作者序、標題與摘要"><a href="#作者序、標題與摘要" class="headerlink" title="作者序、標題與摘要"></a>作者序、標題與摘要</h1><h2 id="決定作者序不是小事"><a href="#決定作者序不是小事" class="headerlink" title="決定作者序不是小事"></a>決定作者序不是小事</h2><ul>
<li>作者順序，自己放在第一個，學長姊其次，老師放最後面。研究生無論如何一定要 keep 自己是 first auther。</li>
<li>要怎麼 keep？把文章寫出來，idea 我出的，實驗我做的，paper 我寫的，誰是老大？</li>
<li>不要說沒人會寄信給你，論文作者的地址是辨識身分的途徑。</li>
<li>不要讓無關的人掛名，稀釋你對論文的貢獻；也不要隨便找人掛名，損害自己的名譽。</li>
<li>簽了名，就要負責。</li>
<li>出點子的、給想法的、設計實驗的放作者；執行的、借器材的、諮詢的放致謝。</li>
<li>作者的順序要在做實驗之前就講好，論文發表時也要所有的作者同意，否則朋友可能變敵人。</li>
</ul>
<h2 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h2><ul>
<li>Title should be sexy（標題必須性感），review 才適合寫大題目。</li>
<li>Keyword 可以補充文章沒出現過的字。</li>
<li>要假設你的論文會被不同時代、不同知識背景、不同閱讀媒介的專業讀者閱讀，所以有時效性的不要寫、艱澀難懂的術語不要寫、縮寫不要寫、廢話不要寫。</li>
<li>然後，不要裝可愛。</li>
</ul>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>摘要就是迷你論文，全文的 README (IMRAD)。</li>
<li>摘要獨立於論文，網路檢索往往只看得到摘要，因此要self contained。</li>
<li>不只要學會寫摘要，也要會畫圖，圖畫得好，一副要被人引用的樣子。不過賣得出去就好，管他不漂亮。</li>
<li>標題是標籤，不需要是完整的句子，所以標題用字和字序很重要。</li>
<li>結論可以在標題講一次、摘要講一次、簡介講一次、討論講一次。</li>
<li>沒做的實驗不要寫進摘要。</li>
</ul>
<h1 id="簡介與討論"><a href="#簡介與討論" class="headerlink" title="簡介與討論"></a>簡介與討論</h1><p>方法和結果是死的，Introduction 和 Discussion 才是重頭戲</p>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><ul>
<li><p>Introduction 的目標是 introduce 這篇論文。</p>
</li>
<li><p>撰寫 introduction 的重點在擺放概念的位置，還有提醒讀者「要來了」的轉折詞。</p>
</li>
<li><p>如果你不曾寫過論文，那就寫成漏斗狀：(1) 概述主題，(2) 依照時間順序描述前人的工作，(3) 解釋既有不足和研究問題，(4) 提出假說、研究目的和原創性。</p>
</li>
<li><p>文獻回顧：如果你對主題比 reviewer 還清楚，他還敢給你 reject 嗎？</p>
</li>
<li><p>原創性：如果不確定有沒有人做過，就寫出你找了多少文獻，讓 reviewer 幫你補充。</p>
</li>
<li><p>研究問題：提出的問題要合理要可被理解否則讀者不會有興趣。</p>
</li>
<li><p>研究目的：研究目的其實就是結論。</p>
</li>
</ul>
<h2 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h2><ul>
<li>好的 data 若沒有好的討論也會被退稿。</li>
<li>討論的目的是回答 Introduction 提出的問題，不要節外生枝產生更多困惑。</li>
<li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li>
<li>不要讓讀者讀完了有種「又怎樣」的想法。</li>
<li>討論不理想結果的句型要記住，為討論而討論的內容雖然不切題，但也討論了啊。</li>
<li>要把例外和限制講清楚，不要蒙混過關或睜眼說瞎話。</li>
<li>不要羞於討論結果的理論含意或應用價值，因為那是你的遠見和貢獻。</li>
<li>分清楚 future work（希望）、comming work（即將）和 upcomming work（已經）。</li>
</ul>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul>
<li>作者要為每個結論簡述證據，所以結論不要下得像宇宙那麼大，不然會讓研究被質疑。</li>
<li>實驗沒做過的不要放進結論，也不要過度延伸結果 ，那沒有你的事。</li>
<li>你能做的是在一個地方聚焦事實。</li>
</ul>
<h1 id="方法與結果"><a href="#方法與結果" class="headerlink" title="方法與結果"></a>方法與結果</h1><blockquote>
<p>The greatest invention of the nineteenth century was the invention of the method of invention.（十九世紀最偉大的發明是創造了發明的方法。）<br>A. N. Whitehead</p>
</blockquote>
<h2 id="實驗記錄"><a href="#實驗記錄" class="headerlink" title="實驗記錄"></a>實驗記錄</h2><ul>
<li>做錯做慢都 OK，千萬不能造假。</li>
<li>筆記包含自己寫的內容 (print materials) 和引用的內容 (quoted meterials)。</li>
<li>不要相信人的記憶力。東西還在，記憶猶新，實驗邊做，paper 邊寫。</li>
<li>做研究時的想法要記錄，寫論文時才有底稿和素材。</li>
<li>可重複 (Repeatability) 是同個人使用相同方法和器材得到相同結果 ；可再現 (Reproducibility) 是不同人使用相同方法和不同器材得到相同結果。</li>
<li>實驗記錄要讓自己能重複，論文的方法要讓別人能重現。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>相較於藝術和玄學，科學的價值是可以被重現。所以方法被認為無法重複或重現就會被退稿。</li>
<li>方法可以出現在實驗記錄、論文的簡介和論文的方法中。你要在 Introduction 裡陳述並捍衛自己的實驗設計，在 Materials and Methods 給出細節，讓潛在的競爭對手可以重複。</li>
<li>方法的架構是：大處依照時間順序排列，小處依照方法類型分區，說明採用的方法後簡述原理。</li>
<li>舊方法要引用，新方法要詳述，改良的方法除了引用也要稍微解釋。</li>
<li>不管怎麼樣，以第三人稱描述方法最保險。</li>
<li>石器時代結束了，但石頭一顆也沒少。High tech depends on low tech.</li>
</ul>
<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><ul>
<li>如果方法和討論寫得好，結果應該是最短的 section。</li>
<li>科學論文不精簡，那只會得到一個字，redundancy，也只有一個命運，rejection。</li>
<li>撰寫結果只有三個原則：簡述實驗、呈現數據、時態用過去式。</li>
<li>數據得整理，文、圖、表擇一，方法結果要對應，確保行文一致性。</li>
<li>圖表沒有對錯，只有合適不合適，用在什麼場合。</li>
<li>結果呈現的原則：趨勢畫圖，數據製表，一般撰文。</li>
<li>文、圖、表各自獨立，圖表要 self-contained。</li>
<li>給老闆完整的資料，但給編輯代表性的資訊。</li>
<li>但不要只給老闆數據，你要寫成一個 section paraghragh。因為一旦你的 data 跟其他人做的混在一起，你的貢獻就沒了。</li>
</ul>
<h2 id="引用與致謝"><a href="#引用與致謝" class="headerlink" title="引用與致謝"></a>引用與致謝</h2><ul>
<li>Credit 要給原創者，不是給 review 的人，review 的人沒有做實驗。</li>
<li>Idea 只要不是自己的，一定要引用，寧可多引用給 reviewer 篩選，也不要少東少西。</li>
<li>引用要從優，挑選重要的一手文獻。</li>
<li>如果文獻值得引用，要在文中讓讀者了解原因。</li>
<li>完稿後要確認文內引用和參考文獻一一對應。</li>
<li>致謝跟科學論文沒什麼關係，因為禮貌是文明社會的生活型態。</li>
<li>公開的書面致謝是科學的玩法。</li>
<li>誰幫助你就感謝誰，但別謝過頭，反而損害自己的貢獻。</li>
</ul>
<h1 id="結論：科學論文寫作十訓"><a href="#結論：科學論文寫作十訓" class="headerlink" title="結論：科學論文寫作十訓"></a>結論：科學論文寫作十訓</h1><ol>
<li>不要讓語言阻礙科學。</li>
<li>科學不問對錯，只求合理；實驗室沒有真理，只有證據。</li>
<li>做完實驗一定要發表論文，論文發完發綜述。</li>
<li>科學論文由 WHY、HOW、WHAT、WHAT 組成 (IMRAD)，簡介與討論呼應，方法與結果配對。</li>
<li>寫作時，自己做的用過去式，別人做的用現在式。</li>
<li>Introduction 的目標就是 introduce 這篇論文：概述主題、文獻回顧、提出問題、說明目的。</li>
<li>實驗紀錄要能重複，論文方法要能重現。</li>
<li>撰寫結果只有三個原則：簡述實驗，呈現數據，文圖表擇一。</li>
<li>結果不須解釋意義，討論也非重述結果，Discussion 要探討觀察與事實之間的關係。</li>
<li>引用的榮耀屬於知識創造者，而非知識整理者。</li>
</ol>
]]></content>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Transcribing DNA into RNA (RNA)</title>
    <url>/transcribing-dna-into-rna/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模擬 DNA 轉錄 RNA 的過程，將給定 DNA 字串中的 T 替換為 U。</p>
<blockquote>
<p>Given: A DNA string t having length at most 1000 nt.</p>
<p>Return: The transcribed RNA string of t.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/rna/">https://rosalind.info/problems/rna/</a>)</p>
<span id="more"></span>

<p>此題為字符替換問題，可使用 *str.replace(old, new, max)*，將字串中的 old（舊字符串） 替換為 new（新字符串）。若指定第三個參數 max，還可設定最大替換次數。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transcribe</span>(<span class="params">dna</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Transcribe DNA into RNA</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> dna.replace(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>R 語言與 replace 相應的 function 為 gsub，然而 gsub 可以接受向量，批次替換字符串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dna <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAATTTT&quot;</span><span class="punctuation">)</span></span><br><span class="line">rna <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> replacement <span class="operator">=</span> <span class="string">&quot;U&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span>  dna<span class="punctuation">)</span></span><br><span class="line">print<span class="punctuation">(</span>rna<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>bash 的 tr (transform) 可用於替換、刪除、修改等多種字符操作。此例使用的是其替換功能，參數設定為：$string | tr old new，意指將字串中的 old（舊字符） 替換為 new（新字符）。相較於 R 的 gsub() 和 python 的 replace()，tr 只針對字符的操作（即只能 A→T，不能 AT→CG），若要替換字符串則要使用 sed，其參數設定為：sed “s&#x2F;old&#x2F;new&#x2F;g”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transcribing DNA into RNA using tr</span></span><br><span class="line">dna=<span class="string">&quot;GATGGAACTTGACTACGTAAATT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Translating RNA into protein using sed</span></span><br><span class="line">dna=<span class="string">&quot;GGTGGTGGTGGT&quot;</span></span><br><span class="line">rna=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dna</span>&quot;</span> | <span class="built_in">tr</span> T U)</span><br><span class="line">protein=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$rna</span>&quot;</span> |  sed <span class="string">&quot;s/GGU/G/g&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$protein</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>ROSALIND｜Translating RNA into Protein (PROT)</title>
    <url>/translating-rna-into-protein/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>轉譯RNA字串為蛋白質字串</p>
<blockquote>
<p>Given: An RNA string s corresponding to a strand of mRNA (of length at most 10 kbp).</p>
<p>Return: The protein string encoded by s.</p>
</blockquote>
<p>(<a href="https://rosalind.info/problems/prot/">https://rosalind.info/problems/prot/</a>)</p>
<span id="more"></span>

<h1 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h1><p>mRNA 紀錄了由 DNA 轉錄而來的基因資訊，其上每三個核苷酸會對應到一個胺基酸或終止密碼子。在轉譯時，tRNA 會攜帶對應的胺基酸，以 mRNA 為模板，於核醣體合成蛋白質。</p>
<ul>
<li>genetic code：核苷酸 codon 及其轉譯時對應的胺基酸。</li>
<li>codon：密碼子，解讀遺傳密碼表的單位。mRNA 上每三個核苷酸為一個 codon。由於有 A、U、C、G 四種核苷酸，所以存在 4^3 &#x3D; 64 種 codon，對應著 20 種胺基酸和終止密碼子。</li>
<li>anticodon：即 codon 的互補序列。</li>
<li>start codon：起始密碼子，代表轉譯開始的訊號，會轉譯出 methionine。AUG 是常見的 start codon，但也有其他序列可啟動轉譯。</li>
<li>stop codons：終止密碼子，代表轉譯停止的訊號，不會轉譯出胺基酸。對應的核苷酸序列為 UAA&#x2F;UAG&#x2F;UGA。</li>
</ul>
<h1 id="解題觀念"><a href="#解題觀念" class="headerlink" title="解題觀念"></a>解題觀念</h1><p>轉譯的過程可分解為：構建密碼表、分割 mRNA 序列、查找密碼表、處理終止密碼子。</p>
<ul>
<li>構建密碼表：遺傳密碼需要以特定的資料型態（例如：list、hash table、table 等），儲存的型態會影響翻譯的方式。</li>
<li>分割 mRNA 序列：將 mRNA 切成三個一組的 codon，以逐一查找密碼表。</li>
<li>查找密碼表：逐一查詢 codon 對應的胺基酸，再傳接所有得出的胺基酸。</li>
<li>處理終止密碼子：由於終止密碼子不轉譯胺基酸，所以要移除終止密碼子以後的序列。</li>
</ul>
<h1 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>密碼表可以 dictionary 儲存。python 的 dictionary 由數個 items 組成，每個 item 則包含 key 和 value 兩部分：value 是欲儲存的資訊，其資料型態可為數值、字串、list 甚或其他的 dictionary (nested dictionary)；而 key 則為查找 value 的依據，每個 key 對應一個 value。</p>
<p>dictionary 的特性是item無序性和資料型態可變性，前者意味著 dictionary 的 item 間沒有依照順序排列，因此無法依照索引取值；後者則是指可以透過新增、刪除、取代等操作改變 dictionary 內各 item 的內容。</p>
<p>詳細的 dictionary 介紹可參考<a href="https://selflearningsuccess.com/python-dictionary/">Python字典（dictionary）基礎與16種操作</a>和<a href="https://www.learncodewithmike.com/2019/12/python-dictionary.html">Python Dictionary完全教學一次搞懂</a>。在此題中，主要是應用 dictionary 的 key 和 value 互相查找的特性來儲存密碼表。</p>
<p>首先，依照取值策略，可以兩種方式儲存密碼表。第一種取值策略為正向索引，即透過 key 來查找 value，可以 codon 為 key，胺基酸為 value 儲存，轉譯時每三個字符從 dictionary 取值。在這張密碼表中，終止密碼子對應到空字串，表示它們不會轉譯出任何胺基酸。</p>
<h3 id="Get-values-by-keys"><a href="#Get-values-by-keys" class="headerlink" title="Get values by keys"></a>Get values by keys</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">rna</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Translate a RNA string into a proten string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        rna (str): A RNA string composed of nucleotides (&#x27;U&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;G&#x27;), length must be a multiple of three.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        str: Amino acid sequence derived from the RNA</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    code = &#123;</span><br><span class="line">    <span class="string">&quot;UUU&quot;</span>: <span class="string">&quot;F&quot;</span>, <span class="string">&quot;UUC&quot;</span>: <span class="string">&quot;F&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UUA&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;UUG&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUU&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUC&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUA&quot;</span>: <span class="string">&quot;L&quot;</span>, <span class="string">&quot;CUG&quot;</span>: <span class="string">&quot;L&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AUU&quot;</span>: <span class="string">&quot;I&quot;</span>, <span class="string">&quot;AUC&quot;</span>: <span class="string">&quot;I&quot;</span>, <span class="string">&quot;AUA&quot;</span>: <span class="string">&quot;I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AUG&quot;</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GUU&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUA&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUC&quot;</span>: <span class="string">&quot;V&quot;</span>, <span class="string">&quot;GUG&quot;</span>: <span class="string">&quot;V&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UCU&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCC&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCA&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;UCG&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;AGU&quot;</span>: <span class="string">&quot;S&quot;</span>, <span class="string">&quot;AGC&quot;</span>: <span class="string">&quot;S&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CCU&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCC&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCA&quot;</span>: <span class="string">&quot;P&quot;</span>, <span class="string">&quot;CCG&quot;</span>: <span class="string">&quot;P&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ACU&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACC&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACA&quot;</span>: <span class="string">&quot;T&quot;</span>, <span class="string">&quot;ACG&quot;</span>: <span class="string">&quot;T&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GCU&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCC&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCA&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;GCG&quot;</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UAU&quot;</span>: <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;UAC&quot;</span>: <span class="string">&quot;Y&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CAU&quot;</span>: <span class="string">&quot;H&quot;</span>, <span class="string">&quot;CAC&quot;</span>: <span class="string">&quot;H&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CAA&quot;</span>: <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;CAG&quot;</span>: <span class="string">&quot;Q&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AAU&quot;</span>: <span class="string">&quot;N&quot;</span>, <span class="string">&quot;AAC&quot;</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AAA&quot;</span>: <span class="string">&quot;K&quot;</span>, <span class="string">&quot;AAG&quot;</span>: <span class="string">&quot;K&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GAU&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;GAC&quot;</span>: <span class="string">&quot;D&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GAA&quot;</span>: <span class="string">&quot;E&quot;</span>, <span class="string">&quot;GAG&quot;</span>: <span class="string">&quot;E&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGU&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;UGC&quot;</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGG&quot;</span>: <span class="string">&quot;W&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CGU&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGA&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGC&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;CGG&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;AGA&quot;</span>: <span class="string">&quot;R&quot;</span>, <span class="string">&quot;AGG&quot;</span>: <span class="string">&quot;R&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GGU&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGA&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGC&quot;</span>: <span class="string">&quot;G&quot;</span>, <span class="string">&quot;GGG&quot;</span>: <span class="string">&quot;G&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UGA&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;UAG&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;UAA&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    protein = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> code.get(rna[pos: pos + <span class="number">3</span>], <span class="string">&quot;&quot;</span>):</span><br><span class="line">        protein = protein + code.get(rna[pos: pos + <span class="number">3</span>], <span class="string">&quot;&quot;</span>)</span><br><span class="line">        pos = pos + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> protein</span><br></pre></td></tr></table></figure>

<p>終止密碼子會讓轉譯進度提前結束，為了處理這種情況，我使用 while 來控制迴圈的執行。</p>
<ul>
<li>轉譯到終止密碼子：終止密碼子對應到空字串，於是迴圈停止。</li>
<li>轉譯到RNA尾端：list slicing 在索引值超出範圍時不會報錯，而只會回傳空字串，於是迴圈照樣停止。</li>
</ul>
<p>透過這兩種機制，我就能讓轉譯在碰到終止密碼子或RNA尾端時自然結束。</p>
<h3 id="Get-keys-by-values-in-list-form"><a href="#Get-keys-by-values-in-list-form" class="headerlink" title="Get keys by values (in list form)"></a>Get keys by values (in list form)</h3><p>第二種取值策略則為逆向索引，即透過 value 來查找 key，可以胺基酸為 key，codon 為 value 儲存。由於 value 為 list 形式，無法直接取值，所以定義 function 來判斷 codon 是否位於 value 並回傳對應的 Key：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_val</span>(<span class="params">d, target</span>):</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> val:</span><br><span class="line">            <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure>
<p>而實踐轉譯的方式則是利用 for 依序找出所有 codon 對應的胺基酸，並在每次迴圈延伸已知的蛋白質序列。相較於第一種方式，這方法會用到兩個迴圈，第一個迴圈用以尋找 value，第二個迴圈則用以取出所有 codon 對應的 key。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = &#123;</span><br><span class="line">    <span class="string">&quot;F&quot;</span>: [<span class="string">&quot;UUU&quot;</span>, <span class="string">&quot;UUC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;L&quot;</span>: [<span class="string">&quot;UUA&quot;</span>, <span class="string">&quot;UUG&quot;</span>, <span class="string">&quot;CUU&quot;</span>, <span class="string">&quot;CUC&quot;</span>, <span class="string">&quot;CUA&quot;</span>, <span class="string">&quot;CUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;I&quot;</span>: [<span class="string">&quot;AUU&quot;</span>, <span class="string">&quot;AUC&quot;</span>, <span class="string">&quot;AUA&quot;</span>],</span><br><span class="line">    <span class="string">&quot;M&quot;</span>: [<span class="string">&quot;AUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;V&quot;</span>: [<span class="string">&quot;GUU&quot;</span>, <span class="string">&quot;GUA&quot;</span>, <span class="string">&quot;GUC&quot;</span>, <span class="string">&quot;GUG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: [<span class="string">&quot;UCU&quot;</span>, <span class="string">&quot;UCC&quot;</span>, <span class="string">&quot;UCA&quot;</span>, <span class="string">&quot;UCG&quot;</span>, <span class="string">&quot;AGU&quot;</span>, <span class="string">&quot;AGC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;P&quot;</span>: [<span class="string">&quot;CCU&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CCA&quot;</span>, <span class="string">&quot;CCG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;T&quot;</span>: [<span class="string">&quot;ACU&quot;</span>, <span class="string">&quot;ACC&quot;</span>, <span class="string">&quot;ACA&quot;</span>, <span class="string">&quot;ACG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: [<span class="string">&quot;GCU&quot;</span>, <span class="string">&quot;GCC&quot;</span>, <span class="string">&quot;GCA&quot;</span>, <span class="string">&quot;GCG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;Y&quot;</span>: [<span class="string">&quot;UAU&quot;</span>, <span class="string">&quot;UAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;H&quot;</span>: [<span class="string">&quot;CAU&quot;</span>, <span class="string">&quot;CAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;Q&quot;</span>: [<span class="string">&quot;CAA&quot;</span>, <span class="string">&quot;CAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;N&quot;</span>: [<span class="string">&quot;AAU&quot;</span>, <span class="string">&quot;AAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;K&quot;</span>: [<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;AAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;D&quot;</span>: [<span class="string">&quot;GAU&quot;</span>, <span class="string">&quot;GAC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;E&quot;</span>: [<span class="string">&quot;GAA&quot;</span>, <span class="string">&quot;GAG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;C&quot;</span>: [<span class="string">&quot;UGU&quot;</span>, <span class="string">&quot;UGC&quot;</span>],</span><br><span class="line">    <span class="string">&quot;W&quot;</span>: [<span class="string">&quot;UGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;R&quot;</span>: [<span class="string">&quot;CGU&quot;</span>, <span class="string">&quot;CGA&quot;</span>, <span class="string">&quot;CGC&quot;</span>, <span class="string">&quot;CGG&quot;</span>, <span class="string">&quot;AGA&quot;</span>, <span class="string">&quot;AGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;G&quot;</span>: [<span class="string">&quot;GGU&quot;</span>, <span class="string">&quot;GGA&quot;</span>, <span class="string">&quot;GGC&quot;</span>, <span class="string">&quot;GGG&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&quot;</span> : [<span class="string">&quot;UGA&quot;</span>, <span class="string">&quot;UAG&quot;</span>, <span class="string">&quot;UAA&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">rna, code</span>):</span><br><span class="line">    p = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [s[i:i+<span class="number">3</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">3</span>)]:</span><br><span class="line">        p += find_val(code, i)</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>在 R 中，則可以用 list 儲存密碼表。 list 可以儲存不同類型的資料型態（例如：整數、浮點數、邏輯、向量等），每個儲存的元素皆有其編號，可以透過元素的索引值取值。除了固有的編號，也能於創建 list 時為元素命名，以便使用名稱取值。</p>
<p>在此題中，是利用 list 能同時紀錄內容和其名稱的特性來儲存密碼表。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># extract a element by index</span></span><br><span class="line"><span class="operator">&gt;</span> l <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>l<span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="literal">TRUE</span></span><br><span class="line"><span class="comment"># extract a element by name</span></span><br><span class="line"><span class="operator">&gt;</span> l <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span> <span class="operator">=</span> <span class="string">&quot;dog&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span> <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span> <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> print<span class="punctuation">(</span>l<span class="punctuation">[[</span><span class="string">&quot;A&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;dog&quot;</span></span><br></pre></td></tr></table></figure>

<p>示範數據如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rna <span class="operator">&lt;-</span> <span class="string">&quot;AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA&quot;</span></span><br></pre></td></tr></table></figure>
<p>首先，定義將 mRNA 序列三個一組分為 codon 的副程式。簡言之，以 strsplit 將字串切割為由 list 儲存且長度為三字符的一批短字串[4]，再用 unlist 將之轉換為 vector [5]。 其他寫法可參考 <a href="https://statisticsglobe.com/split-character-string-into-chunks-in-r">Split Character String into Chunks in R (2 Examples)</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chunks <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>s<span class="punctuation">,</span> n<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  unlist<span class="punctuation">(</span>strsplit<span class="punctuation">(</span>s<span class="punctuation">,</span> paste0<span class="punctuation">(</span><span class="string">&quot;(?&lt;=.&#123;&quot;</span><span class="punctuation">,</span> n<span class="punctuation">,</span> <span class="string">&quot;&#125;)&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>接著同樣可依照取值策略循兩種方式儲存密碼表。第一種是正向索引，以 codon 為名，胺基酸為元素，將密碼表存為 list。接著，以 lapply 依序對照密碼表，取出 codon 對應的胺基酸字符，再用 paste0 接合為蛋白質字串。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">code <span class="operator">&lt;-</span>  </span><br><span class="line">  <span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">  <span class="string">&quot;UUU&quot;</span><span class="operator">=</span> <span class="string">&quot;F&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUC&quot;</span><span class="operator">=</span> <span class="string">&quot;F&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UUA&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUG&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUU&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUC&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUA&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUG&quot;</span><span class="operator">=</span> <span class="string">&quot;L&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AUU&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUC&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUA&quot;</span><span class="operator">=</span> <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AUG&quot;</span><span class="operator">=</span> <span class="string">&quot;M&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GUU&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUA&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUC&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUG&quot;</span><span class="operator">=</span> <span class="string">&quot;V&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UCU&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCC&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCA&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCG&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGU&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGC&quot;</span><span class="operator">=</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CCU&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCC&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCA&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCG&quot;</span><span class="operator">=</span> <span class="string">&quot;P&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;ACU&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACC&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACA&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACG&quot;</span><span class="operator">=</span> <span class="string">&quot;T&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GCU&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCC&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCA&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCG&quot;</span><span class="operator">=</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UAU&quot;</span><span class="operator">=</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAC&quot;</span><span class="operator">=</span> <span class="string">&quot;Y&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CAU&quot;</span><span class="operator">=</span> <span class="string">&quot;H&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAC&quot;</span><span class="operator">=</span> <span class="string">&quot;H&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CAA&quot;</span><span class="operator">=</span> <span class="string">&quot;Q&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAG&quot;</span><span class="operator">=</span> <span class="string">&quot;Q&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AAU&quot;</span><span class="operator">=</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAC&quot;</span><span class="operator">=</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;AAA&quot;</span><span class="operator">=</span> <span class="string">&quot;K&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAG&quot;</span><span class="operator">=</span> <span class="string">&quot;K&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GAU&quot;</span><span class="operator">=</span> <span class="string">&quot;D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAC&quot;</span><span class="operator">=</span> <span class="string">&quot;D&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GAA&quot;</span><span class="operator">=</span> <span class="string">&quot;E&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAG&quot;</span><span class="operator">=</span> <span class="string">&quot;E&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGU&quot;</span><span class="operator">=</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UGC&quot;</span><span class="operator">=</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGG&quot;</span><span class="operator">=</span> <span class="string">&quot;W&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;CGU&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGA&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGC&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGG&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGA&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGG&quot;</span><span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;GGU&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGA&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGC&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGG&quot;</span><span class="operator">=</span> <span class="string">&quot;G&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;UGA&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAG&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAA&quot;</span><span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">transl <span class="operator">&lt;-</span> <span class="keyword">function</span> <span class="punctuation">(</span>rna<span class="punctuation">,</span> code<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>paste0<span class="punctuation">(</span>lapply<span class="punctuation">(</span>chunks<span class="punctuation">(</span>rna<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span>code<span class="punctuation">[[</span>x<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>第二種則是逆向索引，以胺基酸為名，codon 為元素，將密碼表存為 list。要注意的是，由於無法以空字符命名，所以這種儲存方法要把終止密碼子命名為其他符號，最後再把終止密碼子的符號從輸出的蛋白質序列中刪除。</p>
<p>簡言之，利用 lapply 遍歷所有 codon，以 grep 判斷 codon 位於 list 何處，藉此取出對應的胺基酸字符，使用 paste0 接合為蛋白質字串。最後以 gsub 配合正則表達式移除終止密碼子的符號及其後的序列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">code <span class="operator">&lt;-</span> </span><br><span class="line">  <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;F&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;L&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UUG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;I&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUA&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;M&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;V&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GUU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GUG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;S&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UCG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;P&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CCG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;T&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ACU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ACG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;A&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GCU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GCG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;Y&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;H&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;Q&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;N&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;K&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;D&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GAU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;E&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GAA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GAG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;C&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UGC&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;W&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;R&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;CGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CGG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;G&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GGU&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;GGG&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;*&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UAA&quot;</span><span class="punctuation">)</span></span><br><span class="line">       <span class="punctuation">)</span></span><br><span class="line">transl <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>rna<span class="punctuation">,</span> code<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  p <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span>lapply<span class="punctuation">(</span>chunks<span class="punctuation">(</span>rna<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span><span class="built_in">names</span><span class="punctuation">(</span>code<span class="punctuation">)</span><span class="punctuation">[</span>grep<span class="punctuation">(</span>x<span class="punctuation">,</span> code<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">)</span><span class="punctuation">,</span> collapse <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">  p <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&quot;\\*.*?$&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span> p<span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>p<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="討論"><a href="#討論" class="headerlink" title="討論"></a>討論</h1><h2 id="Biology-Translation"><a href="#Biology-Translation" class="headerlink" title="Biology: Translation"></a>Biology: Translation</h2><p>遺傳密碼的模式有很多故事可以探討，例如「為什麼遺傳密碼以三個一組為單位？」、「為什麼遺傳密碼與蛋白質非一對一關係？」、「為什麼遺傳密碼中，第三個鹼基比較無專一性？」等問題，這些問題反映了生命演化出遺傳密碼的蛛絲馬跡。這些資訊可參考書籍《生物決定論》或 Koonin &amp; Novozhilov. (2009). Origin and evolution of the genetic code: the universal enigma. IUBMB life, 61(2), 99-111.</p>
<p>而遺傳密碼破譯前，也有許多高明的見解和理論想解釋轉譯的模式，可以參考《創世第八天》。</p>
<h2 id="Python-List-comprehension"><a href="#Python-List-comprehension" class="headerlink" title="Python: List comprehension"></a>Python: List comprehension</h2><p>List comprehension 可簡化程式碼，將 for 迴圈輸出值儲存到 list 中，其結構為：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[expression for item in iterable (if-else statement)]</span><br></pre></td></tr></table></figure>
<ul>
<li>expression：可為運算式或取值</li>
<li>item：Iterable Object 之元素</li>
<li>iterable：Iterable Object</li>
<li>if-else statement：條件判斷，即 item 符合條件才執行 expression</li>
</ul>
<p>以下列出不同類型 expression 的範例：</p>
<p>value extraction</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; l = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line">&gt; o = [l[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(l), <span class="number">2</span>)]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>computation</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; n = [i*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] </span><br><span class="line">&gt; <span class="built_in">print</span> n</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p>computation with if-else statement</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; n = [i*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> i &gt; <span class="number">2</span>] </span><br><span class="line">&gt; <span class="built_in">print</span> n</span><br><span class="line">[<span class="number">9</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>詳細介紹可參考 <a href="https://www.learncodewithmike.com/2020/01/python-comprehension.html">Python Comprehension語法應用教學</a></p>
<h2 id="Python-“”-join-的使用方法"><a href="#Python-“”-join-的使用方法" class="headerlink" title="Python: “”.join() 的使用方法"></a>Python: “”.join() 的使用方法</h2><p>join() 可將 list 內的各元素依照指定分隔符連接為字串，寫法為</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &quot;sep&quot;.join(list)</span></span><br><span class="line">&gt; <span class="built_in">print</span> <span class="string">&quot;,&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">A,B,C</span><br><span class="line">&gt; <span class="built_in">print</span> <span class="string">&quot;_&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">A_B_C</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&quot;</span>.join([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>])</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure>
<h2 id="R-strsplit-如何切割無符號分隔的字串？"><a href="#R-strsplit-如何切割無符號分隔的字串？" class="headerlink" title="R: strsplit 如何切割無符號分隔的字串？"></a>R: strsplit 如何切割無符號分隔的字串？</h2><p>strsplit 可依照指定分隔符將字串切割為一批以 list 儲存的短字串，使用方法為：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># strsplit(s, sep)</span></span><br><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A_B_C_D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;_&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br></pre></td></tr></table></figure>

<p>倘若字串中沒有規律出現的符號（例如：mRNA 序列，”AUCGAUCGA”），可以使用正則表達式的 positive lookbehind 概念來解決。</p>
<p>positive lookbehind 的形式如下，意思是尋找前位字串符合 pattern 的 y。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?&lt;=pattern)y</span><br></pre></td></tr></table></figure>
<p>例如在以下範例中，就是把前位字符為「1」的「A」取代為「B」，而前位字符不符合條件者則不受影響</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> gsub<span class="punctuation">(</span><span class="string">&quot;(?&lt;=1)A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1A2A3A1A2A3A&quot;</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;1B2A3A1B2A3A&quot;</span></span><br></pre></td></tr></table></figure>
<p>在了解 positive lookbehind 的意思之後，即可解釋以下程式碼的運作原理。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;AUCGAUCGA&quot;</span><span class="punctuation">,</span> <span class="string">&quot;(?&lt;=.&#123;3&#125;)&quot;</span><span class="punctuation">,</span> perl <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;AUC&quot;</span> <span class="string">&quot;GAU&quot;</span> <span class="string">&quot;CGA&quot;</span></span><br></pre></td></tr></table></figure>

<p>此處 「(?&lt;&#x3D;.{3})」 的涵義其實是 「(?&lt;&#x3D;.{3})””」，表示「尋找前位為字串長三個字符的空字符」， 換句話說，此程式碼先以 positive lookbehind 表達式取出預計切割位置的空字符「””」，再以 strsplit 將這些空字符當作分隔符，將輸入字串切割為一批短字串。</p>
<h2 id="R-為什麼要以-unlist-處理-strsplit-的輸出結果？"><a href="#R-為什麼要以-unlist-處理-strsplit-的輸出結果？" class="headerlink" title="R: 為什麼要以 unlist 處理 strsplit 的輸出結果？"></a>R: 為什麼要以 unlist 處理 strsplit 的輸出結果？</h2><p>strsplit 原始輸出為 list 形式，所以需要使用 unlist 將之轉換為 vector 以利後續處理</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> unlist<span class="punctuation">(</span>strsplit<span class="punctuation">(</span><span class="string">&quot;A,B,C,D&quot;</span><span class="punctuation">,</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rosalind</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim｜VSCodeVim 常用設定</title>
    <url>/vscode-common-settings-for-vscodevim/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文紀錄一些有助於在 Vscode 使用 vim 的套件與快捷鍵設定。</p>
<span id="more"></span>
<h1 id="除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？"><a href="#除了-Esc，還有哪些鍵適合作為模式切換快捷鍵？" class="headerlink" title="除了 Esc，還有哪些鍵適合作為模式切換快捷鍵？"></a>除了 <code>Esc</code>，還有哪些鍵適合作為模式切換快捷鍵？</h1><p>Vim 被開發出來的時候，<code>Esc</code> 位於現今當代鍵盤 <code>Tab</code> 和 <code>Caps</code> 的位置。如今，<code>Esc</code> 被移到鍵盤左上角，已不若以往方便了。既然 VSCodeVim 支援重新設定快捷鍵，那麼有哪些鍵適合作為模式切換快捷鍵？</p>
<ol>
<li><code>jj</code>：位置很棒，只是打字打到 j 時，會有輕微的停頓感。缺點是編輯中文時，要頻繁切換輸入法。</li>
<li><code>jk</code>：一次按兩顆鍵，但因為可以一起按，沒有連續按鈕的卡頓感，只是同樣要解決換模式前得切換輸入法的問題。</li>
<li><code>Enter</code>*2：剛開始使用 vim 很容易忘記切回 normal 模式，既然中文輸入會頻繁輸入 enter讓文字寫入文件，enter 設定為切換模式的快捷鍵既不會干擾文字輸入也好記。只是碰到換行時會延遲等候第二次按鍵的訊號，有時還挺煩人的。</li>
<li><code>Shift</code> + <code>Enter</code>：雖然要兩個按鈕，但位置其實不錯按，而且不會輸入新列的卡頓感。唯一的缺點是設置稍嫌麻煩。</li>
</ol>
<h2 id="前述三種方法要修改-setting-json"><a href="#前述三種方法要修改-setting-json" class="headerlink" title="前述三種方法要修改 setting.json"></a>前述三種方法要修改 setting.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.insertModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;CR&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CR&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;Esc&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Shift-Enter-的方法要改-keybindings-json"><a href="#Shift-Enter-的方法要改-keybindings-json" class="headerlink" title="Shift + Enter 的方法要改 keybindings.json"></a><code>Shift</code> + <code>Enter</code> 的方法要改 keybindings.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//https://github.com/VSCodeVim/Vim/issues/2584#issuecomment-385561286</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shift+Enter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extension.vim_escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="使用相對列名"><a href="#使用相對列名" class="headerlink" title="使用相對列名"></a>使用相對列名</h1><p>由於 vim 可以為指令添加數字以重複執行，所以為了計算方便，需要設置相對行號，設定方式為：</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，啟動 UI 設定</li>
<li>搜尋 “Line numbers” </li>
<li>由 “on” 改為 “relative”，預設為絕對行號</li>
</ol>
<p>然而，內建方式只能顯示絕對行號或相對行號，若要一併顯示，則要安裝 <em>Double Line Numbers</em> 套件。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>X</code>，開啟擴充套件。</li>
<li>搜尋並安裝 <em>Double Line Numbers</em> </li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，輸入 <code>Double Line Numbers: Relative + Absolute</code></li>
</ol>
<h1 id="怎樣設定快捷鍵"><a href="#怎樣設定快捷鍵" class="headerlink" title="怎樣設定快捷鍵"></a>怎樣設定快捷鍵</h1><p>vscode 和 vim 有些彼此衝突的快捷鍵，例如常用的 <code>Ctrl</code> + <code>F</code> 或 <code>Ctrl</code> +<code>W</code> 等。依照個人習慣，可以選擇 vim 模式要啟用那些快捷鍵</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置來關掉 vim的快捷鍵 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="attr">&quot;vim.handleKeys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-d&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-s&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-w&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-t&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&lt;C-z&gt;&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
這些是我常用的指令。</li>
</ol>
<h1 id="怎樣才不會忘記在切換模式後切為英文輸入法"><a href="#怎樣才不會忘記在切換模式後切為英文輸入法" class="headerlink" title="怎樣才不會忘記在切換模式後切為英文輸入法"></a>怎樣才不會忘記在切換模式後切為英文輸入法</h1><p>由於 Normal mode 僅能以英文輸入法下指令，假如在 Insert mode 以中文輸入法編輯文件，使用預設的 <code>Esc</code> 切換模式後，仍維持中文輸入法，還要將輸入法切回英文，才能下達指令。為了解決這問題有兩個策略：</p>
<h2 id="改變模式切換快捷鍵"><a href="#改變模式切換快捷鍵" class="headerlink" title="改變模式切換快捷鍵"></a>改變模式切換快捷鍵</h2><p>第一種策略是把切換模式的快捷鍵設定為 <code>jj</code>，雖然不見得比較快，但一定能避免中文輸入法讓指令無法執行的問題。由於改用英文字母作為切換快捷鍵，所以在切換模式前一定要更換輸入法，所以能確保切換後一定是英文輸入法</p>
<ol>
<li><code>Shift</code>, then <code>jj</code>，切為 Normal mode</li>
<li><code>i</code>，切為 Insert mode</li>
<li><code>Shift</code>，切為中文輸入法</li>
</ol>
<h2 id="自動切換輸入法"><a href="#自動切換輸入法" class="headerlink" title="自動切換輸入法"></a>自動切換輸入法</h2><p>另一種是呼叫自動切換輸入法的腳本，在切回 normal mode 時自動幫我們切換文字</p>
<ol>
<li>下載 (im.select.exe)[<a href="https://github.com/daipeihust/im-select]">https://github.com/daipeihust/im-select]</a> 放到任何你喜歡的路徑</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VScode 擴充套件命令列</li>
<li>搜尋 “open user settings”，輸入 <code>Enter</code> 開啟 <code>setting.json</code></li>
<li>新增以下設置以啟用輸入法自動切換 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/path/to/im-select.exe -s &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>透過這樣設置，在切回 normal mode 瞬間，就會變成英文輸入法。而進入 insert mode 時，就會回到當初離開時的輸入法。</p>
<h1 id="關閉括號自動補全"><a href="#關閉括號自動補全" class="headerlink" title="關閉括號自動補全"></a>關閉括號自動補全</h1><p>VSCode 內建括號與引號自動補全，然而有時這還挺雞肋的，因為在括號內打完字還要使用方向鍵移到括號外才能繼續打字，若使用 Vim 還得切模式再移動，不管哪種方式都沒省太多功夫。因此，對於一般文本編輯或編輯程式碼的需求而言，似乎可以在 setting.json 添加以下設置來關閉自動補全。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// automatical closing</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingQuotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.autoClosingBrackets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h1 id="調整視窗大小的快捷鍵"><a href="#調整視窗大小的快捷鍵" class="headerlink" title="調整視窗大小的快捷鍵"></a>調整視窗大小的快捷鍵</h1><p>設定快捷鍵，就不用為了調整欄位大小，辛苦地讓游標對齊邊框了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="更新檔案瀏覽側欄"><a href="#更新檔案瀏覽側欄" class="headerlink" title="更新檔案瀏覽側欄"></a>更新檔案瀏覽側欄</h1><p>使用終端或指令新增或刪除檔案不會同步更新在檔案探索側欄，因為重新整理的按鈕太小了，所以我也設定快捷鍵輔助。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put those into keybinding.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f5&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;when&quot;</span><span class="punctuation">:</span><span class="string">&quot;filesExplorerFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="超棒的學習資源和網站"><a href="#超棒的學習資源和網站" class="headerlink" title="超棒的學習資源和網站"></a>超棒的學習資源和網站</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10291847">VsCodeVim 自動在normal mode切回英文輸入法的方法</a></li>
<li><a href="https://www.blog.lasai.com.tw/2020/07/05/vscode-vim-mode/">vscode vim mode</a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode｜無助於開發，但有助於身心的套件</title>
    <url>/vscode-extensions-that-are-do-nothing-but-are-cool/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近調查 VSCode 有哪些能幫助軟體開發的工具時，發現不少有趣的擴充套件，這些套件也許不能提升開發速度，但說不定能為百無聊賴、獨自 coding 的下午增添風格與生氣。</p>
<span id="more"></span>

<h1 id="像駭客一樣寫程式"><a href="#像駭客一樣寫程式" class="headerlink" title="像駭客一樣寫程式"></a>像駭客一樣寫程式</h1><p>首先是能增加打字回饋感並且裝模作樣的套件。</p>
<h2 id="Power-Mode"><a href="#Power-Mode" class="headerlink" title="Power Mode"></a>Power Mode</h2><blockquote>
<p>This is the most necessary and MUST TO plugin EVER. Now I can feel the power of my typing. Recommended to all my friends and colleges. 1000000&#x2F;10</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/hoovercj/vscode-power-mode/7bbc4f68dd46da883b24011ae67516c861d09d1b/images/demo-presets-particles.gif" alt="powermode"></p>
<p>Power Mode 能大幅增加 coding 的回饋感，除了隨著打字噴發的特效與劇烈震動以外，在頁面右上角也會顯示連續打字次數，讓打字除了聽覺與觸覺的回饋感以外，還增加了視覺的激情與火爆。</p>
<p>Power Mode 的設定健全，無論特效的形式、時間、幅度、頻率或觸發條件都可調整。以震動特效為例，若覺得太過干擾，可以透過以下方式關閉，</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟設置</li>
<li>搜尋 “Powermode &gt; Shake: Enabled”</li>
<li>關閉震動特效</li>
</ol>
<h2 id="VSCode-HackerTyper"><a href="#VSCode-HackerTyper" class="headerlink" title="VSCode HackerTyper"></a>VSCode HackerTyper</h2><blockquote>
<p> Writing Code Like a Real Hacker </p>
</blockquote>
<p><a href="https://hackertyper.net/">HackerTyper</a> 是模擬駭客寫程式的網頁。一點開網頁，映入眼簾的即典型的駭客工作環境：黑底綠字的終端畫面、等寬的程式碼字體、閃爍的文字游標等。</p>
<p>在這畫面中，無論敲打哪個按鍵，網頁都會印出虛構的迴圈、變數、判斷，營造出用戶正在快速寫程式的模樣。</p>
<p><img data-src="https://github.com/jevakallio/vscode-hacker-typer/raw/master/docs/hackertyper-video.gif" alt="VSCode HackerTyper 讓你像個駭客一樣 coding"></p>
<p>相較之下，VSCode HackerTyper 可以印出「真正」的程式碼。這款套件能錄製文件編輯行為，再透過用戶每次按鍵撥放來達到網頁版的效果。由於是採用自己的程式碼，所以這項套件也挺適合在現場示範時博其它人一笑的（詳見開發者親自示範如何<a href="https://www.youtube.com/watch?v=ulnC-SDBDKE">像個駭客一樣現場 demo</a>。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟 VSCode 命令列。（接下來指令皆於命令列執行)</li>
<li>輸入 “HackerTyper: Record Macro”，接著開始編輯文件</li>
<li>編輯完文件後，輸入 “HackerTyper: Save Macro” 紀錄並命名</li>
<li>要展示駭客技能時，開啟文件並輸入 “HackerTyper: Play Macro”</li>
</ol>
<p><em>已知 VSCodeVim 與此套件衝突，所以要使用這工具前，得先停用 VSCodeVim 並且重啟視窗</em></p>
<h2 id="Cursor-smooth-setting"><a href="#Cursor-smooth-setting" class="headerlink" title="Cursor smooth setting"></a>Cursor smooth setting</h2><blockquote>
<p>Watching those lines of codes flow like butter along with your cursor is just another satisfying thing to watch for any programmer like the satisfying sounds of their mechanical keyboards. 😌 (Trishiraj)</p>
</blockquote>
<p>除了使用套件，VSCode 也有許多內建設置能調整編輯的視覺效果，其中我覺得最有效提升視覺舒適感的是一系列平滑設定。</p>
<p>好比說啟用 “Cursor Smooth Caret Animation” 之後，VSCode 會在移動過程添加殘影動畫，讓游標在字元與行列間跳動時的移動軌跡更接近肉眼習慣的模式，看起來更為滑順與流暢。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code></li>
<li>搜尋 “smooth”</li>
<li>勾選 “Cursor smooth Caret Animation”</li>
</ol>
<h2 id="hacker-theme"><a href="#hacker-theme" class="headerlink" title="hacker theme"></a>hacker theme</h2><p>有了 Power Mode、HackerTyper、smooth cursor，再加上 VScode 商店許多駭客佈景主題，就能打造一座自嗨小天地，或是秀一回盛大而且浮誇的表演囉。<br><img data-src="https://github.com/thorerik/vscode-hacker-theme/raw/HEAD/media/Code_2020-08-12_01-55-19.png" alt="pro hacker theme"></p>
<h1 id="寫程式時不再孤獨"><a href="#寫程式時不再孤獨" class="headerlink" title="寫程式時不再孤獨"></a>寫程式時不再孤獨</h1><p>接著讓 coding 在鍵盤敲擊聲、鍵盤的觸感與閃爍的游標之外，還增添人造互動的套件。</p>
<h2 id="vscode-pet"><a href="#vscode-pet" class="headerlink" title="vscode-pet"></a>vscode-pet</h2><blockquote>
<p>Coding can be lonely sometimes but these pets always keep me company !! (Aya Lahrech)</p>
</blockquote>
<p>vscode-pets 會在 VSCode 側欄新增寵物窗格，可以在其中添加貓咪、小狗與小雞等寵物。除了看著寵物閒晃以外，也能透過點擊或擲球與他們互動。</p>
<p><img data-src="https://tonybaloney.github.io/vscode-pets/_images/throw-ball.gif" alt="VSCode 小動物會追著丟出的球跑，也會以表情符號回應點擊。"></p>
<p>若覺得預設的背景太單調，可以在設定更換背景</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟設定</li>
<li>搜尋 “vscode-pets.theme”，設定想要的主題</li>
</ol>
<p><img data-src="https://tonybaloney.github.io/vscode-pets/_images/forest.gif" alt="除了森林，還有城堡與海灘背景"></p>
<h2 id="Encourage"><a href="#Encourage" class="headerlink" title="Encourage"></a>Encourage</h2><blockquote>
<p>There are times when writing code is drudgery. In those dark times, bathed in the soft glow of your monitor, engrossed in the rhythmic ticky tacka sound of of your keyboard, a few kind words can make a big difference. And who better to give you those kind words than your partner in crime - your editor. (Haacked)</p>
</blockquote>
<p><img data-src="https://user-images.githubusercontent.com/7860985/79793932-66320380-831f-11ea-8188-fb4a627f670a.gif" alt="Encourage 會在文件儲存時，根據程式碼正確與否給予對應的回饋。"></p>
<p>Encourage 是款文字互動套件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。 ">1</span></a></sup>，會根據文件儲存當下，程式碼是否語法錯誤給予對應的回饋。假如沒有錯誤，則會隨機印出鼓勵的話；反之，則會吐出吐槽或挖苦的句子。</p>
<p>這套件支援自訂語錄，所以可以自行添加喜歡的座右銘、名言或幹話等，</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟設定介面 </li>
<li>搜尋 “Preferences: Open User settings (JSON)”</li>
<li>在大括號內添加以下內容，即可新增自訂語錄： <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [extensions]: Encourages</span></span><br><span class="line"><span class="attr">&quot;encourage.additionalEncouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;Wake the fuck up, Samurai. We have a city to burn 🔥🔥🔥&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Just focus, you are better than them.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Fuck yeah!!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Death to Corpos!!!💀&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Never stop fighting.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;Holy FUCK!!!&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
<li>若只想聽到鼓勵的話，可以用空字串覆蓋預設的挖苦內容。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;encourage.discouragements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>此處我加入了一些 Cyberpunk 2077 的台詞，但你也可以調整成從飲料封膜看到的冷笑話或農民曆頁緣的生活訣竅。</p>
<h2 id="Hotheaded-VS-Code"><a href="#Hotheaded-VS-Code" class="headerlink" title="Hotheaded VS Code"></a>Hotheaded VS Code</h2><blockquote>
<p>love how it kic…, corrects me. (Venipa)</p>
</blockquote>
<p>相較於 Encourage 的文字訊息，Hotheaded VS Code 會在語法出錯時放出嫌棄的語音（而且只有嫌棄，沒有鼓勵）。雖然我個人是比較喜歡鼓勵大於責備啦，但這在業界是種獎勵也說不定。</p>
<p><em>聲線可以參考配音員<a href="https://www.fiverr.com/dalfaria">dalfaria 的網站試聽</a></em></p>
<h1 id="讓人哭笑不得"><a href="#讓人哭笑不得" class="headerlink" title="讓人哭笑不得"></a>讓人哭笑不得</h1><p>最後則是能讓自己的 IDE 與他人很不一樣的主題。此處推薦兩則 VSCode 官方推特也說讚的主題套件<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://twitter.com/code/status/928315998075215873">2</span></a></sup>。</p>
<h2 id="Cage-Icons"><a href="#Cage-Icons" class="headerlink" title="Cage Icons"></a>Cage Icons</h2><blockquote>
<p>With this I’m gonna steal the Declaration of Independence. (Kishore Newton)</p>
</blockquote>
<p>我覺得尼可拉斯凱吉是詮釋「身不由己」最出色的演員，他的表情也是迷因的重要來源。這套件會將原生圖標替換那些常在梗圖裡看到的尼可拉斯凱吉表情。<br><img data-src="https://raw.githubusercontent.com/GabeStep/cage-icons/master/example.png" alt="用膩了 Materials Icon Theme？何不試試 Cage Icons！"></p>
<h2 id="Hot-dog-stand"><a href="#Hot-dog-stand" class="headerlink" title="Hot dog stand"></a>Hot dog stand</h2><blockquote>
<p>This is AMAZING! I can hardly see anymore, recently started using a walking stick. couldn’t recommend more! (Franklin Volcic)</p>
</blockquote>
<p>Hot dog stand 套件復刻了 Win 3.1 史上最糟糕的視覺設計<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/">3</span></a></sup>。套件開發者介紹說，這套主題能在 15 秒內毀了用戶雙眼，但根據 VSCode 推特小編的說法，其實大約只需兩秒鐘……</p>
<p><img data-src="https://raw.githubusercontent.com/SomeKittens/VSC-HDS/master/theme.png" alt="安裝這款主題後，我只堅持了一秒鐘就移除了。"></p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>有時，認真研究點沒意義的事，其實也挺好玩的啊！</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">此處介紹的是 Nicollas R. 承襲 Haacked 所開發的 Encourage 套件，後者的版本目前在 VSCode 1.74.3 的 MarketPlace 已經找不到了。<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://twitter.com/code/status/928315998075215873<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://blog.codinghorror.com/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme/<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜ Failed to parse remote port from server output</title>
    <url>/vscode-remote-ssh-connection-not-working-after-update/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="狀況描述"><a href="#狀況描述" class="headerlink" title="狀況描述"></a>狀況描述</h2><p>原本在 Windows 都能正常用 VSCode Remote SSH 連線伺服器，但一早卻發現連線失敗。當時，VSCode 不斷要求輸入密碼卻無法登入，”OUTPUT” 頁面提示的訊息節錄如下：</p>
<blockquote>
<p>Failed to parse remote port from server output</p>
</blockquote>
<blockquote>
<p>Acquiring lock on &#x2F;home&#x2F;username&#x2F;.vscode-server&#x2F;bin&#x2F;some-hash-code-here&#x2F;vscode-remote-lock.username.some-hash-code-here</p>
</blockquote>
<p><em>版本資訊：windows 21H2, VSCode 1.74.2</em></p>
<span id="more"></span>
<h2 id="原因與解決辦法"><a href="#原因與解決辦法" class="headerlink" title="原因與解決辦法"></a>原因與解決辦法</h2><p>參考 <a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">VSCode remote ssh connection not working</a>，簡言之，VSCode 遠端連線前，需要在伺服器端的 <code>.vscode-server/bin</code> 安裝連線相關的工具並進行一些連線設置。假設伺服器已有這些套件，”OUTPUT” 會提示 <code>Found existing installation at (.vscode-server/bin 的路徑)</code>；若沒有這些套件，則會從官方網站下載與安裝。</p>
<p>若伺服器的套件和配置沒有隨本地 Vscode 更新，便可能因為連線兩端的資訊不相符而無法順利連線，此時可刪除並重新安裝這些工具與配置檔來解決問題。</p>
<ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code>，開啟指令視窗</li>
<li>搜尋並執行 “Remote-SSH: Kill VS Code Server on Host”，刪除 <code>vscode-server</code> 檔案與目錄</li>
<li>選取欲清除既有工具的伺服器</li>
<li>重新連線，VSCode 便會重新安裝相關軟體了</li>
</ol>
<h2 id="檢查方式"><a href="#檢查方式" class="headerlink" title="檢查方式"></a>檢查方式</h2><ol>
<li>開啟 command line 工具，以 <code>ping</code> 確認連線正常</li>
<li>使用 putty 或 mobaXtern 等工具連線伺服器，確認問題出在 VSCode </li>
<li>重新開機、重新安裝 Remote SSH、移除 <code>C:/Users/username/.ssh/Known_host</code> 的內容，確認問題不在本地端</li>
<li>按照前述步驟刪除伺服器內 <code>vscode-server</code> 的內容，重新連線</li>
</ol>
<h2 id="其他可能解法"><a href="#其他可能解法" class="headerlink" title="其他可能解法"></a>其他可能解法</h2><p>若此處提及的方式無法解決問題，可參考以下連結試試看其他人的解法。</p>
<ul>
<li><a href="https://mushding.space/2021/12/22/vscode%20remote-ssh%20%E5%95%8F%E9%A1%8C%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/">首次遠端連線且因為網路問題下載工具受阻</a> </li>
<li><a href="https://www.cnblogs.com/netsa/p/14857577.html">本地與伺服器的 SSH key 因為更新等緣故沒有同步</a></li>
<li><a href="https://stackoverflow.com/questions/64034813/vs-code-remote-ssh-connection-not-working">任何可能與遠端連線配置或安裝的問題</a></li>
<li><a href="https://blog.csdn.net/myWorld001/article/details/119443079">伺服器上的 <code>vscode-server</code> 文件過時</a></li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>IDE 及其擴充套件相當方面，可以免去不少開發環境設置的功夫。畢竟我們不會等到摸熟了 IDE 所有功能及其實踐方式才開始開發，所以功能故障算是讓了解 IDE 機制或潛在設定的好機會。在本文的案例哩，可以關閉自動更新來避免這種狀況發生。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code>，開啟 Settings</li>
<li>搜尋 “update: Mode”</li>
<li>設定為 “manual” 或 “none”</li>
<li>重新啟動 VScode</li>
</ol>
]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode｜常用快捷鍵與個人設置</title>
    <url>/vscode-useful-shortcuts-and-their-settings/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>VSCode 有許多快捷鍵設置，本文記錄一些我覺得挺實用的設置</p>
<span id="more"></span>

<h1 id="開啟個人快捷鍵配置"><a href="#開啟個人快捷鍵配置" class="headerlink" title="開啟個人快捷鍵配置"></a>開啟個人快捷鍵配置</h1><ol>
<li><code>Ctrl</code> + <code>Shift</code> + <code>P</code></li>
<li>搜尋 “Preferences: Open Keyboard Shortcuts (JSON)”</li>
</ol>
<h1 id="調整當前子頁尺寸"><a href="#調整當前子頁尺寸" class="headerlink" title="調整當前子頁尺寸"></a>調整當前子頁尺寸</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+d&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.decreaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+shift+i&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.action.increaseViewSize&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="開啟連結"><a href="#開啟連結" class="headerlink" title="開啟連結"></a>開啟連結</h1><p>設定條件是為了避免快捷鍵彼此衝突，點連結的行為大概只有在編輯 md 檔案時發生，所以才這樣設置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+l&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;editor.action.openLink&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus &amp;&amp; editorLangId == &#x27;markdown&#x27;&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="分頁管理"><a href="#分頁管理" class="headerlink" title="分頁管理"></a>分頁管理</h1><p><code>Alt</code> + <code>[0-9]</code>：切換至指定分頁</p>
<h1 id="刷新側欄檔案目錄"><a href="#刷新側欄檔案目錄" class="headerlink" title="刷新側欄檔案目錄"></a>刷新側欄檔案目錄</h1><p><code>Ctrl</code> + <code>0</code>：開啟檔案目錄，再按一次則聚焦檔案目錄</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+F5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span><span class="string">&quot;workbench.files.action.refreshFilesExplorer&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workbench.explorer.fileView.focus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="游標動畫"><a href="#游標動畫" class="headerlink" title="游標動畫"></a>游標動畫</h1><p>VSCode 有一系列滑順特效動畫，能讓游標移動與視窗滑動的軌跡帶有殘引，看起來更加滑順。我自己覺得彷彿是影片從 720p 改善到 4k 的滑溜溜感。</p>
<ol>
<li><code>Ctrl</code> + <code>,</code></li>
<li>搜尋 “smooth”</li>
<li>勾選 “Cursor smooth Caret Animation”</li>
</ol>
]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>時間機器</title>
    <url>/wells-1895-the-time-machine/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>小說<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Herbert Wells. (1895) The Time Machine，台灣由棉花田文化翻譯出版為《時間機器》　">1</span></a></sup>是以主角朋友的紀錄呈現。開頭場景類似電影《來自地球的人》，是一場舉行在主角家裡的沙龍。當一夥人正熱烈討論著時空本質時，主角現身向他們展示了正在打造的時光機器。不過要到主角衣衫襤褸，渾身是傷地出現在再次造訪的友人面前，讀者才得以讀到由敘事者轉述，主角經歷的未來冒險。</p>
<span id="more"></span>

<p>因為急煞事故，主角被拋出時間機器，來到八十萬年後的世界。雖然與目標的時間區段不符，但本著開拓者的雄心，他決定好好地了解這個世代。主角首先接觸的是身形矮小且細皮嫩肉的埃落依人。埃落依人的外觀不因性別而異，主要以蔬果為食。他們的語言單調而且智慧有限，也未見其有任何生產活動。</p>
<p>望著四處的大樓廢墟和文明遺址，主角推論埃落依人應該是進步到了盡頭的社會產物。隨著社會進步，人類逐漸克服生存威脅與競爭壓力。一旦沒有威脅與競爭，能力與奮鬥便無關個體生存。於是，以往視為重要特質的野心、智慧和力量等在存活下來的族群逐漸廢弛，最終演變為只懂得享樂的埃落依人。</p>
<p>在與埃落依人相處一段時日後，主角對他們的習性益發困惑。首先，既然埃落依人幾乎沒有生存能力，他們究竟從何獲得營生的資源？另外，生性樂觀且無害的埃落依人為何異常地害怕黑暗，也不敢接近各處的井口？</p>
<p>隨著奇異事件接二連三，例如沉重的時光機不翼而飛、在台座上聽到詭異笑聲、夜半瞥見似白狼的生物還有不知通往何處的古井等，主角漸漸意識到，這世界還存在另一批人。這猜想在主角於廢墟直擊一種蒼白枯槁的醜陋生物獲得驗證。</p>
<p>這些族群被稱為摩洛克人。主角推論，埃落依人與摩洛克人源於工業時代資方與勞方的極端分化。在上位的資本家追求雅致，在下位的勞動者掙扎求生；資本家日漸退化，勞動者益發強韌。資方與勞方因階級固化而互不通婚，逐漸形成生殖隔離，最演化為象徵高雅但不事生產的埃落依人，以及醜陋懼光卻身強力壯的摩洛克人。</p>
<p>起初，主角認為埃落依人與摩洛克人仍延續著工業時代資方與勞方的主從關係。然而，當主角進入地底搜索時光機，發現被啃食到一半的人肉，他才瞬間明白埃落依人恐懼的根源。</p>
<p>原來，埃落依人是摩洛克人的牲畜。雖然上位者最初能以資本壓迫勞方，可是隨著勞動者逐漸掌握生產工具和技術，僅存世襲財富而無實業能力的資本家便無法對抗勞動者的反撲。於是勞資的關係反轉，勞動者仍舊像工業時代一樣供應著資本家生活所需的一切，但這種關係無異於飼主對牲畜的餵養。</p>
<p>經歷過這番震驚後，主角還遊歷了三千萬年後太陽能耗盡而衰亡的世界才回到現代。</p>
<p>不過，主角的朋友對於他的冒險多持懷疑態度，再加上主角自己的印象都有些錯亂，口說無憑的奇聞軼事更難以置信了。為證明自己所述，主角再次踏上時光旅行。不過，小說卻在敘事者無期的等待中畫下句點。</p>
<p>我覺得小說中最令人驚嘆的景色是三千萬年後，死寂、淒涼和鬱悶的末日描寫。這段情節或許來自克耳文勳爵的推理。</p>
<p>克耳文勳爵假設地球曾是個熾熱而無法維持生命存在的星球，於是以鐵球冷凝的實驗推論地球約有四千多萬年歷史。隨著地球冷卻，太陽熱能也會因引力塌縮的極限而消退。最終日光燒盡，全球冷凍。</p>
<p>然而，依照我們現在的理解，地球面臨的未來將是相反的景況，太陽將持續膨脹，吞沒太陽系的每顆行星。</p>
<p>另外，威爾斯設定的光機無法回到時光機完工之前的日子。因為時光機會在時間軸上連續移動，若持續回到過去，最終勢必撞上當初打造的時光機，造成時光機毀壞。</p>
<p>雖然推理方式不同，不過這說法和《時間旅人》的 Ronald Mallett 博士的理論巧合地相似。這種說法解釋了為什麼至今我們還沒有看到來自未來的人，畢竟第一部時光機還沒問世。</p>
<p>這設定不禁令人思考，每次時間旅行，穿越時間的幅度會和距離同步嗎？畢竟地球自轉速度越來越慢，若用天來評估時間旅行的長度，很有可能穿越過去後發現自己身在太空吧？</p>
<p>不過，時光機或時光旅行的種種悖論或許不是《時間機器》的主軸。時光機對威爾斯而言，應該比較像當今異世界小說用以交代主角在不同世界穿梭的媒介。</p>
<p>相關的媒介有旅行（例如格列佛遊記）、太空探險、輪迴等，只是威爾斯使用時光機為媒介，將之作為開啟冒險的按鈕，藉此呈現出他所營造的世界。這個世界不一定要能預測未來的矛盾，也可能源於今日荒謬的局面。所謂奇異，只不過是變了樣的現在。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Herbert Wells. (1895) The Time Machine，台灣由棉花田文化翻譯出版為《時間機器》<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
  <entry>
    <title>卡住、沒靈感、寫不出東西怎麼辦？</title>
    <url>/what-to-do-when-you-are-stuck-in-writing/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原本我開啟部落格編輯器是打算寫一篇文章，總結我兩周以來學習降噪演算法的經驗，但回過神來，已經盯著標題與目錄一個鐘頭了。我意識到再這樣下去不是辦法，於是把原先的標題刪除，開始思考「如果寫文章碰到瓶頸，除了躲在桌下哭訴沒有人愛我以外，還能做些什麼？」，在閱讀了網路和實體書籍資源後，我寫了這文章。因此，本文不只是各項建議的彙整，也是這些方法的實踐。  </p>
<span id="more"></span>
<h2 id="寫作瓶頸的成因為何？"><a href="#寫作瓶頸的成因為何？" class="headerlink" title="寫作瓶頸的成因為何？"></a>寫作瓶頸的成因為何？</h2><h3 id="我寫不下去了……"><a href="#我寫不下去了……" class="headerlink" title="我寫不下去了……"></a>我寫不下去了……</h3><p>儘管已經寫了十幾篇文章，每次開啟新文件的時候還是很掙扎，因為我要不是在文章的開頭感到絕望，就是在寫一半的時候覺得快不行了。我試著問論文寫作的老師，當他碰到寫作瓶頸時會怎麼克服，他說：「我在列完大綱後都能順利地寫完論文，所以沒有碰過這種障礙。」  </p>
<p>人類的悲喜和苦惱並不相通，我得靠自己找出解決辦法。  </p>
<h3 id="為什麼會碰到障礙？"><a href="#為什麼會碰到障礙？" class="headerlink" title="為什麼會碰到障礙？"></a>為什麼會碰到障礙？</h3><p>寫文章卡住多半是源於<strong>沒有東西寫（知識問題）和寫不出字來（心態問題）</strong>。在我的寫作經驗裡，大部分的情況都是碰到心態問題。畢竟無論是寫何種題目，至少都有個預設的目標，有目標表示有初步的想法，既然有想法便不至於沒內容可以寫。是以多數的情況是讀穿了參考資料，卻在文件上打兩個字刪三個字，好似永遠也寫不出文章來。  </p>
<h3 id="怎麼辨識寫作瓶頸的成因？"><a href="#怎麼辨識寫作瓶頸的成因？" class="headerlink" title="怎麼辨識寫作瓶頸的成因？"></a>怎麼辨識寫作瓶頸的成因？</h3><p>針對不同原因需要不同的解決辦法，那麼該如何辨識寫作瓶頸的成因呢？Esor Huang（電腦玩物的站長）建議大家口頭陳述想要表達的概念，由於打嘴砲不用負責，所以如果內心有點想法的話幾乎都能講出一些東西來，進而排除是知識問題。  </p>
<p>除了這個方法，我也提供一項判斷的策略：問問現在自己的感覺如何。假如<strong>真的沒東西寫了，那面對空白文件的時候，腦中浮起的應該是困惑</strong>：「什麼是微生物分析？」、「什麼是天文生物學？」、「我什麼都不知道，為什麼我會在這裡」，此時有充分好奇心的同學，應該會自動自發找資料，在資料搜索的過程中為撰寫文章準備。  </p>
<p>然而，<strong>如果是心態問題，打開文件時應該會出現恐懼、焦慮、害怕、猶豫、逃避等情緒</strong>。假如某個人笑著看著文件，卻不時點開社群網站和 Youtube 呵呵笑，即使沒有前述情緒，這個人也碰上了心態問題。  </p>
<h3 id="知識問題和心態問題需要不同的解決策略"><a href="#知識問題和心態問題需要不同的解決策略" class="headerlink" title="知識問題和心態問題需要不同的解決策略"></a>知識問題和心態問題需要不同的解決策略</h3><p>如果是知識問題，唯一的解決辦法就是充實知識，閱讀書籍也好，回顧先前的筆記也好，讓空乏的大腦裝滿寫作的素材克服無東西可寫的困難。如果是心態問題，那麼解決之道便是調整心態，想辦法擠出字來，榨乾自己直到碰上知識問題。我認為寫作一定會碰到障礙，從興起寫作的念頭，我們就開始「不知道寫什麼、閱讀和學習、寫不下去了、調整心態、榨乾自己、不知道寫什麼、……」的循環，既然決定寫文章，就拋開恐懼吧。  </p>
<h2 id="知識問題：該寫什麼？"><a href="#知識問題：該寫什麼？" class="headerlink" title="知識問題：該寫什麼？"></a>知識問題：該寫什麼？</h2><h3 id="成長是寫作與學習的循環"><a href="#成長是寫作與學習的循環" class="headerlink" title="成長是寫作與學習的循環"></a>成長是寫作與學習的循環</h3><p>關於知識問題，紀大偉老師有很棒的建議：<strong>研究所（或成長）是寫作與閱讀的循環。</strong>當寫得殫精竭慮，再也寫不出東西的時候，便該停下筆去學習或去閱讀。不必侷限於文章的主題，相關的專著或文章都可以接觸，既能補充匱乏的知識，也能促進知識間的連結，有助於寫作時有足夠且有趣的內容可以輸出。  </p>
<h3 id="學習不能作為逃避寫作的藉口"><a href="#學習不能作為逃避寫作的藉口" class="headerlink" title="學習不能作為逃避寫作的藉口"></a>學習不能作為逃避寫作的藉口</h3><p>然而<strong>吸收知識不能作為逃避寫作的藉口</strong>。之前寫多樣性分析的簡介文章時，因為總覺得不夠熟悉各項指標，所以遲遲無法下筆。我原本以為這是知識問題，但世上的知識是讀不完的，我的文章也非得涵蓋所有知識，因為對自己知識的不安而裹足不前，這是心理問題。  </p>
<p>擱置手邊的工作去閱讀是為了寫作，而不是為了享受閱讀的過程。如果真的發現要補足的知識讀不完，那麼應該重新審視文章的主題，而不是陷在學習的沼澤裡無法自拔。  </p>
<h3 id="為了寫作而學習，為了學習而寫作"><a href="#為了寫作而學習，為了學習而寫作" class="headerlink" title="為了寫作而學習，為了學習而寫作"></a>為了寫作而學習，為了學習而寫作</h3><p>因此，有效的閱讀要寫筆記。藉由寫筆記留下內容與思考的紀錄，之後撰寫文章便不需要回顧原始資料，還可以累積寫作的素材。例如這篇文章即是我讀了不同來源資料的筆記彙整出來的。  </p>
<h2 id="寫作兼具思考和表達兩種功能"><a href="#寫作兼具思考和表達兩種功能" class="headerlink" title="寫作兼具思考和表達兩種功能"></a>寫作兼具思考和表達兩種功能</h2><h3 id="寫作既是表達的媒介，也是協助思考的工具"><a href="#寫作既是表達的媒介，也是協助思考的工具" class="headerlink" title="寫作既是表達的媒介，也是協助思考的工具"></a>寫作既是表達的媒介，也是協助思考的工具</h3><p>在說明心態問題前得先釐清寫作的兩個功能。首先，寫作是傳達觀念的媒介，亦即寫作是表達的工具。但寫作有另一種身分，寫作是協助思考的方式，或著說，<strong>寫作其實是思考的一部份</strong>。  </p>
<p>因為這兩種功能的差異，所以儘管許多人曾碰到寫文章卡住的問題，仍有些編輯主張沒有寫作瓶頸這回事。因為從寫作即是思考的觀點而言，寫作之於思考有如呼吸之於跑步，跑步覺得有些吃力的時候，不該歸究於呼吸障礙而停止呼吸，應該專注於調整呼吸才對。寫作時亦然，想<strong>不到該寫什麼的時候，不應輕易中止寫作，反而要設法用寫作解決問題。</strong>  </p>
<h3 id="透過寫作思考的好處"><a href="#透過寫作思考的好處" class="headerlink" title="透過寫作思考的好處"></a>透過寫作思考的好處</h3><p>但為什麼寫作能夠協助我們思考並解決寫文章卡住的問題？首先，我們很難不依賴具體的東西把事情想清楚，例如在跟人說話的同時比劃手勢，或是利用紙筆和公式協助數學運算。因此，在寫不出東西的時候更要利用寫作呈現思考的過程，讓大腦主動思考，集中思緒在主題上，以免不同的想法在腦中衝撞，最後只剩下美食、假期和旅遊等無關事物。  </p>
<p>此外，我們的大腦無法一次處理太多事物。寫作留下的紀錄可以讓我們追溯思考的路徑，並依此延伸新想法，繼而組織文章的架構。  </p>
<h3 id="以寫作（思考性寫作）解決寫作（表達性寫作）問題"><a href="#以寫作（思考性寫作）解決寫作（表達性寫作）問題" class="headerlink" title="以寫作（思考性寫作）解決寫作（表達性寫作）問題"></a>以寫作（思考性寫作）解決寫作（表達性寫作）問題</h3><p>綜上所述，<strong>當我們寫文章卡住的時候，其實是用於表達的寫作中止了，但用於思考的寫作應持續進行</strong>，利用自由書寫等方式呈現把所想的內容保留在文字。如此一來，既推進了寫作的進度，也累積了一些文章的素材。  </p>
<p>##完美主義的心態問題</p>
<h3 id="最好是更好的敵人"><a href="#最好是更好的敵人" class="headerlink" title="最好是更好的敵人"></a>最好是更好的敵人</h3><p><strong>完成永遠比完美更重要</strong>，因為任何事都不可能完美，我自己寫作時經常犯完美主義的問題。以我部落格人氣最高的那篇文章為例，那篇就是完美主義的產物。你稍微看一眼可能會感到疑惑：「完美主義？可是那篇用字紊亂而且格式也歪掉了耶？看起來不是很完美啊！」  </p>
<p>沒錯，這就是完美主義的的下場。在撰寫開頭時便字斟句酌，隨後每寫一個字要反覆修改半天，這樣子不僅離完成遙遙無期，還會因為過分在乎細節，反而分不清文章各段的價值，忽略整體的優劣。截止日接近的時候，在匆忙之下也沒有時間充分的修改，最後不得不發布未經潤飾的最新版，而不是理想中的最佳版。  </p>
<h3 id="化解完美主義的心理暗示"><a href="#化解完美主義的心理暗示" class="headerlink" title="化解完美主義的心理暗示"></a>化解完美主義的心理暗示</h3><p>既然完美主義是心理問題，那解決問題的方式就是改變心態，以下是幾個在寫文章前可以提醒自己的事情。  </p>
<ul>
<li><p><strong>其實沒有人在乎你寫了什麼</strong>：我的網站雖然意在吸引那些潛在的同儕或貴人，但其實每天點進來的人真的很少，為了一兩個字或一句話搞些有得沒的實在不值得。</p>
</li>
<li><p><strong>其實也沒有人會好好看文章</strong>：其實我寫完文章的時候都會寄給朋友或老師看，他們未必對內容有興趣，即使有興趣也不會一個字一個字看，所以別太在乎一兩個字的差異。</p>
</li>
<li><p><strong>其實寫文章也沒什麼了不起</strong>：雖然寫了部落格記錄學習歷程，面試還是被嘴沒有實際作為實踐理想，在學校也不會因為多寫了什麼被打高分。所以與其寫得字字珠璣，還不如白話地寫出自己的見解，幫助自己才是寫作的初衷。</p>
</li>
<li><p><strong>其實在乎的事情可能是垃圾</strong>：寫文章不免來回增刪好幾次，要怎麼知道目前寫的那段是不是垃圾？只有寫完初稿才知道。所以不痛快下筆完成文章，有可能就是在垃圾堆裡面反覆撿拾垃圾，還以為自己很用心。</p>
</li>
<li><p><strong>其實沒寫完就是零</strong>：我的電腦裡還躺有好多文稿和寫作計畫，大腦裡也一直浮現新的點子和想法，但是沒寫出來誰也不知道有這些東西。你看，李嚴又帥又強，炸蝦讓人在電視前看了都想吃，結果少了收尾的醬汁還是被小當家打臉。</p>
</li>
</ul>
<p>當然寫這些不代表說寫文章是一文不值，文章累積起來還是很可觀的，只是要調整心態，畢竟寫完才有修改的空間。  </p>
<h3 id="在輕鬆的媒介寫作"><a href="#在輕鬆的媒介寫作" class="headerlink" title="在輕鬆的媒介寫作"></a>在輕鬆的媒介寫作</h3><p>除了心理暗示，也可以<strong>改變寫作的媒介降低完美主義的顧慮</strong>。大家應該有類似的經驗吧，新學期發了新課本，擔心頁面被弄髒不敢翻頁不敢做筆記，但讀二手書的時候怎麼劃記都不心疼。  </p>
<p>寫作也是一樣，當坐在高級辦公室、高級椅子、蘋果電腦、高品質文書編輯軟體前鄭重地打開文件卻寫不出字來時，不妨用隨便的態度看待寫作這件事，用廢紙、新文字文件等看起來很廉價的媒介去寫，寫爛了也不在乎，反而能擺脫完美主義的魔咒。這篇文在用電腦編輯前，即是在印壞的影印紙上擬出來的。  </p>
<p>或是找朋友聊天，即使朋友無法給出回饋，只要他能作為自己的聽眾便有助於克服完美主義的障礙。使用臉書、LINE 或 Instagram 等能記錄文字的通訊軟體聊一聊寫作主題，也順便留下草稿紀錄。我的經驗是，在對方不懂主題的情況下，自己為了裝出一副厲害的樣子便會大放厥詞，反而無意間寫出許多有價值的東西。  </p>
<p>如果沒有朋友，自己在紙上或社群網站開一則小文章自我對話也是不錯的選擇。想想平時在 PTT 或臉書發廢文的時候文思泉湧，但開 word 寫文章卻處處制肘，恐怕是社群平台本來就鼓勵大家發表沒路用的想法，在上頭可以在這種氛圍下擠出字來。  </p>
<h3 id="以截止日督促自己行動"><a href="#以截止日督促自己行動" class="headerlink" title="以截止日督促自己行動"></a>以截止日督促自己行動</h3><p>除了降低期待，設下截止日也是化解完美主義的必要方法。人都很浪漫的，如果沒有截稿日提醒現實的殘酷，也許還會以諾貝爾文學獎為目標慢吞吞地寫文章。藉由設下截稿日，讓自己意識到生存的危機，便不會浪費青春去雕琢一部大作了，從而腳踏實地展開行動。  </p>
<h2 id="工作負擔的心態問題"><a href="#工作負擔的心態問題" class="headerlink" title="工作負擔的心態問題"></a>工作負擔的心態問題</h2><h3 id="因為看不到完成的一天而拖延"><a href="#因為看不到完成的一天而拖延" class="headerlink" title="因為看不到完成的一天而拖延"></a>因為看不到完成的一天而拖延</h3><p>「完蛋，我一定完成不了」這是每個決心萬丈高樓平地起，千里始於足下的熱血男兒起步後的第一個念頭，於是整個人癱在電腦前不斷發呆，看似在網站上尋找解決問題的辦法，其實只是在逃避現實，最終在截止日當天被擊倒。  </p>
<p><strong>解決心理負擔的策略即是減少單次的工作量</strong>，例如權衡標題的廣泛性，縮減議題到可處理的範圍，列大綱和細綱將文章分為獨立的單元，利用每天的空閒時間自由書寫，再用完整的時間整合不同的片段形成段落，最後完成文章。  </p>
<h3 id="多少做一點努力"><a href="#多少做一點努力" class="headerlink" title="多少做一點努力"></a>多少做一點努力</h3><p>即使有很重的心理負擔，也不要全然放棄努力。運動、唱歌、爬山、耍廢都無助於完成文章，東摸西摸也不會加速完成的時間，只有專注於文章才有機會成功。因此在信心被擊倒的時候，得加減做些事情，例如調整大綱、加入新的圖片、改善排版、插入引用等等，在等候勇氣恢復的時候為之後寫作的過程減輕負擔。  </p>
<p>真的寫不出來，也可以先寫點其他的文章。此舉可以保持書寫的慣性和動力，讓大腦處在書寫模式，增加完成的文章的信心也順便磨筆頭。  </p>
<h3 id="安排可行的寫作計畫"><a href="#安排可行的寫作計畫" class="headerlink" title="安排可行的寫作計畫"></a>安排可行的寫作計畫</h3><p>安排寫作計畫的快感跟寫完一篇文章一樣，所以不要安於計畫。但有時仍需要可執行且可維持計畫，我自己的經驗是把文章撰寫分為蒐集資料、紀錄筆記、自由書寫、彙整想法、寫草稿、列大綱、撰寫文章、修改與校正等八個步驟，由於大家都不是專職作家，總會有俗務纏身，所以想要立下「今天要完成這篇文章」這種目標往往會失敗。  </p>
<p>因此，<strong>相較於以目標安排進度，用努力的程度來安排進度會比較適當</strong>，例如今天安排花三小時蒐集資料，如果蒐集不完就算了，用僅存的資料先走一步。如果全部流程走完，一篇文章的內容撐不起標題，那改標題即可，不需節外生枝。畢竟已經用努力來安排進度，每段時間都投注了最大的精力，如果只完成這些內容，那也沒有愧對任何人了，驕傲地把標題改小吧。  </p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>寫文章卡住的時候應釐清是源於知識問題還是源於心態問題。如果是知識問題，需要藉由閱讀和學習充實寫作的素材。如果是心態問題，則要逼自己擠出任何文字，直到腦中沒有任何想法，得重新學習為止。  </p>
<p>寫作既是思考的方式也是表達的方式，儘管寫作（表達）碰上障礙，也不要停止寫作（思考），藉由自由書寫呈現想法，保留思考的途徑和內容，將有助於規劃文章內容。  </p>
<p>完美主義和拖延的心態是完成文章的敵人，因此寫作時要降低期待，列大綱劃分文章為數個單元各個擊破。即使碰到障礙也不要輕言放棄，看書寫筆記、調整排版、繪製配圖和修正錯字等工作都有助於減輕之後的負擔。畢竟<strong>沒有克服絕望的方法，耍廢和講幹話只會讓時間流逝，面對寫作瓶頸只有硬著頭皮闖過去才有機會。</strong>  </p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p>Esor Huang (2016)：<a href="https://www.playpcesor.com/2016/04/lifehack-8.html">[LifeHack 8] 先寫再想，激發靈感潛能的心流筆記法</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2016)： <a href="https://www.playpcesor.com/2016/09/help-you-write-something.html">如何開始一場寫作風暴？編輯給任何人寫不出東西時的建議</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2018)：<a href="https://www.playpcesor.com/2018/04/write-plan.html">不要這樣列寫作計畫，幫你不拖延完成論文、書籍與部落格創作</a>。電腦玩物  </p>
</li>
<li><p>Esor Huang (2019)：<a href="https://www.playpcesor.com/2019/03/write-speed.html">寫作加速法教學，解決寫報告論述文章的截稿壓力與速度瓶頸</a>。電腦玩物  </p>
</li>
<li><p>Mark Levy (2011)：《自由書寫術》。商周出版  </p>
</li>
<li><p>Steve Wallace (2018)：<a href="https://www.editing.tw/blog/progress/%E6%B2%92%E6%9C%89%E3%80%8C%E5%AF%AB%E4%BD%9C%E7%93%B6%E9%A0%B8%E3%80%8D%E9%80%99%E6%AA%94%E4%BA%8B.html">沒有「寫作瓶頸」這檔事</a>。華樂絲學術寫作部落格  </p>
</li>
<li><p>李連江 (2018)：《如何進行學術寫作．在學術界謀生存》。香港中文大學出版社  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E6%9C%9F%E6%9C%AB%E5%A0%B1%E5%91%8A%E8%87%AA%E6%95%91%E6%B3%95-%E5%AF%ABpaper-%E5%AF%AB%E8%AB%96%E6%96%87-%E5%AF%AB%E4%B8%8D%E4%B8%8B%E5%8E%BB%E6%80%8E%E9%BA%BC%E8%BE%A6-add4ebb2c827">便秘：寫paper，寫碩論，卡住怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>紀大偉 (2017)：<a href="https://medium.com/@taweichi/%E5%8E%BB%E9%9A%94%E5%A3%81%E5%81%B7%E8%8F%9C-%E8%AE%80%E6%9B%B8%E5%8D%A1%E4%BD%8F-%E5%AF%AB%E5%AD%97%E5%8D%A1%E4%BD%8F-%E6%80%8E%E9%BA%BC%E8%BE%A6-1f6cf064c324">去隔壁放鬆：讀書卡住、寫字卡住，怎麼辦？</a>。♤研究生青紅燈♤  </p>
</li>
<li><p>英論閣學術論文編修 (2018)：<a href="https://www.enago.tw/academy/%e7%aa%81%e7%a0%b4%e5%af%ab%e4%bd%9c%e7%93%b6%e9%a0%b8%e6%9c%89%e5%85%b7%e9%ab%94%e6%96%b9%e6%b3%95%e7%9a%84%ef%bc%81/">突破寫作瓶頸有具體方法的！</a>  </p>
</li>
<li><p>畢恆達 (2005)：《論文寫作症候群：寫作心理 ．教授為什麼沒告訴我》。學富文化  </p>
</li>
<li><p>彌糧糧 (2012)：<a href="https://paste.plurk.com/show/WypPD1CYUH0MqpNAQ7b8">大家都有寫報告寫心得寫論文寫文章卡稿的經驗吧？</a>。Plurk paste 彌糧糧</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>寫科普又不能當飯吃，為什麼還要寫？</title>
    <url>/why-do-people-write-scientific-articles/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文是 Mitalk 4 講座「科普如何當飯吃？」的聽講心得，陳俊堯老師在演講一開始先回答了這問題，再一一告訴我們，如果無法靠寫科普賺錢營生，那麼從事研究的學生、老師和學者們，到底有什麼理由勞心費神去寫科普文？</p>
<blockquote>
<p>科普如何當飯吃？做夢吧，科普怎麼可能當飯吃。</p>
</blockquote>
<span id="more"></span>

<h2 id="科普不能當飯吃，為什麼還要寫科普？"><a href="#科普不能當飯吃，為什麼還要寫科普？" class="headerlink" title="科普不能當飯吃，為什麼還要寫科普？"></a>科普不能當飯吃，為什麼還要寫科普？</h2><h3 id="即使無法靠科普吃飯，也能藉由撰寫科普成長"><a href="#即使無法靠科普吃飯，也能藉由撰寫科普成長" class="headerlink" title="即使無法靠科普吃飯，也能藉由撰寫科普成長"></a>即使無法靠科普吃飯，也能藉由撰寫科普成長</h3><p>老師提到，他的著作《細菌好朋友》雖然囊括許多獎項，但半年的銷量折算為利潤後僅得兩萬餘元。既然連成功的出版品都無法為作者帶來財富，那研究生為什麼要勞費心力撰寫更冷門的科普文章？</p>
<p>儘管老師提及科普能促進跨領域對話、增進國民素養或支援科學教育，但先不論寫科普的外部效益，書寫本身就是一種有效的學習方式。</p>
<p>很多時候我們不是懂了才開始寫作，而是從蒐集資料、提煉知識和撰寫文章的過程中，逐漸了解想要傳達的事物。具體的文字能協助我們察覺思路不嚴謹之處，而寫作瓶頸則讓我們意識到知識的空缺。因此，即使我們無法憑藉科普營生，也能從撰寫中成長。</p>
<h3 id="研究員也能為自己的愛好發聲"><a href="#研究員也能為自己的愛好發聲" class="headerlink" title="研究員也能為自己的愛好發聲"></a>研究員也能為自己的愛好發聲</h3><p>但是，當今有許多科普網站和知識型 Youtuber 向大眾導讀論文和破解迷思，那麼研究員還有必要跳進來寫科普嗎？若想要自我成長，為什麼不寫在筆記本上就好了？</p>
<p>首先，學術需要政府與社會支持，研究員不能總是期待他人為研究議題發聲。以新視野號任務為例，由於美國政府的漠視，探索冥王星始終不是太空任務的優先目標，即使獲准執行，其預算也接連被削減。</p>
<p>為此，志在研究冥王星的 Alan Stern 只得想盡辦法遊說國會，並發起請願以尋求大眾支持。最終，新視野號任務總算排進了正式的探索行程中。雖然不能把任務的成功完全歸功於科普，但這項案例告訴我們：若研究員能為了自己的好奇心而發聲，嘗試去說服他人，那麼確實有機會將個人的願望推廣為大眾的願望。</p>
<p>在說服大眾方面，科普文章是性價比很高的工具。儘管影視寓教於樂，但研究員恐無暇製作。相較之下，寫作的成本低廉還能傳遞最多資訊。內容確實且題材多樣的文字材料，可作為其他科普媒介發展的基礎，擴張文章的影響力。</p>
<h3 id="不輕易將話語權讓給不懷好意的人"><a href="#不輕易將話語權讓給不懷好意的人" class="headerlink" title="不輕易將話語權讓給不懷好意的人"></a>不輕易將話語權讓給不懷好意的人</h3><p>教育家不是唯一對科普感興趣的人，還有濾水器廠商、智慧設計學家、政客等不懷好意的人也等著扭曲科學事實以支持他們的主張。因此，即使認為教育普羅大眾沒什麼益處，研究員也是較有立場和專業去維護科學的理性客觀價值。</p>
<p>相關案例在同婚公投期間層出不窮。護家盟為了表達反同立場，除了引用爭議性研究以外，還任意曲解其他學者經過長年研究和同儕審查得出的嚴謹結果。即使是研究人員本身，也會受到政治立場影響，做出有瑕疵的研究。</p>
<p>鑒於這些情形，研究員就算不為積極的理由寫作，也有動機為消極的理由發聲，以免研究成果為人利用，最後損及大眾對科學的信任。</p>
<h3 id="科普文章是經驗交流的管道"><a href="#科普文章是經驗交流的管道" class="headerlink" title="科普文章是經驗交流的管道"></a>科普文章是經驗交流的管道</h3><p>最後，撰寫科普也能協力國內的科學教育發展。儘管推動雙語教學的風氣日盛，中文始終是最便捷的語言。但除了有限的翻譯書籍和科普網站，國高中生欠缺可靠的中文資料，架構完整而且內容正確的中文科普文章可以填補這個空缺。</p>
<p>我認為，即使是研究生也能受益於科普寫作。相較於國外林立的論壇，台灣的網路學術經驗交流很封閉，許多技術細節和科研心得埋藏在碩博士論文、實驗室內網或私密社群裡，以至於解決問題的經驗無法共享和傳承。</p>
<p>可是，國外既有成熟的討論區，為何執意要促進我們自己的交流風氣？首先，多數人的中文優於英文，故以中文撰寫文章較能準確表達觀念。再則，即使面對同樣問題，解決辦法與說明方式也因人而異，多元的內容能惠及不同程度和背景的群眾。</p>
<p>是以，撰寫科普文章不僅能彙整思路和鞏固知識，也能保留思考的成果，幫助他人解決困難。由於互助的效益會隨參與人數增加，所以即使費時耗力也值得投資。</p>
<h2 id="那麼該如何撰寫科普文章呢？"><a href="#那麼該如何撰寫科普文章呢？" class="headerlink" title="那麼該如何撰寫科普文章呢？"></a>那麼該如何撰寫科普文章呢？</h2><h3 id="科普、課本和論文的差異在於受眾"><a href="#科普、課本和論文的差異在於受眾" class="headerlink" title="科普、課本和論文的差異在於受眾"></a>科普、課本和論文的差異在於受眾</h3><p>由於科普、課本和論文的目的皆為有效傳達訊息，優良的著作皆具有趣、簡潔和明瞭等特性。然而，三種文體的受眾不一，所以各自側重不同特性。論文的讀者是學者，所以旁徵博引、言簡意賅；課本的讀者是學生，因此體系完整、內容詳盡。</p>
<p>至於科普的讀者，則是任何有興趣的大眾。是以，科普雖然像論文一樣報導新知，卻不能吝於用字；科普也跟課本一樣具有理解新知所需的背景知識，卻不應填塞無關的資訊。除了話不能省和料不能多，科普文章要能製造驚奇以取悅讀者。</p>
<h3 id="撰寫科普的第一步是選定讀者"><a href="#撰寫科普的第一步是選定讀者" class="headerlink" title="撰寫科普的第一步是選定讀者"></a>撰寫科普的第一步是選定讀者</h3><p>讀者的年齡、背景和興趣攸關選材、用字和敘事風格。因此，撰寫科普文章的第一步是選定讀者，接著推測讀者想讀的內容，尋找具有衝擊性的主題。至於該怎麼寫，可以參考老師提出的「派大星貓一拳結構」。</p>
<p>每一篇科普都是一場冒險，文章開頭要建立現實與科學之間的橋樑，吸引讀者踏入作者營造的奇妙世界。例如，想要介紹趨化性 (chemotaxis)，可以從「撲鼻而來的雞排味」寫起，利用與主題相關的生活經驗，讓讀者對內容有具體的概念，也讓他們了解自己與主題的關係。</p>
<p>好的故事需要鋪陳，重要觀念也有其前提，所以破題之後先別切入重點，要交代問題和背景知識。例如經典的回馬槍結構：提問以後，先順應大眾的常識推論，接著點出先前敘述的矛盾，讓讀者在觀念衝突之下，迫不及待想要知道答案。</p>
<p>鋪陳以後迎來故事的高潮，要把想傳達的科學概念清楚明瞭地寫出來。最後則要總結文章，再次連結主題和生活經驗，把讀者送回現實。而更多寫作結構的細節，老師推薦我們讀讀《怎樣談科學》。</p>
<h3 id="撰寫科普的訣竅"><a href="#撰寫科普的訣竅" class="headerlink" title="撰寫科普的訣竅"></a>撰寫科普的訣竅</h3><p>寫作時請留意，科普讀者只是還沒學到相關知識，而不是欠缺理解能力。因此，要簡化內容，但不要藐視讀者（例如對著國小學生用）。</p>
<p>其次，儘管寫作時要交代背景知識，並且陳述推理的過程，但用字仍要力求簡練，以免花俏或冗贅的字眼模糊焦點。老師強調「話不能省」是指邏輯不要跳躍，而不是用繁複的文字困擾讀者。</p>
<p>最後，撰寫文章是學習的過程，所以開始動筆時對主題沒有完整的理解仍可以接受。然而在交付文章之前，要再三確認自己已經搞懂，以免寫出似是而非的奇怪內容。</p>
<h2 id="該如何練習寫科普？"><a href="#該如何練習寫科普？" class="headerlink" title="該如何練習寫科普？"></a>該如何練習寫科普？</h2><h3 id="所謂寫作，就是空出時間寫作"><a href="#所謂寫作，就是空出時間寫作" class="headerlink" title="所謂寫作，就是空出時間寫作"></a>所謂寫作，就是空出時間寫作</h3><p>所謂寫作，就是空出時間寫作。他人整理的訣竅得在練習中實踐，障礙和困難也只有在實作中才能體會。而且，文章完成後才有被閱讀和被修改的機會，因此，老師在建議大家，聽完演講以後趕快找一則論文試試看。</p>
<h3 id="以改寫培養寫作能力"><a href="#以改寫培養寫作能力" class="headerlink" title="以改寫培養寫作能力"></a>以改寫培養寫作能力</h3><p>如果真的不知道怎麼寫，可以從改寫起步。首先熟讀感興趣的論文，再擷取核心觀念以中文重述（若想要省事也可以直接從摘要開始改寫）。</p>
<p>接著，思考想傳達給讀者的訊息，開始移除不必要的內容。例如在介紹飲食跟腸道微生物關係的文章裡，不需要用大半篇幅解釋 PCA ，重點是讓讀者明白吃肉的人吃素的人，腸道裡的微生物有什麼差異。</p>
<p>由於術語、抽象詞和簡稱會造成困惑，所以可以用代稱、範例和比喻等技巧減輕讀者的負擔。例如以下這段截自維基百科的句子便含有許多難解的詞彙：</p>
<blockquote>
<p><strong>枯草桿菌（學名：Bacillus subtilis）</strong>，是<strong>芽孢桿菌屬</strong>的一種細菌，為<strong>革蘭氏陽性</strong>的好氣性菌，普遍存在於土壤及植物體表，在人體亦可發現在腸道內共生的枯草桿菌。型態上的主要特徵是菌體表面生有<strong>鞭毛</strong>，體內形成的<strong>內生孢子</strong>可抵抗惡劣的外在環境而存活。</p>
</blockquote>
<p>可以改寫為：</p>
<blockquote>
<p>人的肚子裡住著一群長條狀的細菌，叫做 Bacillus subtilis ——就叫它 B 細菌吧。 B 細菌身上有條尾巴，所以可以在肚子裡游來游去。</p>
</blockquote>
<p>在改寫版本裡，用「肚子裡住著」來解釋「共生」（比喻），用 B 細菌替代 Bacillus subtilis 減輕讀者對英文的恐懼（代稱）卻不損害本意。最後以游泳為例，說明鞭毛的功能（範例）。此處用尾巴比喻鞭毛可能造成誤解，所以可以補充鞭毛的照片給讀者正確的印象。</p>
<p>改寫後，能用「因為」、「所以」、「但是」等連接詞完善文章的架構，讓讀者了解此段的用意和前後文關係。而且要顧及讀者的注意力和記憶力，適時總結內容或插入圖片以調整閱讀節奏。</p>
<p>綜上所述，透過改寫培養寫作能力的流程就是：閱讀文獻、決定要旨、篩選內容、改寫文句、理清句子關係、安插小結與圖片。接下來就能分享成品給其他人看，再從回饋中改進自己不足之處了。</p>
<h3 id="可以在哪裡寫科普？"><a href="#可以在哪裡寫科普？" class="headerlink" title="可以在哪裡寫科普？"></a>可以在哪裡寫科普？</h3><p>寫文章難，找到讀者更難，讀者願意給意見則難上加難。儘管讀者的回饋可以促使作者成長，但寫作初期不容易找到知音，此時可以投稿科學月刊、泛科學和科普寫作網路平台等媒體，在與編輯來往的過程中學習。（即使被退稿，也能了解自己與已出版著作的差異。）</p>
<p>除此之外，社群網站也是分享文章的管道。許多組織都會利用社群網站傳遞消息，所以作者也能利用臉書或推特宣傳作品。然而社群媒體適合宣傳，卻不適合保存知識。簡言之，這些網站的內部檢索不友善，對搜尋引擎的支援也不佳，所以不易取用裡頭的資訊。</p>
<p>所以，我認為在個人網頁寫作然後用社群網站推廣，是兼顧知識保存和即時交流的好方法（也可以利用 medium 這樣結合寫文和社交的平台）。而這種方式也非新鮮事，因為在軟體工程的圈子裡，透過撰寫技術文章來自我提升已是常態。</p>
<p>當然，寫作除了養成能力以外，也是建立個人知識品牌的手段。想知道在熟練科普寫作以後，要怎麼拓展自己發言的份量，老師推薦我們讀《知識內容寫作課》。</p>
<h3 id="科普不是終點"><a href="#科普不是終點" class="headerlink" title="科普不是終點"></a>科普不是終點</h3><p>演講後，有同學請教老師怎麼避免想要解釋的衝動。的確，為了達到普及的效果，科普不免要犧牲文章的精確性，所以身為作者，有時難以克制更正內容的渴望。然而，溝通的效率不在於作者說了什麼，而在於讀者接收了多少。如果詳實的說明阻礙交流，那麼科普便喪失其意義了。</p>
<p>不過即使有意掌握文章的深度，初學者該怎麼判斷什麼應該寫進文章呢？老師指出，最好的方式就是在讀者的回饋中養成品味，所以再次強調，寫作的訣竅是練習。</p>
<p>更重要的，科普不是終點，科普的目標在於承先啟後。讀者終究要放下科普，拿起課本或期刊論文，踏入嚴肅而且冷漠的科學世界。科普作者的職責是為自己的言論負責，在告訴讀者瑰麗想像的同時，也要說明當前研究的限制。因此，只要留下足夠的參考資訊，讀者就能在往後的學習中，逐漸了解當初作者想方設法要告訴他們的，是科學的哪一面。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>即使無法以科普謀生，也值得為了提升能力、宣揚理念與捍衛自己的研究寫作。科普的特性是寫實、有趣和淺顯，寫作前可鎖定讀者以安排內容深淺和用字風格。科普文章也像故事，需要破題和鋪陳，欲傳達的知識若在故事的高潮細述，有助於讓讀者在讀畢後回味無窮。</p>
<p>行文時要留意，內容簡化不代表裝可愛，用字盡可能周詳而不冗贅，抱著分享而非炫耀的心態。吸引讀者之後，若能保持他們的注意力，移除無關或令人困惑的內容，可以大幅增加文章的可讀性。完成作品後可以投稿或刊登在自己的網站上，利己也利人。</p>
<p>若擔心簡化的內容會誤導讀者，可以用註記或參考資訊補充說明。畢竟科普的目的是引領讀者踏入科學世界，只要留下足夠的延伸資訊，讀者終究能從比喻中習得事實。</p>
]]></content>
      <tags>
        <tag>writing</tag>
      </tags>
  </entry>
  <entry>
    <title>「It&#39;s MyGo!!!!!」太好看了八😭</title>
    <url>/why-should-we-watch-bangdream-its-my-go/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>「It’s MyGo!!!!!」太好看了八😭😭😭，這部和「放學後的昴星團」一樣，是應取代雅量與鄭伯克段於鄢，納入國民義務教育的作品。</p>
<span id="more"></span>
<p>動畫標題的含義是「迷路的孩子」，講述一個樂團解散後，曾經的成員與愛慕虛榮的轉學生在組織新樂團時，發生種種得面對各自過往創傷的故事。</p>
<p>在卡牌動畫裡，沒有什麼爭端是「決鬥」不能解決的；在超級機器人的世界觀，最終的命運往往要靠「合體」來決定；至於在樂團作品，上了台，「音樂」就是對一切的回應。</p>
<p>儘管「It’s MyGo!!!!!」靠音樂的感染力掩飾掉部分生硬的情節轉折。我覺得這部作品仍然可貴的理由在於，編劇並沒有因為主題是迷茫，就為了推動情節而向觀眾許諾一個有解的宇宙。</p>
<p>到了故事尾聲，角色的目標與方向不見得較開始時清晰明朗，反而還有更多不甘、愧疚、困惑與說不清的苦楚。</p>
<p>苦、茫與惑這些字眼從甲骨文保留到當代未曾消失，就像現實中冰會融、雨會下一樣自然，繞了一大圈仍回到原點的事情也屢見不鮮。</p>
<p>然而，如同動畫專輯封面所呈現，角色歷經了這麼多，雖然雨還在下，但他們已曉得撐傘。即使在熱力學主宰的世界裡，「冰塊融化後，還是會有像水一樣留下的東西」，也因為存在摩擦，邁向原點的曲折路上依然能發（不可見）光發熱。</p>
<p>在動畫第十集插曲MV的最後畫面，新成立樂團的五位成員在舞台上的站位，對應著團名的首字母，也象徵著仙后座的形象。找齊仙后座的五顆星，便能在茫茫星河之中，找到指引著方向的北極星。</p>
]]></content>
      <tags>
        <tag>acgn</tag>
      </tags>
  </entry>
  <entry>
    <title>人類存在的意義</title>
    <url>/wilson-2014-the-meaning-of-human-existence/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最早認識 E.O. Wilson 是讀 Stephen Gould 的書，Wilson 作為 Gould 反對的對象存在我的記憶中。隨後，我在小說《螞蟻》裡讀到致敬Wilson 所創造的角色—— 艾德蒙．威爾斯，才逐漸了解 Wilson 在螞蟻、演化和生物多樣性方面的成就。</p>
<p>而想讀這本書的動機，則是寫故事時對於意義的追求，想了解不同思想家怎麼回答人類從何而來，該往何處去等問題。不過讀完以後意識到，這本書試圖解釋的不是個人的存在焦慮，也沒有為人類這樣短暫存在的物種是否有意義給上結論。</p>
<p>這本書做到的，是解釋道德、愛、心等被視為人類存在重要價值怎麼演化出來。Wilson 推廣其多層次擇汰學說，主張那些人類之所以為人類的特質，是群體選擇與個體選擇的結果。（這讓我挺好奇的，就我理解 Wilson 的社會生物學應該也是基於親緣選擇學說，但在此書中，他的立場卻反駁親緣選擇學說。這也許要多讀一點演化學說的發展，以及 Wilson 近年的著作才會知道為什麼。）</p>
<span id="more"></span>

<h1 id="我們存在的理由"><a href="#我們存在的理由" class="headerlink" title="我們存在的理由"></a>我們存在的理由</h1><h2 id="意義的「意義」"><a href="#意義的「意義」" class="headerlink" title="意義的「意義」"></a>意義的「意義」</h2><p>《人類存在的意義》探討人類存在於世間的理由與地位，認為應結合人文與科學共同思索這個問題。</p>
<p>卷初作者便釐清意義的兩種含意：事物之所以發生的遠因與近因。近因帶有目的，例如蜘蛛結網捕蟲，蜘蛛網存在的意義就是為了獵食求生，或說神創論者相信人類是造物主規劃下的產物，人類生存的意義便是達成被賦予使命或任務。至於遠因則無關意向和動機，是事情發展至現況所經歷的一切偶然與歷史因素，沒有任何規劃與目的。</p>
<p>探究近因能理解事情怎麼發生，而探究遠因則能明白事情為什麼會如此。由於生物技術和優生學發展，人類已經能逐步跨出遠因的支配，依照目的性規畫自己演化的途徑，但究竟我們該翻修自己到何種程度？面對這樣的道德困境，此書著墨於人類存在的遠因——亦即人類的祖先是怎麼經歷一連串的累積而成為我們，繼而探討當我們理解這種意義後又該怎麼考量自己的處境，明瞭未來的方向。</p>
<h2 id="解開人類之謎"><a href="#解開人類之謎" class="headerlink" title="解開人類之謎"></a>解開人類之謎</h2><p>文明社會是人類的重要屬性，其發源於真社會性（eusociality），已知的人類外的真社會性生物僅出現在昆蟲、某些海生甲殼綱動物和生活在地下的齧齒類動物，並不超過三十種。儘管經歷數次物種爆發，真社會性一直要到近兩億年才出現，儘管如此，真社會性替生物帶來非常大的利益。不過發展真社會性需要在演化過程中出現一連串改變，首先建立巢穴，然後以此為據點覓食哺育，成員分工合作最終形成真社會性的群體，因此儘管能帶來許多好處，仍然很晚近才發展出來。</p>
<p>人類的真社會性可能源於飲食習慣改變為肉食，因此要更嚴謹的分工合作，繼而設立營地，因為合作與競爭發展人際關係，交流中凸顯心智的重要性，因此逐步演化出心智能力。</p>
<p>而解釋演化趨力的學說主流學說有兩種：「親緣選擇 （kin selection）」以及「總括生殖成就（inclusibe fitness）或是整體適存度」。前者認為個體互助源於基因相似，能從利他行為獲利，最終發展出社會行為；後者則是只要行為能確保最大基因流傳，則群體就可能發展出社會行為。然而作者主張的多層次擇汰（multilevel selection），認為自然選擇發生在個體在群體內的競爭（個體擇汰）以及群體和群體間的競爭（群體擇汰），因此人類不僅會對群體有認同感，也極其關注群體內的是是非非。</p>
<h2 id="演化與我們內在的衝突"><a href="#演化與我們內在的衝突" class="headerlink" title="演化與我們內在的衝突"></a>演化與我們內在的衝突</h2><p>人類的善與惡即是利他與利己的衝突，這種矛盾特徵源於基因的個體選擇和群體選擇。僅影響個體的不利基因會在群體內或群體外的人際關係中被汰除，而會影響群體（即個體互動）的基因，則會在群體與群體互動中汰除，因為無法合作協調的群體難以對抗較團結的群體。人類的利己基因能讓個體在群體內競爭中勝出，於是團體逐漸變成自私的團體，然而自私的團體在群體間競爭卻無法對抗因帶有利他基因而合作的團體。個體擇汰篩選出利己基因，群體擇汰篩選出利他基因，兩者會在演化過程中拉扯游移。</p>
<p>「個體擇汰」（個體和同一群體內的其他個體競爭）和和「群體擇汰」（群體與其他群體競爭）這兩種力量之間發生了衝突。後者會使同一群體的所有成員懷抱利他精神，相互合作，並產生道德意識、良知與榮譽感。簡而言之，這兩股力量之間的中途在於：在同一個群體內，自私的個體會擊敗具有利他精神的個體，但由利他主義者所組成的群體，會擊敗由自私的個體所組成的群體。說得更簡單一些：個體擇汰會助長邪惡，群體擇汰則會增強美德。</p>
<p>史前時期這段「多層次擇汰」的演化過程，使得人類的心中永遠充滿了矛盾與衝突，不時在這兩股極端的演化力量之間游移。我們不可能完全屈服於其中任何一種力量，因為它們都不是解決我們的社會與政治問題的理想方式。如果我們完全聽任「個體擇汰」的本能趨使，則整個社會終將瓦解。反過來說，我們如果完全臣服於「群體擇汰」的趨力，則會變成天使一般的機器人，如同一群特大號的螞蟻。（page 49）</p>
<h1 id="知識的統合"><a href="#知識的統合" class="headerlink" title="知識的統合"></a>知識的統合</h1><h2 id="新啟蒙時代"><a href="#新啟蒙時代" class="headerlink" title="新啟蒙時代"></a>新啟蒙時代</h2><p>雖然意在強調整合人文與科學以探索人類之所以為人類的理由，但作者卻以大量篇幅敘述人文學科的侷限，列舉科學進展飛速試圖證明科學已經到了可以解決問題的時候。</p>
<h2 id="人文學科的重要"><a href="#人文學科的重要" class="headerlink" title="人文學科的重要"></a>人文學科的重要</h2><p>儘管作者認為人文學科難以解釋人類的意義，但是能從倫理學的角度解決科技進步的衝擊。作者提及的道德危機是「人類是否應為了避免疾病或培養特質而編輯自己的基因」，作者支持存在保守主義（existential conservatism）主張人的生物特性是一項神聖的資產，有義務要加以保存。另外科技能被科技取代，且在傳播中會逐漸均質；但文化多樣性是獨一無二，它的演進越來越複雜越來越獨特，人文學科的第二個價值就在於它保留了人類之所以為人的特質。</p>
<p>總言之，作者認為人文學科不能解決我們的疑問，但它一方面作為解決道德抉擇的利器，一方面作為標本保留了文化發展獨一無二的一面。</p>
<h2 id="社會演化的驅力"><a href="#社會演化的驅力" class="headerlink" title="社會演化的驅力"></a>社會演化的驅力</h2><p>本章節敘述總括生殖理論和多層次擇汰的內涵，並提出前者的反證。總括生殖理論的核心觀點可以用漢彌爾頓的不等式（Hamilton inequality）表達：</p>
<blockquote>
<p>某個利他行為所造福的對象，如果他所繁衍的後代數量，超過那位利他者因該利他行為而損失的後代數量，則表現這個利他行為的基因就會增加。然而，唯有在利他者和他所造福的對象彼此的親緣關係很近的情況之下，利他者才能從自己的利他行為中受惠。至於兩者親緣接近的程度，則視他們共同擁有的基因的比例而定：兄弟姊妹是四分之一，堂（表）兄弟姊妹是八分之一，依此類推。親緣關係愈遠，比例愈低，而且下降得很快。這樣的過程後來稱為『親緣選擇』（kin selection）。(p.87)</p>
</blockquote>
<blockquote>
<p>……他（漢彌爾頓）認為，生活在群體中的個體會與群體中的其他成員互動。在這個過程中，牠和每一個與牠有互動關係的成員都共同參與了「親緣選擇」。這些行為的總和對牠能傳給下一代的基因數量的影響，便是牠的總括生殖成就，也就是將這些行為的好處與成本統統加起來，再用牠和每一個成員之間的親緣等級來打折所得出的數字。依照「總括生殖成就理論」，擇汰的單位在不知不覺間從『基因』變成了『個體』。(p.89)</p>
</blockquote>
<p>而作者反對的理由有：</p>
<ul>
<li>過於抽象，脫離實際觀察結果。</li>
<li>僅觀察少數現象做出結論，忽略生態學、譜系學、神經生物學等領域。</li>
<li>錯將選擇單位界定為個體。</li>
<li>行為的效應不一定可以加總。</li>
</ul>
<h1 id="人類之外的世界"><a href="#人類之外的世界" class="headerlink" title="人類之外的世界"></a>人類之外的世界</h1><p>（前兩節略過，閱讀無收穫）</p>
<h2 id="外星人的模樣"><a href="#外星人的模樣" class="headerlink" title="外星人的模樣"></a>外星人的模樣</h2><p>作者依據地球生物學知識推論能發展出文明的外星人是什麼模樣。</p>
<ul>
<li>陸生：文明發展的基礎是能源，需要乾燥的環境生火或應用其他能源。</li>
<li>體型大：智慧需要記憶體，而記憶體大小受限於空間大小。</li>
<li>視覺與聽覺溝通：化學物質的擴散太慢，不利於迅速溝通，因此文明生物需以光或波動傳訊。</li>
<li>觸手：任何可以製作工具的構造。</li>
<li>道德：由於群體擇汰和個體擇汰作用，很可能在外星趨同演化出道德觀念。</li>
<li>社會性：能夠合作和促使競爭，讓團體本身和其中成員具有演化優勢。</li>
</ul>
<h2 id="生物多樣性的崩壞"><a href="#生物多樣性的崩壞" class="headerlink" title="生物多樣性的崩壞"></a>生物多樣性的崩壞</h2><p>分類學的價值在於</p>
<ul>
<li>分類學家本身就是該生物的專家，是生物學知識的源頭。</li>
<li>生態學或其他學說需要以來自分類學的研究作為基礎，否則可能會發生誤判關鍵物種等錯誤，導致錯誤的生態改良。</li>
<li>發掘新物種可以擴充基因改良工具，促進生物學發展。</li>
</ul>
<h1 id="心靈的幻象"><a href="#心靈的幻象" class="headerlink" title="心靈的幻象"></a>心靈的幻象</h1><p>作者說明人性是源於「人類的心智發展過程中，得自遺傳的一些規律行為，而這些行為又使得人類的文化朝特定的方向發展，因此它是人腦中基因與文化的連結。」（p176），並舉出人們對居住地的偏好為證，還沒有居住地偏見的兒童天性愛好稀樹草原這種人類發源地的環境（African savanna hypothesis）。這些個性來自基因裡頭的預備學習（prepared learning），預備學習而來的行為因人而異，而學習傾向的多樣性在演化擇汰保留下來，導致族群普世的內在價值觀。</p>
<h1 id="補充心得"><a href="#補充心得" class="headerlink" title="補充心得"></a>補充心得</h1><p>我後來在《做哲學》這本書讀到蠻貼切的說法：威爾森確實為人類的信念和行為提供了一種生物學解釋，不過，了解人類「是」怎樣的存在，還不足以答覆人類「該」如何存在。</p>
<p>「我們從哪來？」尋找的是解釋，「我們要走向何方？」追求的則是規範。解釋擷取遺傳、社會和心理等學科的知識來釐清過去；而規範則寄託了人們的渴望、期許與畏懼來展望未來，它受限於過去，但不必與過去一致。這本書提供了解釋，也暗示遵循解釋的規範。然而，是否認同這樣的價值觀還是讀者的功課了。</p>
<h1 id="摘錄"><a href="#摘錄" class="headerlink" title="摘錄"></a>摘錄</h1><ul>
<li>人類的存在或許比我們所想像的更加簡單。沒有既定的宿命，沒有深邃難解的生命奧秘，也沒有競相要我們宣示效忠的魔鬼與神祇。我們只不過是靠著自己的努力適應環境，因而得以在這個生物世界中存活的一個獨特物種，獨立而脆弱。若欲永續存活，我們就必須敢於突破現今仍存在於社會（包括那些已經極為民主的社會）的制約，秉持獨立思考的精神與理性，好好地認識我們自己。(page 42)</li>
<li>「人類的所有煩惱皆起因於我們不知道自己是什麼，對於我們想要成為什麼，也沒有一致的看法」(Jean Bruller&#x2F;Vercors You Shall Know Them, page 166)</li>
<li>宗教在凡夫俗子的眼中是真的，在智者的眼中是假的，在統治者的眼中則是有用的。(小塞內卡, page 188)</li>
</ul>
]]></content>
      <tags>
        <tag>evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>凝視太陽 — 學習面對死亡也是學習自由</title>
    <url>/yalom-2008-staring-at-the-sun/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自我意識是人類最珍貴的特質，但伴隨著思考能力而來的，卻是對消亡的恐懼。雖然嬰兒在出生時沒有被灌輸死亡的觀念，但從季節更迭、花開花謝和親人離世等跡象中，他們也會留意到，有些東西會因某個原因「永遠消失」。</p>
<p>隨著成長，不祥的事例逐漸累積心中。儘管一開始可能無法理解，但從大人的反應，孩童也知道這些現象不會是好事情。一旦他們意識到自己終將面臨相同的命運，孩童的生活便蒙上了死亡的陰影。</p>
<span id="more"></span>

<h1 id="凡人的傷痛"><a href="#凡人的傷痛" class="headerlink" title="凡人的傷痛"></a>凡人的傷痛</h1><p>面對兒女萌生的死亡焦慮，父母往往把孩童的注意力轉移到奇幻故事、宗教寓言或是遙遠的未來，試圖脫離這個不吉利的話題。然而這些舉動雖然能讓孩童暫時淡忘，卻沒辦法把死亡逐出他們的腦海。死亡焦慮在青少年時期會沒入潛意識中悄悄作祟，使人們做出瘋狂的舉止以在行動中證明自己的存在。</p>
<p>不過，輕狂的歲月是短暫的。隨著出社會，人們將面臨社會壓力和成家立業的負擔，忙碌取代幼年的敷衍想像和青年的瘋狂舉止，掩蓋我們對於死亡的恐懼。</p>
<p>不過等到退休賦閒且兒女離家時，自己也年過半百。此時，我們再沒有能擺脫死亡的手段，只能直視它步步逼近。</p>
<h1 id="辨識死亡焦慮"><a href="#辨識死亡焦慮" class="headerlink" title="辨識死亡焦慮"></a>辨識死亡焦慮</h1><h2 id="死亡焦慮確實存在"><a href="#死亡焦慮確實存在" class="headerlink" title="死亡焦慮確實存在"></a>死亡焦慮確實存在</h2><p>受到佛洛伊德去死亡化的精神分析模式影響，死亡焦慮往往被視為其它種焦慮的替身。然而作者歐文．亞隆認為，死亡焦慮確實存在，只是因為隱匿得難以察覺，才會和其他焦慮混淆。</p>
<p>在死亡的陰影中，人們難以享受當下的愉快。細查那些沒來由的焦慮，很可能追溯到個體對死亡的不安，如果心理治療師沒辦法辨識恐懼的根源是什麼，便無法有效改善諮商對象的狀況。</p>
<p>所以這本書將從鑑別死亡焦慮開始，討論我們恐懼死亡的緣由，接著引用賢哲的智慧和作者的經歷，指出死亡不足懼的原因。最後提出正視死亡並緩解焦慮的可行手段，以幫助讀者度過充實的人生。</p>
<h2 id="死亡焦慮的形式"><a href="#死亡焦慮的形式" class="headerlink" title="死亡焦慮的形式"></a>死亡焦慮的形式</h2><p>如前所述，死亡焦慮可能偽裝成不同形式。有的人陷入購物瘋狂，有的人則在晚年迷上化妝，有的人擔心自己的事業會一夕間崩解，在這些案例裡，造成焦慮的行為實際上是諮商對象擺脫死亡陰影的途徑。</p>
<p>例如過分在意外表而一再補上濃妝的人，或許不是求偶焦慮，而是擔心在鏡面上顯露老態，讓自己意識到死亡的逼近。而對事業的擔憂，也是因為事業反映了諮商對象的存在價值，如果寄託的事物瓦解，那麼自己也不得不面對消亡的事實。</p>
<p>另外有些人在年紀輕時不願去同學會，但在年老時又樂於出席社交場合。因為這樣的場合讓他們想起年輕歲月，在交流中彷彿又能重新擁有對於刺激生活的夢想與期待。</p>
<h2 id="死亡焦慮怎麼現身？"><a href="#死亡焦慮怎麼現身？" class="headerlink" title="死亡焦慮怎麼現身？"></a>死亡焦慮怎麼現身？</h2><p>死亡焦慮之所以隱晦，是因為日夜笙歌的假象和案牘勞形的無暇都能讓我們暫時把注意力移到求生。然而我們賴以維持理智的人事物也有其壽命，不可能永遠隔開我們與死亡。</p>
<p>以父母過世為例，我們的痛苦不只是因為離別的哀傷，也是因為再也沒有人能擋在我們與死亡之間，我們得獨自面對死亡的憂鬱。</p>
<p>除了保護者離世讓人意識到自己的死亡，其他威脅到生命、意識到沒有明天、感受時間流逝、體會到老化、察覺到傾頹等人事物也會讓死亡焦慮現身。</p>
<p>雖然死亡焦慮是令人不安的經驗，可是一旦現身，便是我們嘗試面對與疏解的機會。</p>
<h1 id="為什麼害怕死亡？"><a href="#為什麼害怕死亡？" class="headerlink" title="為什麼害怕死亡？"></a>為什麼害怕死亡？</h1><h2 id="死亡：我們害怕自己對死亡的想像"><a href="#死亡：我們害怕自己對死亡的想像" class="headerlink" title="死亡：我們害怕自己對死亡的想像"></a>死亡：我們害怕自己對死亡的想像</h2><p>有些人害怕的是死亡本身和死後的痛苦。相信神的人擔憂最終的審判，不相信神的則害怕亡故後永遠困在不可知的黑暗。這些害怕是源於我們對死亡的想像，因此作者認為需要在觀念上轉變解決。</p>
<p>伊比鳩魯認為死亡是阻礙享樂的主因，也是痛苦的根源。他提出三項克服死亡恐懼的觀念：首先，靈魂將滅，所以不需要害怕死後迎來的懲罰和審判。其次，自我在死亡那剎即消失，我們根本意識不到死亡，也不必憂慮屆時是否懊悔、是否孤獨與寂寞。最後，生死對稱，死後如同出生前，不必抱著特別或驚恐的眼光看待。</p>
<p>換句話說，我們必須理解到死亡和死後本身不可懼，因為那時已經沒有我們的事了。</p>
<h2 id="無意義：害怕死亡讓一切喪失意義"><a href="#無意義：害怕死亡讓一切喪失意義" class="headerlink" title="無意義：害怕死亡讓一切喪失意義"></a>無意義：害怕死亡讓一切喪失意義</h2><p>然而理解死亡本身不可懼，不代表能抵禦死亡為世間一切帶來的無意義感。可曾有過一種顫慄經驗？也就是在面對廣袤無垠的宇宙，感受到自己的渺小，繼而對存在的意義起了懷疑。</p>
<p>然而意義實際上與尺度無關，也與其存在的時間無關。事物之所以有意義是因為它們令人驚艷，而不是它們很顯眼或是能否在往後重現。</p>
<p>作者引用佛洛伊德的論述，解釋美不會因其終將消逝而失去價值，重點在於美在當下帶來的感受。我們存在的意義也是一樣，和肉體或靈魂是否永垂不朽無關，只要曾激起他人心中的波瀾，曾惠澤家人朋友乃至不相識的人，我們在世界的一切便有其意義。</p>
<h2 id="孤獨：害怕死亡帶來的終極隔絕"><a href="#孤獨：害怕死亡帶來的終極隔絕" class="headerlink" title="孤獨：害怕死亡帶來的終極隔絕"></a>孤獨：害怕死亡帶來的終極隔絕</h2><p>孤獨有兩種，一種是人際關係上的孤立，另一種則是個人與世界的隔絕。第二種孤獨是死亡之所以讓人害怕的原因，我們自嬰兒起不斷為自己的獨立性奮鬥，想要與他人區隔，想要自主活動。但是我們又苦於死亡帶來的毀滅，所以嘗試與他人連結，這就是生與死的焦慮。</p>
<h1 id="存在性焦慮的改善方法"><a href="#存在性焦慮的改善方法" class="headerlink" title="存在性焦慮的改善方法"></a>存在性焦慮的改善方法</h1><p>總結恐懼死亡的原因，除了死亡本身，其實可以追溯到更深層的存在性焦慮。作者建議，我們要努力過活克服無意義感，並降低人際孤獨以緩解存在性孤獨。</p>
<h2 id="覺醒經驗：努力過活克服無意義"><a href="#覺醒經驗：努力過活克服無意義" class="headerlink" title="覺醒經驗：努力過活克服無意義"></a>覺醒經驗：努力過活克服無意義</h2><p>死亡給人立下界線，使人因理想挫敗而沮喪；我們應正視至種感覺，試著充實地活著，減少臨走前的遺憾。</p>
<p>作者將種種讓人意識到死亡的事件稱為刺激，而個人在受到刺激後從中頓悟，從原先僅關注生理和世俗層次的日常階段，轉向留意到自身存在意義的本體階段，進而努力活下去的過程，則稱為覺醒。</p>
<p>換言之，我們必須把意義的來源從外在事物轉向自身，以免那些短暫易逝的事物消失後，我們存在的證據也跟著不見。</p>
<h2 id="漣漪效應：透過聯繫緩解孤獨"><a href="#漣漪效應：透過聯繫緩解孤獨" class="headerlink" title="漣漪效應：透過聯繫緩解孤獨"></a>漣漪效應：透過聯繫緩解孤獨</h2><p>古代的陪葬習俗顯漏了人們想抗拒死亡帶來的存在性孤獨——它不僅隔絕人與人的關係，還把死者徹底玻璃這個世界。因此增進與他人的關係，並真誠地陪伴能減緩死亡的寂寞，尤其是為他人帶來恩澤的漣漪效應是對此的最大安慰。</p>
<h1 id="治療師與存在心理治療"><a href="#治療師與存在心理治療" class="headerlink" title="治療師與存在心理治療"></a>治療師與存在心理治療</h1><h2 id="察覺死亡：回憶錄"><a href="#察覺死亡：回憶錄" class="headerlink" title="察覺死亡：回憶錄"></a>察覺死亡：回憶錄</h2><p>此章呼應作者在治療過程中自我袒露的主張，主動分享它自己體認死亡的種種經歷，並且如何克服這種焦慮，寫書在某方面也是其一，它帶來的漣漪是作者最大的安慰。另一部份提到宗教和超自然論述，作者在治療中並不會刻意否定其功效，畢竟病患的福祉仍是最要緊的，可是作者自己並不依賴宗教，它認為宗教並無解決死亡焦慮，只是抹煞了死亡的事實。</p>
<h2 id="給治療師的建言"><a href="#給治療師的建言" class="headerlink" title="給治療師的建言"></a>給治療師的建言</h2><p>作者最後想表達，精神異常其實不只是生理和匱乏等因素造成，對「存在」的疑問也可能是造成絕望的原因。治療師應注意到這方面的問題，並且在與輔導對象的關係中不知不覺引入。</p>
<p>治療雖有理論根據，但過程卻是在與對象建立關係中進行。一段友好關係並非治療的目標，卻是確保過程順利的手段。治療師的工作並非挖掘過往種種或關切未來動向，而是從當下的關係中找尋癥結。每次治療都是人際十彥，能看出對象供述內容外的一手消息，還有他們最真實的反應。所以要留意此時此地，甚至是自己的情緒波動也要利用。</p>
<p>雖然這些主張有違正統，但如果對療程有益的話，適時講解治療遠裡或袒露自我的以增進治療效果</p>
<h1 id="結論與心得"><a href="#結論與心得" class="headerlink" title="結論與心得"></a>結論與心得</h1><p>海德格說：「死亡的定義是不再有任何可能。」</p>
<p>昆德拉說：「死亡最駭人之處不是沒有未來，而是失去過去。」</p>
<p>我想這些說法之間沒有衝突，而是每個人恐懼死亡的原因不同。我大概在七、八歲的時候意識到終將一死，那時聽著自己的心跳聲，我開始思考「萬一停下來了怎麼辦？」，然後我想像著之後的事情，逐漸感到害怕與不安。</p>
<p>直到現在，我仍會在夜深人靜之時突然陷入恐慌。雖然說起來很可笑，但我實在是沒辦法想像一個自己不在，但仍安然運轉的世界。就好像要求一台電腦估算自己關機的速率，人要怎麼在存活的時候想像不存在的狀態？所以對我而言，活著就好像待在時間的監獄一樣，困在時間軸的一小段裡面。</p>
<p>然而如同伊比鳩魯所述，死亡其實與當事人最沒關係，我們實際上更該關注於現世，而不是畏懼自己的想像。畢竟，有形的監牢會限制我們的自由，而無形的枷鎖也會讓我們淪為不自覺的奴隸。除了物質和虛妄的聲名，對於死亡的恐懼也約束著我們的所作所為。如果能夠學習面對死亡，那麼便沒有其他東西可以束縛我們了（生死之間就是在服人類役）。</p>
<p>所以我希望自己能好好過日子，好好與人相處，好好養生，這樣才能降低對死亡的恐懼。無懼死亡不是魯莽送死，而是可以自由地活著。生活中不須擔驚受怕，面對崇高理想時，也能慷慨赴義。</p>
]]></content>
      <tags>
        <tag>philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title>生物調控原理的上課筆記</title>
    <url>/yang-2019-principles-of-biological-regulation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我在上課的時候發現，把任何定義裏頭的名詞換成人生，聽起來都會很有道理。</p>
<span id="more"></span>

<blockquote>
<p>人生的哲學是化約、假說和驗證。</p>
</blockquote>
<blockquote>
<p>如果你碰到一個問題卻沒辦法解釋，但有毅力把生物系統劃分為子系統，那麼你就有機會藉由研究較單純的子系統，拼湊出整個系統的運作機制。在生物學上，我們稱這種決心叫化約。</p>
</blockquote>
<blockquote>
<p>小紙條放在口袋裡面，有點像錦囊妙計，問題解決不了時就拿出來看看。</p>
</blockquote>
<blockquote>
<p>要在不一樣的人生中看到相似性。</p>
</blockquote>
<blockquote>
<p>巴斯德的鵝頸瓶裏頭的肉汁到現在還是清澈的。</p>
</blockquote>
<blockquote>
<p>每個人都有屬於自己的宿命，人在年輕的時候，或許會走偏，或許會原地踏步，甚至繞了一大圈仍然迷惑不已，但最終終究會走回自己應走的道路上。</p>
</blockquote>
<blockquote>
<p>你說「生物系統這個黑盒子這麼難我怎麼可能理解」，但我們台灣人的長處就是 reverse engineering。</p>
</blockquote>
<blockquote>
<p>人生是由物件（components）、事件（events）、順序（pathways）與循環（circuits）組成。</p>
</blockquote>
<blockquote>
<p>小分子碰撞在一起會立即彈開，大分子碰撞在一起則會接觸一陣子才彈開，相處時間決定反應是否發生。</p>
</blockquote>
<blockquote>
<p>以前的生物化學強調記憶，現在的生物化學注重道理。</p>
</blockquote>
<blockquote>
<p>TCA cycle 與人生都是由拋棄與弭補構成的循環。</p>
</blockquote>
<blockquote>
<p>人生中很常出現 duplicate。</p>
</blockquote>
<blockquote>
<p>人生有兩個難題：找到該走的路（puzzle），決定該怎麼走（maze）。如果不搞清楚的話，思考的時候就會亂掉。</p>
</blockquote>
<blockquote>
<p>人生怎麼從高峰走向低潮是動力學問題，為什麼既有高峰也有低潮則是熱力學問題。</p>
</blockquote>
<blockquote>
<p>人生的轉變很難像個理想的開關，只有 All or None。</p>
</blockquote>
<blockquote>
<p>兩個人想要追求目標，要考慮先形成 complex 再 binding，還是先 binding 再建立 cooperativity？</p>
</blockquote>
<blockquote>
<p>台灣做的味精大多是用發酵作的。</p>
</blockquote>
<p>如今，我已經忘記當初是用人生來替換哪些字眼，但還是記得該怎麼活下去的訣竅唷。</p>
]]></content>
      <tags>
        <tag>philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title>夏娃的時間</title>
    <url>/yoshiura-2008-time-of-eve/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>未來，大概日本。<br>機器人應用行之有年。<br>人形機器人才剛實用化。</p>
</blockquote>
<p>女孩小時候出了車禍成為植物人，二十年後奇蹟甦醒醒面對大不同的環境</p>
<span id="more"></span>

<p>在病榻前不離不棄的哥哥陪著她學習走路、說話重新認識世界。隨著記憶恢復，女孩卻察覺哥哥和童年印象不同，和其他人比起來多了一分淡然。有次到祭拜父母時居然發現哥哥的墓碑居然立在爸媽旁，受驚嚇的女孩不可置信地望著站在一旁的哥哥，卻毫無頭緒。</p>
<p>她往回家衝，瘋狂打開家中抽屜想索出蛛絲馬跡。最後她打開哥哥那不曾進過的房間，裏頭的擺設和車禍早上那天相同：2050年的電影海報、新推出的機器人玩具……。</p>
<p>這時她老哥在他身後，眼睛突然放出亮光，在牆上投影出一幕幕影像。</p>
<p>原來那天車禍奪去了爸爸媽媽和哥哥的性命，女孩的爺爺在臨終前打造了哥哥機器人，希望在自己往生後能持續照顧她。</p>
<p>女孩忍不住悲傷哭了起來，突然天空出現異變，被拉扯出一個大洞，巨大的宇宙生物竄出，在東京上空噴出一百兆五百億度的火焰，大氣層被點燃延燒全球。女孩毅然決然搭上巨大化的哥哥機器人和宇宙怪物進行決戰。</p>
<p>陸續擊潰了四大天王和最終宇宙生命後發現這些「怪物」其實是守護世界的神獸，牠們正在和看不見的敵人作戰。百億年來不甘死去的智慧生命亡魂吞食暗能量與暗物質後以量子態聚積，最終成為威脅宇宙存亡的次元惡魔。</p>
<p>為了守護爸爸、媽媽、哥哥與爺爺的宇宙，女孩將自己量子化將時間軸前後二十年的時空給炸毀，犧牲了過去與未來在現在全力一搏。強大的時壓消滅了次元惡魔 99.999999% 的能量，但仍然剩餘將近 $10^{5989454}$ 焦耳，女孩將之永遠放逐到過去的過去，將邪惡的力量化為創世的大霹靂。</p>
<p>戰鬥的最後，女孩倒臥在殘破的東京都，惆悵地望著餘暉。一眨眼，她竟因時間炸毀的關係回到了 2050 年，正站在馬路中央，迎面撞上的車上她看見了爸爸、媽媽和哥哥，卻沒看見自己。</p>
<h1 id="讀後感"><a href="#讀後感" class="headerlink" title="讀後感"></a>讀後感</h1><p>以上情節與動畫無關，只是看完動畫後有感而發瞎掰的。我一開始猜店長凪的老爸在過世前以自己形象打造機器人來照顧受傷的凪，結果劇情發展與我的猜想大相逕庭。既然都起了頭，便把心中預想的劇情一口氣打出來了。</p>
<p>這部動畫才六集，可以直接從劇場版開始看，裏頭有網路播映沒有的內容，是個輕鬆溫馨的科幻小品（大概是艾西莫夫機器人短篇集那樣的篇幅吧？雖然動畫和小說比較好像怪怪的。）</p>
<p>故事的開頭寫著：未來，大概日本。機器人應用行之有年，但人型機器人才剛實用化。但是劇中機器人得用投影光環以便與人區別，這不就代表機器人在外表已經跨越恐怖谷了嗎？</p>
<p>故事主要地點是在一家不區分人機的咖啡廳。在裏頭，主角和他同學若不是親眼看見零件或是光環也無法從對話中分辨人與機器人，這不就代表連人工智慧都通過圖靈測試了。</p>
<p>外表和智慧都和人類無異，而且外表可愛還會賣萌的機器人，真的是人形機器人剛實用化的時代嗎？不得不說我十分期待……</p>
<p>先不論科技的先進程度，《夏娃的時間》的設定還挺細緻，但都說得很隱諱，在結尾也有很多未解釋的部分，所以看得時候還是得把重點放在人機相處，不然會有種意猶未竟的感覺。</p>
<p>六集的主題分別是背景介紹、主僕矛盾、愛戀、認同、忌妒與羈絆。</p>
<p>我覺得被非法拋棄的機器人那集最好看，前面是主角和他同學滑稽地想保護壞掉的機器人不會因邏輯錯誤或是誤喝咖啡而爆炸，後面店長出來和機器人聊天才知道他雖然被拋棄卻仍懷念小主人，並想要獲得別人認同與記憶。在壞掉前一刻，店長也不顧機器人一臉機器人樣（薩米或麗莎都一副人樣，這舊機器人只有金屬殼子還踏著機械步）抱著他給他安慰。</p>
<p>然後第五集講到男主角討厭他家的機器人的緣故，是因為擔心他家機器人會比他還會彈鋼琴。這主題可以寫很大，不過導演把重點放在薩米和男主角的和解上而沒去討論機器人取代人類的事情（這些議題都在背景中出現呢）。</p>
<p>不過就算機器人很屌好了，彈鋼琴還是一項需要努力練習的技能啊！機車賽出來後腳踏車賽還是一樣熱門，阿法狗在圍棋上打敗人類最強後，下棋還是一件充滿智慧且有趣的事情啊。</p>
<p>周邊也做得一副欠買的樣子<br>不只美術設計，連周邊也做得一副欠買的模樣</p>
<p><img data-src="https://p2.bahamut.com.tw/B/2KU/37/0000827037.JPG?w=1000"><br>（圖：<a href="https://gnn.gamer.com.tw/detail.php?sn=82019%EF%BC%89">https://gnn.gamer.com.tw/detail.php?sn=82019）</a></p>
<p>我不懂電影製作，不過總覺這部作品的分鏡和其他動畫不大一樣呢！一些小圖示設計很漂亮，咖啡廳光看就覺得療癒。</p>
<p>另外，機器人上的光環是有意要和天使做連結嗎？</p>
]]></content>
      <tags>
        <tag>sf</tag>
      </tags>
  </entry>
</search>
